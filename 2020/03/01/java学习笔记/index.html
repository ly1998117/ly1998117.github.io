<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;ly1998117.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:true,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;&#x2F;search.xml&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:false}}</script>
<meta name="description" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="java学习笔记">
<meta property="og:url" content="https://ly1998117.github.io/2020/03/01/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="LiuYang&#39;s Blog">
<meta property="og:description" content="Java">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ly1998117.github.io/2020/03/01/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java运行原理图.png">
<meta property="og:image" content="https://ly1998117.github.io/2020/03/01/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/String内存存储方式.png">
<meta property="og:image" content="https://ly1998117.github.io/2020/03/01/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/类.png">
<meta property="og:image" content="https://ly1998117.github.io/2020/03/01/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/并发线程.png">
<meta property="og:image" content="https://ly1998117.github.io/2020/03/01/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/套接字.png">
<meta property="og:image" content="https://ly1998117.github.io/2020/03/01/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/tcp1.png">
<meta property="og:image" content="https://ly1998117.github.io/2020/03/01/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/tcp2.png">
<meta property="og:image" content="https://ly1998117.github.io/2020/03/01/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/tcp3.png">
<meta property="og:image" content="https://ly1998117.github.io/2020/03/01/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/加载器.png">
<meta property="article:published_time" content="2020-02-29T17:04:18.000Z">
<meta property="article:modified_time" content="2021-05-27T02:12:29.697Z">
<meta property="article:author" content="LiuYang">
<meta property="article:tag" content="java">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ly1998117.github.io/2020/03/01/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java运行原理图.png">


<link rel="canonical" href="https://ly1998117.github.io/2020/03/01/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;ly1998117.github.io&#x2F;2020&#x2F;03&#x2F;01&#x2F;java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0&#x2F;&quot;,&quot;path&quot;:&quot;2020&#x2F;03&#x2F;01&#x2F;java学习笔记&#x2F;&quot;,&quot;title&quot;:&quot;java学习笔记&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>java学习笔记 | LiuYang's Blog</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LiuYang's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">26</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#java"><span class="nav-number">1.</span> <span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F"><span class="nav-number">1.1.</span> <span class="nav-text">定义常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.2.</span> <span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="nav-number">1.3.</span> <span class="nav-text">逻辑运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">1.4.</span> <span class="nav-text">位运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.5.</span> <span class="nav-text">三元运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.6.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.6.1.</span> <span class="nav-text">隐式类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.6.2.</span> <span class="nav-text">显式类型转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">1.7.</span> <span class="nav-text">流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E5%8F%A5%E5%9D%97"><span class="nav-number">1.7.1.</span> <span class="nav-text">语句块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-1"><span class="nav-number">1.7.2.</span> <span class="nav-text">流程控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B---reference-type"><span class="nav-number">1.8.</span> <span class="nav-text">字符串 (引用数据类型 - reference type)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="nav-number">1.8.1.</span> <span class="nav-text">字符串常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E9%87%8F"><span class="nav-number">1.8.2.</span> <span class="nav-text">字符串变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="nav-number">1.8.3.</span> <span class="nav-text">字符串比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-api"><span class="nav-number">1.8.4.</span> <span class="nav-text">字符串 API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.9.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E5%88%9B%E5%BB%BA%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-number">1.9.1.</span> <span class="nav-text">引用类型和基本类型变量创建的不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E"><span class="nav-number">1.9.2.</span> <span class="nav-text">声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">1.9.3.</span> <span class="nav-text">数据类型默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC"><span class="nav-number">1.9.4.</span> <span class="nav-text">赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E5%88%9B%E5%BB%BA"><span class="nav-number">1.9.5.</span> <span class="nav-text">特殊创建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">1.10.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="nav-number">1.10.1.</span> <span class="nav-text">方法重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99-override"><span class="nav-number">1.10.2.</span> <span class="nav-text">方法重写 override</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90"><span class="nav-number">1.11.</span> <span class="nav-text">帮助文档生成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.12.</span> <span class="nav-text">类和面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">1.12.1.</span> <span class="nav-text">成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-gc"><span class="nav-number">1.12.2.</span> <span class="nav-text">垃圾回收机制 (GC)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.12.3.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E6%8C%87%E9%92%88"><span class="nav-number">1.12.4.</span> <span class="nav-text">this指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#private-public"><span class="nav-number">1.12.5.</span> <span class="nav-text">private &amp; public</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">1.12.6.</span> <span class="nav-text">static关键字（静态变量）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">1.12.7.</span> <span class="nav-text">静态代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.12.8.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99override%E6%88%96%E8%A6%86%E7%9B%96"><span class="nav-number">1.12.9.</span> <span class="nav-text">方法重写(override)或覆盖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BDoverload"><span class="nav-number">1.12.10.</span> <span class="nav-text">方法重载(overload)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.12.11.</span> <span class="nav-text">final 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-%E7%B1%BB%E5%8C%85package"><span class="nav-number">1.12.12.</span> <span class="nav-text">java 类包(package)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.12.13.</span> <span class="nav-text">权限修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.12.14.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.12.14.1.</span> <span class="nav-text">局部内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.12.14.2.</span> <span class="nav-text">抽象匿名内部类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">1.12.15.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="nav-number">1.12.16.</span> <span class="nav-text">继承的弊端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">1.12.17.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99override"><span class="nav-number">1.12.18.</span> <span class="nav-text">类特殊方法重写（override）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tostring%E6%96%B9%E6%B3%95"><span class="nav-number">1.12.18.1.</span> <span class="nav-text">toString方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#equals%E6%96%B9%E6%B3%95"><span class="nav-number">1.12.18.2.</span> <span class="nav-text">equals方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3interface"><span class="nav-number">1.13.</span> <span class="nav-text">接口（interface）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.13.1.</span> <span class="nav-text">接口和类的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.13.2.</span> <span class="nav-text">接口与匿名内部类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="nav-number">1.14.</span> <span class="nav-text">常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#scanner"><span class="nav-number">1.14.1.</span> <span class="nav-text">Scanner</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stringbuffer-stringbuilder"><span class="nav-number">1.14.2.</span> <span class="nav-text">StringBuffer &amp;&amp; StringBuilder</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">1.14.2.1.</span> <span class="nav-text">区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#arrays"><span class="nav-number">1.14.3.</span> <span class="nav-text">Arrays</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#math"><span class="nav-number">1.14.4.</span> <span class="nav-text">Math</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bigdecimal-biginteger"><span class="nav-number">1.14.5.</span> <span class="nav-text">BigDecimal &amp; BigInteger</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#date-calendar"><span class="nav-number">1.14.6.</span> <span class="nav-text">Date &amp;&amp; Calendar</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">1.14.7.</span> <span class="nav-text">包装类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB-collection"><span class="nav-number">1.14.8.</span> <span class="nav-text">集合类 Collection</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.14.8.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B-%E9%9B%86%E5%90%88%E6%89%93%E5%8D%B0"><span class="nav-number">1.14.8.2.</span> <span class="nav-text">案例-集合打印</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list"><span class="nav-number">1.14.8.3.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#set-%E9%9B%86%E5%90%88"><span class="nav-number">1.14.8.4.</span> <span class="nav-text">Set 集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#map-%E6%98%A0%E5%B0%84"><span class="nav-number">1.14.8.5.</span> <span class="nav-text">Map 映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#queue-%E9%98%9F%E5%88%97"><span class="nav-number">1.14.8.6.</span> <span class="nav-text">Queue 队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E5%9E%8B"><span class="nav-number">1.14.9.</span> <span class="nav-text">范型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iterators-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.14.10.</span> <span class="nav-text">Iterators 迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#listiterator"><span class="nav-number">1.14.10.1.</span> <span class="nav-text">ListIterator</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">1.15.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%86%E7%AE%B1-%E8%A3%85%E7%AE%B1"><span class="nav-number">1.16.</span> <span class="nav-text">拆箱 &amp;&amp; 装箱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">1.17.</span> <span class="nav-text">文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E5%AD%97%E8%8A%82%E6%B5%81"><span class="nav-number">1.17.1.</span> <span class="nav-text">IO字节流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fileoutputstream"><span class="nav-number">1.17.1.1.</span> <span class="nav-text">FileOutputStream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fileinputstream"><span class="nav-number">1.17.1.2.</span> <span class="nav-text">FileInputStream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bufferinputstream"><span class="nav-number">1.17.1.3.</span> <span class="nav-text">BufferInputStream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bufferoutputstream-%E5%8C%85%E8%A3%85%E6%B5%81"><span class="nav-number">1.17.1.4.</span> <span class="nav-text">BufferOutputStream 包装流</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="nav-number">1.17.2.</span> <span class="nav-text">IO字符流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#outputstreamwriter"><span class="nav-number">1.17.2.1.</span> <span class="nav-text">OutputStreamWriter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#inputstreamreader"><span class="nav-number">1.17.2.2.</span> <span class="nav-text">InputStreamReader</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#filewriter-filereader"><span class="nav-number">1.17.2.3.</span> <span class="nav-text">FileWriter &amp;&amp; FileReader</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bufferedwriter-bufferedreader"><span class="nav-number">1.17.2.4.</span> <span class="nav-text">BufferedWriter &amp;&amp; BufferedReader</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">1.18.</span> <span class="nav-text">并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#thread%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.18.1.</span> <span class="nav-text">Thread(线程)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runnable-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.18.2.</span> <span class="nav-text">Runnable 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%94%81"><span class="nav-number">1.18.3.</span> <span class="nav-text">线程加锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized"><span class="nav-number">1.18.3.1.</span> <span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reentrantlock"><span class="nav-number">1.18.3.2.</span> <span class="nav-text">ReentrantLock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="nav-number">1.18.4.</span> <span class="nav-text">线程组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#timer-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">1.18.5.</span> <span class="nav-text">Timer 定时器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">1.19.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.19.1.</span> <span class="nav-text">TCP&#x2F;IP网络模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inetaddress"><span class="nav-number">1.19.2.</span> <span class="nav-text">InetAddress</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket-%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">1.19.3.</span> <span class="nav-text">Socket 套接字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#datagramsocket---udp"><span class="nav-number">1.19.3.1.</span> <span class="nav-text">DatagramSocket --UDP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B2----%E5%8F%8C%E5%90%91%E5%8F%91%E9%80%81"><span class="nav-number">1.19.3.2.</span> <span class="nav-text">案例2 -- 双向发送</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#socket---tcp"><span class="nav-number">1.19.3.3.</span> <span class="nav-text">Socket --TCP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B3---tcp-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%85%A8%E5%8F%8C%E5%B7%A5"><span class="nav-number">1.19.3.4.</span> <span class="nav-text">案例3 --TCP 点对点全双工</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.20.</span> <span class="nav-text">枚举类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.21.</span> <span class="nav-text">类的加载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">1.21.0.1.</span> <span class="nav-text">类加载器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">1.22.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">1.22.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E9%80%94"><span class="nav-number">1.22.2.</span> <span class="nav-text">用途</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%90%8D%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.22.3.</span> <span class="nav-text">获取类名三种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">1.22.4.</span> <span class="nav-text">获取构造函数及成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E7%B1%BB"><span class="nav-number">1.22.5.</span> <span class="nav-text">相关类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#class"><span class="nav-number">1.22.5.1.</span> <span class="nav-text">class</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LiuYang"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">LiuYang</p>
  <div class="site-description" itemprop="description">人与人的悲欢并不相通</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.macwk.com/" title="https:www.macwk.com&#x2F;" rel="noopener" target="_blank">Macwk</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ly1998117.github.io/2020/03/01/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="LiuYang">
      <meta itemprop="description" content="人与人的悲欢并不相通">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuYang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-01 01:04:18" itemprop="dateCreated datePublished" datetime="2020-03-01T01:04:18+08:00">2020-03-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-27 10:12:29" itemprop="dateModified" datetime="2021-05-27T10:12:29+08:00">2021-05-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>86k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:19</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="java">Java</h1>
<span id="more"></span>
<figure>
<img src="Java运行原理图.png" alt="Java运行原理图" /><figcaption aria-hidden="true">Java运行原理图</figcaption>
</figure>
<h2 id="定义常量">定义常量</h2>
<p>自定义常量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> PI=<span class="number">3.14f</span></span><br></pre></td></tr></table></figure>
<p>字面值常量</p>
<h2 id="运算符">运算符</h2>
<ul>
<li><p>在java中，浮点数运算具有不精确性，浮点数本身是非精确存储</p></li>
<li><p>字符串可以用 + 拼接</p></li>
<li><p>字符串与整型+运算，结果仍是字符串</p></li>
<li><p>字符与整型+运算结果为ASCII码的运算结果</p></li>
</ul>
<h2 id="逻辑运算">逻辑运算</h2>
<ul>
<li>短路与：&amp;&amp; 短路或：| |</li>
<li>与：&amp; 或：|</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>,b=<span class="number">10</span>;</span><br><span class="line">System.out.println(a&gt;<span class="number">20</span> &amp; (++b) &gt; <span class="number">10</span>); <span class="comment">// false</span></span><br><span class="line">System.out.println(b); <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">System.out.println(a&gt;<span class="number">20</span> &amp;&amp; (++b) &gt; <span class="number">10</span>); <span class="comment">// false</span></span><br><span class="line">System.out.println(b); <span class="comment">// 10  短路作用，根据 a&gt;20 直接判断为false，&amp;&amp;之后不再运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//短路或 类似</span></span><br></pre></td></tr></table></figure>
<h2 id="位运算">位运算</h2>
<p>计算机正数存储原码，负数存储补码便于运算。</p>
<ul>
<li>正数：原码、反码、补码相同</li>
<li>负数：原码(符号位为1)、反码(符号位不变，其余取反)、补码(反码加一)</li>
</ul>
<blockquote>
<p>-9: 原码 1000 0000 0000 1001 反码 1111 1111 1111 0110 补码 1111 1111 1111 0111</p>
<p>-7 1000 0000 0000 0111 1111 1111 1111 1000 1111 1111 1111 1001</p>
<p>-9 &amp; -7 1000 0000 0000 1111 1111 1111 1111 0000 1111 1111 1111 0001</p>
</blockquote>
<p>~ 按位取反 ^ 按位异或 &lt;&lt; 左移(高位抛弃) &gt;&gt;右移 (高位符号位补齐，低位抛弃) &gt;&gt;&gt;&gt;无符号右移</p>
<h2 id="三元运算符">三元运算符</h2>
<p>? : 规则： 布尔表达式 | 7&gt;8 ? 表达式1 ：表达式2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(a&gt;b?a:b);</span><br></pre></td></tr></table></figure>
<h2 id="类型转换">类型转换</h2>
<h3 id="隐式类型转换">隐式类型转换</h3>
<p>​ 小类型转换为大类型会自动转换： byte -&gt; short , char -&gt; int -&gt; long -&gt; float -&gt; double</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">虽然float比long小，但因为存储方法不一致导致 float 里面可以存储的数据范围比 long 要大( java 中 float 4个字节  的范围：3.4e+38 - 1.4e-45 ; long 占用 8 个字节 范围：-2^63 - +2^63  )</span><br><span class="line"></span><br><span class="line">使用情况：</span><br><span class="line"><span class="bullet">                1.</span> 赋值语句</span><br><span class="line"><span class="bullet">                2.</span> 算术表达式</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="keyword">byte</span> a=<span class="number">10</span>;</span><br><span class="line">      <span class="keyword">short</span> b = a;</span><br><span class="line">      <span class="keyword">int</span> c = b;</span><br><span class="line">      <span class="keyword">long</span> d = c;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">float</span> e = d;</span><br><span class="line">      <span class="keyword">double</span> f = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="显式类型转换">显式类型转换</h3>
<p>强制类型转换：大类型数据赋值给小类型数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> b;</span><br><span class="line">a = (<span class="keyword">double</span>) b;</span><br></pre></td></tr></table></figure>
<h2 id="流程控制">流程控制</h2>
<h3 id="语句块">语句块</h3>
<p>语句块的执行顺序从上到下</p>
<p>语句块可以访问外面定义的变量，外面不能访问语句块内部定义变量</p>
<h3 id="流程控制-1">流程控制</h3>
<p>控制程序中语句执行的顺序</p>
<ul>
<li><p>条件语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bool表达式)&#123;</span><br><span class="line">​    <span class="comment">// 语句，bool为 true 执行。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if( ){ ​ //语句 }else{ ​ //语句 }</p>
<p>if(){</p>
<p>}else if(){</p>
<p>}else{</p>
<p>}</p></li>
<li><p>Switch 语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(variable)&#123;        <span class="comment">// variable 可以是字符串</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>while 语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件)&#123;</span><br><span class="line">  <span class="comment">// 语句</span></span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">//赋值语句可以放在条件中</span></span><br><span class="line"><span class="keyword">while</span> ((input = fileInputStream.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>do - while 先执行一遍循环体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">   <span class="comment">// 循环体</span></span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式)    </span><br></pre></td></tr></table></figure></li>
<li><p>for 循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(init ; condition ; update)&#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="字符串-引用数据类型---reference-type">字符串 (引用数据类型 - reference type)</h2>
<p>字符串变量声明在栈中。</p>
<p>字符串本身无法被修改，变量指向字符串存储的地址，只能分配新的内存再使变量指向其地址。</p>
<h3 id="字符串常量">字符串常量</h3>
<p>存放在<strong>方法区的运行常量</strong>区中，不可修改，栈中的变量指向内容相同的字符串常量时，不在开辟新的空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="字符串变量">字符串变量</h3>
<p>new 得到的对象存放在堆中，堆中保存String传入的字符串地址，变量 str 则保存堆中对象的地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;); <span class="comment">// &quot;asd&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串比较">字符串比较</h3>
<p>若同为字符串变量或常量，则比较引用；若二者不同则比较字符串本身</p>
<p><img src="String内存存储方式.png" /></p>
<ul>
<li><p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String str4 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较引用</span></span><br><span class="line">System.out.println(str1 == str2);  <span class="comment">//true</span></span><br><span class="line">System.out.println(str2 == str3);  <span class="comment">//false</span></span><br><span class="line">System.out.println(str1 == str4);  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较字符串</span></span><br><span class="line">str1.equals(str3);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="字符串-api">字符串 API</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">str.length();  <span class="comment">//长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找子字符串的位置，不存在返回-1</span></span><br><span class="line">str.indexOf(<span class="keyword">int</span> c);     <span class="comment">// 传递一个字符  &#x27;A&#x27; == 65</span></span><br><span class="line">str.indexOf(String str);</span><br><span class="line">str.lastIndexOf(String str); <span class="comment">// 从后向前查找子串位置</span></span><br><span class="line">str.charAt(<span class="keyword">int</span> c); <span class="comment">//获取指定位置字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取子字符串</span></span><br><span class="line">str.substring(<span class="keyword">int</span> beginIndex); <span class="comment">//从 c 开始的位置截取子串</span></span><br><span class="line">str.substring(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断字符串的开始和结尾是否是</span></span><br><span class="line">str.startsWith(String prefix);</span><br><span class="line">str.endsWith(String suffix);</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较</span></span><br><span class="line">str.equals(String str);</span><br><span class="line">str.equalsIgnoreCase(String str);    <span class="comment">//忽略大小写</span></span><br><span class="line"></span><br><span class="line">str.compareTo(String str); <span class="comment">//从字符串开头，相同字符跳过，直至不同的字符并返回该字符ASCII码的差，若比较的字符串长度不同，且其中一个字符串是另一个的前缀，返回长度差</span></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">EXAMPLE：</span><br><span class="line">String str = <span class="string">&quot;abcDde&quot;</span>;</span><br><span class="line">System.out.println(str.compareTo(<span class="string">&quot;abc&quot;</span>)); <span class="comment">// 3</span></span><br><span class="line">System.out.println(str.compareTo(<span class="string">&quot;abcd&quot;</span>)); <span class="comment">// -32</span></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">str.contains(String str); <span class="comment">//判断是否包含</span></span><br><span class="line">str.isEmpty();   <span class="comment">//判断是否为空 即 str = &quot;&quot;;  而不是 str = null;空对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换</span></span><br><span class="line">str.toLowerCase();  <span class="comment">//小写</span></span><br><span class="line">str.toUpperCase();  <span class="comment">//大写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分割</span></span><br><span class="line">String[] strs = str.split(<span class="string">&quot;\\.&quot;</span>);   <span class="comment">// 按照输入对字符串分割,返回字符串数组 java中的存储为 \. 故\\.</span></span><br><span class="line"><span class="keyword">for</span>(String s : strs)&#123;</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">str.trim(); <span class="comment">// 去除前边和后边的空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串替换</span></span><br><span class="line">str.replace(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar);</span><br><span class="line">str.replace(String oldStr, String newStr);</span><br></pre></td></tr></table></figure>
<h2 id="数组">数组</h2>
<h3 id="引用类型和基本类型变量创建的不同">引用类型和基本类型变量创建的不同</h3>
<ul>
<li><p>所有局部变量都存放在栈里，在方法里创建的变量都是局部变量</p></li>
<li><p>基本类型不管是否赋值，都已经分配了空间</p></li>
<li><p>引用类型，声明只在栈分配内存(存储引用)、初始化在堆或者方法区里</p></li>
</ul>
<h3 id="声明">声明</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; <span class="comment">//按照默认值初始化0</span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">32</span>,<span class="number">34</span>&#125;; </span><br><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">3</span>,<span class="number">32</span>,<span class="number">34</span>&#125;;</span><br><span class="line"></span><br><span class="line">array.length;   <span class="comment">//长度属性</span></span><br></pre></td></tr></table></figure>
<h3 id="数据类型默认值">数据类型默认值</h3>
<p>基本类型是0 (0 0.0 0所代表的字符 false)</p>
<p>引用类型是null , null数组不能访问其属性及内容。</p>
<p>数组名的赋值只赋值引用</p>
<h3 id="赋值">赋值</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line">Arrays.fill(<span class="keyword">int</span>[], fromIndex, toIndex, val);</span><br></pre></td></tr></table></figure>
<h3 id="特殊创建">特殊创建</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][];</span><br><span class="line">array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">array[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="方法">方法</h2>
<p>java中引用类型传入方法会同步修改，对指针进行封装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> [] a)</span></span>&#123;</span><br><span class="line">  a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">  method(a);            <span class="comment">// 方法中将引用复制到方法局部变量a，对引用a初始化，不影响 main 的数组a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法重载">方法重载</h3>
<p>相同方法名，不同参数</p>
<h3 id="方法重写-override">方法重写 override</h3>
<p>子类对父类，参数相同，方法名相同</p>
<h2 id="帮助文档生成">帮助文档生成</h2>
<p>必须 public 类才能生成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">javadoc -d 要生成的文件夹名 xxx.java</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个处理数组的静态工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTool</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array shuzu</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value zhi</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find_index</span><span class="params">(<span class="keyword">float</span>[] array, <span class="keyword">float</span> value)</span></span>&#123;&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="类和面向对象">类和面向对象</h2>
<p>类中的属性未初始化不可使用，默认为null；</p>
<blockquote>
<p>面向对象程序设计以对象为核心，该方法认为程序由一系列对象组成。类是对现实世界的抽象，包括表示静态属性的数据和对数据的操作，<strong>对象是类的实例化</strong>。对象间通过消息传递相互通信，来模拟现实世界中不同实体间的联系。在面向对象的程序设计中，对象是组成程序的基本模块。</p>
<p>面向对象程序设计（Object Oriented Programming，OOP）是一种计算机编程架构。OOP的一条基本原则是计算机程序由单个能够起到子程序作用的单元或对象组合而成。OOP达到了软件工程的三个主要目标：重用性、灵活性和扩展性。OOP=对象+类+继承+多态+消息，其中核心概念是类和对象。</p>
</blockquote>
<p>匿名对象：</p>
<p>​ new Object(); //适用只使用一次</p>
<h3 id="成员变量">成员变量</h3>
<p>在类中定义的变量，不占任何内存。在其创建对象时分配空间，堆。</p>
<p>局部变量则在栈中存储，方法调用结束销毁，且必须初始化</p>
<p>可将对象作为类的成员变量</p>
<h3 id="垃圾回收机制-gc">垃圾回收机制 (GC)</h3>
<p>堆是垃圾回收的主要区域，可以分为新生代和老年代(tenured)。新生代用于存放刚创建的对象以及年轻的 对象，如果对象一直没有被回收，生存得足够长，老年对象就会被移入老年代。</p>
<p>标记-清除算法(Mark-Sweep)从根节点开始标记所有可达对象，其余没标记的即为垃圾对象，执行清除。但回收后的空间是不连续的。</p>
<p>复制算法(copying)将内存分成两块，每次只使用其中一块，垃圾回收时，将标记的对象拷贝到另外一块中，然后完全清除原来使用的那块内存。复制后的空间是连续的。</p>
<p>复制算法适用于新生代，因为垃圾对象多于存活对象，复制算法更高效。 标记-压缩算法(Mark-compact)适合用于老年代的算法(存活对象多于垃圾对象)。</p>
<h3 id="构造方法">构造方法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Object</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//对成员变量赋值，与c++构造函数类似；可以对构造方法重载</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Object</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//当工具类都为静态方法，使构造方法私有化，防止对其进行实例化</span></span><br></pre></td></tr></table></figure>
<h3 id="this指针">this指针</h3>
<p>this 代表当前类，可以通过 this 访问方法和成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">  datatype attribute;</span><br><span class="line">  <span class="function">datatype <span class="title">method</span><span class="params">(datatype attribute)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.attribute = attribute;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="private-public">private &amp; public</h3>
<p>私有化与公有化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将属性全部私有，利用get、set方法对属性操作,体现了封装性及安全性</span></span><br><span class="line"><span class="keyword">private</span> datatype attribute;</span><br><span class="line"><span class="function"><span class="keyword">public</span> datatype <span class="title">getAttribute</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> attribute;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(datatype attribute)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.attribute = attribute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="static关键字静态变量">static关键字（静态变量）</h3>
<ul>
<li><p>可修饰成员变量和成员方法</p></li>
<li><p>修饰成员变量表示静态变量，静态变量对所有对象共用，在内存中保存一份</p></li>
<li><p>修饰成员变量表示静态方法，<strong>静态方法只能访问静态变量</strong>(在静态区中存储) 可以把成员变量作为参数传递给静态方法。</p></li>
<li><p>静态成员变量通过类名访问；Object.variable；其实例化的所有对象值一致</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object ob)</span></span>&#123;</span><br><span class="line">    <span class="comment">//  通过参数对对象进行访问；</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    Object.name = <span class="string">&quot;asdf&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li><p>static 随着类的加载而加载，优先于对象存在。所有对象共享(可以通过对象或者类来访问)</p></li>
<li><p>main 放法 为特殊的静态方法</p></li>
<li><p>main(String[] args); 中 args 用来传递参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Object 参数</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li><p>static 实现工具类</p>
<p>工具类不需要存储数据，不需要实例化，利用 static 构造静态方法</p></li>
</ul>
<h3 id="静态代码块">静态代码块</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//放在类里，只会执行一次</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">          pi = <span class="number">3.14</span>;    <span class="comment">//因为只运行一次，里面的变量必须是静态变量；</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承">继承</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> gender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name, <span class="keyword">char</span> gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> classNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name, <span class="keyword">int</span> classNumber,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">char</span> gender, <span class="keyword">int</span> rank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(age, name, gender);    <span class="comment">//通过 super() 调用父类的构造方法, 且必须在第一行</span></span><br><span class="line">        <span class="keyword">this</span>.classNumber = classNumber;</span><br><span class="line">        <span class="keyword">this</span>.rank = rank;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tips：</p>
<ul>
<li><p>java不支持多继承，即同时继承多个类，但支持多层继承</p></li>
<li><p>子类不能访问父类的私有成员，但子类包含父类的私有成员不能直接访问</p></li>
<li><p>子类和父类中有同名的变量，就近原则</p></li>
<li><p>可以通过<strong>super</strong>访问父类的 public 变量、方法和构造方法；<strong>this</strong> 访问当前类的成员变量，方法，构造</p></li>
<li><p>super 和 this 调用构造方法必须在第一行</p></li>
<li><p>子类构造子类对象时，会调用父类的构造放法，如果父类没有无参数构造方法，则必须在子类构造方法显式的调用父类的有参数构造方法(利用 super 和 this)</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> gender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name, <span class="keyword">char</span> gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> classNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rank;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//报错，父类无无参数构造方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>this 通常用于存在多个构造方法时，在其中一个构造方法中调用同类的其他构造方法，从而简洁代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name)</span></span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name, <span class="keyword">char</span> gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(age, name);</span><br><span class="line">          <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="方法重写override或覆盖">方法重写(override)或覆盖</h3>
<p>子类的方法名、参数、返回值和父类相同</p>
<p>意义：子类和父类有相同功能，但是子类有自己的特定内容和特定实现方式。为了见名知意，保持父类的名字，自己重新实现方法体。</p>
<p>tips：</p>
<ul>
<li>不能重写private方法, 否则相当于在子类创建新的方法</li>
<li>重写的时候访问权限不能更低(public 最高)</li>
</ul>
<h3 id="方法重载overload">方法重载(overload)</h3>
<ul>
<li>同一个类中，相同的方法名，参数不同，返回值不要求</li>
</ul>
<h3 id="final-关键字">final 关键字</h3>
<ul>
<li><p>final 类 (表示类不可继承)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>fianl 方法(表示这个方法不能被子类重写)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>final 变量 (常量)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> con;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="java-类包package">java 类包(package)</h3>
<p>通过包对类进行管理，避免重名问题。不同包里可以包含同名的类</p>
<p>包的定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xx.xx.xx; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名规则，以域名开头，都小写</span></span><br><span class="line">com.liuyang.xxx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包文件自动生成，再把源文件放到路径下</span></span><br><span class="line">javac -d . xxxx.java</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行包文件</span></span><br><span class="line">java com.liuyang.xxx.xxxx</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">import</span> com.liuyang.xxx.xxxx.Object;</span><br></pre></td></tr></table></figure>
<h3 id="权限修饰符">权限修饰符</h3>
<p>应用：类、成员变量、成员方法</p>
<blockquote>
<p>default 在同一个包里使用，不能在包外使用；在成员函数定义时，没有加访问限制符的函数，其访问等级为default</p>
<p>父类中的 protected 成员变量在子类可以直接访问</p>
</blockquote>
<figure>
<img src="类.png" alt="image" /><figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="内部类">内部类</h3>
<p>内部类寄生在外部类对象，外部类对象中可以有多个内部类对象，内部类对象只有一个外部类对象</p>
<p>内部类不能单独存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer1 = <span class="keyword">new</span> Outer(<span class="string">&quot;outer&quot;</span>);</span><br><span class="line">        outer1.test(<span class="number">1.2f</span>, <span class="string">&quot;sss&quot;</span>).method();</span><br><span class="line"></span><br><span class="line">        Outer outer2 = <span class="keyword">new</span> Outer(<span class="string">&quot;outer2&quot;</span>, <span class="number">1.2f</span>, <span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">        outer2.inner.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部类 不能直接访问内部类成员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> Inner inner;        <span class="comment">//内部类实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">(String name, <span class="keyword">float</span> weight, String innerName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        inner = <span class="keyword">new</span> Inner(weight,innerName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">test</span><span class="params">(<span class="keyword">float</span> weight, String name)</span> </span>&#123;</span><br><span class="line">        inner = <span class="keyword">new</span> Inner(weight, name);</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类 public default protect private static</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">float</span> weight;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">(<span class="keyword">float</span> weight, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;this a inner class&quot;</span>);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.weight);</span><br><span class="line">            System.out.println(<span class="string">&quot;外部类：&quot;</span> + Outer.<span class="keyword">this</span>.name); <span class="comment">//内部类访问外部类成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从外部类直接访问<strong>public</strong>内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Outer.Inner inner = <span class="keyword">new</span> Outer().<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//--------------------------------------------</span></span><br><span class="line"></span><br><span class="line">Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">Outer.Inner inner = out.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="局部内部类">局部内部类</h4>
<p>方法内定义的局部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">                        <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">                  System.out.println(age);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Person p1 = <span class="keyword">new</span> Person(<span class="number">12</span>);</span><br><span class="line">      p1.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="抽象匿名内部类">抽象匿名内部类</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Plane</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> speed;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plane</span><span class="params">(<span class="keyword">float</span> speed, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id =id;</span><br><span class="line">        <span class="keyword">this</span>.speed =speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.speed+<span class="string">&quot; &quot;</span>+<span class="keyword">this</span>.id);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">========================================================================================</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonNameInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">          <span class="comment">// 匿名内部类</span></span><br><span class="line">        <span class="keyword">new</span> Plane(<span class="number">1.2f</span>,<span class="number">12</span>)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.speed+<span class="string">&quot; &quot;</span>+<span class="keyword">this</span>.id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有名内部类</span></span><br><span class="line">        Plane plane = <span class="keyword">new</span> Plane(<span class="number">1.2f</span>,<span class="number">12</span>) &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">this</span>.show();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">          plane.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多态">多态</h3>
<p>多态指同一个实体同时具有多种形式。它是面向对象程序设计（OOP）的一个重要特征。如果一个语言只支持类而不支持多态，只能说明它是<u><strong>基于对象</strong></u>的，而不是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a>的。C++中的多态性具体体现在运行和编译两个方面。运行时多态是动态多态，其具体引用的对象在运行时才能确定。编译时多态是静态多态，在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91">编译</a>时就可以确定对象使用的形式。</p>
<p>多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。即<strong>父类的引用在运行过程中存在不同的状态</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseClass bc = <span class="keyword">null</span>;</span><br><span class="line">bc = SubClass1();</span><br><span class="line">bc = SubClass2();</span><br><span class="line"><span class="comment">// bc在运行过程中有多种状态</span></span><br></pre></td></tr></table></figure>
<p>java多态的前提：</p>
<ul>
<li>继承</li>
<li>重写</li>
<li>父类对象的引用指向子类对象</li>
</ul>
<p>继承关系：IS-A；组合关系Has-A；依赖关系 USE-A</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">20</span>;        <span class="comment">// 静态成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;        <span class="comment">// 静态方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;动物在睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在奔跑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cat is a kind of animal</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">80</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">90</span>;</span><br><span class="line">        String name = <span class="string">&quot;tomCat&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫在睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchMouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫在抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//测试用类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">    Animal am = <span class="keyword">new</span> Cat();        <span class="comment">// 父类对象的引用指向子类对象</span></span><br><span class="line">    am.eat();        <span class="comment">//--&gt; 猫吃饭        </span></span><br><span class="line">    am.sleep();        <span class="comment">//--&gt; 动物在睡觉    // 静态方法</span></span><br><span class="line">    am.run();        <span class="comment">//--&gt;动物在奔跑       // 未重写方法</span></span><br><span class="line"></span><br><span class="line">    am.catchMouse(); <span class="comment">// 报错  不能使用子类特有的属性和方法</span></span><br><span class="line">    System.out.println(am.name); <span class="comment">//报错  不能使用子类特有的属性和方法</span></span><br><span class="line"></span><br><span class="line">    System.out.println(am.num); <span class="comment">// 10</span></span><br><span class="line">    System.out.println(am.age); <span class="comment">// 20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类 Cat 重写了父类Animal的非静态成员方法am.eat();的输出结果为：猫吃饭。 子类 Cat 重写了父类(Animal)的静态成员方法am.sleep();的输出结果为：动物在睡觉 未被子类（Cat）重写的父类（Animal）方法am.run()输出结果为：动物在奔跑</p>
<p><strong>成员变量</strong> 编译看左边(父类),运行看左边(父类) <strong>成员方法</strong> 编译看左边(父类)，运行看右边(子类)。<strong>动态绑定</strong> <strong>静态方法</strong> 编译看左边(父类)，运行看左边(父类)。 (静态和类相关，算不上重写，所以，访问还是左边的) <strong>只有非静态的成员方法,编译看左边,运行看右边</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseClass bc = <span class="keyword">new</span> SubClass();</span><br></pre></td></tr></table></figure>
<h3 id="继承的弊端">继承的弊端</h3>
<p><strong>不能使用子类特有的成员属性和子类特有的成员方法。</strong></p>
<p>解决: 强制转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat cat = (Cat) animal;</span><br></pre></td></tr></table></figure>
<h3 id="抽象类">抽象类</h3>
<p>抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法的声明格式为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>抽象方法必须用<strong>abstract</strong>关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用<strong>abstract</strong>关键字修饰。</p>
<p>因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象, 抽象类就是为了继承而存在的.</p>
<p>包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类的主要有三点区别：</p>
<hr />
<p>　　<strong>1. 抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</strong></p>
<p>　　<strong>2. 抽象类不能用来创建对象；</strong></p>
<p>　　<strong>3. 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。</strong></p>
<p>　　在其他方面，抽象类和普通的类并没有区别。</p>
<hr />
<h3 id="类特殊方法重写override">类特殊方法重写（override）</h3>
<h4 id="tostring方法">toString方法</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Object ob = <span class="keyword">new</span> Object();</span><br><span class="line">System.out.println(ob.toString());    <span class="comment">//打印对象ob的地址</span></span><br><span class="line">System.out.println(ob);            <span class="comment">//打印对象ob的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 toString() override 打印需要的参数</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;B&#123;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;c=&quot;</span> + c +</span><br><span class="line">    <span class="string">&quot;, d=&#x27;&quot;</span> + d + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">    <span class="string">&quot;&#125; &quot;</span> ;</span><br><span class="line">&#125;                                                    <span class="comment">// B&#123;c=12, d=&#x27;dxwec&#x27;&#125; </span></span><br></pre></td></tr></table></figure>
<h4 id="equals方法">equals方法</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(o == <span class="keyword">this</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span>(o == <span class="keyword">null</span> || o.getClass() != <span class="keyword">this</span>.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      This_Object o1 = (This_Object)o;</span><br><span class="line">      <span class="keyword">return</span> o1.variable == <span class="keyword">this</span>.variable &amp;&amp; string.equals(o1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口interface">接口（interface）</h2>
<p>软件工程中，接口泛指供别人调用的方法或者函数，Java语言设计者的初衷，它是对行为的抽象</p>
<p>接口的形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>] <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceName</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>接口内只能是抽象方法（接口是完全抽象化的类，里面没有完整的方法），方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现</strong></li>
<li><strong>接口中可以含有变量，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误）</strong> ，静态常量</li>
<li><strong>接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。</strong></li>
</ul>
<hr />
<p>要让一个类遵循某组特地的接口需要使用implements关键字，具体格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> <span class="keyword">implements</span> <span class="title">Interface1</span>,<span class="title">Interface2</span>,[....]</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>允许一个类遵循多个特定的接口</strong></li>
<li><strong>一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法</strong></li>
</ul>
<h3 id="接口和类的区别">接口和类的区别</h3>
<ol type="1">
<li>语法层面上的区别</li>
</ol>
<p>　　1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</p>
<p>　　2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</p>
<p>　　3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</p>
<p>　　4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<p>2.设计层面上的区别</p>
<ul>
<li><p>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。</p></li>
<li><p>继承是一个 "<strong>IS-A</strong>"的关系，而 接口实现则是 "<strong>HAS-A</strong>"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p></li>
<li><p>抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。</p></li>
<li><p>对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p></li>
</ul>
<p><strong>Example</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对门添加 alarm() 功能</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Alarm</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlarmDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> <span class="keyword">implements</span> <span class="title">Alarm</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// specific implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// specific implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// specific implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口与匿名内部类">接口与匿名内部类</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonNameInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Alarm()&#123;        <span class="comment">// 定义实现 Alarm 接口的子类</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>&#123;        <span class="comment">//必须加 public， interface里的方法默认 public</span></span><br><span class="line">                System.out.println(<span class="string">&quot;alarm&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.alarm();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用类">常用类</h2>
<h3 id="scanner">Scanner</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.utils.Scanner;</span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">scanner.next(); <span class="comment">//输入字符串 遇到空格停止扫描</span></span><br><span class="line">scanner.nextLine(); <span class="comment">// 输入字符串 遇到 &quot;\r&quot; 停止扫描</span></span><br><span class="line">scanner.nextInt();</span><br><span class="line">scanner.next().charAt(<span class="number">0</span>); <span class="comment">//输入字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// haxNext**() 是否有下一个，返回 boolean 类型</span></span><br><span class="line">scanner.hasNext(); <span class="comment">//输入数据，检测是否有下一个字符串，返回</span></span><br><span class="line">scanner.hasNextInt(); <span class="comment">// 是否有下一个整型</span></span><br><span class="line">scanner.hasNextFloat();</span><br></pre></td></tr></table></figure>
<h3 id="stringbuffer-stringbuilder">StringBuffer &amp;&amp; StringBuilder</h3>
<p>创建的字符串可以被修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();<span class="comment">// 可以指定容量</span></span><br><span class="line"></span><br><span class="line">sb.append(<span class="string">&quot;sd&quot;</span>)</span><br><span class="line">  .append(<span class="string">&quot;.com&quot;</span>)</span><br><span class="line">  .append(<span class="string">&quot;.cn&quot;</span>);   <span class="comment">// 使用该方法进行字符串的连接，将比String更加节约内容</span></span><br><span class="line">sb.insert(<span class="keyword">int</span> offset,String str);  <span class="comment">//在StringBuffer对象中插入内容，然后形成新的字符串</span></span><br><span class="line">sb.deleteCharAt(<span class="keyword">int</span> p); <span class="comment">//删除指定位置的字符，然后将剩余的内容形成新的字符串。</span></span><br><span class="line">sb.delete(<span class="keyword">int</span> start,<span class="keyword">int</span> end) <span class="comment">//该方法的作用是删除指定区间以内的所有字符，包含start，不包含end索引值的区间</span></span><br><span class="line"></span><br><span class="line">sb.reverse(); <span class="comment">//将StringBuffer对象中的内容反转</span></span><br><span class="line">sb.setCharAt(<span class="keyword">int</span> index, <span class="keyword">char</span> ch)    <span class="comment">// 该方法的作用是修改对象中索引值为index位置的字符为新的字符ch</span></span><br><span class="line"></span><br><span class="line">sb.capacity();  <span class="comment">//返回缓冲区容量，默认16;</span></span><br><span class="line"></span><br><span class="line">sb.substring(<span class="keyword">int</span> start, <span class="keyword">int</span> end); <span class="comment">//截取包含start，不包含end索引值</span></span><br><span class="line">sb.replace(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String ch); <span class="comment">//替换 包含start，不包含end索引值 的字符串</span></span><br></pre></td></tr></table></figure>
<h4 id="区别">区别</h4>
<p>执行速度，<strong>在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String</strong></p>
<p><strong>String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。</strong></p>
<p>Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多</p>
<p>StringBuilder和StringBuffer一样，都是继承自抽象类AbstractStringBuilder类，也是一个可变的字符序列。StringBuilder和StringBuffer非常相似，甚至有互相兼容的API，不过，<strong>StringBuilder不是线程安全的，这是和StringBuffer的主要区别</strong></p>
<p>当 StringBuffer 的缓冲区满之后，java会申请2倍大小的空间把原来的值赋值过去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">&quot;abc&quot;</span>+<span class="string">&quot;de&quot;</span>;</span><br><span class="line">StringBuilder stringBuilder = newStringBuilder().append(<span class="string">&quot;abc&quot;</span>).append(<span class="string">&quot;de&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line">System.out.println(stringBuilder.toString());</span><br></pre></td></tr></table></figure>
<p>　　这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多，这是因为第1行中的操作和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">&quot;abcde&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>是完全一样的，所以会很快，而如果写成下面这种形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String str2=<span class="string">&quot;de&quot;</span>;</span><br><span class="line">String str=str1+str2;</span><br></pre></td></tr></table></figure>
<p>那么JVM就会像上面说的那样，不断的创建、回收对象来进行这个操作了。速度就会很慢。所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更加适合一些。</p>
<p>字符的存储，JDK9之前是char存储，JDK9之后是byte存储</p>
<p>####互相转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str= <span class="string">&quot;qwert&quot;</span>;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(str);    <span class="comment">//String转换为StringBuffer</span></span><br><span class="line">String str2 = sb.toString(); <span class="comment">//StringBuffer转换为String</span></span><br></pre></td></tr></table></figure>
<h3 id="arrays">Arrays</h3>
<p>静态工具类</p>
<p>method：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>&#125;</span><br><span class="line">Arrays.sort(array);    <span class="comment">// 排序</span></span><br><span class="line">Arrays.toString(array); <span class="comment">//返回 String [1,2,3,3,6]</span></span><br><span class="line">Arrays.BinarySearch(array, <span class="number">3</span>); <span class="comment">// 二分查找，数组有序</span></span><br></pre></td></tr></table></figure>
<h3 id="math">Math</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Math.E;        <span class="comment">//自然对数e</span></span><br><span class="line">Math.abs(); <span class="comment">//取绝对值</span></span><br><span class="line">Math.round(<span class="number">3.4</span>);<span class="comment">//四舍五入</span></span><br><span class="line">Math.aqurt(); <span class="comment">//平方根</span></span><br><span class="line">Math.pow(<span class="keyword">double</span> a, <span class="keyword">double</span> b);  <span class="comment">//第一个参数的值，该值是第二个参数的幂</span></span><br><span class="line">Math.ceil(<span class="keyword">double</span>); <span class="comment">// 向上取整</span></span><br><span class="line">Math.floor(); <span class="comment">//向下取整</span></span><br><span class="line">Math.random(); <span class="comment">//生成随机数，[0,1)</span></span><br></pre></td></tr></table></figure>
<h3 id="bigdecimal-biginteger">BigDecimal &amp; BigInteger</h3>
<p><code>BigDecimal</code>由<code>任意精度</code>整数非<em>标度值</em>和32位整数<em>标度组成</em> 。</p>
<p><code>BigInteger</code>由不可变的<code>任意长度</code>整数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bd = <span class="keyword">new</span> BigDecimal(String str);  <span class="comment">// 小数字符串</span></span><br><span class="line">BigDecimal bd = BigDecimal.valueOf(<span class="number">0.01</span>);    <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>Tips：<code>BigDecimal bd = new BigDecimal(0.02); // 0.0200000000000000004163336</code>: $ $</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bd.divide(BigDecimal divisor,<span class="keyword">int</span> scale, <span class="keyword">int</span> roundingMode);</span><br><span class="line">bd.multiply(BigDecimal nultiplicand);</span><br><span class="line">bd.subtract(BigDecimal subtrahend);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bigInteger = <span class="keyword">new</span> BigInteger(String str);</span><br><span class="line"><span class="comment">//其他方法与BigDecimal 类似</span></span><br></pre></td></tr></table></figure>
<h3 id="date-calendar">Date &amp;&amp; Calendar</h3>
<p>时间类，<code>Date</code>被 <code>Calendar</code> 取代</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">Date d = <span class="keyword">new</span> Date(<span class="keyword">long</span> date);<span class="comment">//使用给定的毫秒时间值构造Date对象。date - 自1970年1月1日00:00:00 GMT以来的毫秒数不超过8099年的毫秒表示。</span></span><br><span class="line">d.toString(); <span class="comment">//以日期转义格式yyyy-mm-dd格式化日期。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">System.out.println(calendar.getTime());</span><br></pre></td></tr></table></figure>
<h3 id="包装类">包装类</h3>
<p>存于栈上</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">包装类</th>
<th style="text-align: center;">基本类</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Byte</td>
<td style="text-align: center;">byte</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">short</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Integer</td>
<td style="text-align: center;">int</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Long</td>
<td style="text-align: center;">long</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">double</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">char</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">boolean</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer.parseInt(String str); <span class="comment">// 整数字符串转为int</span></span><br><span class="line">Integer.valueOf(<span class="keyword">int</span> i); <span class="comment">//Returns an Integer instance representing the specified int value.</span></span><br><span class="line">Integer.valueOf(String i); <span class="comment">//Returns an Integer object holding the value of the specified String.</span></span><br></pre></td></tr></table></figure>
<hr />
<h3 id="集合类-collection">集合类 Collection</h3>
<p><strong>java.util 库提供了一套相当完整的集合类(collection classes)来解决这个问题，其中基本的类型有 List 、Set 、Queue 和 Map。这些类型也被称作容器类(container classes)，集合还有一些其它特性。例如，Set 对于每个值都只保存一个对象，Map 是一个 关联数组，允许将某些对象与其他对象关联起来。Java 集合类都可以自动地调整自己 的大小。</strong></p>
<blockquote>
<p>ArrayList LinkedList Vector // 元素可重复，有序</p>
<p>HashSet TreeSet LinkedSet //不可重复，无序</p>
<p>HashMap TreeMap LinkedMap //</p>
</blockquote>
<h4 id="基本概念">基本概念</h4>
<ul>
<li>集合(Collection): 一个独立元素的序列，这些元素都服从一条或多条规则。List 必须以插入的顺序保存元素，Set 不能包含重复元素，Queue 按照排队规则来确 定对象产生的顺序(通常与它们被插入的顺序相同)。</li>
<li>映射(Map):一组成对的“键值对”对象，允许使用键来查找值。map 允 许我们使用一个对象来查找另一个对象，它也被称作关联数组(associative array)， 因为它将对象和其它对象关联在一起;或者称作字典(dictionary)，</li>
</ul>
<h4 id="案例-集合打印">案例-集合打印</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合的打印</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintingCollections</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Collection&lt;String&gt; <span class="title">fill</span><span class="params">(Collection&lt;String&gt; collection)</span></span>&#123;</span><br><span class="line">        collection.add(<span class="string">&quot;rat&quot;</span>);                    <span class="comment">//Map.put(key, value) </span></span><br><span class="line">        collection.add(<span class="string">&quot;cat&quot;</span>);                    <span class="comment">//添加一个所想要添加的值并将它与一个键(用来查找值)相关联。</span></span><br><span class="line">        collection.add(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> collection;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Map&lt;String,String&gt; <span class="title">fill</span><span class="params">(Map&lt;String,String&gt; map)</span></span>&#123;</span><br><span class="line">        map.put(<span class="string">&quot;rat&quot;</span>,<span class="string">&quot;Fuzzy&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;Rags&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;Bosco&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;Spot&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> ArrayList&lt;&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> LinkedList&lt;&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> HashSet&lt;&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> TreeSet&lt;&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> LinkedHashSet&lt;&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> HashMap&lt;&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> TreeMap&lt;&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> LinkedHashMap&lt;&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[rat, cat, dog, dog]</span></span><br><span class="line"><span class="comment">[rat, cat, dog, dog]</span></span><br><span class="line"><span class="comment">[rat, cat, dog]</span></span><br><span class="line"><span class="comment">[cat, dog, rat]</span></span><br><span class="line"><span class="comment">[rat, cat, dog]</span></span><br><span class="line"><span class="comment">&#123;rat=Fuzzy, cat=Rags, dog=Spot&#125; </span></span><br><span class="line"><span class="comment">&#123;cat=Rags, dog=Spot, rat=Fuzzy&#125; </span></span><br><span class="line"><span class="comment">&#123;rat=Fuzzy, cat=Rags, dog=Spot&#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>结论：</p>
<ul>
<li><code>Collection</code> &amp;&amp; <code>Map</code> 区别在于集合中的每个 “槽”(slot) 保存的元素个数。Collection 类型在每个槽中只能保存一个元素，Map 在每个槽中存放了两个元素，即键和与之关联的值。</li>
<li>ArrayList 和 LinkedList 都是 List 的类型，从输出中可以看出，它们都按插入顺序保存元素。HashSet ，TreeSet 和 LinkedHashSet 是 Set 的类型。从输出中可以看到，Set 仅保存每个相同项中的一个，并且不同的 Set 实现存储元素的方式也不同。</li>
<li>HashSet ，TreeSet 和 LinkedHashSet 是 Set 的类型。从输出中可以看到，Set 仅保存每个相同项中的一个</li>
<li>Set是检索元素的最快方法， TreeSet 按比较结果的升序保存对象； LinkedHashSet 按照被添加的先后顺序保存对象。</li>
<li>HashMap 实现使用了非常快速的算法来控制顺序，键和值不是插入顺序保存在 HashMap 中</li>
<li>TreeMap 通过比较结果的升序来保存键</li>
<li>LinkedHashMap 在保持 HashMap 查找速度的同时按键的插入顺序保存键。</li>
</ul>
<h4 id="list">List</h4>
<p>List 接口在 Collection 的基础上添加了 许多方法，允许在 List 的中间插入和删除元素。</p>
<p>有两种类型的 List :</p>
<ul>
<li><p>基本的 ArrayList ，内部通过数组实现，擅长随机访问元素，但在 List 中间插入和删除元素时速度较慢。</p></li>
<li><p>LinkedList ，链表通过代价较低的在 List 中间进行的插入和删除操作，提供了优化的顺序访问。LinkedList 对于随机访问来说相对较慢，但它具有比 ArrayList 更大的特征集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinkedList linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">linkedList.addFirst();</span><br><span class="line">linkedList.addLast();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>ArrayList &amp;&amp; Vector</p>
<blockquote>
<p>ArrayList &amp;&amp; Vector 几乎一样，区别在于 Vector 线程安全，因此效率低于ArrayList</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//constructors</span></span><br><span class="line">ArrayList al = <span class="keyword">new</span> ArrayList();  <span class="comment">//默认容量为10；</span></span><br><span class="line">ArrayList al = <span class="keyword">new</span> ArrayList(<span class="keyword">int</span> initialCapacity); <span class="comment">//给定初始化容量</span></span><br><span class="line">ArrayList al = <span class="keyword">new</span> ArrayList(Collection &lt;? extends E&gt; c);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用范型，指定集合可以保存的类型，使用泛型，从 List 中获取元素不需要强制类型转换。因为 List 知道它持有什么类型，因此当调用 get() 时，它会替你执行转型。</span></span><br><span class="line">ArrayList&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// methods</span></span><br><span class="line">al.add(E element);  <span class="comment">//在列表末尾加入元素 element</span></span><br><span class="line">al.add(<span class="keyword">int</span> index, E element);</span><br><span class="line">al.addAll(Collection &lt;? extends E&gt; c); <span class="comment">// 将指定集合加入列表的末尾</span></span><br><span class="line">al.remove(Object o); <span class="comment">//在列表中删除第一个给定元素</span></span><br><span class="line">al.removeAll(Collection &lt;? extends E&gt; c);</span><br><span class="line">al.get(<span class="keyword">int</span> index);</span><br><span class="line"><span class="comment">//ubList() 方法可以轻松地从更大的列表中创建切片,对所返回列表的更改都将会反映在原始列表中</span></span><br><span class="line">al.subList();</span><br><span class="line">al.isEmpty();</span><br><span class="line">al.contains(); <span class="comment">//是否包含指定元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转数组</span></span><br><span class="line">Object[] ob = al.toArray();        <span class="comment">//Object 类型元素在for循环时可强制转换其他类型</span></span><br><span class="line">al.toArray(T[] a); <span class="comment">// a - 要存储列表元素的数组</span></span><br></pre></td></tr></table></figure>
<p>Example：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*##########################################################*/</span></span><br><span class="line"></span><br><span class="line">ArrayList al = <span class="keyword">new</span> ArrayList();</span><br><span class="line">al.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">al.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">Object[] s = al.toArray();</span><br><span class="line"></span><br><span class="line">String[] a = <span class="keyword">new</span> String[<span class="number">2</span>];</span><br><span class="line">al.toArray(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Object o: al)&#123;</span><br><span class="line">  System.out.println((String)o);    <span class="comment">// 强制转换为String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*##########################################################*/</span></span><br><span class="line">ArrayList&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  apples.add(<span class="keyword">new</span> Apple(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Apple a:apples)&#123;</span><br><span class="line">  a.showInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Apple[] apples1 = apples.toArray(Apple[]::<span class="keyword">new</span>); <span class="comment">//必须加范型才可使用， 转换为Apple数组</span></span><br></pre></td></tr></table></figure>
<p><strong>Arrays.asList() 方法接受一个数组或是逗号分隔的元素列表(使用可变参数)， 并将其转换为 List 对象。Collections.addAll() 方法接受一个 Collection 对象，以 及一个数组或是一个逗号分隔的列表，将其中元素添加到 Collection 中。下边的示例展示了这两个方法，以及更通用的 addAll() 方法，所有 Collection 类型都包含该方 法:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Arrays.asList(); 转化为 List 对象，继承于 Collection </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Collection 的构造器可以接受另一个 Collection，用它来将自身初始化。因此，可以 使用 Arrays.asList() 来为这个构造器产生输入。</span></span><br><span class="line"><span class="comment">但是，Collections.addAll() 运行得更快，而且很容易构建一个不包含元素的 Collection ，然后调用 Collections.addAll()，因此这是首选方式。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">Collection&lt;Integer&gt; collection = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line"><span class="comment">// Integer 数组</span></span><br><span class="line">Integer[] moreInts = &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(moreInts);</span><br><span class="line">list.set(<span class="number">0</span>,-<span class="number">10</span>);</span><br><span class="line">collection.addAll(list);</span><br><span class="line">System.out.println(collection.toString());</span><br></pre></td></tr></table></figure>
<hr />
<p>####Stack 栈</p>
<p>堆栈是 “后进先出”(LIFO)集合。它有时被称为叠加栈(pushdown stack)，因为 最后 “压入”(push)栈的元素，第一个被 “弹出”(pop)</p>
<p>Java 1.0 中附带了一个 Stack 类，结果设计得很糟糕，Java 6 添加了 ArrayDeque ，其中包含直接实现堆栈功能的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Deque&lt;String&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String s : <span class="string">&quot;My dog has fleas&quot;</span>.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">        stack.push(s); </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">        System.out.print(stack.pop() + <span class="string">&quot; &quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">fleas has dog My</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<hr />
<h4 id="set-集合">Set 集合</h4>
<p>Set 不保存重复的元素。Set 最常见的用途是测试归属性，可以很轻松地询问某个对象是否 在一个 Set 中。因此，查找通常是 Set 最重要的操作，因此通常会选择 HashSet 实 现，该实现针对快速查找进行了优化。</p>
<p>Set 具有与 Collection 相同的接口，因此没有任何额外的功能，不像前面两种不同类型的 List 那样。实际上，Set 就是一个 Collection ，只是行为不同</p>
<p>由 HashSet 维护的顺序与 TreeSet 或 LinkedHashSet 不同，因为它们的实现具有不同的元素存储方式。TreeSet 将元素存储在红-黑树数据结构中，而 HashSet 使用散列函数。LinkedHashSet 因为查询速度的原因也使用了散列，但是使用了链表来维护元素的插入顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>); </span><br><span class="line">Set&lt;Integer&gt; intset = <span class="keyword">new</span> HashSet&lt;&gt;(); </span><br><span class="line"><span class="comment">//在 0 到 29 之间的 10000 个随机整数被添加到 Set 中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        intset.add(rand.nextInt(<span class="number">30</span>)); </span><br><span class="line">System.out.println(intset);</span><br></pre></td></tr></table></figure>
<h4 id="map-映射">Map 映射</h4>
<p>保存键值对 Key ， Value、Key不可重复</p>
<p>衍生类：HashMap、TreeMap、LinkedMap</p>
<p>HashMap &amp;&amp; HashTable</p>
<blockquote>
<p>相同点：</p>
<p>实现原理相同，功能相同，底层都是哈希表结构，查询速度快，在很多情况下可以互用</p>
</blockquote>
<blockquote>
<p>不同点：</p>
<p>1、Hashtable是早期提供的接口，HashMap是新版JDK提供的接口。</p>
<p>2、Hashtable继承Dictionary类，HashMap实现Map接口。</p>
<p>3、Hashtable线程安全，HashMap线程非安全。</p>
<p>4、Hashtable不允许null值，HashMap允许null值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Integer value = map.get(key);</span><br><span class="line"><span class="comment">// 不存在的key，返回 null</span></span><br><span class="line">map.put(key,value==<span class="keyword">null</span>? <span class="number">1</span> : value+<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 遍历不支持 foreach</span></span><br><span class="line">map.keySet() <span class="comment">//返回 Set 类型</span></span><br><span class="line">map.values() <span class="comment">//返回 Collection 类型</span></span><br><span class="line"><span class="keyword">for</span>(Object key:map.keySet())&#123;</span><br><span class="line">      System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="queue-队列">Queue 队列</h4>
<h3 id="范型">范型</h3>
<p>利用范型自我实现ArrayList</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuyang.Tools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">        capacity = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyArrayList</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">capacityExpend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= capacity) &#123;</span><br><span class="line">            capacity = capacity * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            Object[] objects = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">            <span class="keyword">if</span> (size + <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                System.arraycopy(data, <span class="number">0</span>, objects, <span class="number">0</span>, size);</span><br><span class="line">            data = objects;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        capacityExpend();</span><br><span class="line">        data[size] = t;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; size)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> (T) data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o :</span><br><span class="line">                data) &#123;</span><br><span class="line">            s.append(o).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="iterators-迭代器">Iterators 迭代器</h3>
<p>目标：不重写代码就可以应用于不 同类型的集合</p>
<p>迭代器是一个对象，它在一个序列中移动并选择该序列中的每个对象，而客户端程序员不知道或不关心该序列的底 层结构。</p>
<p>迭代器通常被称为轻量级对象(lightweight object):创建它的代价小。 可以看到一些对迭代器有些奇怪的约束。例如，Java 的 Iterator 只能单向移动。这个 Iterator 只能用来:</p>
<ol type="1">
<li>使用 iterator() 方法要求集合返回一个 Iterator。Iterator 将准备好返回序列中的第一个元素。</li>
<li>使用next()方法获得序列中的下一个元素。</li>
<li>使用hasNext()方法检查序列中是否还有元素。</li>
<li>使用remove()方法将迭代器最近返回的那个元素删除。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化列表，元素为Apple</span></span><br><span class="line">List&lt;Apple&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">      list.add(<span class="keyword">new</span> Apple(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterator 迭代， 迭代器初始化一次，使用一次</span></span><br><span class="line">Iterator&lt;Apple&gt; it = list.iterator();        </span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">      Apple apple = it.next();</span><br><span class="line">      apple.showInfo();</span><br><span class="line">&#125;</span><br><span class="line">it.remove();        <span class="comment">//删除由 next() 生成的最后一个元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;size: &quot;</span>+list.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">Apple ID: 0</span></span><br><span class="line"><span class="comment">Apple ID: 1</span></span><br><span class="line"><span class="comment">Apple ID: 2</span></span><br><span class="line"><span class="comment">Apple ID: 3</span></span><br><span class="line"><span class="comment">Apple ID: 4</span></span><br><span class="line"><span class="comment">Apple ID: 5</span></span><br><span class="line"><span class="comment">Apple ID: 6</span></span><br><span class="line"><span class="comment">Apple ID: 7</span></span><br><span class="line"><span class="comment">Apple ID: 8</span></span><br><span class="line"><span class="comment">Apple ID: 9</span></span><br><span class="line"><span class="comment">size: 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>Iterator 的真正威力:能够将遍历序列的操作与该序列的底层结构分离。出于这个原因，我们有 时会说:迭代器统一了对集合的访问方式。</p>
<h4 id="listiterator">ListIterator</h4>
<ul>
<li>ListIterator 是一个更强大的 Iterator 子类型，它只能由各种 List 类生成。</li>
<li>It- erator 只能向前移动，而 ListIterator 可以双向移动。</li>
<li>还可以生成相对于迭代器在列表中指向的当前位置的后一个和前一个元素的索引，并且可以使用 set() 方法替换它访问过的最近一个元素。</li>
<li>通过调用 <strong>listIterator</strong>() 方法来生成指向 List 开头 处的 <strong>ListIterator</strong> ，还可以通过调用 <strong>listIterator(n)</strong> 创建一个一开始就指向列表索 引号为 n 的元素处的 <strong>ListIterator</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">ListIterator&lt;Apple&gt; it = list.listIterator();</span><br><span class="line"><span class="comment">//输出 toString，nextIndex，previousIndex</span></span><br><span class="line"><span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">  System.out.println(it.next()+</span><br><span class="line">                     <span class="string">&quot;,&quot;</span>+it.nextIndex()+</span><br><span class="line">                     <span class="string">&quot;,&quot;</span>+it.previousIndex());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (it.hasPrevious())&#123;</span><br><span class="line">  System.out.println(it.previous().toString());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">// 从 3 开始替换list中的元素</span></span><br><span class="line">it = list.listIterator(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">  Apple apple = it.next();</span><br><span class="line">  it.set(<span class="keyword">new</span> Apple(apple.getId()+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Apple ID: 0,1,0</span></span><br><span class="line"><span class="comment">Apple ID: 1,2,1</span></span><br><span class="line"><span class="comment">Apple ID: 2,3,2</span></span><br><span class="line"><span class="comment">Apple ID: 3,4,3</span></span><br><span class="line"><span class="comment">Apple ID: 4,5,4</span></span><br><span class="line"><span class="comment">Apple ID: 5,6,5</span></span><br><span class="line"><span class="comment">Apple ID: 6,7,6</span></span><br><span class="line"><span class="comment">Apple ID: 7,8,7</span></span><br><span class="line"><span class="comment">Apple ID: 8,9,8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Apple ID: 8</span></span><br><span class="line"><span class="comment">Apple ID: 7</span></span><br><span class="line"><span class="comment">Apple ID: 6</span></span><br><span class="line"><span class="comment">Apple ID: 5</span></span><br><span class="line"><span class="comment">Apple ID: 4</span></span><br><span class="line"><span class="comment">Apple ID: 3</span></span><br><span class="line"><span class="comment">Apple ID: 2</span></span><br><span class="line"><span class="comment">Apple ID: 1</span></span><br><span class="line"><span class="comment">Apple ID: 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[Apple ID: 0, Apple ID: 1, Apple ID: 2, Apple ID: 4, Apple ID: 5, Apple ID: 6, Apple ID: 7, Apple ID: 8, Apple ID: 9]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="异常处理">异常处理</h2>
<p><code>try&#123;&#125;catch&#123;&#125;</code> 语句</p>
<p>Java 中所有异常类继承自 Java.lang.Exception</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(IndexOutOfBoundsException e)&#123;</span><br><span class="line">      e.printStackTrace();    <span class="comment">//打印错误信息，但不终止程序</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ClassCastException e)&#123;</span><br><span class="line">      <span class="comment">// 强制类型转换错误</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者在方法中抛出错误</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拆箱-装箱">拆箱 &amp;&amp; 装箱</h2>
<p>装箱：<code>Integer i = 10;</code> 自动包装机制把基本类型 10 封装为Integer类型</p>
<p>拆箱：<code>i = i + 100</code> Integer 拆箱转为 基本类型 int，再加法运算.</p>
<h2 id="文件操作">文件操作</h2>
<p>文件： 文本文件、非文本文件（二进制文件）</p>
<p>文件操作对象包括文件和文件夹（目录）</p>
<p>Java的文件操作通过File对象实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//File 对象构造方法 </span></span><br><span class="line">File file = <span class="keyword">new</span> File(File parent, String child);<span class="comment">//从父抽象路径名和子路径名(文件名)字符串创建新的 File实例</span></span><br><span class="line">File file = <span class="keyword">new</span> File(String pathname);<span class="comment">//将给定的路径名字符串转换为抽象路径名来创建新的 File实例</span></span><br><span class="line">File file = <span class="keyword">new</span> File(String parent, String child)<span class="comment">//从父路径名字符串和子路径名字符串创建新的 File实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">canExecute</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//测试应用程序是否可以执行此抽象路径名表示的文件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">canRead</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//测试应用程序是否可以读取此抽象路径名表示的文件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">canWrite</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//测试应用程序是否可以修改此抽象路径名表示的文件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">compareTo</span><span class="params">(File pathname)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//按字典顺序比较两个抽象路径名。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">createNewFile</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//当且仅当具有此名称的文件尚不存在时，以原子方式创建由此抽象路径名命名的新空文件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> File    <span class="title">createTempFile</span><span class="params">(String prefix, String suffix)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//在默认临时文件目录中创建一个空文件，使用给定的前缀和后缀生成其名称。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> File    <span class="title">createTempFile</span><span class="params">(String prefix, String suffix, File directory)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">delete</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//删除此抽象路径名表示的文件或目录。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">equals</span><span class="params">(Object obj)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//测试此抽象路径名与给定对象的相等性。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">exists</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//测试此抽象路径名表示的文件或目录是否存在。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//get类</span></span></span><br><span class="line"><span class="function">File    <span class="title">getAbsoluteFile</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回此抽象路径名的绝对形式。</span></span></span><br><span class="line"><span class="function">String    <span class="title">getAbsolutePath</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回此抽象路径名的绝对路径名字符串。</span></span></span><br><span class="line"><span class="function">File    <span class="title">getCanonicalFile</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回此抽象路径名的规范形式。</span></span></span><br><span class="line"><span class="function">String    <span class="title">getCanonicalPath</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回此抽象路径名的规范路径名字符串。</span></span></span><br><span class="line"><span class="function">String    <span class="title">getName</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回此抽象路径名表示的文件或目录的名称。</span></span></span><br><span class="line"><span class="function">String    <span class="title">getParent</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回此抽象路径名父项的路径名字符串，如果此路径名未指定父目录，则返回 null 。</span></span></span><br><span class="line"><span class="function">File    <span class="title">getParentFile</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回此抽象路径名父项的抽象路径名，如果此路径名未指定父目录，则返回 null 。</span></span></span><br><span class="line"><span class="function">String    <span class="title">getPath</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//将此抽象路径名转换为路径名字符串，即返回定义的路径名字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">hashCode</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//计算此抽象路径名的哈希码。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">isAbsolute</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//测试此抽象路径名是否为绝对路径。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">isDirectory</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//测试此抽象路径名表示的文件是否为目录。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">isFile</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//测试此抽象路径名表示的文件是否为普通文件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">isHidden</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//测试此抽象路径名指定的文件是否为隐藏文件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span>    <span class="title">lastModified</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回上次修改此抽象路径名表示的文件的时间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span>    <span class="title">length</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回此抽象路径名表示的文件的长度。</span></span></span><br><span class="line"><span class="function">String[]    <span class="title">list</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回一个字符串数组，用于命名此抽象路径名表示的目录中的文件和目录。</span></span></span><br><span class="line"><span class="function">String[]    <span class="title">list</span><span class="params">(FilenameFilter filter)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回一个字符串数组，用于命名由此抽象路径名表示的目录中的文件和目录，以满足指定的过滤器。</span></span></span><br><span class="line"><span class="function">File[]    <span class="title">listFiles</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回一个抽象路径名数组，表示此抽象路径名表示的目录中的文件。</span></span></span><br><span class="line"><span class="function">File[]    <span class="title">listFiles</span><span class="params">(FileFilter filter)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回一个抽象路径名数组，表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</span></span></span><br><span class="line"><span class="function">File[]    <span class="title">listFiles</span><span class="params">(FilenameFilter filter)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回一个抽象路径名数组，表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> File[]    <span class="title">listRoots</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//列出可用的文件系统根目录。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">mkdir</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//创建此抽象路径名指定的目录。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">mkdirs</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//创建此抽象路径名指定的目录，包括任何必需但不存在的父目录。多级创建</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    renameTo​<span class="params">(File dest)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//重命名此抽象路径名表示的文件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    setExecutable​<span class="params">(<span class="keyword">boolean</span> executable)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//一种方便的方法，用于设置此抽象路径名的所有者执行权限。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    setExecutable​<span class="params">(<span class="keyword">boolean</span> executable, <span class="keyword">boolean</span> ownerOnly)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//设置此抽象路径名的所有者或每个人的执行权限。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    setLastModified​<span class="params">(<span class="keyword">long</span> time)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//设置此抽象路径名指定的文件或目录的上次修改时间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    setReadable​<span class="params">(<span class="keyword">boolean</span> readable)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//一种方便的方法，用于设置此抽象路径名的所有者读取权限。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    setReadable​<span class="params">(<span class="keyword">boolean</span> readable, <span class="keyword">boolean</span> ownerOnly)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//设置此抽象路径名的所有者或每个人的读取权限。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">setReadOnly</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//标记此抽象路径名指定的文件或目录，以便仅允许读取操作。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    setWritable​<span class="params">(<span class="keyword">boolean</span> writable)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//一种方便的方法，用于设置此抽象路径名的所有者写入权限。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    setWritable​<span class="params">(<span class="keyword">boolean</span> writable, <span class="keyword">boolean</span> ownerOnly)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//设置此抽象路径名的所有者或每个人的写入权限。</span></span></span><br><span class="line"><span class="function">Path    <span class="title">toPath</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回从此抽象路径构造的java.nio.file.Path对象。</span></span></span><br><span class="line"><span class="function">String    <span class="title">toString</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回此抽象路径名的路径名字符串。</span></span></span><br><span class="line"><span class="function">URI    <span class="title">toURI</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//构造一个表示此抽象路径名的 file: URI。</span></span></span><br></pre></td></tr></table></figure>
<p>Tip:</p>
<blockquote>
<p>可以通过renameTo（）方法实现文件和文件夹的剪切操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 文件拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path 文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetPath 目标文件路径</span></span><br><span class="line"><span class="comment"> */</span>        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileCopy</span><span class="params">(String path, String targetPath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">         FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(targetPath);) &#123;</span><br><span class="line">          <span class="keyword">int</span> sigh = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//数组缓冲区</span></span><br><span class="line">          <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">          <span class="keyword">while</span> ((sigh = fileInputStream.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">           outputStream.write(b, <span class="number">0</span>, sigh);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 文件移动</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path 文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetPath 目标文件路径</span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">fileMove</span><span class="params">(String path, String targetPath)</span> </span>&#123;</span><br><span class="line">    String[] s1 = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    String[] s2 = targetPath.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    file = <span class="keyword">new</span> File(path);</span><br><span class="line">    <span class="keyword">if</span> (s1[s1.length - <span class="number">1</span>].equals(s2[s1.length - <span class="number">1</span>])) &#123;</span><br><span class="line">        String name = file.getPath();</span><br><span class="line">        File file1 = <span class="keyword">new</span> File(name + <span class="string">&quot;`&quot;</span>);</span><br><span class="line">        file.renameTo(file1);</span><br><span class="line">        (<span class="keyword">new</span> File(name)).mkdirs();</span><br><span class="line">        <span class="keyword">return</span> file1.renameTo(<span class="keyword">new</span> File(targetPath));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> file.renameTo(<span class="keyword">new</span> File(targetPath));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归删除文件  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path 待删除文件目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回bool值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">fileDelete</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(path);</span><br><span class="line">    <span class="keyword">if</span> (delete(file))</span><br><span class="line">      <span class="keyword">return</span> file.delete();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (files == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> file.delete();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">      <span class="keyword">if</span> (f.isFile())</span><br><span class="line">        result = f.delete();</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        result = delete(f) &amp;&amp; f.delete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###数据流（IO流）基类</p>
<ul>
<li><p>字节流 可以读取任意类型数据</p>
<p>​ 抽象基类： InputStream、OutputStream</p></li>
<li><p>字符流 只可以读取文本数据</p>
<p>​ 抽象基类： Reader、Writer</p></li>
</ul>
<p><strong>字节流和字符流的区别</strong>： <strong>（1）读写单位不同</strong>：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。 <strong>（2）处理对象不同</strong>：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。 <strong>（3）缓冲区</strong>：字节流在操作的时候本身是不会用到缓冲区的，是文件本身的直接操作的；而字符流在操作的时候下后是会用到缓冲区的，是通过缓冲区来操作文件。</p>
<p>结论：优先选用字节流。首先因为硬盘上的所有文件都是以字节的形式进行传输或者保存的，包括图片等内容。但是字符只是在内存中才会形成的，所以在开发中，字节流使用广泛。</p>
<h3 id="io字节流">IO字节流</h3>
<p>IO流操作结束必须调用 <code>close()</code> 方法</p>
<h4 id="fileoutputstream">FileOutputStream</h4>
<p>文件输出流是用于将数据写入<code>File</code>或<code>FileDescriptor</code>的输出流。 文件是否可用或是否可以创建取决于底层平台。 特别是某些平台允许一次仅打开一个文件以供写入<code>FileOutputStream</code> （或其他文件写入对象）。 在这种情况下，如果涉及的文件已经打开，则此类中的构造函数将失败。</p>
<p><code>FileOutputStream</code>用于写入诸如图像数据的原始字节流。 要编写字符流，请考虑使用<code>FileWriter</code> 。</p>
<p><strong>Note:</strong></p>
<p>要释放此流使用的资源，应直接或通过通过（Java7 以后）<strong>try-with-resources</strong>调用<a href="chm://33031dcc470bf81a5f5e8595b0905ec1/java.base/java/io/FileOutputStream.html#close()"><code>close()</code></a> 。 子类负责清理子类获取的资源。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream​(File file)    </span><br><span class="line">  <span class="comment">//创建文件输出流以写入由指定的 File对象表示的文件。</span></span><br><span class="line">FileOutputStream​(FileDescriptor fdObj)    </span><br><span class="line">    <span class="comment">//创建要写入指定文件描述符的文件输出流，该文件描述符表示与文件系统中实际文件的现有连接。</span></span><br><span class="line">FileOutputStream​(File file, <span class="keyword">boolean</span> append)    </span><br><span class="line">    <span class="comment">//创建文件输出流以写入由指定的 File对象表示的文件。</span></span><br><span class="line">FileOutputStream​(String name)    </span><br><span class="line">    <span class="comment">//创建文件输出流以写入具有指定名称的文件。</span></span><br><span class="line">FileOutputStream​(String name, <span class="keyword">boolean</span> append)    </span><br><span class="line">    <span class="comment">//创建文件输出流以写入具有指定名称的文件。append 如果是 true ，那么字节将被写入文件的末尾而不是开头</span></span><br></pre></td></tr></table></figure>
<p><strong>实例方法</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>close()</code></td>
<td style="text-align: left;">关闭此文件输出流并释放与此流关联的所有系统资源。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FileChannel</code></td>
<td style="text-align: left;"><code>getChannel()</code></td>
<td style="text-align: left;">返回与此文件输出流关联的唯一<a href="chm://33031dcc470bf81a5f5e8595b0905ec1/java.base/java/nio/channels/FileChannel.html"><code>FileChannel</code></a>对象。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FileDescriptor</code></td>
<td style="text-align: left;"><code>getFD()</code></td>
<td style="text-align: left;">返回与此流关联的文件描述符。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>write(byte[] b)</code></td>
<td style="text-align: left;">将指定字节数组中的 <code>b.length</code>字节写入此文件输出流。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>write(byte[] b, int off, int len)</code></td>
<td style="text-align: left;">将从偏移量 <code>off</code>开始的指定字节数组中的 <code>len</code>字节写入此文件输出流。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>write(int b)</code></td>
<td style="text-align: left;">将指定的字节写入此文件输出流。</td>
</tr>
</tbody>
</table>
<h4 id="fileinputstream">FileInputStream</h4>
<p><strong>实例方法</strong></p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 29%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>available()</code></td>
<td>返回可以从此输入流中读取（或跳过）的剩余字节数的估计值，而不会被下一次调用此输入流的方法阻塞。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>close()</code></td>
<td>关闭此文件输入流并释放与该流关联的所有系统资源。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FileChannel</code></td>
<td style="text-align: left;"><code>getChannel()</code></td>
<td>返回与此文件输入流关联的唯一[<code>FileChannel</code>]对象。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FileDescriptor</code></td>
<td style="text-align: left;"><code>getFD()</code></td>
<td>返回 <code>FileDescriptor</code>对象，该对象表示与此<code>FileInputStream</code>正在使用的文件系统中的实际文件的连接。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>read()</code></td>
<td>从此输入流中读取一个字节的数据，末尾返回-1</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>read(byte[] b)</code></td>
<td>从此输入流中读取最多 <code>b.length</code>字节的数据到字节数组b中，返回每次读取长度</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>read(byte[] b, int off, int len)</code></td>
<td>从此输入流 <code>len</code>最多 <code>len</code>字节的数据读入一个字节数组。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>long</code></td>
<td style="text-align: left;"><code>skip(long n)</code></td>
<td>跳过并从输入流中丢弃 <code>n</code>字节的数据。</td>
</tr>
</tbody>
</table>
<p>字节数组使用</p>
<p>数组大小不可过大，否则会导致内存不足，读取到数组时按数组大小一次读取，合适的数组大小会提升性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//read</span></span><br><span class="line"><span class="keyword">int</span> input = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> ((input = fileInputStream.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">  System.out.println(input);</span><br><span class="line">  ArrayTool.print(b, <span class="number">0</span>, input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="string">&quot;中国🇨🇳我爱你&quot;</span>.getBytes();</span><br><span class="line">fileOutputStream.write(b);</span><br></pre></td></tr></table></figure>
<p><strong>关闭方法</strong></p>
<blockquote>
<p>JAVA的流不单在内存中分配了空间，也在操作系统占有了资源，比如占用的端口,文件句柄,网络操作数据库应用等。java的垃圾回收机制GC是能从内存中回收不使用的对象，但对操作系统分配的资源是无法干预的，所以就要调用close()方法来通知系统来释放这个资源。</p>
</blockquote>
<p>Java7 以前</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(is != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      is.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException)&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java7 以后，使用<code>try-with-resources</code>,将需要关闭的流对象放在try的()中创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(InputStream fileInputStream = <span class="keyword">new</span> FileInputStream(text)) &#123;</span><br><span class="line">  <span class="keyword">int</span> input;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    input = fileInputStream.read();    <span class="comment">//指针到达末尾返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (input == -<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>)input);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bufferinputstream">BufferInputStream</h4>
<p><code>BufferedInputStream</code>向另一个输入流添加功能 - 即缓冲输入并支持<code>mark</code>和<code>reset</code>方法的功能。</p>
<p>创建<code>BufferedInputStrea</code>会创建内部缓冲区阵列。 当读取或跳过来自流的字节时，会根据需要从包含的输入流中一次多个字节向内部缓冲区重新填充。 <code>mark</code>操作会记住输入流中的一个点，并且<code>reset</code>操作会导致在从包含的输入流中获取新字节之前重新读取自最近的<code>mark</code>操作以来读取的所有字节。</p>
<p><strong>buffer 性能较高，使用字节数组的性能略低但差别不大。</strong></p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 23%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>available()</code></td>
<td style="text-align: left;">返回可以从此输入流中读取（或跳过）的字节数的估计值，而不会被下一次调用此输入流的方法阻塞。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>close()</code></td>
<td style="text-align: left;">关闭此输入流并释放与该流关联的所有系统资源。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>mark(int readlimit)</code></td>
<td style="text-align: left;">标记此输入流中的当前位置，随后对<code>reset</code>方法的调用会在最后标记的位置重新定位此流，以便后续读取重新读取相同的字节。 readlimit<code>- 标记位置变为无效之前可读取的最大字节数限制 | |</code>boolean<code>|</code>markSupported()<code>| 测试此输入流是否支持</code>mark<code>和</code>reset<code>方法。                                                                         | |</code>int<code>|</code>read()<code>| 从输入流中读取下一个数据字节。                                                                                       | |</code>int<code>|</code>read(byte[] b, int off, int len)<code>| 从给定的偏移量开始，将此字节输入流中的字节读入指定的字节数组。                                                                       | |</code>void<code>|</code>reset()<code>| 将此流重新定位到上次在此输入流上调用</code>mark<code>方法时的位置                                                                        | |</code>long<code>|</code>skip(long n)<code>| 见的总承包</code>skip<code>的方法</code>InputStream` 。</td>
</tr>
</tbody>
</table>
<h4 id="bufferoutputstream-包装流">BufferOutputStream 包装流</h4>
<p>该类实现缓冲输出流。 通过设置这样的输出流，应用程序可以将字节写入基础输出流，而不必为写入的每个字节调用底层系统，节约性能。</p>
<p>对OutputStream类进行包装，内部设置缓冲区</p>
<p><strong>构造方法</strong></p>
<p>FileOutputStream 继承自 OutputStream，也可作为参数</p>
<table>
<colgroup>
<col style="width: 58%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">构造器</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>BufferedOutputStream(OutputStream out)</code></td>
<td style="text-align: left;">创建新的缓冲输出流以将数据写入指定的基础输出流。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>BufferedOutputStream(OutputStream out, int size)</code></td>
<td style="text-align: left;">创建新的缓冲输出流，以使用指定的缓冲区大小将数据写入指定的基础输出流。</td>
</tr>
</tbody>
</table>
<p><strong>实例方法</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>void</code></td>
<td style="text-align: left;"><code>flush()</code></td>
<td style="text-align: left;">刷新此缓冲的输出流。</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>void</code></td>
<td style="text-align: left;"><code>write(byte[] b, int off, int len)</code></td>
<td style="text-align: left;">将从偏移量 <code>off</code>开始的指定字节数组中的 <code>len</code>字节写入此缓冲输出流。</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>void</code></td>
<td style="text-align: left;"><code>write(int b)</code></td>
<td style="text-align: left;">将指定单个字节写入此缓冲区的输出流，减少对硬盘的io次数</td>
</tr>
</tbody>
</table>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> path 待删除文件目录</span></span><br><span class="line"><span class="comment">* <span class="doctag">@append</span> true 则写入文件的末尾而不是开头</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileWrite</span><span class="params">(String path, String string, <span class="keyword">boolean</span> append)</span></span>&#123;</span><br><span class="line">    file = <span class="keyword">new</span> File(path);</span><br><span class="line">    <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Can not be a directory&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>(BufferedOutputStream bufferedOutputStream =</span><br><span class="line">        <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(path, append))) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = string.getBytes();</span><br><span class="line">        bufferedOutputStream.write(b,<span class="number">0</span>,b.length);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="io字符流">IO字符流</h3>
<p>抽象基类： System.io.write、System.io.read</p>
<p>用于写入字符流的抽象类。 子类必须实现的唯一方法是write（char []，int，int），flush（）和close（）。 但是，大多数子类将覆盖此处定义的一些方法，以提供更高的效率，附加功能或两者兼而有之。</p>
<h4 id="outputstreamwriter">OutputStreamWriter</h4>
<p><strong>包装流</strong></p>
<p>从字符流到字节流的桥接器：使用指定的<code>charset</code>将写入其中的字符编码为字节。 它使用的字符集可以通过名称指定，也可以明确指定，或者可以接受平台的默认字符集。</p>
<p><strong>每次调用write（）方法都会导致在给定字符上调用编码转换器。 生成的字节在写入底层输出流之前在缓冲区中累积。</strong></p>
<p><strong>注意： 传递给write（）方法的单个字符不会被缓冲。</strong></p>
<p>为了获得最高效率，考虑在BufferedWriter中包装OutputStreamWriter，以避免频繁的转换器调用。 例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Writer out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out)); </span><br></pre></td></tr></table></figure>
<p><strong>构造方法</strong></p>
<table>
<colgroup>
<col style="width: 61%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">构造器</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>OutputStreamWriter(OutputStream out)</code></td>
<td style="text-align: left;">创建使用默认字符编码的OutputStreamWriter。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>OutputStreamWriter(OutputStream out, String charsetName)</code></td>
<td style="text-align: left;">创建使用指定charset的OutputStreamWriter。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>OutputStreamWriter(OutputStream out, Charset cs)</code></td>
<td style="text-align: left;">创建使用给定charset的OutputStreamWriter。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>OutputStreamWriter(OutputStream out, CharsetEncoder enc)</code></td>
<td style="text-align: left;">创建使用给定charset编码器的OutputStreamWriter。</td>
</tr>
</tbody>
</table>
<p><strong>实例方法</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>flush()</code></td>
<td style="text-align: left;">刷新流。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;"><code>getEncoding()</code></td>
<td style="text-align: left;">返回此流使用的字符编码的名称。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>write(char[] cbuf, int off, int len)</code></td>
<td style="text-align: left;">写一个字符数组的一部分。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>write(int c)</code></td>
<td style="text-align: left;">写一个字符。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>write(String str, int off, int len)</code></td>
<td style="text-align: left;">写一个字符串的一部分。</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法写</span></span><br><span class="line"><span class="comment">//@param charset 编码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String path, <span class="keyword">char</span>[] chars,String charset, <span class="keyword">int</span> off, <span class="keyword">int</span> length, <span class="keyword">boolean</span> append)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (OutputStreamWriter outputStreamWriter =</span><br><span class="line">         <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(path, append),charset)) &#123;</span><br><span class="line">          outputStreamWriter.write(chars, off, length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="inputstreamreader">InputStreamReader</h4>
<p>InputStreamReader是从字节流到字符流的桥接器：它使用指定的[<code>charset</code>]读取字节并将其解码为字符。 它使用的字符集可以通过名称指定，也可以明确指定，或者可以接受平台的默认字符集。</p>
<p>为了获得最高效率，在BufferedReader中包装InputStreamReader。 例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)); </span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 59%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">构造器</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>InputStreamReader(InputStream in)</code></td>
<td style="text-align: left;">创建一个使用默认字符集的InputStreamReader。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>InputStreamReader(InputStream in, String charsetName)</code></td>
<td style="text-align: left;">创建一个使用指定charset的InputStreamReader。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>InputStreamReader(InputStream in, Charset cs)</code></td>
<td style="text-align: left;">创建一个使用给定charset的InputStreamReader。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>InputStreamReader(InputStream in, CharsetDecoder dec)</code></td>
<td style="text-align: left;">创建一个使用给定charset解码器的InputStreamReader。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;"><code>getEncoding()</code></td>
<td style="text-align: left;">返回此流使用的字符编码的名称。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>read()</code></td>
<td style="text-align: left;">读一个字符。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>read(char[] cbuf, int offset, int length)</code></td>
<td style="text-align: left;">将字符读入数组的一部分。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>ready()</code></td>
<td style="text-align: left;">判断此流是否可以读取。</td>
</tr>
</tbody>
</table>
<p>字符读取**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">read</span><span class="params">(String path, String charset)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStreamReader inputStreamReader =</span><br><span class="line">         <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(path),charset))&#123;</span><br><span class="line">      <span class="keyword">if</span> (!inputStreamReader.ready())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">      StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">int</span> sigh;</span><br><span class="line">      <span class="keyword">while</span> ((sigh = inputStreamReader.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sigh;i++)&#123;</span><br><span class="line">          stringBuilder.append(chars[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="filewriter-filereader">FileWriter &amp;&amp; FileReader</h4>
<ul>
<li><p><strong>java.lang.Object</strong></p></li>
<li><ul>
<li><p><strong>java.io.Writer</strong></p>
<ul>
<li><ul>
<li><strong>java.io.OutputStreamWriter</strong>
<ul>
<li><ul>
<li><strong>java.io.FileWriter</strong></li>
</ul></li>
</ul></li>
</ul></li>
<li><ul>
<li><p><strong>java.io.InoutStreamReader</strong></p>
<ul>
<li><ul>
<li><strong>Java.io.FileReader</strong></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p>与父类类似，封闭性更好，创建简单</p>
<p>调用时默认使用平台的<strong>charset</strong></p>
<p><strong>FileWriter</strong></p>
<table>
<colgroup>
<col style="width: 44%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">构造器</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>FileWriter(File file)</code></td>
<td style="text-align: left;">给 <code>File</code>写一个 <code>FileWriter</code> ，使用平台的 [default charset]</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FileWriter(FileDescriptor fd)</code></td>
<td style="text-align: left;">构造一个 <code>FileWriter</code>给出的文件描述符，使用该平台的 [default charset]</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FileWriter(File file, boolean append)</code></td>
<td style="text-align: left;">在给出要写入的 <code>FileWriter</code>下构造 <code>File</code> ，并使用平台的 [default charset构造] 一个布尔值，指示是否附加写入的数据。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FileWriter(File file, Charset charset)</code></td>
<td style="text-align: left;">构造一个<code>FileWriter</code>给予<code>File</code>编写和[charset]</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FileWriter(File file, Charset charset, boolean append)</code></td>
<td style="text-align: left;">构造<code>FileWriter</code>给出<code>File</code>写入， [charset] 和一个布尔值，指示是否附加写入的数据。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FileWriter(String fileName)</code></td>
<td style="text-align: left;">构造一个 <code>FileWriter</code>给出文件名，使用平台的 [default charset]</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FileWriter(String fileName, boolean append)</code></td>
<td style="text-align: left;">使用平台的 [default charset] 构造一个 <code>FileWriter</code>给定一个文件名和一个布尔值，指示是否附加写入的数据。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FileWriter(String fileName, Charset charset)</code></td>
<td style="text-align: left;">构造一个<code>FileWriter</code>给出文件名和[charset]。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FileWriter(String fileName, Charset charset, boolean append)</code></td>
<td style="text-align: left;">构造一个<code>FileWriter</code>给定一个文件名， [charset] 和一个布尔值，指示是否附加写入的数据。</td>
</tr>
</tbody>
</table>
<p><strong>FileReader</strong></p>
<table>
<colgroup>
<col style="width: 40%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">构造器</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>FileReader(File file)</code></td>
<td style="text-align: left;">使用平台 <code>FileReader</code> ，在 <code>File</code>读取时创建一个新的 FileReader。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FileReader(FileDescriptor fd)</code></td>
<td style="text-align: left;">使用平台 [default charset] 创建一个新的 <code>FileReader</code> ，给定 <code>FileDescriptor</code>进行读取。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FileReader(File file, Charset charset)</code></td>
<td style="text-align: left;">创建一个新的<code>FileReader</code> ，给出<code>File</code>读取和[charset]。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FileReader(String fileName)</code></td>
<td style="text-align: left;">使用平台 [default charset] 创建一个新的 <code>FileReader</code> ，给定要读取的文件的 [名称] 。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FileReader(String fileName, Charset charset)</code></td>
<td style="text-align: left;">给定要读取的文件的名称和<code>FileReader</code> ，创建一个新的[FileReader]</td>
</tr>
</tbody>
</table>
<h4 id="bufferedwriter-bufferedreader">BufferedWriter &amp;&amp; BufferedReader</h4>
<p><strong>BufferedWriter</strong></p>
<p>BufferedWriter将文本写入字符输出流，缓冲字符，以便有效地写入单个字符，数组和字符串。</p>
<p>可以指定缓冲区大小，或者可以接受默认大小。 对于大多数用途，默认值足够大。</p>
<p>提供了一个newLine（）方法，它使用平台自己的行分隔符概念，由系统属性<code>line.separator</code>定义。 并非所有平台都使用换行符（' n'）来终止行。 因此，调用此方法终止每个输出行比直接编写换行符更为可取。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">构造器</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>BufferedWriter(Writer out)</code></td>
<td style="text-align: left;">创建使用默认大小的输出缓冲区的缓冲字符输出流。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>BufferedWriter(Writer out, int sz)</code></td>
<td style="text-align: left;">创建一个使用给定大小的输出缓冲区的新缓冲字符输出流。</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BufferedWriter bufferedWriter = </span><br><span class="line">          <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(path));</span><br><span class="line"></span><br><span class="line">BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(path);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>flush()</code></td>
<td style="text-align: left;">刷新流。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>newLine()</code></td>
<td style="text-align: left;">写一个行分隔符。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>write(char[] cbuf, int off, int len)</code></td>
<td style="text-align: left;">写一个字符数组的一部分。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>write(int c)</code></td>
<td style="text-align: left;">写一个字符。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>write(String s, int off, int len)</code></td>
<td style="text-align: left;">写一个字符串的一部分。</td>
</tr>
</tbody>
</table>
<p><strong>BufferedReader</strong></p>
<p>由Reader构成的每个读取请求都会导致相应的读取请求由基础字符或字节流构成。 因此，建议将BufferedReader包装在任何read（）操作可能代价高昂的Reader上，例如FileReaders和InputStreamReaders。 例如，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in</span><br><span class="line"> = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;foo.in&quot;</span>)); </span><br></pre></td></tr></table></figure>
<p>将缓冲指定文件的输入。 如果没有缓冲，read（）或readLine（）的每次调用都可能导致从文件中读取字节，转换为字符，然后返回，这可能是非常低效的。</p>
<p>使用DataInputStreams进行文本输入的程序可以通过用适当的BufferedReader替换每个DataInputStream来进行本地化。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">构造器</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>BufferedReader(Reader in)</code></td>
<td style="text-align: left;">创建使用默认大小的输入缓冲区的缓冲字符输入流。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>BufferedReader(Reader in, int sz)</code></td>
<td style="text-align: left;">创建使用指定大小的输入缓冲区的缓冲字符输入流。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Stream</code></td>
<td style="text-align: left;"><code>lines()</code></td>
<td style="text-align: left;">返回 <code>Stream</code> ，其元素是从此 <code>BufferedReader</code>读取的行。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>mark(int readAheadLimit)</code></td>
<td style="text-align: left;">标记流中的当前位置。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>markSupported()</code></td>
<td style="text-align: left;">判断此流是否支持mark（）操作。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>read()</code></td>
<td style="text-align: left;">读一个字符。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>read(char[] cbuf, int off, int len)</code></td>
<td style="text-align: left;">将字符读入数组的一部分。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;"><code>readLine()</code></td>
<td style="text-align: left;">读一行文字。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>ready()</code></td>
<td style="text-align: left;">判断此流是否可以读取。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>reset()</code></td>
<td style="text-align: left;">将流重置为最新标记。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>long</code></td>
<td style="text-align: left;"><code>skip(long n)</code></td>
<td style="text-align: left;">跳过字符。</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="并发">并发</h2>
<p>• 并发是关于正确有效地控制对共享资源的访问。</p>
<p>• 并行是使用额外的资源来更快地产生结果。</p>
<p>将一个程序转换成多个独立运行的子任务，像这样的每个子任务都叫作一个“线程”（Thread）。编写程序时，可将每个线程都想象成独立运行，而且都有自己的专用CPU。一些基础机制实际会为我们自动分割CPU的时间。我们通常不必关心这些细节问题，所以多线程的代码编写是相当简便的。</p>
<p>Java 并发的核心机制是 Thread 类，在该语言最初版本中，Thread (线程)是由 程序员直接创建和管理的。随着语言的发展以及人们发现了更好的一些方法，中间层机制 - 特别是 Executor 框架 - 被添加进来，以消除自己管理线程时候的心理负担(及错误)</p>
<hr />
<h3 id="thread线程">Thread(线程)</h3>
<p>将任务关联到处理器的软件概念，当创建一个 Thread 时，JVM 将分配一大块内存到专为线程保留的特殊区域上，用于提供运行任务时所需 的一切，包括:</p>
<p>• 程序计数器，指明要执行的下一个 JVM 字节码指令。 • 用于支持 Java 代码执行的栈，包含有关此线程已到达当时执行位置所调用方法的信息。它也包含每个正在执行的方法的所有局部变量 (包括原语和堆对象的引用)。 每个线程的栈通常在 64K 到 1M 之间 。</p>
<p>• 第二个则用于 native code(本机方法代码)执行的栈</p>
<p>• thread-local variables (线程本地变量)的存储区域</p>
<p>• 用于控制线程的状态管理变量</p>
<hr />
<p><strong>Thread 类</strong></p>
<p>每个线程都有优先权。 具有较高优先级的线程优先于具有较低优先级的线程执行。 每个线程可能也可能不会被标记为守护进程。 当在某个线程中运行的代码创建一个新的<code>Thread</code>对象时，新线程的优先级最初设置为等于创建线程的优先级，并且当且仅当创建线程是守护进程时才是守护进程线程。</p>
<p>当Java虚拟机启动时，通常会有一个非守护进程线程（通常调用某个指定类的名为<code>main</code>的方法）。 Java虚拟机继续执行线程，直到发生以下任一情况：</p>
<ul>
<li>已调用类<code>Runtime</code>的<code>exit</code>方法，并且安全管理器已允许执行退出操作。</li>
<li>通过调用<code>run</code>方法返回或抛出超出<code>run</code>方法传播的异常，所有非守护程序线程的线程都已死亡。</li>
</ul>
<p><strong>有两种方法可以创建新的执行线程</strong>。</p>
<p>一种是将类声明为<code>Thread</code>的子类。 此子类应覆盖类<code>Thread</code>的<code>run</code>方法。 然后可以分配和启动子类的实例。 例如，计算大于规定值的素数的线程可以写成如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> minPrime;</span><br><span class="line">    PrimeThread(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">          <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">                 <span class="comment">//. . .</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下代码将创建一个线程并开始运行：</span></span><br><span class="line">PrimeThread p = <span class="keyword">new</span> PrimeThread(<span class="number">143</span>);</span><br><span class="line">p.start();</span><br></pre></td></tr></table></figure>
<p>另一种方法是声明一个实现<code>Runnable</code>接口的类。 该类然后实现<code>run</code>方法。 然后可以分配类的实例，在创建<code>Thread</code>时作为参数传递，然后启动。 此其他样式中的相同示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">PrimeRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> minPrime;</span><br><span class="line">     PrimeRun(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">       <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">       . . .</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下代码将创建一个线程并开始运行：</span></span><br><span class="line"></span><br><span class="line">PrimeRun p = <span class="keyword">new</span> PrimeRun(<span class="number">143</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(p).start();</span><br></pre></td></tr></table></figure>
<p>每个线程都有一个用于识别目的的名称。 多个线程可能具有相同的名称。 如果在创建线程时未指定名称，则会为其生成新名称</p>
<p>Example</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程用例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread: &quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">        ThreadTest.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MainThread: &quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">MainThread: 0</span></span><br><span class="line"><span class="comment">MyThread: 0</span></span><br><span class="line"><span class="comment">MainThread: 1</span></span><br><span class="line"><span class="comment">MyThread: 1</span></span><br><span class="line"><span class="comment">MyThread: 2</span></span><br><span class="line"><span class="comment">MainThread: 2</span></span><br><span class="line"><span class="comment">MyThread: 3</span></span><br><span class="line"><span class="comment">MainThread: 3</span></span><br><span class="line"><span class="comment">MyThread: 4</span></span><br><span class="line"><span class="comment">MainThread: 4</span></span><br><span class="line"><span class="comment">MyThread: 5</span></span><br><span class="line"><span class="comment">MainThread: 5</span></span><br><span class="line"><span class="comment">MyThread: 6</span></span><br><span class="line"><span class="comment">MainThread: 6</span></span><br><span class="line"><span class="comment">MyThread: 7</span></span><br><span class="line"><span class="comment">MainThread: 7</span></span><br><span class="line"><span class="comment">MyThread: 8</span></span><br><span class="line"><span class="comment">MainThread: 8</span></span><br><span class="line"><span class="comment">MyThread: 9</span></span><br><span class="line"><span class="comment">MainThread: 9</span></span><br><span class="line"><span class="comment">MyThread: 10</span></span><br><span class="line"><span class="comment">MainThread: 10</span></span><br><span class="line"><span class="comment">MyThread: 11</span></span><br><span class="line"><span class="comment">MainThread: 11</span></span><br><span class="line"><span class="comment">MyThread: 12</span></span><br><span class="line"><span class="comment">MainThread: 12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><img src="并发线程.png" style="zoom:60%;" /></p>
<ul>
<li><p>测试类为父线程，Mythread类创建子线程</p></li>
<li><p>子线程和父线程同时运行，因此结果具有随机性，打印出的数据顺序非线性。</p></li>
</ul>
<p><strong>字段</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">字段</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>static int</code></td>
<td style="text-align: left;"><code>MAX_PRIORITY</code></td>
<td style="text-align: left;">线程可以拥有的最大优先级 (10)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>static int</code></td>
<td style="text-align: left;"><code>MIN_PRIORITY</code></td>
<td style="text-align: left;">线程可以拥有的最低优先级。(1)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static int</code></td>
<td style="text-align: left;"><code>NORM_PRIORITY</code></td>
<td style="text-align: left;">分配给线程的默认优先级。(5)</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">构造器</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Thread()</code></td>
<td style="text-align: left;">分配新的 <code>Thread</code>对象。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Thread(Runnable target)</code></td>
<td style="text-align: left;">分配新的 <code>Thread</code>对象。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Thread(Runnable target, String name)</code></td>
<td style="text-align: left;">分配新的 <code>Thread</code>对象。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Thread(String name)</code></td>
<td style="text-align: left;">分配新的 <code>Thread</code>对象。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Thread(ThreadGroup group, Runnable target)</code></td>
<td style="text-align: left;">分配新的 <code>Thread</code>对象。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Thread(ThreadGroup group, Runnable target, String name)</code></td>
<td style="text-align: left;">分配新的 <code>Thread</code>对象，使其具有 <code>target</code>作为其运行对象，具有指定的 <code>name</code>作为其名称，并且属于 <code>group</code>引用的线程组。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Thread(ThreadGroup group, Runnable target, String name, long stackSize)</code></td>
<td style="text-align: left;">分配新的 <code>Thread</code>对象，使其具有 <code>target</code>作为其运行对象，具有指定的 <code>name</code>作为其名称，并且属于 <code>group</code>引用的线程组，并具有指定的 <em>堆栈大小</em> 。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Thread(ThreadGroup group, Runnable target, String name, long stackSize, boolean inheritThreadLocals)</code></td>
<td style="text-align: left;">分配新的<code>Thread</code>对象，使其具有<code>target</code>作为其运行对象，具有指定的<code>name</code>作为其名称，属于<code>group</code>引用的线程组，具有指定的<code>stackSize</code>，并且如果<code>inheritThreadLocals</code>是<code>true</code> ，则继承<a href="chm://33031dcc470bf81a5f5e8595b0905ec1/java.base/java/lang/InheritableThreadLocal.html">inheritable thread-local</a>变量的初始值。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Thread(ThreadGroup group, String name)</code></td>
<td style="text-align: left;">分配新的 <code>Thread</code>对象。</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 33%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>static int</code></td>
<td style="text-align: left;"><code>activeCount()</code></td>
<td style="text-align: left;">返回当前线程<a href="chm://33031dcc470bf81a5f5e8595b0905ec1/java.base/java/lang/ThreadGroup.html">thread group</a>及其子组中活动线程数的估计值。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>checkAccess()</code></td>
<td style="text-align: left;">确定当前运行的线程是否具有修改此线程的权限。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>protected Object</code></td>
<td style="text-align: left;"><code>clone()</code></td>
<td style="text-align: left;">抛出CloneNotSupportedException，因为无法有意义地克隆线程。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>static Thread</code></td>
<td style="text-align: left;"><code>currentThread()</code></td>
<td style="text-align: left;">返回对当前正在执行的线程对象的引用。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static void</code></td>
<td style="text-align: left;"><code>dumpStack()</code></td>
<td style="text-align: left;">将当前线程的堆栈跟踪打印到标准错误流。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>static int</code></td>
<td style="text-align: left;"><code>enumerate(Thread[] tarray)</code></td>
<td style="text-align: left;">将当前线程的线程组及其子组中的每个活动线程复制到指定的数组中。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static Map</code></td>
<td style="text-align: left;"><code>getAllStackTraces()</code></td>
<td style="text-align: left;">返回所有活动线程的堆栈跟踪映射。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ClassLoader</code></td>
<td style="text-align: left;"><code>getContextClassLoader()</code></td>
<td style="text-align: left;">返回此线程的上下文 <code>ClassLoader</code> 。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>long</code></td>
<td style="text-align: left;"><code>getId()</code></td>
<td style="text-align: left;">返回此Thread的标识符。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;"><code>getName()</code></td>
<td style="text-align: left;">返回此线程的名称。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>getPriority()</code></td>
<td style="text-align: left;">返回此线程的优先级。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>StackTraceElement[]</code></td>
<td style="text-align: left;"><code>getStackTrace()</code></td>
<td style="text-align: left;">返回表示此线程的堆栈转储的堆栈跟踪元素数组。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Thread.State</code></td>
<td style="text-align: left;"><code>getState()</code></td>
<td style="text-align: left;">返回此线程的状态。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ThreadGroup</code></td>
<td style="text-align: left;"><code>getThreadGroup()</code></td>
<td style="text-align: left;">返回此线程所属的线程组。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Thread. UncaughtExceptionHandler</code></td>
<td style="text-align: left;"><code>getUncaughtExceptionHandler()</code></td>
<td style="text-align: left;">返回此线程由于未捕获的异常而突然终止时调用的处理程序。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>static boolean</code></td>
<td style="text-align: left;"><code>holdsLock(Object obj)</code></td>
<td style="text-align: left;">当且仅当当前线程在指定对象上保存监视器锁时，返回 <code>true</code> 。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>interrupt()</code></td>
<td style="text-align: left;">中断此线程。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>static boolean</code></td>
<td style="text-align: left;"><code>interrupted()</code></td>
<td style="text-align: left;">测试当前线程是否已被中断。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isAlive()</code></td>
<td style="text-align: left;">测试此线程是否存活。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isDaemon()</code></td>
<td style="text-align: left;">测试此线程是否为守护程序线程。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isInterrupted()</code></td>
<td style="text-align: left;">测试此线程是否已被中断。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>join()</code></td>
<td style="text-align: left;">等待这个线程死亡。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>join(long millis)</code></td>
<td style="text-align: left;">此线程最多等待 <code>millis</code>毫秒。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>join(long millis, int nanos)</code></td>
<td style="text-align: left;">此线程最多等待 <code>millis</code>毫秒加上 <code>nanos</code>纳秒。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static void</code></td>
<td style="text-align: left;"><code>onSpinWait()</code></td>
<td style="text-align: left;">表示调用者暂时无法进展，直到其他活动发生一个或多个操作为止。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>run()</code></td>
<td style="text-align: left;">如果此线程是使用单独的<code>Runnable</code>运行对象构造的，则调用该<code>Runnable</code>对象的<code>run</code>方法; 否则，此方法不执行任何操作并返回。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setContextClassLoader(   ClassLoader cl)</code></td>
<td style="text-align: left;">为此Thread设置上下文ClassLoader。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setDaemon(boolean on)</code></td>
<td style="text-align: left;">将此线程标记为 <a href="chm://33031dcc470bf81a5f5e8595b0905ec1/java.base/java/lang/Thread.html#isDaemon()">daemon</a>线程或用户线程。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static void</code></td>
<td style="text-align: left;"><code>setDefaultUncaughtExceptionHandler( Thread.UncaughtExceptionHandler  eh)</code></td>
<td style="text-align: left;">设置当线程由于未捕获的异常而突然终止时调用的默认处理程序，并且没有为该线程定义其他处理程序。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setName(String name)</code></td>
<td style="text-align: left;">将此线程的名称更改为等于参数 <code>name</code> 。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setPriority(int newPriority)</code></td>
<td style="text-align: left;">更改此线程的优先级。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setUncaughtExceptionHandler( Thread.UncaughtExceptionHandler eh)</code></td>
<td style="text-align: left;">设置当此线程由于未捕获的异常而突然终止时调用的处理程序。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static void</code></td>
<td style="text-align: left;"><code>sleep(long millis)</code></td>
<td style="text-align: left;">导致当前正在执行的线程休眠（暂时停止执行）指定的毫秒数，具体取决于系统计时器和调度程序的精度和准确性。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>static void</code></td>
<td style="text-align: left;"><code>sleep(long millis, int nanos)</code></td>
<td style="text-align: left;">导致当前正在执行的线程休眠（暂时停止执行）指定的毫秒数加上指定的纳秒数，具体取决于系统定时器和调度程序的精度和准确性。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>start()</code></td>
<td style="text-align: left;">导致此线程开始执行; Java虚拟机调用此线程的<code>run</code>方法。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;"><code>toString()</code></td>
<td style="text-align: left;">返回此线程的字符串表示形式，包括线程的名称，优先级和线程组。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static void</code></td>
<td style="text-align: left;"><code>yield()</code></td>
<td style="text-align: left;">向调度程序提示当前线程是否愿意产生其当前使用的处理</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>常用方法</strong></p>
<p><strong>start</strong></p>
<p>线程开始执行; Java虚拟机调用此线程的<code>run</code>方法，不可重复启动</p>
<p><strong>currentThread</strong></p>
<p>返回对当前正在执行的线程对象的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread mainThread = Thread.currentThread();</span><br></pre></td></tr></table></figure>
<p>**getPriority &amp;&amp; setPriority</p>
<p>返回此线程的优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.getPriority();</span><br></pre></td></tr></table></figure>
<p><strong>sleep &amp;&amp; join</strong></p>
<p>Thread.sleep() 仅代表当前线程等待时间</p>
<p><strong>join(0)时，表示等将该线程加入主线程中，共用一个CPU核心，待该线程执行结束或死亡，才继续执行下一线程</strong></p>
<p>线程 start()后再调用 join()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> millisecond)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(millisecond);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(Thread thread, <span class="keyword">int</span> millisecond)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      thread.join(millisecond);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>setDaemon</strong></p>
<p>设置守护线程</p>
<p>Java 中的线程可以分为两种：守护线程和普通线程。在 JVM 刚启动时，它创建的所有线程，除了主线程（main thread）外，其他的线程都是守护线程（比如：垃圾收集器、以及其他执行辅助操作的线程）。</p>
<p>当创建一个新线程时，新线程将会继承它线程的守护状态，默认情况下，主线程创建的所有线程都是普通线程。</p>
<p><strong>当我们希望创建一个线程来执行一些辅助的工作，但是又不希望这个线程阻碍 JVM 的关闭，在这种情况下，我们就需要使用守护线程了。</strong></p>
<p><strong>区别</strong></p>
<p>守护线程与普通线程唯一的区别是：当线程退出时，JVM 会检查其他正在运行的线程，如果这些线程都是守护线程，那么 JVM 会正常退出操作，但是如果有普通线程还在运行，JVM 是不会执行退出操作的。当 JVM 退出时，所有仍然存在的守护线程都将被抛弃，既不会执行 finally 部分的代码，也不会执行 stack unwound 操作，JVM 会直接退出</p>
<ol type="1">
<li>thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。</li>
<li>在Daemon线程中产生的新线程也是Daemon的。</li>
<li>守护线程不能用于去访问固有资源，比如读写操作或者计算逻辑。因为它会在任何时候甚至在一个操作的中间发生中断。</li>
<li>Java自带的多线程框架，比如ExecutorService，会将守护线程转换为用户线程，所以如果要使用后台线程就不能用Java的线程池。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Thread thread1 = <span class="keyword">new</span> MyThread(Thread.MAX_PRIORITY,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">Thread thread2 = <span class="keyword">new</span> MyThread(Thread.NORM_PRIORITY,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"><span class="comment">// 线程2设置为守护线程</span></span><br><span class="line">thread2.setDaemon(<span class="keyword">true</span>);    </span><br><span class="line"></span><br><span class="line">thread1.start();</span><br><span class="line"><span class="comment">//线程1 加入主线程，保证thread1在thread2之前执行</span></span><br><span class="line">join(thread1,<span class="number">0</span>);</span><br><span class="line">thread2.start();</span><br><span class="line"><span class="comment">/* output 守护线程未执行，jvm 直接退出</span></span><br><span class="line"><span class="comment">t1finished time: 1583768160516</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Process finished with exit code 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>interrupt</strong></p>
<p>修改线程为中断状态，不会直接终止线程，通知<strong>线程主动释放所占用的系统资源</strong>，并终止自己。</p>
<p>stop()方法则直接杀死线程，因此被弃用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(<span class="keyword">int</span> p, String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        setPriority(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">      <span class="comment">// 如果为中断状态，则返回</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (interrupted())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot; &quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName()+<span class="string">&quot; finished time: &quot;</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.currentThread().setPriority(<span class="number">10</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> MyThread(Thread.MAX_PRIORITY,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        sleep(<span class="number">16</span>);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">t1 42</span></span><br><span class="line"><span class="comment">t1 43</span></span><br><span class="line"><span class="comment">t1 44</span></span><br><span class="line"><span class="comment">t1 45</span></span><br><span class="line"><span class="comment">t1 46</span></span><br><span class="line"><span class="comment">t1 47</span></span><br><span class="line"><span class="comment">t1 48</span></span><br><span class="line"><span class="comment">t1 49</span></span><br><span class="line"><span class="comment">t1 50</span></span><br><span class="line"><span class="comment">interrupt</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<hr />
<h3 id="runnable-接口">Runnable 接口</h3>
<p><code>Runnable</code>接口应由任何其实例由线程执行的类实现。 该类必须定义一个名为<code>run</code>的无参数的方法。</p>
<p>此接口旨在为希望在活动时执行代码的对象提供通用协议。 例如， <code>Runnable</code>由类<code>Thread</code>实现。 活动只是意味着一个线程已经启动但尚未停止。</p>
<p>此外， <code>Runnable</code>提供了一个类活动而不是<code>Thread</code> 。 实现<code>Runnable</code>类<code>Thread</code>通过实例化<code>Thread</code>实例并将其自身作为目标传递而无需子类化<code>Thread</code> 。 在大多数情况下，如果只打算覆盖<code>run()</code>方法而不使用其他<code>Thread</code>方法，则应使用<code>Runnable</code>接口。</p>
<p><strong>Runnable 使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// To-Do</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((Thread.currentThread()).getName() + <span class="string">&quot; finished time: &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匿名内部类加Runnable</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TO_DO</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MyRunnableThread t = <span class="keyword">new</span> MyRunnableThread();</span><br><span class="line">        Thread myRunnableThread = <span class="keyword">new</span> Thread(t,<span class="string">&quot;tt1&quot;</span>);</span><br><span class="line">        myRunnableThread.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>利用Runnable实现进程共享</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StringBuilder data = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//静态信号量，控制线程执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> s = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (s==<span class="keyword">true</span>)&#123;&#125;</span><br><span class="line">        s = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            data.append(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//线程执行完毕修改静态信号量</span></span><br><span class="line">        s = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println((Thread.currentThread()).getName() + <span class="string">&quot; finished time: &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyRunnableThread myRunnableThread = <span class="keyword">new</span> MyRunnableThread();</span><br><span class="line">Thread myRunnableThread1 = <span class="keyword">new</span> Thread(myRunnableThread,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">Thread myRunnableThread2 = <span class="keyword">new</span> Thread(myRunnableThread,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">myRunnableThread1.start();</span><br><span class="line">myRunnableThread2.start();</span><br><span class="line">sleep(<span class="number">1000</span>);</span><br><span class="line">System.out.println(myRunnableThread.getData());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">t1t1t1t1t1t1t1t1t1t1t1t1t1t1t2t2t2t2t2t2t2t2t2t2t2t2t2t2t2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="线程加锁">线程加锁</h3>
<p>多线程环境下，对临界资源加锁，设置临界区</p>
<p>临界区保证同时只能有一个线程访问</p>
<h4 id="synchronized">synchronized</h4>
<p>需要利用一个类实例加锁标记</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object(); <span class="comment">// Runnable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object(); <span class="comment">// Thread</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">// 临界区</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 临界区</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p><strong>锁方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TO_DO</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>案例</strong></p>
<p>机票售卖点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 机票数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> tickets = <span class="number">10</span>; </span><br><span class="line">    <span class="comment">// 剩余机票   </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    TicketThread(<span class="keyword">int</span> t) &#123;</span><br><span class="line">        tickets = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tickets&lt;=<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                count++;</span><br><span class="line">                num++;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; --卖出第 &quot;</span> + num + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">                tickets--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 售罄 卖出了：&quot;</span> + count + <span class="string">&quot; 剩余：&quot;</span> + tickets);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主程序</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始机票 10000</span></span><br><span class="line">        TicketThread ticketThread = <span class="keyword">new</span> TicketThread(<span class="number">10000</span>);</span><br><span class="line">        <span class="comment">// 设置 10 个售卖点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(ticketThread, <span class="string">&quot;t&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">t7 售罄 卖出了：1253 剩余：0</span></span><br><span class="line"><span class="comment">t1 售罄 卖出了：574 剩余：0</span></span><br><span class="line"><span class="comment">t8 售罄 卖出了：962 剩余：0</span></span><br><span class="line"><span class="comment">t4 售罄 卖出了：989 剩余：0</span></span><br><span class="line"><span class="comment">t2 售罄 卖出了：1210 剩余：0</span></span><br><span class="line"><span class="comment">t6 售罄 卖出了：855 剩余：0</span></span><br><span class="line"><span class="comment">t9 售罄 卖出了：1176 剩余：0</span></span><br><span class="line"><span class="comment">t0 售罄 卖出了：491 剩余：0</span></span><br><span class="line"><span class="comment">t3 售罄 卖出了：1168 剩余：0</span></span><br><span class="line"><span class="comment">t5 售罄 卖出了：1322 剩余：0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="reentrantlock">ReentrantLock</h4>
<p>ReentrantLock 类实现加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure>
<p>使用中，若加锁临界区异常，会导致无法解锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// TO_DO</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;        <span class="comment">// 最后始终会解锁</span></span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>线程安全类</strong></p>
<p>StringBuffer、Vector</p>
<p><strong>线程不安全</strong></p>
<p>StringBuilder、ArrayList</p>
<hr />
<h3 id="线程组">线程组</h3>
<p>多线程中，为了方便管理一批线程，我们使用ThreadGroup来表示线程组，通过它对一批线程进行分类管理 。（默认情况下，A线程创建的线程B，B线程是属于A线程的线程组的。）</p>
<p>此外，线程组还可以包括其他线程组。线程组形成一个树，其中除初始线程组之外的每个线程组都有父节点。</p>
<p>允许线程访问有关其自己的线程组的信息，但不允许访问有关其线程组的父线程组或任何其他线程组的信息。</p>
<p><strong>构造方法</strong></p>
<table>
<thead>
<tr class="header">
<th>构造器</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ThreadGroup​(String name)</code></td>
<td>构造一个新的线程组。</td>
</tr>
<tr class="even">
<td><code>ThreadGroup​(ThreadGroup parent,String name)</code></td>
<td>创建指定父线程组，名为name的新线程组</td>
</tr>
</tbody>
</table>
<p><strong>注意:</strong></p>
<p><strong>不要把后台线程组和后台线程（守护线程）混为一谈，后台线程组的特性是最后一个线程执行完或最后一个线程被销毁时，后台线程组自动销毁，线程组只是为了统一管理线程的一个方式</strong></p>
<p><strong>常用方法</strong></p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 43%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th>变量和类型</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>int</code></td>
<td><code>activeCount()</code></td>
<td>返回此线程组及其子组中活动线程数的估计值。</td>
</tr>
<tr class="even">
<td><code>int</code></td>
<td><code>activeGroupCount()</code></td>
<td>返回此线程组及其子组中活动组数的估计值。</td>
</tr>
<tr class="odd">
<td><code>void</code></td>
<td><code>checkAccess()</code></td>
<td>确定当前运行的线程是否具有修改此线程组的权限。</td>
</tr>
<tr class="even">
<td><code>void</code></td>
<td><code>destroy()</code></td>
<td>销毁此线程组及其所有子组。</td>
</tr>
<tr class="odd">
<td><code>int</code></td>
<td><code>enumerate​(Thread[] list)</code></td>
<td>将此线程组及其子组中的每个活动线程复制到指定的数组中。</td>
</tr>
<tr class="even">
<td><code>int</code></td>
<td><code>enumerate​(Thread[] list, boolean recurse)</code></td>
<td>将此线程组中的每个活动线程复制到指定的数组中。</td>
</tr>
<tr class="odd">
<td><code>int</code></td>
<td><code>enumerate​(ThreadGroup[] list)</code></td>
<td>复制到此线程组及其子组中每个活动子组的指定数组引用。</td>
</tr>
<tr class="even">
<td><code>int</code></td>
<td><code>enumerate​(ThreadGroup[] list, boolean recurse)</code></td>
<td>复制到此线程组中每个活动子组的指定数组引用。</td>
</tr>
<tr class="odd">
<td><code>int</code></td>
<td><code>getMaxPriority()</code></td>
<td>返回此线程组的最大优先级。</td>
</tr>
<tr class="even">
<td><code>String</code></td>
<td><code>getName()</code></td>
<td>返回此线程组的名称。</td>
</tr>
<tr class="odd">
<td><code>ThreadGroup</code></td>
<td><code>getParent()</code></td>
<td>返回此线程组的父级。</td>
</tr>
<tr class="even">
<td><code>void</code></td>
<td><code>interrupt()</code></td>
<td>中断此线程组中的所有线程。</td>
</tr>
<tr class="odd">
<td><code>boolean</code></td>
<td><code>isDaemon()</code></td>
<td>测试此线程组是否为守护程序线程组。</td>
</tr>
<tr class="even">
<td><code>boolean</code></td>
<td><code>isDestroyed()</code></td>
<td>测试此线程组是否已被销毁。</td>
</tr>
<tr class="odd">
<td><code>void</code></td>
<td><code>list()</code></td>
<td>将有关此线程组的信息打印到标准输出。</td>
</tr>
<tr class="even">
<td><code>boolean</code></td>
<td><code>parentOf​(ThreadGroup g)</code></td>
<td>测试此线程组是线程组参数还是其祖先线程组之一。</td>
</tr>
<tr class="odd">
<td><code>void</code></td>
<td><code>setDaemon​(boolean daemon)</code></td>
<td>设置线程组为后台线程（当后台线程组中最后一个线程执行完成活着最后一个线程被销毁，后台线程将自动销毁）</td>
</tr>
<tr class="even">
<td><code>void</code></td>
<td><code>setMaxPriority​(int pri)</code></td>
<td>设置组的最大优先级。</td>
</tr>
<tr class="odd">
<td><code>String</code></td>
<td><code>toString()</code></td>
<td>返回此Thread组的字符串表示形式。</td>
</tr>
<tr class="even">
<td><code>void</code></td>
<td><code>uncaughtException​(Thread t,Throwable e)</code></td>
<td>t代表抛出异常的线程，e代表抛出的异常，该方法处理此线程组里所有线程抛出的未处理的异常</td>
</tr>
</tbody>
</table>
<p><strong>用例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程组 “liuyang”</span></span><br><span class="line">        ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">&quot;liuyang&quot;</span>);</span><br><span class="line">        TicketThread ticketThread = <span class="keyword">new</span> TicketThread(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// Runnable 创建线程加入线程组</span></span><br><span class="line">            <span class="keyword">new</span> Thread(threadGroup,ticketThread,i+<span class="string">&quot; 售票点&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印线程组信息</span></span><br><span class="line">        threadGroup.list();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">java.lang.ThreadGroup[name=liuyang,maxpri=10]</span></span><br><span class="line"><span class="comment">    Thread[0 售票点,5,liuyang]</span></span><br><span class="line"><span class="comment">    Thread[1 售票点,5,liuyang]</span></span><br><span class="line"><span class="comment">    Thread[2 售票点,5,liuyang]</span></span><br><span class="line"><span class="comment">    Thread[3 售票点,5,liuyang]</span></span><br><span class="line"><span class="comment">    Thread[4 售票点,5,liuyang]</span></span><br><span class="line"><span class="comment">    Thread[5 售票点,5,liuyang]</span></span><br><span class="line"><span class="comment">    Thread[6 售票点,5,liuyang]</span></span><br><span class="line"><span class="comment">    Thread[7 售票点,5,liuyang]</span></span><br><span class="line"><span class="comment">    Thread[8 售票点,5,liuyang]</span></span><br><span class="line"><span class="comment">    Thread[9 售票点,5,liuyang]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3 售票点 卖出了：100 还有：0</span></span><br><span class="line"><span class="comment">9 售票点 卖出了：109 还有：0</span></span><br><span class="line"><span class="comment">6 售票点 卖出了：215 还有：0</span></span><br><span class="line"><span class="comment">5 售票点 卖出了：66 还有：0</span></span><br><span class="line"><span class="comment">1 售票点 卖出了：18 还有：0</span></span><br><span class="line"><span class="comment">4 售票点 卖出了：78 还有：0</span></span><br><span class="line"><span class="comment">0 售票点 卖出了：73 还有：0</span></span><br><span class="line"><span class="comment">7 售票点 卖出了：65 还有：0</span></span><br><span class="line"><span class="comment">2 售票点 卖出了：139 还有：0</span></span><br><span class="line"><span class="comment">8 售票点 卖出了：137 还有：0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>通过线程组处理异常</strong></p>
<p>定义一个会抛出异常的线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 除 0 错误</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">3</span>/<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写下线程组中的void uncaughtException(Thread t, Throwable e)方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">&quot;liuyang&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.uncaughtException(t, e);</span><br><span class="line">            System.out.println(t.getName()+<span class="string">&quot; 抛出 &quot;</span>+ e);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TicketThread ticketThread = <span class="keyword">new</span> TicketThread(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(threadGroup,ticketThread,i+<span class="string">&quot; 售票点&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">3 售票点 抛出 java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">7 售票点 抛出 java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">6 售票点 抛出 java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">1 售票点 抛出 java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">8 售票点 抛出 java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">2 售票点 抛出 java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">4 售票点 抛出 java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">5 售票点 抛出 java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">9 售票点 抛出 java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">0 售票点 抛出 java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="timer-定时器">Timer 定时器</h3>
<p>本质上也是线程</p>
<ul>
<li><p>线程的工具，用于在后台线程中安排将来执行的任务。可以将任务安排为一次性执行，或者以固定间隔重复执行。</p></li>
<li><p>此类是线程安全的，多个线程可以共享单个<code>Timer</code>对象，而无需外部同步</p></li>
<li><p>Java 5.0引入了<code>java.util.concurrent</code>包，其中一个并发实用程序是<code>ScheduledThreadPoolExecutor</code>，它是一个线程池，用于以给定的速率或延迟重复执行任务。这实际上是对一个更灵活的替代<code>Timer</code>/<code>TimerTask</code>组合，因为它允许多个服务线程，接受各种时间单位，并且不需要子类<code>TimerTask</code>（只实现<code>Runnable</code>）。使用一个线程配置<code>ScheduledThreadPoolExecutor</code>使其等效于<code>Timer</code>。</p></li>
</ul>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">构造器</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Timer()</code></td>
<td style="text-align: left;">创建一个新计时器。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Timer(boolean isDaemon)</code></td>
<td style="text-align: left;">创建一个新的计时器，其关联的线程可以指定为 <a href="chm://33031dcc470bf81a5f5e8595b0905ec1/java.base/java/lang/Thread.html#setDaemon(boolean)">run as a daemon</a> 。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Timer(String name)</code></td>
<td style="text-align: left;">创建一个新的计时器，其关联的线程具有指定的名称。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Timer(String name, boolean isDaemon)</code></td>
<td style="text-align: left;">创建一个新的计时器，其关联的线程具有指定的名称，并且可以指定为 <a href="chm://33031dcc470bf81a5f5e8595b0905ec1/java.base/java/lang/Thread.html#setDaemon(boolean)">run as a daemon</a> 。</td>
</tr>
</tbody>
</table>
<p>方法</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 62%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>cancel()</code></td>
<td style="text-align: left;">终止此计时器，丢弃当前计划的任何任务。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>purge()</code></td>
<td style="text-align: left;">从此计时器的任务队列中删除所有已取消的任务。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>schedule(TimerTask task, long delay)</code></td>
<td style="text-align: left;">在指定的延迟后安排指定的任务执行。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>schedule(TimerTask task, long delay, long period)</code></td>
<td style="text-align: left;">在指定的延迟之后开始，每隔 period 执行一次</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>schedule(TimerTask task, Date time)</code></td>
<td style="text-align: left;">计划在指定时间执行指定的任务。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>schedule(TimerTask task, Date firstTime, long period)</code></td>
<td style="text-align: left;">从指定时间开始，为重复的 <em>固定延迟执行</em>安排指定的任务。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>scheduleAtFixedRate(TimerTask task, long delay, long period)</code></td>
<td style="text-align: left;">在指定的延迟之后开始，为重复的 <em>固定速率执行</em>安排指定的任务。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>scheduleAtFixedRate(TimerTask task, Date firstTime, long period)</code></td>
<td style="text-align: left;">从指定时间开始，为重复的 <em>固定速率执行</em>安排指定的任务。</td>
</tr>
</tbody>
</table>
<p><strong>计时器任务 TimerTask</strong></p>
<p>可由<code>Timer</code>一次性或重复执行的 [任务] 。计时器任务<em>不可</em>重复使用</p>
<p><strong>用例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.liuyang.Tool.ThreadTool;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTimerTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟1000 millisecond 并隔同样时长执行一次</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">     timer.schedule(<span class="keyword">new</span> MyTimerTask(), <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">     ThreadTool.sleep</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="网络编程">网络编程</h2>
<blockquote>
<ul>
<li><strong>IP地址范围</strong></li>
</ul>
<p><em>链路本地</em>地址旨在用于在单个链路上进行寻址，以用于诸如自动地址配置，邻居发现或不存在路由器的目的。</p>
<p><em>站点本地</em>地址旨在用于在站点内部进行寻址，而无需全局前缀。</p>
<p><em>全球</em>地址在互联网上是独一无二的。</p>
<ul>
<li><strong>IP地址的文本表示</strong></li>
</ul>
<p>IP地址的文本表示是特定于地址族的。</p>
<ul>
<li><strong>主机名解析</strong></li>
</ul>
<p>主机名到IP地址<em>解析</em>是通过使用本地机器配置信息和网络命名服务（如域名系统（DNS）和网络信息服务（NIS））的组合来完成的。 默认情况下，正在使用的特定命名服务是本地计算机配置的一个。 对于任何主机名，将返回其对应的IP地址。</p>
<p><em>反向名称解析</em>意味着对于任何IP地址，都会返回与IP地址关联的主机。</p>
<p>InetAddress类提供了将主机名解析为其IP地址的方法，反之亦然。</p>
</blockquote>
<h3 id="tcpip网络模型">TCP/IP网络模型</h3>
<p>TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p>
<ul>
<li>链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。</li>
<li>网络层：负责路由以及把分组报文发送给目标网络或主机。</li>
<li>传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</li>
<li>应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</li>
</ul>
<p>在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。</p>
<p><strong>TCP/IP 中代表性传输层协议—-TCP 和 UDP</strong></p>
<ul>
<li><p>TCP</p>
<p>TCP协议全称是<strong>传输控制协议</strong>，是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 仅支持单播传输，即点对点传输</p>
<p><strong>面向连接</strong>，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础</p>
<p>TCP 建立连接：</p>
<blockquote>
<p><strong>第一次握手</strong></p>
<p>客户端向服务端发送连接请求报文段<code>SYN</code>。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</p>
<p><strong>第二次握手</strong></p>
<p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答<code>SYN-ACK</code>，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</p>
<p><strong>第三次握手</strong></p>
<p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文<code>ACK</code>。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</p>
</blockquote>
<p>TCP 断开连接</p>
<blockquote>
<p>TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK</p>
<p><strong>第一次握手</strong></p>
<p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求<code>FIN</code>。</p>
<p><strong>第二次握手</strong></p>
<p>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 <code>ACK</code> 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。</p>
<p><strong>第三次握手</strong></p>
<p>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求<code>FIN</code>，然后 B 便进入 LAST-ACK 状态。</p>
<p><strong>第四次握手</strong></p>
<p>A 收到释放请求后，向 B 发送确认应答<code>ACK</code>，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p>
</blockquote></li>
<li><p>UDP</p>
<p>UDP协议全称<strong>用户数据报协议</strong>，与TCP协议一样用于处理数据包，是一种无连接的协议。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，报文发送之后，无法得知其是否安全完整到达。UDP 提供了单播，多播，广播的功能</p></li>
<li><p>区别</p></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">UDP</th>
<th style="text-align: left;">TCP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">是否连接</td>
<td style="text-align: left;">无连接</td>
<td style="text-align: left;">面向连接</td>
</tr>
<tr class="even">
<td style="text-align: left;">是否可靠</td>
<td style="text-align: left;">不可靠传输，不使用流量控制和拥塞控制</td>
<td style="text-align: left;">可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr class="odd">
<td style="text-align: left;">连接对象个数</td>
<td style="text-align: left;">支持一对一，一对多，多对一和多对多交互通信</td>
<td style="text-align: left;">只能是一对一通信</td>
</tr>
<tr class="even">
<td style="text-align: left;">传输方式</td>
<td style="text-align: left;">面向报文</td>
<td style="text-align: left;">面向字节流</td>
</tr>
<tr class="odd">
<td style="text-align: left;">首部开销</td>
<td style="text-align: left;">首部开销小，仅8字节</td>
<td style="text-align: left;">首部最小20字节，最大60字节</td>
</tr>
<tr class="even">
<td style="text-align: left;">适用场景</td>
<td style="text-align: left;">适用于实时应用（IP电话、视频会议、直播等）</td>
<td style="text-align: left;">适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody>
</table>
<h3 id="inetaddress">InetAddress</h3>
<p>此类表示Internet协议（IP）地址,</p>
<p>InetAddress类具有用于存储成功和不成功主机名解析的缓存。</p>
<p>默认情况下，安装安全管理器时，为了防止DNS欺骗攻击，可以永久缓存正主机名解析的结果。 未安装安全管理器时，默认行为是缓存有限（依赖于实现）时间段的条目。 主机名解析失败的结果将在非常短的时间（10秒）内缓存，以提高性能。</p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 51%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>equals(Object obj)</code></td>
<td style="text-align: left;">将此对象与指定的对象进行比较。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>byte[]</code></td>
<td style="text-align: left;"><code>getAddress()</code></td>
<td style="text-align: left;">返回此 <code>InetAddress</code>对象的原始IP地址。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static InetAddress[]</code></td>
<td style="text-align: left;"><code>getAllByName(String host)</code></td>
<td style="text-align: left;">根据主机的名称，根据系统上配置的名称服务返回其IP地址数组。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>static InetAddress</code></td>
<td style="text-align: left;"><code>getByAddress(byte[] addr)</code></td>
<td style="text-align: left;">给定原始IP地址返回 <code>InetAddress</code>对象。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static InetAddress</code></td>
<td style="text-align: left;"><code>getByAddress(String host, byte[] addr)</code></td>
<td style="text-align: left;">根据提供的主机名和IP地址创建InetAddress。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>static InetAddress</code></td>
<td style="text-align: left;"><code>getByName(String host)</code></td>
<td style="text-align: left;">根据主机名称确定主机的IP地址。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;"><code>getCanonicalHostName()</code></td>
<td style="text-align: left;">获取此IP地址的完全限定域名。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;"><code>getHostAddress()</code></td>
<td style="text-align: left;">返回文本表示中的IP地址字符串。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;"><code>getHostName()</code></td>
<td style="text-align: left;">获取此IP地址的主机名。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>static InetAddress</code></td>
<td style="text-align: left;"><code>getLocalHost()</code></td>
<td style="text-align: left;">返回本地主机的地址。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static InetAddress</code></td>
<td style="text-align: left;"><code>getLoopbackAddress()</code></td>
<td style="text-align: left;">返回环回地址。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>hashCode()</code></td>
<td style="text-align: left;">返回此IP地址的哈希码。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isAnyLocalAddress()</code></td>
<td style="text-align: left;">用于检查InetAddress是否为通配符地址的实用例程。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isLinkLocalAddress()</code></td>
<td style="text-align: left;">用于检查InetAddress是否为链接本地地址的实用程序例程。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isLoopbackAddress()</code></td>
<td style="text-align: left;">用于检查InetAddress是否为环回地址的实用例程。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isMCGlobal()</code></td>
<td style="text-align: left;">用于检查多播地址是否具有全局范围的实用例程。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isMCLinkLocal()</code></td>
<td style="text-align: left;">用于检查多播地址是否具有链接范围的实用例程。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isMCNodeLocal()</code></td>
<td style="text-align: left;">用于检查多播地址是否具有节点范围的实用例程。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isMCOrgLocal()</code></td>
<td style="text-align: left;">用于检查多播地址是否具有组织范围的实用例程。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isMCSiteLocal()</code></td>
<td style="text-align: left;">用于检查多播地址是否具有站点范围的实用程序例程。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isMulticastAddress()</code></td>
<td style="text-align: left;">用于检查InetAddress是否为IP多播地址的实用程序例程。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isReachable(int timeout)</code></td>
<td style="text-align: left;">测试该地址是否可达。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isReachable(NetworkInterface netif, int ttl, int timeout)</code></td>
<td style="text-align: left;">测试该地址是否可达。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isSiteLocalAddress()</code></td>
<td style="text-align: left;">用于检查InetAddress是否为站点本地地址的实用程序例程。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;"><code>toString()</code></td>
<td style="text-align: left;">将此IP地址转换为 <code>String</code> 。</td>
</tr>
</tbody>
</table>
<h3 id="socket-套接字">Socket 套接字</h3>
<blockquote>
<p>应用通过传输层进行数据通信时，TCP和UDP会遇到同时为多个应用程序进程提供并发服务的问题。为了区别不同的应用程序进程和连接，计算机操作系统就可以为应用程序与TCP/IP协议交互提供套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p>
<p>Socket是一种进程通信机制，凭借这种机制，客户/服务器系统的开发工作既可以在本地单机上进行，也可以跨网络进行。Socket是对TCP/IP协议的封装，它是一组接口。这组接口当然可以由不同的语言去实现。它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部</p>
<p>Socket是面向客户/服务器模型而设计的，针对客户和服务器程序提供不同的Socket系统调用。通过Socket建立通信连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket.</p>
</blockquote>
<p><strong>套接字之间的连接过程</strong></p>
<p>分为三个步骤：服务器监听，客户端请求，连接确认。</p>
<ol type="1">
<li>服务器监听：是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态。</li>
<li>客户端请求：是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</li>
<li>连接确认：是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</li>
</ol>
<p><img src="套接字.png" style="zoom:30%;" /></p>
<h4 id="datagramsocket---udp"><code>DatagramSocket</code> --UDP</h4>
<p>发送和接收数据报套接字</p>
<p>数据报套接字是分组传送服务的发送或接收点。 在数据报套接字上发送或接收的每个数据包都是单独寻址和路由的。 从一台机器发送到另一台机器的多个分组可以被不同地路由，并且可以以任何顺序到达</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 48%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">构造器</th>
<th style="text-align: left;">描述</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code></code></td>
<td style="text-align: left;"><code>DatagramSocket()</code></td>
<td>构造一个数据报套接字并将其绑定到本地主机上的任何可用端口。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code></code></td>
<td style="text-align: left;"><code>DatagramSocket(int port)</code></td>
<td>构造一个数据报套接字并将其绑定到本地主机上的指定端口。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code></code></td>
<td style="text-align: left;"><code>DatagramSocket(int port, InetAddress laddr)</code></td>
<td>创建绑定到指定本地地址的数据报套接字。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>protected</code></td>
<td style="text-align: left;"><code>DatagramSocket(DatagramSocketImpl impl)</code></td>
<td>使用指定的DatagramSocketImpl创建未绑定的数据报套接字。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code></code></td>
<td style="text-align: left;"><code>DatagramSocket(SocketAddress bindaddr)</code></td>
<td>创建绑定到指定本地套接字地址的数据报套接字。</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 29%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>bind(SocketAddress addr)</code></td>
<td style="text-align: left;">将此DatagramSocket绑定到特定的地址和端口。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>close()</code></td>
<td style="text-align: left;">关闭此数据报套接字。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>connect(InetAddress address, int port)</code></td>
<td style="text-align: left;">将套接字连接到此套接字的远程地址。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>connect(SocketAddress addr)</code></td>
<td style="text-align: left;">将此套接字连接到远程套接字地址（IP地址+端口号）。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>disconnect()</code></td>
<td style="text-align: left;">断开连接。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>DatagramChannel</code></td>
<td style="text-align: left;"><code>getChannel()</code></td>
<td style="text-align: left;">返回与此数据报套接字关联的唯一<a href="chm://33031dcc470bf81a5f5e8595b0905ec1/java.base/java/nio/channels/DatagramChannel.html"><code>DatagramChannel</code></a>对象（如果有）。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>InetAddress</code></td>
<td style="text-align: left;"><code>getInetAddress()</code></td>
<td style="text-align: left;">返回此套接字连接的地址。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>InetAddress</code></td>
<td style="text-align: left;"><code>getLocalAddress()</code></td>
<td style="text-align: left;">获取套接字绑定的本地地址。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>getLocalPort()</code></td>
<td style="text-align: left;">返回此套接字绑定到的本地主机上的端口号。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>SocketAddress</code></td>
<td style="text-align: left;"><code>getLocalSocketAddress()</code></td>
<td style="text-align: left;">返回此套接字绑定的端点的地址。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>T</code></td>
<td style="text-align: left;"><code>getOption(SocketOption name)</code></td>
<td style="text-align: left;">返回套接字选项的值。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>getPort()</code></td>
<td style="text-align: left;">返回此套接字连接的端口号。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>getReceiveBufferSize()</code></td>
<td style="text-align: left;">获取此 <code>DatagramSocket</code>的SO_RCVBUF选项的值，即该平台在此 <code>DatagramSocket</code>上用于输入的缓冲区大小。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>SocketAddress</code></td>
<td style="text-align: left;"><code>getRemoteSocketAddress()</code></td>
<td style="text-align: left;">返回此套接字连接到的端点的地址，如果未连接则返回 <code>null</code> 。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>getSendBufferSize()</code></td>
<td style="text-align: left;">获取此 <code>DatagramSocket</code>的SO_SNDBUF选项的值， <code>DatagramSocket</code>上的输出的缓冲区大小。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>getTrafficClass()</code></td>
<td style="text-align: left;">获取从此DatagramSocket发送的数据包的IP数据报头中的流量类或服务类型。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isBound()</code></td>
<td style="text-align: left;">返回套接字的绑定状态。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isClosed()</code></td>
<td style="text-align: left;">返回套接字是否关闭。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isConnected()</code></td>
<td style="text-align: left;">返回套接字的连接状态。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>receive(DatagramPacket p)</code></td>
<td style="text-align: left;">从此套接字接收数据报包。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>send(DatagramPacket p)</code></td>
<td style="text-align: left;">从此套接字发送数据报包。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setBroadcast(boolean on)</code></td>
<td style="text-align: left;">启用/禁用SO_BROADCAST。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static void</code></td>
<td style="text-align: left;"><code>setDatagramSocketImplFactory(DatagramSocketImplFactory fac)</code></td>
<td style="text-align: left;">设置应用程序的数据报套接字实现工厂。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>DatagramSocket</code></td>
<td style="text-align: left;"><code>setOption(SocketOption name, T value)</code></td>
<td style="text-align: left;">设置套接字选项的值。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setSendBufferSize(int size)</code></td>
<td style="text-align: left;">将<code>DatagramSocket</code>上的输出的缓冲区大小设置为指定值。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setSoTimeout(int timeout)</code></td>
<td style="text-align: left;">使用指定的超时启用/禁用SO_TIMEOUT，以毫秒为单位。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setTrafficClass(int tc)</code></td>
<td style="text-align: left;">在IP数据报头中为从此DatagramSocket发送的数据报设置流量类或服务类型八位字节。</td>
</tr>
</tbody>
</table>
<p>####<strong>案例1-- 单向发送</strong></p>
<p>设置多个 客户机对其发送 socket、 客户机类 implement Runnable 接口，多线程执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDP_Send</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data;</span><br><span class="line">    <span class="keyword">private</span> InetAddress address;  <span class="comment">// 目标主机地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;        <span class="comment">// 目标主机端口</span></span><br><span class="line"></span><br><span class="line">    UDP_Send(String string, InetAddress address, <span class="keyword">int</span> port) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = string.getBytes();</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 客户机 Socket，端口系统分配</span></span><br><span class="line">        <span class="keyword">try</span> (DatagramSocket datagramSocket = <span class="keyword">new</span> DatagramSocket()) &#123;</span><br><span class="line"></span><br><span class="line">            DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(data, data.length, address, port);</span><br><span class="line">            datagramSocket.send(dp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置一个 主机循环接收 socket</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDP_Receive</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置监听的端口号</span></span><br><span class="line">        <span class="keyword">if</span> (args == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 接收输入端口</span></span><br><span class="line">        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 主机绑定到端口 port，监听</span></span><br><span class="line">        <span class="keyword">try</span> (DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(port)) &#123;</span><br><span class="line">            <span class="comment">// 创建数据报包对象，存储接收的数据</span></span><br><span class="line">            DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>], <span class="number">1024</span>);</span><br><span class="line">            <span class="comment">// 循环监听端口，接收数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ds.receive(dp);</span><br><span class="line">                    System.out.println(<span class="string">&quot;主机[&quot;</span> + port + <span class="string">&quot;]%  客户机地址：    &quot;</span> + dp.getSocketAddress() +</span><br><span class="line">                            <span class="string">&quot;    客户机发送信息：&quot;</span> + <span class="keyword">new</span> String(dp.getData(), <span class="number">0</span>, dp.getLength()));</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置 UDP_Main 类进行测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDP_Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态变量 本地 ip</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String local_address = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        <span class="comment">// 设置主机端口为 1086</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">1086</span>;</span><br><span class="line">        <span class="comment">// 创建 InetAddress 对象</span></span><br><span class="line">        InetAddress address = InetAddress.getByName(local_address);</span><br><span class="line">        <span class="comment">// 创建客户机线程组</span></span><br><span class="line">        ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">&quot;liuyang&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建 10 个客户机线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(threadGroup,</span><br><span class="line">                    <span class="keyword">new</span> UDP_Send(<span class="string">&quot;我是客户机 &quot;</span>+i,address,port), <span class="string">&quot;客户机&quot;</span>+i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印线程组信息</span></span><br><span class="line">        threadGroup.list();</span><br><span class="line">        <span class="comment">// 调用主机，传递参数</span></span><br><span class="line">        UDP_Receive.main(<span class="keyword">new</span> String[]&#123;String.valueOf(port)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出结果</strong></p>
<blockquote>
<p>java.lang.ThreadGroup[name=liuyang,maxpri=10] Thread[客户机0,5,liuyang] Thread[客户机1,5,liuyang] Thread[客户机2,5,liuyang] Thread[客户机3,5,liuyang] Thread[客户机4,5,liuyang] Thread[客户机5,5,liuyang] Thread[客户机6,5,liuyang] Thread[客户机7,5,liuyang] Thread[客户机8,5,liuyang] Thread[客户机9,5,liuyang]</p>
<p>主机[1086]% 客户机地址： /127.0.0.1:57939 客户机发送信息：我是客户机 0 主机[1086]% 客户机地址： /127.0.0.1:57932 客户机发送信息：我是客户机 1 主机[1086]% 客户机地址： /127.0.0.1:57936 客户机发送信息：我是客户机 5 主机[1086]% 客户机地址： /127.0.0.1:57938 客户机发送信息：我是客户机 9 主机[1086]% 客户机地址： /127.0.0.1:57937 客户机发送信息：我是客户机 3 主机[1086]% 客户机地址： /127.0.0.1:57941 客户机发送信息：我是客户机 6 主机[1086]% 客户机地址： /127.0.0.1:57933 客户机发送信息：我是客户机 8 主机[1086]% 客户机地址： /127.0.0.1:57935 客户机发送信息：我是客户机 4 主机[1086]% 客户机地址： /127.0.0.1:57934 客户机发送信息：我是客户机 7 主机[1086]% 客户机地址： /127.0.0.1:57940 客户机发送信息：我是客户机 2</p>
</blockquote>
<h4 id="案例2----双向发送">案例2 -- 双向发送</h4>
<p>分别设置发送线程和接收线程</p>
<ol type="1">
<li>发送线程，参数：发送数据，发送ip，发送端口</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data;</span><br><span class="line">    <span class="keyword">private</span> InetAddress address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    SendThread(String string, InetAddress address, <span class="keyword">int</span> port) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = string.getBytes();</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 发送Socket，端口系统分配</span></span><br><span class="line">        <span class="keyword">try</span> (DatagramSocket datagramSocket = <span class="keyword">new</span> DatagramSocket()) &#123;</span><br><span class="line">            DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(data, data.length, address, port);</span><br><span class="line">            datagramSocket.send(dp);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>接收线程, 参数：监听的端口</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReceiveThread</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(port)) &#123;</span><br><span class="line">            <span class="comment">// 创建数据报包对象，存储接收的数据</span></span><br><span class="line">            DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>], <span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ds.receive(dp);</span><br><span class="line">                    System.out.println(<span class="string">&quot;&gt;&gt; ReceivePort[&quot;</span> + port + <span class="string">&quot;]%   SendInfo：&quot;</span> + dp.getSocketAddress() +</span><br><span class="line">                            <span class="string">&quot;\n&quot;</span> + <span class="keyword">new</span> String(dp.getData(), <span class="number">0</span>, dp.getLength()));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>UDP_Service 类，对接收和发送线程包装</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDP_Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String pcName;            <span class="comment">// 主机名</span></span><br><span class="line">    <span class="keyword">private</span> InetAddress targetAddress;        <span class="comment">// 目标ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;                        <span class="comment">// 本机监听端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> targetPort;                    <span class="comment">// 发送目标端口</span></span><br><span class="line">    <span class="keyword">private</span> ThreadGroup threadGroup;        <span class="comment">//线程组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pcName 主机名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetAddress 目标ip</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port 监听端口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetPort 目标端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UDP_Service</span><span class="params">(String pcName, String targetAddress, <span class="keyword">int</span> port, <span class="keyword">int</span> targetPort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pcName = pcName;</span><br><span class="line">        toInetAddress(targetAddress);</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.targetPort = targetPort;</span><br><span class="line">        threadGroup = <span class="keyword">new</span> ThreadGroup(pcName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址转换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> address ip字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">toInetAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.targetAddress = InetAddress.getByName(address);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  发送 数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content 数据内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(threadGroup, <span class="keyword">new</span> SendThread(content, targetAddress, targetPort),</span><br><span class="line">                   pcName + <span class="string">&quot;发送&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread receive = <span class="keyword">new</span> Thread(threadGroup, <span class="keyword">new</span> ReceiveThread(port)</span><br><span class="line">                , pcName + <span class="string">&quot;监听&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置 监听 为守护线程，否则进程无法退出</span></span><br><span class="line">        receive.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        receive.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收并发送</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">udpChat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receive();</span><br><span class="line">        String content;</span><br><span class="line">        <span class="keyword">while</span> (!(content = Scan.scanString()).equals(<span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">            send(<span class="string">&quot;[&quot;</span> + pcName + <span class="string">&quot;]：&quot;</span> + content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>客户机和主机实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDP_Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UDP_Service udp_service = <span class="keyword">new</span> UDP_Service(<span class="string">&quot;Client&quot;</span>,</span><br><span class="line">                <span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1087</span>,<span class="number">1088</span>);</span><br><span class="line">        udp_service.udpChat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDP_Host</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UDP_Service udp_service = <span class="keyword">new</span> UDP_Service(<span class="string">&quot;Host&quot;</span>,</span><br><span class="line">                <span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1088</span>,<span class="number">1087</span>);</span><br><span class="line">        udp_service.udpChat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>测试效果</li>
</ol>
<ul>
<li>主机</li>
</ul>
<blockquote>
<p>你好我是主机</p>
<p>&gt;&gt;ReceivePort[1088]% SendInfo：/127.0.0.1:50749</p>
<p>[Client]：我是客户机</p>
<p>那你能帮帮我吗？</p>
<p>&gt;&gt;ReceivePort[1088]% SendInfo：/127.0.0.1:49685 [Client]：爬</p>
</blockquote>
<ul>
<li>客户机</li>
</ul>
<blockquote>
<p>&gt;&gt; ReceivePort[1087]% SendInfo：/127.0.0.1:56760 [Host]：你好我是主机 我是客户机</p>
<p>&gt;&gt; ReceivePort[1087]% SendInfo：/127.0.0.1:64583</p>
<p>[Host]：那你能帮帮我吗？ 爬</p>
</blockquote>
<h4 id="socket---tcp"><code>Socket</code> --TCP</h4>
<p>该类实现客户端套接字（也称为“套接字”），套接字是两台机器之间通信的端点.</p>
<p><strong>构造函数</strong></p>
<table>
<colgroup>
<col style="width: 66%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">描述</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Socket()</code></td>
<td>创建一个未连接的套接字，系统默认类型为SocketImpl。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Socket(String host, int port)</code></td>
<td>创建流套接字并将其连接到指定主机上的指定端口号。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Socket(String host, int port, InetAddress localAddr, int localPort)</code></td>
<td>创建套接字并将其连接到指定远程端口上的指定远程主机。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Socket(InetAddress address, int port)</code></td>
<td>创建流套接字并将其连接到指定IP地址处的指定端口号。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Socket(InetAddress address, int port, InetAddress localAddr, int localPort)</code></td>
<td>创建套接字并将其连接到指定远程端口上的指定远程地址。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Socket(Proxy proxy)</code></td>
<td>创建一个未连接的套接字，指定应该使用的代理类型（如果有），而不管其他任何设置。</td>
</tr>
</tbody>
</table>
<p><strong>常用方法</strong></p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 21%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>bind(SocketAddress addr)</code></td>
<td style="text-align: left;">将此DatagramSocket绑定到特定的地址和端口。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>close()</code></td>
<td style="text-align: left;">关闭此数据报套接字。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>connect(InetAddress address, int port)</code></td>
<td style="text-align: left;">将套接字连接到此套接字的远程地址。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>connect(SocketAddress addr)</code></td>
<td style="text-align: left;">将此套接字连接到远程套接字地址（IP地址+端口号）。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>disconnect()</code></td>
<td style="text-align: left;">断开插座。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>getBroadcast()</code></td>
<td style="text-align: left;">测试是否启用了SO_BROADCAST。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>DatagramChannel</code></td>
<td style="text-align: left;"><code>getChannel()</code></td>
<td style="text-align: left;">返回与此数据报套接字关联的唯一<a href="chm://33031dcc470bf81a5f5e8595b0905ec1/java.base/java/nio/channels/DatagramChannel.html"><code>DatagramChannel</code></a>对象（如果有）。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>InetAddress</code></td>
<td style="text-align: left;"><code>getInetAddress()</code></td>
<td style="text-align: left;">返回此套接字连接的地址。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>InetAddress</code></td>
<td style="text-align: left;"><code>getLocalAddress()</code></td>
<td style="text-align: left;">获取套接字绑定的本地地址。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>getLocalPort()</code></td>
<td style="text-align: left;">返回此套接字绑定到的本地主机上的端口号。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>SocketAddress</code></td>
<td style="text-align: left;"><code>getLocalSocketAddress()</code></td>
<td style="text-align: left;">返回此套接字绑定的端点的地址。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>getPort()</code></td>
<td style="text-align: left;">返回此套接字连接的端口号。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>OutputStream</code></td>
<td style="text-align: left;"><code>getOutputStream()</code></td>
<td style="text-align: left;">返回此套接字的输出流。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>SocketAddress</code></td>
<td style="text-align: left;"><code>getRemoteSocketAddress()</code></td>
<td style="text-align: left;">返回此套接字连接到的端点的地址，如果未连接则返回 <code>null</code> 。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isBound()</code></td>
<td style="text-align: left;">返回套接字的绑定状态。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isClosed()</code></td>
<td style="text-align: left;">返回套接字是否关闭。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isConnected()</code></td>
<td style="text-align: left;">返回套接字的连接状态。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>receive(DatagramPacket p)</code></td>
<td style="text-align: left;">从此套接字接收数据报包。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>send(DatagramPacket p)</code></td>
<td style="text-align: left;">从此套接字发送数据报包。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setBroadcast(boolean on)</code></td>
<td style="text-align: left;">启用/禁用SO_BROADCAST。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setSoTimeout(int timeout)</code></td>
<td style="text-align: left;">使用指定的超时启用/禁用SO_TIMEOUT，以毫秒为单位。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setTrafficClass(int tc)</code></td>
<td style="text-align: left;">在IP数据报头中为从此DatagramSocket发送的数据报设置流量类或服务类型八位字节。</td>
</tr>
</tbody>
</table>
<h4 id="案例3---tcp-点对点全双工">案例3 --TCP 点对点全双工</h4>
<p>Socket 套接字，该类通过<code>SeverSocket</code> 建立TCP连接，然后即可全双工传输</p>
<p>因此，必须将 发送 和 接收 设置为2个线程，才能实现实时发送</p>
<p><strong>发送线程，传入参数为 Socket 对象</strong></p>
<p>服务端同时对多个客户端发送消息，设置输入临界区，保证对客户端的轮访</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCP_SendThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> String pcName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TCP_SendThread</span><span class="params">(Socket socket, String pcName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.pcName = pcName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (OutputStream outputStream = socket.getOutputStream()) &#123;</span><br><span class="line">            String string;</span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;To &quot;</span>+socket.getPort()+<span class="string">&quot;：&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (socket.isClosed() || (string = scanner.nextLine()).equals(<span class="string">&quot;exit&quot;</span>))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                string = <span class="string">&quot;&gt;&gt; [&quot;</span> + pcName + <span class="string">&quot;] &quot;</span> + string;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputStream.write(string.getBytes());</span><br><span class="line">                    <span class="comment">// 保证线程能轮流抢占</span></span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>接收线程，参数Socket 对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCP_ReceiveThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TCP_ReceiveThread</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;连接到 &quot;</span> + socket.getPort() + <span class="string">&quot; 本机：&quot;</span>+ socket.getLocalPort());</span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="keyword">int</span> sigh;</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((sigh = inputStream.read(data, <span class="number">0</span>, data.length)) != -<span class="number">1</span>)</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> String(data, <span class="number">0</span>, sigh));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>构建 TCP_IOSocket 类</strong></p>
<p>实现对以上两个线程的包装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCP_IOSocket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> targetPort;</span><br><span class="line">    <span class="keyword">private</span> String pcName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isServer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TCP_IOSocket</span><span class="params">(String pcName, <span class="keyword">boolean</span> isServer,</span></span></span><br><span class="line"><span class="params"><span class="function">                        String address, <span class="keyword">int</span> targetPort, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.pcName = pcName;</span><br><span class="line">        <span class="keyword">this</span>.targetPort = targetPort;</span><br><span class="line">        <span class="keyword">this</span>.isServer = isServer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建调用发送和接收线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">        Thread re = <span class="keyword">new</span> TCP_ReceiveThread(socket);</span><br><span class="line">        Thread se = <span class="keyword">new</span> TCP_SendThread(socket,pcName);</span><br><span class="line">        re.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        re.start();</span><br><span class="line">        se.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tcpIoSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">                serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">                <span class="comment">// 与多客户机建立连接</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        socket = serverSocket.accept();</span><br><span class="line">                        start(socket);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                socket = <span class="keyword">new</span> Socket(address, targetPort, InetAddress.getByName(address), port);</span><br><span class="line">                start(socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (</span><br><span class="line">                IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户机与主机</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCP_Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String pcName = <span class="string">&quot;Client&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isServer = <span class="keyword">false</span>;</span><br><span class="line">        String address = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> targetPort = <span class="number">1090</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">1089</span>;</span><br><span class="line">        TCP_IOSocket tcp_ioSocket = <span class="keyword">new</span> TCP_IOSocket(pcName, isServer,</span><br><span class="line">                address, targetPort, port);</span><br><span class="line">        tcp_ioSocket.tcpIoSocket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCP_Host</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String pcName = <span class="string">&quot;Host&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isServer = <span class="keyword">true</span>;</span><br><span class="line">        String address = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> targetPort = <span class="number">1089</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">1090</span>;</span><br><span class="line">        TCP_IOSocket tcp_ioSocket = <span class="keyword">new</span> TCP_IOSocket(pcName, isServer,</span><br><span class="line">                address, targetPort, port);</span><br><span class="line">        tcp_ioSocket.tcpIoSocket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试结果</strong></p>
<blockquote>
<p>服务器</p>
<p><img src="tcp1.png" style="zoom:60%;" /></p>
<p>客户端1</p>
<p><img src="tcp2.png" style="zoom:60%;"/></p>
<p>客户端2</p>
<p><img src="tcp3.png" style="zoom:60%;" /></p>
</blockquote>
<h2 id="枚举类型">枚举类型</h2>
<p>每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，枚举类型拥有的实例在编写的时候,就已经确定下,不能通过其他手段进行创建,且枚举变量在jvm有且只有一个对应的实例.</p>
<blockquote>
<ol type="1">
<li>枚举实例必须在 <code>enum</code>关键字声明的类中显式的指定(首行开始的以第一个分号结束)</li>
<li>除了1, 没有任何方式(new,clone,反射,序列化)可以手动创建枚举实例</li>
<li>枚举类不可被继承</li>
<li>枚举类是线程安全的</li>
<li>枚举类型是类型安全的(typesafe)，方法参数自动会对传入类型进行检查, <code>static final</code>定义的常量则不具备 类型安全的特点.</li>
<li>无法继承其他类(已经默认继承Enum)</li>
</ol>
</blockquote>
<ol type="1">
<li>常规用法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RoleTypeEnum</span> </span>&#123;</span><br><span class="line">    TEACHER, STUDENT, PRINCIPLE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们为沉默枚举创建了三个值，分别是教师、学生、校长。这段代码实际上调用了3次<code>Enum(String name, int ordinal)</code>（ordinal单词的意思为顺序），也就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Enum&lt;Chenmo&gt;(<span class="string">&quot;TEACHER&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> Enum&lt;Chenmo&gt;(<span class="string">&quot;STUDENT&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> Enum&lt;Chenmo&gt;(<span class="string">&quot;PRINCIPLE&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (RoleTypeEnum e : RoleTypeEnum.values()</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">TEACHER</span></span><br><span class="line"><span class="comment">STUDENT</span></span><br><span class="line"><span class="comment">PRINCIPLE</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>使用枚举常量比使用<code>final static</code>来实现常量定义,枚举的内存消耗比后高不止两倍. 应该严格避免在Android上使用枚举.</strong></p>
<h2 id="类的加载">类的加载</h2>
<p>我们运行写好的 java 文件时，编译器会先将 java 文件编译为 .class 字节码，再由类加载器将 .class文件加载到 JVM 中，生成 Class 对象</p>
<p><strong>类加载过程：</strong></p>
<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，包括：加载 -&gt; 连接 -&gt; 初始化 三个阶段</p>
<p><strong>1、加载</strong></p>
<p>（1）通过一个类的全限定名来获取其定义的二进制字节流</p>
<p>（2）将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构</p>
<p>（3）在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口。</p>
<p>相对于类加载的其他阶段而言，加载阶段是可控性最强的阶段，程序员可以使用系统的类加载器加载，还可以使用自己的类加载器加载。</p>
<p><strong>2、链接</strong></p>
<p>链接需要检查、准备和解析，先检查载入class文件数据的正确性然后给类的静态变量分配存储空间最后将符号引用转成直接引用。</p>
<p>（1）验证</p>
<p>​ 确保被加载的类的正确性</p>
<p>（2）准备</p>
<p>​ <strong>准备阶段主要为类变量分配内存并设置初始值</strong>。这些内存都在方法区分配。在这个阶段主要是类变量和初始值两个关键词：</p>
<ul>
<li><p>类变量（static）会分配内存，但是实例变量不会，实例变量主要随着对象的实例化一块分配到java堆中，</p></li>
<li><p>这里的初始值指的是数据类型默认值，而不是代码中被显示赋予的值</p></li>
</ul>
<p>（3）解析</p>
<p>​ 虚拟机将常量池中的符号引用转化为直接引用的过程。</p>
<ul>
<li>符号引用：以一组符号来描述所引用的目标，可以是任何形式的字面量，只要是能无歧义的定位到目标就好</li>
<li>直接引用：直接引用是可以指向目标的指针、相对偏移量或者是一个能直接或间接定位到目标的句柄。和虚拟机实现的内存有关，不同的虚拟机直接引用一般不同。</li>
</ul>
<p><strong>3、初始化</strong></p>
<p>类加载机制的最后一步，在这个阶段，java程序代码才开始真正执行</p>
<p>在初始化阶段，主要为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化</p>
<ul>
<li><p>JVM初始化步骤</p>
<p>1、假如这个类还没有被加载和连接，则程序先加载并连接该类</p>
<p>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</p>
<p>3、假如类中有初始化语句，则系统依次执行这些初始化语句</p></li>
<li><p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p>
<p>1、创建类的实例，也就是new的方式</p>
<p>2、访问某个类或接口的静态变量，或者对该静态变量赋值</p>
<p>3、调用类的静态方法</p>
<p>4、反射（如 Class.forName(“com.shengsiyuan.Test”)）</p>
<p>5、初始化某个类的子类，则其父类也会被初始化</p>
<p>6、Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类</p></li>
</ul>
<h4 id="类加载器">类加载器</h4>
<p>虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类</p>
<p><strong>Java语言系统自带有三个类加载器</strong></p>
<ul>
<li><strong>Bootstrap ClassLoader</strong> （启动类加载器）：最顶层的加载类，主要加载核心类库，也就是我们环境变量下面<code>$&#123;JAVA_HOME&#125;/lib</code>下的<code>rt.jar、resources.jar、charsets.jar和class</code>等。JVM内部 <code>C++</code> 语言实现，开发者不允许直接操作（它不是继承自ClassLoader的）</li>
<li><strong>Extention ClassLoader</strong> (扩展的类加载器)：加载目录<code>$&#123;JAVA_HOME&#125;\lib\ext</code>目录下的jar包和class文件。JAVA 层面实现，开发者可以直接操作。</li>
<li><strong>Appclass Loader</strong> (系统类加载器)：也称为SystemAppClass。 加载当前应用的classpath的所有类，它也是Java程序默认的类加载器，Java层面实现，开发者可以直接操作。</li>
</ul>
<p><img src="加载器.png" style="zoom:100%;" /></p>
<p>基本上所有的类加载器都是 <code>ClassLoader</code> 类的一个实现，除了 <code>bootStrap</code> 这个系统内部的加载器之外,也就是说除了它所有的类加载器都有一个父类加载器，可以通过图中的方法得到。当然，我们也可以自己在Java程序里通过继承 <code>ClassLoader</code> 来实现自己的类加载器。</p>
<p><strong>双亲委派原则</strong></p>
<p>当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务</p>
<p>采用双亲委派的一个好处是比如加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象</p>
<ul>
<li>可以避免重复加载，父类已经加载了，子类就不需要再次加载</li>
<li>更加安全，很好的解决了各个类加载器的基础类的统一问题，如果不使用该种方式，那么用户可以随意定义类加载器来加载核心api，会带来相关隐患</li>
</ul>
<p><strong>每一个Java类都维护一个指向定义它的类加载器的引用，可以通过getClassLoader() 就可以获取父类加载器 </strong></p>
<p><strong>ExtentionClassLoader加载器的父类加载器返回Null，因为bootStrap 加载器是C++写的，并不存在这么一个java类的实体。但在逻辑上是它的父类加载器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassLoader classLoader = ClassLoaderDemo.class.getClassLoader();</span><br><span class="line">        <span class="keyword">while</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(classLoader.toString());</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 获取上一级的类加载器</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            classLoader = classLoader.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>委托机制</strong></p>
<p>类的加载工作由 <code>ClassLoader</code> 和其子类负责，JVM在运行时会产生三个 <code>ClassLoader</code>，默认使用 AppClassLoader 状态应用程序的类。Java装载类使用 <code>全盘委托机制</code></p>
<ul>
<li><strong>全盘负责</strong> 是指一个 <code>ClassLoader</code> 装载一个类时，除非显式的使用另外一个 <code>ClassLoader</code>，否则该类所依赖的类也都是由这个 <code>ClassLoader</code> 装入。</li>
<li><code>委托机制</code> 是先委托父类装载器寻找目标类，只有在找不到的情况下才从自己的子类装载器路径中查找并装载目标类</li>
</ul>
<p><strong>自定义加载类</strong></p>
<ul>
<li><p>JVM已经提供了默认的类加载器，但是有一些弊端，比如只能加载指定目录下的<code>jar包或者class文件</code>，如果我们想加载其它位置的 <code>jar或者class文件</code> 时，比如网络上的某 class通过动态加载到内存来使用，这样的场景默认的类加载器就不能给我们提供帮助了，所以就要自己定义 <code>ClassLoader</code>。</p></li>
<li><p>自定义类的加载器继承 <code>ClassLoader</code> 然后重写父类的<code>findClass方法</code>，之所以只重写这个方法是因为JDK已经在loadClass中帮我们使用了ClassLoader搜索类的算法，当在loadClass方法中找不到类时，loadClass方法就会调用findClass方法来搜索类</p></li>
</ul>
<p>定义方式：</p>
<p>（1）遵守双亲委派模型：继承ClassLoader，重写findClass()方法。</p>
<p>（2）破坏双亲委派模型：继承ClassLoader,重写loadClass()方法。 通常我们推荐采用第一种方法自定义类加载器，最大程度上的遵守双亲委派模型。</p>
<h2 id="反射">反射</h2>
<h3 id="定义">定义</h3>
<p>JAVA 反射机制指：在程序运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。Java程序可以加载一个运行时才得知名称的class，获悉其完整构造（但不包括methods定义），并生成其对象实体、或对其fields设值、或唤起其methods</p>
<h3 id="用途">用途</h3>
<p>某个类的某个成员变量、方法或是属性是私有的或是只对系统应用开放，这时候就可以利用Java的反射机制通过反射来获取所需的私有成员或是方法。</p>
<h3 id="获取类名三种方式">获取类名三种方式</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuyang.Reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过实例</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">Class cl = user.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过类，不常用</span></span><br><span class="line">Class cl = User.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Class.forName() </span></span><br><span class="line">Class cl = Class.forName(<span class="string">&quot;com.liuyang.Reflect.User&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="获取构造函数及成员变量">获取构造函数及成员变量</h3>
<p>设置User类，对其进行反射。并重写<code>to_String()</code>便于测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuyang.Reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">public</span> String email;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> age, String userName, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String course)</span> </span>&#123;</span><br><span class="line">        System.out.println(id + <span class="string">&quot; - &quot;</span> + userName + <span class="string">&quot;: &quot;</span> + password + <span class="string">&quot;学了: &quot;</span> + course);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Studying&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">study</span><span class="params">(String course)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Studying &quot;</span> + course);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Finished&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, userName=&#x27;&quot;</span> + userName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, password=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, email=&#x27;&quot;</span> + email + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过反射得到构造函数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据类名，得到类的对象</span></span><br><span class="line">Class cl = Class.forName(<span class="string">&quot;com.liuyang.Reflect.User&quot;</span>);</span><br><span class="line"><span class="comment">// 得到 所有 公有构造方法，返回构造数组</span></span><br><span class="line">Constructor[] constructors = cl.getConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">    System.out.println(constructor);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到指定构造方法</span></span><br><span class="line">Constructor publicConstructor = cl.getConstructor(<span class="keyword">int</span>.class, <span class="keyword">int</span>.class, String.class, String.class);</span><br><span class="line"><span class="comment">// 输入参数，实例化</span></span><br><span class="line">System.out.println(publicConstructor.newInstance(<span class="number">2</span>, <span class="number">12</span>, <span class="string">&quot;dd&quot;</span>, <span class="string">&quot;wdr3434rewf324234&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到所有的构造方法，包括私有方法</span></span><br><span class="line">Constructor[] constructors1 = cl.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor c : constructors1) &#123;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到私有的构造方法</span></span><br><span class="line">Constructor privateConstructor = cl.getDeclaredConstructor(<span class="keyword">int</span>.class);</span><br><span class="line"><span class="comment">// 设置访问权限</span></span><br><span class="line">privateConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line">System.out.println(privateConstructor.newInstance(<span class="number">210</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Output</span></span><br><span class="line"><span class="comment">public com.liuyang.Reflect.User(int,int,java.lang.String,java.lang.String)</span></span><br><span class="line"><span class="comment">public com.liuyang.Reflect.User()</span></span><br><span class="line"><span class="comment">-----------------------------------------------</span></span><br><span class="line"><span class="comment">User&#123;id=2, userName=&#x27;dd&#x27;, password=&#x27;wdr3434rewf324234&#x27;, email=&#x27;null&#x27;, age=12&#125;</span></span><br><span class="line"><span class="comment">-----------------------------------------------</span></span><br><span class="line"><span class="comment">public com.liuyang.Reflect.User(int,int,java.lang.String,java.lang.String)</span></span><br><span class="line"><span class="comment">private com.liuyang.Reflect.User(int)</span></span><br><span class="line"><span class="comment">public com.liuyang.Reflect.User()</span></span><br><span class="line"><span class="comment">-----------------------------------------------</span></span><br><span class="line"><span class="comment">User&#123;id=210, userName=&#x27;null&#x27;, password=&#x27;null&#x27;, email=&#x27;null&#x27;, age=0&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>获得public成员属性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到公有成员变量</span></span><br><span class="line">Field[] objects = cl.getFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : objects) &#123;</span><br><span class="line">    System.out.println(field);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到指定的 public 成员变量</span></span><br><span class="line">Field ageField = cl.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="comment">// 通过反射的方式获取 user.age --&gt;  age.user</span></span><br><span class="line">System.out.println(ageField.getInt(<span class="keyword">new</span> User(<span class="number">2</span>,<span class="number">13</span>,<span class="string">&quot;dwsd&quot;</span>,<span class="string">&quot;ded&quot;</span>)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">User&#123;id=210, userName=&#x27;null&#x27;, password=&#x27;null&#x27;, email=&#x27;null&#x27;, age=0&#125;</span></span><br><span class="line"><span class="comment">-----------------------------------------------</span></span><br><span class="line"><span class="comment">public java.lang.String com.liuyang.Reflect.User.email</span></span><br><span class="line"><span class="comment">public int com.liuyang.Reflect.User.age</span></span><br><span class="line"><span class="comment">-----------------------------------------------</span></span><br><span class="line"><span class="comment">13</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>获得所有成员属性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到全部成员变量属性</span></span><br><span class="line">Field[] allFields = cl.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field field: allFields)&#123;</span><br><span class="line">    System.out.println(field);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到指定私有成员变量属性</span></span><br><span class="line">Field userNameField = cl.getDeclaredField(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">userNameField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(userNameField.get(<span class="keyword">new</span> User(<span class="number">102</span>,<span class="number">18</span>,<span class="string">&quot;liuyang&quot;</span>,<span class="string">&quot;123456780&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">private int com.liuyang.Reflect.User.id</span></span><br><span class="line"><span class="comment">private java.lang.String com.liuyang.Reflect.User.userName</span></span><br><span class="line"><span class="comment">private java.lang.String com.liuyang.Reflect.User.password</span></span><br><span class="line"><span class="comment">public java.lang.String com.liuyang.Reflect.User.email</span></span><br><span class="line"><span class="comment">public int com.liuyang.Reflect.User.age</span></span><br><span class="line"><span class="comment">-----------------------------------------------</span></span><br><span class="line"><span class="comment">liuyang</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>反射获取成员方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 User 对象</span></span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="number">102</span>,<span class="number">18</span>, <span class="string">&quot;liuyang&quot;</span>,<span class="string">&quot;123456780&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// public 成员方法， 包括父类</span></span><br><span class="line">Method[] publicMethods = cl.getMethods();</span><br><span class="line"><span class="keyword">for</span> (Method method: publicMethods)&#123;</span><br><span class="line">System.out.println(method);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定成员方法</span></span><br><span class="line">Method showMethod = cl.getMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line">showMethod.invoke(user, <span class="string">&quot;数学&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得所有成员方法，不包括父类</span></span><br><span class="line">Method[] allMethods = cl.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span> (Method method:allMethods)</span><br><span class="line">System.out.println(method);</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得指定的 私有 成员方法</span></span><br><span class="line">Method studyMethod = cl.getDeclaredMethod(<span class="string">&quot;study&quot;</span>, String.class);</span><br><span class="line"><span class="comment">// 取得访问权限</span></span><br><span class="line">studyMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object re = studyMethod.invoke(user,<span class="string">&quot;数学&quot;</span>);</span><br><span class="line">System.out.println(re);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">public java.lang.String com.liuyang.Reflect.User.toString()</span></span><br><span class="line"><span class="comment">public void com.liuyang.Reflect.User.study()</span></span><br><span class="line"><span class="comment">public void com.liuyang.Reflect.User.show(java.lang.String)</span></span><br><span class="line"><span class="comment">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">public boolean java.lang.Object.equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">public native int java.lang.Object.hashCode()</span></span><br><span class="line"><span class="comment">public final native java.lang.Class java.lang.Object.getClass()</span></span><br><span class="line"><span class="comment">public final native void java.lang.Object.notify()</span></span><br><span class="line"><span class="comment">public final native void java.lang.Object.notifyAll()</span></span><br><span class="line"><span class="comment">-----------------------------------------------</span></span><br><span class="line"><span class="comment">102 - liuyang: 123456780学了: 数学</span></span><br><span class="line"><span class="comment">-----------------------------------------------</span></span><br><span class="line"><span class="comment">public java.lang.String com.liuyang.Reflect.User.toString()</span></span><br><span class="line"><span class="comment">public void com.liuyang.Reflect.User.study()</span></span><br><span class="line"><span class="comment">private java.lang.String com.liuyang.Reflect.User.study(java.lang.String)</span></span><br><span class="line"><span class="comment">public void com.liuyang.Reflect.User.show(java.lang.String)</span></span><br><span class="line"><span class="comment">-----------------------------------------------</span></span><br><span class="line"><span class="comment">Studying 数学</span></span><br><span class="line"><span class="comment">Finished</span></span><br></pre></td></tr></table></figure>
<h3 id="相关类">相关类</h3>
<table>
<thead>
<tr class="header">
<th>类名</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Class类</td>
<td>代表类的实体，在运行的Java应用程序中表示类和接口</td>
</tr>
<tr class="even">
<td>Field类</td>
<td>代表类的成员变量（成员变量也称为类的属性）</td>
</tr>
<tr class="odd">
<td>Method类</td>
<td>代表类的方法</td>
</tr>
<tr class="even">
<td>Constructor类</td>
<td>代表类的构造方法</td>
</tr>
</tbody>
</table>
<h4 id="class">class</h4>
<p>代表类的实体，在运行的Java应用程序中表示类和接口</p>
<ul>
<li><strong>获得类相关的方法</strong></li>
</ul>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>asSubclass(Class<U> clazz)</td>
<td>把传递的类的对象转换成代表其子类的对象</td>
</tr>
<tr class="even">
<td>Cast</td>
<td>把对象转换成代表类或是接口的对象</td>
</tr>
<tr class="odd">
<td>getClassLoader()</td>
<td>获得类的加载器</td>
</tr>
<tr class="even">
<td>getClasses()</td>
<td>返回一个数组，数组中包含该类中所有公共类和接口类的对象</td>
</tr>
<tr class="odd">
<td>getDeclaredClasses()</td>
<td>返回一个数组，数组中包含该类中所有类和接口类的对象</td>
</tr>
<tr class="even">
<td>forName(String className)</td>
<td>根据类名返回类的对象</td>
</tr>
<tr class="odd">
<td>getName()</td>
<td>获得类的完整路径名字</td>
</tr>
<tr class="even">
<td>newInstance()</td>
<td>创建类的实例</td>
</tr>
<tr class="odd">
<td>getPackage()</td>
<td>获得类的包</td>
</tr>
<tr class="even">
<td>getSimpleName()</td>
<td>获得类的名字</td>
</tr>
<tr class="odd">
<td>getSuperclass()</td>
<td>获得当前类继承的父类的名字</td>
</tr>
<tr class="even">
<td>getInterfaces()</td>
<td>获得当前类实现的类或是接口</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>获得类中属性相关的方法</strong></li>
</ul>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>getField(String name)</td>
<td>获得某个公有的属性对象</td>
</tr>
<tr class="even">
<td>getFields()</td>
<td>获得所有公有的属性对象</td>
</tr>
<tr class="odd">
<td>getDeclaredField(String name)</td>
<td>获得某个属性对象</td>
</tr>
<tr class="even">
<td>getDeclaredFields()</td>
<td>获得所有属性对象</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>获得类中注解相关的方法</strong></li>
</ul>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>getAnnotation(Class<A> annotationClass)</td>
<td>返回该类中与参数类型匹配的公有注解对象</td>
</tr>
<tr class="even">
<td>getAnnotations()</td>
<td>返回该类所有的公有注解对象</td>
</tr>
<tr class="odd">
<td>getDeclaredAnnotation(Class<A> annotationClass)</td>
<td>返回该类中与参数类型匹配的所有注解对象</td>
</tr>
<tr class="even">
<td>getDeclaredAnnotations()</td>
<td>返回该类所有的注解对象</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>获得类中构造器相关的方法</strong></li>
</ul>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>getConstructor(Class...&lt;?&gt; parameterTypes)</td>
<td>获得该类中与参数类型匹配的公有构造方法</td>
</tr>
<tr class="even">
<td>getConstructors()</td>
<td>获得该类的所有公有构造方法</td>
</tr>
<tr class="odd">
<td>getDeclaredConstructor(Class...&lt;?&gt; parameterTypes)</td>
<td>获得该类中与参数类型匹配的构造方法</td>
</tr>
<tr class="even">
<td>getDeclaredConstructors()</td>
<td>获得该类所有构造方法</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>获得类中方法相关的方法</strong></li>
</ul>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>getMethod(String name, Class...&lt;?&gt; parameterTypes)</td>
<td>获得该类某个公有的方法</td>
</tr>
<tr class="even">
<td>getMethods()</td>
<td>获得该类所有公有的方法</td>
</tr>
<tr class="odd">
<td>getDeclaredMethod(String name, Class...&lt;?&gt; parameterTypes)</td>
<td>获得该类某个方法</td>
</tr>
<tr class="even">
<td>getDeclaredMethods()</td>
<td>获得该类所有方法</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>类中其他重要的方法</strong></li>
</ul>
<table>
<tbody>
<tr class="odd">
<td></td>
</tr>
</tbody>
</table>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"># 笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/05/26/LDA%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8APython%E5%AE%9E%E7%8E%B0/" rel="prev" title="LDA线性判别分析基本原理及Python实现">
                  <i class="fa fa-chevron-left"></i> LDA线性判别分析基本原理及Python实现
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/03/04/OpenCV%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/" rel="next" title="OpenCV三种方式">
                  OpenCV三种方式 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2017 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiuYang</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">871k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">13:12</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>






  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{&quot;enable&quot;:true,&quot;tags&quot;:&quot;none&quot;,&quot;js&quot;:&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;mathjax@3.1.4&#x2F;es5&#x2F;tex-mml-chtml.js&quot;}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.1.0/dist/quicklink.umd.js"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{&quot;enable&quot;:true,&quot;home&quot;:true,&quot;archive&quot;:true,&quot;delay&quot;:true,&quot;timeout&quot;:3000,&quot;priority&quot;:true,&quot;ignores&quot;:null,&quot;url&quot;:&quot;https:&#x2F;&#x2F;ly1998117.github.io&#x2F;2020&#x2F;03&#x2F;01&#x2F;java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0&#x2F;&quot;}</script>
  <script src="/js/third-party/quicklink.js"></script>



  <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
  <script src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
  <script async src="/js/cursor/explosion.js"></script>

</body>
</html>
