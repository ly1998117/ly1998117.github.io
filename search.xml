<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android应用基础知识</title>
    <url>/2020/03/04/Android%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="android应用基础">Android应用基础</h1>
<blockquote>
<p>使用语言：Kotlin、Java、C++</p>
<p>Android SDK：将代码连同任何数据和资源文件编译成 APK</p>
</blockquote>
<span id="more"></span>
<h2 id="android-os">Android OS</h2>
<h3 id="最小权限原则">最小权限原则</h3>
<p>​ Android 系统实现了<em>最小权限原则。</em>默认情况下，每个应用只能访问执行其工作所需的组件，而不能访问其他组件。这样便能创建非常安全的环境。在此环境中，应用无法访问其未获得权限的系统部分。不过，应用仍可通过一些途径与其他应用共享数据以及访问系统服务：</p>
<ul>
<li>可以安排两个应用共享同一 Linux 用户 ID，在此情况下，二者便能访问彼此的文件。为节省系统资源，也可安排拥有相同用户 ID 的应用在同一 Linux 进程中运行，并共享同一VM。应用还必须使用相同的证书进行签名。</li>
<li>应用可以请求访问设备数据（如用户的联系人、短信消息、可装载存储装置（SD 卡）、相机、蓝牙等）的权限。用户必须明确授予这些权限。</li>
</ul>
<h3 id="android-安全功能">Android 安全功能</h3>
<p>每个Android 应用都处于Android 安全功能各自的安全沙盒中，并受以下 Android 安全功能的保护：</p>
<ul>
<li>Android 操作系统是一种多用户 Linux 系统，其中的每个应用都是一个不同的用户；</li>
<li>默认情况下，系统会为每个应用分配一个唯一的 Linux 用户 ID（该 ID 仅由系统使用，应用并不知晓）。系统会为应用中的所有文件设置权限，使得只有分配给该应用的用户 ID 才能访问这些文件；</li>
<li>每个进程都拥有自己的虚拟机 (VM)，因此应用代码独立于其他应用而运行。</li>
<li>默认情况下，每个应用都在其自己的 Linux 进程内运行。Android 系统会在需要执行任何应用组件时启动该进程，然后当不再需要该进程或系统必须为其他应用恢复内存时，其便会关闭该进程。</li>
</ul>
<h2 id="应用组件">应用组件</h2>
<p>应用组件是 Android 应用的基本构建块。每个组件都是一个入口点，系统或用户可通过该入口点进入您的应用。有些组件会依赖于其他组件。每种类型都有不同的用途和生命周期。</p>
<p>共有四种不同的应用组件类型：</p>
<ul>
<li>Activity</li>
<li>服务</li>
<li>广播接收器</li>
<li>内容提供程序</li>
</ul>
<h3 id="activity">Activity</h3>
<blockquote>
<p><strong>Activity</strong>是与用户交互的入口点。它表示拥有界面的单个屏幕。电子邮件应用可能有一个显示新电子邮件列表的 Activity、一个用于撰写电子邮件的 Activity 以及一个用于阅读电子邮件的 Activity。尽管这些 Activity 通过协作在电子邮件应用中形成一种紧密结合的用户体验，但每个 Activity 都独立于其他 Activity 而存在。因此，其他应用可以启动其中任何一个 Activity（如果电子邮件应用允许）。例如，相机应用可以启动电子邮件应用内用于撰写新电子邮件的 Activity，以便用户共享图片。</p>
</blockquote>
<p>Activity 有助于完成系统和应用程序之间的以下重要交互：</p>
<ul>
<li>追踪用户当前关心的内容（屏幕上显示的内容），以确保系统继续运行托管 Activity 的进程。</li>
<li>了解先前使用的进程包含用户可能返回的内容（已停止的 Activity），从而更优先保留这些进程。</li>
<li>帮助应用处理终止其进程的情况，以便用户可以返回已恢复其先前状态的 Activity。</li>
<li>提供一种途径，让应用实现彼此之间的用户流，并让系统协调这些用户流。（此处最经典的示例是共享。）</li>
</ul>
<h4 id="概念">概念</h4>
<ol type="1">
<li><p><code>Activity</code> 类的目的就是实现当一个应用调用另一个应用时，调用方应用会调用另一个应用中的 Activity，而不是整个应用。通过这种方式，Activity 充当了应用与用户互动的入口点。可以将 Activity 实现为 <code>Activity</code> 类的子类。</p></li>
<li><p>大多数应用包含多个屏幕，这意味着它们包含多个 Activity。通常，应用中的一个 Activity 会被指定为主 Activity，这是用户启动应用时出现的第一个屏幕。然后，每个 Activity 可以启动另一个 Activity，以执行不同的操作。虽然应用中的各个 Activity 协同工作形成统一的用户体验，但每个 Activity 与其他 Activity 之间只存在松散的关联，应用内不同 Activity 之间的依赖关系通常很小。事实上，Activity 经常会启动属于其他应用的 Activity。</p></li>
<li><p>要在应用中使用 Activity，您必须在应用的清单<code>AndroidManifest.xml</code>中注册关于 Activity 的信息，并且必须适当地管理 Activity 的生命周期。</p></li>
</ol>
<h4 id="配置androidmanifest">配置AndroidManifest</h4>
<h5 id="声明-activity">声明 Activity</h5>
<p>要声明 Activity，请打开清单文件，并添加<code>&lt;activity&gt;</code>元素作为<code>&lt;application&gt;</code>元素的子元素。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">application</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span>/&gt;</span> </span><br><span class="line">     ...</span><br><span class="line">  &lt;/application &gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/manifest &gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.android.com/guide/topics/manifest/activity-element?hl=zh-cn#nm">android:name</a>属性用于指定 Activity 的类名称。也可以添加用于定义标签、图标或界面主题等 Activity 特征的属性。</p>
<h4 id="intent-过滤器">Intent 过滤器</h4>
<p>Intent 过滤器不但可以根据显式请求启动 Activity，还可以根据隐式请求启动 Activity。显式请求可能会告诉系统“在 Gmail 应用中启动‘发送电子邮件’Activity”，而隐式请求可能会告诉系统“在任何能够完成此工作的 Activity 中启动‘发送电子邮件’屏幕”。要使用此功能，您需要在<code>&lt;activity&gt;</code>元素中声明<code>&lt;intent-filter&gt;</code>属性。此元素的定义包括<code>action</code>元素，以及可选的<code>category</code>元素和/或<code>data</code>元素</p>
<ul>
<li><strong>显式 Intent</strong>：通过提供目标应用的软件包名称或完全限定的组件类名来指定可处理 Intent 的应用。通常，在自己的应用中使用显式 Intent 来启动组件，因为我们知道要启动的 Activity 或服务的类名。</li>
<li><strong>隐式 Intent</strong> ：不会指定特定的组件，而是声明要执行的常规操作，从而允许其他应用中的组件来处理。例如，如需在地图上向用户显示位置，则可以使用隐式 Intent，请求另一具有此功能的应用在地图上显示指定的位置。</li>
</ul>
<p>隐式 Intent 如何通过系统传递以启动其他 Activity：</p>
<p><strong>1.</strong> <em>Activity A</em> 创建包含操作描述的 <code>Intent</code>，并将其传递给 <code>startActivity()</code>。</p>
<p><strong>2.</strong> Android 系统搜索所有应用中与 Intent 匹配的 Intent 过滤器。找到匹配项之后</p>
<p><strong>3</strong> 该系统通过调用匹配 Activity (<em>Activity B</em>) 的 <code>onCreate()</code> 方法并将其传递给 <code>Intent</code>，以此启动匹配 Activity。</p>
<p><img src="intent.png" alt="隐式intent" style="zoom:70%;" /></p>
<p>使用隐式 Intent 时，Android 系统通过将 Intent 的内容与在设备上其他应用的<code>清单文件</code>中声明的<code>Intent 过滤器</code>进行比较，从而找到要启动的相应组件。如果 Intent 与 Intent 过滤器匹配，则系统将启动该组件，并向其传递 <code>Intent</code> 对象。如果多个 Intent 过滤器兼容，则系统会显示一个对话框，支持用户选取要使用的应用。</p>
<p><code>Intent 过滤器</code>是应用清单文件中的一个表达式，用于指定该组件要接收的 Intent 类型。只有声明<code>Intent过滤器</code>才能被其他 Activity 启动，下面给出声明范例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 以下代码段展示了如何配置一个发送文本数据并接收其他 Activity 的文本数据发送请求的 Activity --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.ExampleActivity&quot;</span> <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/app_icon&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.SEND&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">&quot;text/plain&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;action&gt;</code> 元素指定该 Activity 会发送数据; <code>&lt;category&gt;</code>元素声明为 <code>DEFAULT</code> 可使 Activity 能够接收启动请求;<code>&lt;data&gt;</code>元素指定此 Activity 可以发送的数据类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下代码段展示了如何调用上述 Activity</span></span><br><span class="line"> <span class="comment">// Create the text message with a string</span></span><br><span class="line">Intent sendIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">sendIntent.setAction(Intent.ACTION_SEND);</span><br><span class="line">sendIntent.setType(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);</span><br><span class="line"><span class="comment">// Start the activity</span></span><br><span class="line">startActivity(sendIntent);</span><br></pre></td></tr></table></figure>
<p>Intent 常见操作：</p>
<ul>
<li><p>ACTION_VIEW：如果您拥有一些某项 Activity 可向用户显示的信息（例如，要使用图库应用查看的照片），通过 Intent 将此操作与 <code>startActivity()</code> 结合使用。</p></li>
<li><p>ACTION_SEND：这也称为<em>共享</em> Intent。如果您拥有一些用户可通过其他应用（例如，电子邮件应用或社交共享应用）共享的数据，则应使用 Intent 将此操作与 <code>startActivity()</code> 结合使用。</p></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>K-Means聚类算法原理</title>
    <url>/2019/04/25/K-Means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="introduction-to-k-means-clustering">Introduction To K-Means Clustering</h1>
<p>K-Means 聚类算法是一类无监督学习算法，适用于unlabeled data (data without defined categories or groups)该算法的目标是在数据中找到划分的界限，使数据被分为K个类别。算法不断的迭代，使得每个数据点根据特征被归入K个Categories中的其中一个。</p>
<span id="more"></span>
<p>算法的最终输出有：</p>
<pre><code>    1. K簇的质心，可用于标记新数据
    2. 训练数据的标签（每个数据点分配给一个集群）</code></pre>
<p>K簇的质心就是一组特征值，根据这k个质心即确定数据所代表的类</p>
<h1 id="算法">算法</h1>
<p><em>Κ</em> -means聚类算法使用迭代优化，以产生最终结果。算法输入是簇 <em>Κ</em> 和数据集的数量。数据集是每个数据点的向量集合。算法从<em>Κ</em> 质心的初始估计开始，可以随机生成或从数据集中随机选择。然后算法在两个步骤之间迭代：</p>
<ol type="1">
<li><p>数据分配</p>
<p>每个质心定义一个簇。在此步骤中，每个数据点基于平方欧几里德距离分配到距其最近的质心。更正式地说，如果<em>c i</em> 是集合<em>C中</em>的质心集合，则每个数据点<em>x</em>按下面公式被分配给集群。</p>
<p>​ <span class="math display">\[ \underset{c_i\in C}{\arg\min}\;DIST(C_i，x)^2 \]</span></p>
<ol start="2" type="1">
<li>质心更新</li>
</ol>
<p>在此步骤中，质心被重新计算，通过计算分配给该质心的所有数据的平均值来更新质心</p>
<p>​ <span class="math display">\[c_i=\frac{1}{|S_i|}\sum_{x_i \in S_i x_i}\]</span></p></li>
</ol>
<p>该算法在步骤1和步骤2之间迭代，直到满足停止标准（即，没有数据点改变簇，距离的总和最小化，或者达到一些最大迭代次数）。</p>
<p>由于初始质心的选择是随机确定，这意味着最终结果可能是局部最优。</p>
<h1 id="k-的选择">K 的选择</h1>
<p>上面描述的K-Means算法找到类并为数据点标记都基于提前给定的K值。为了发现数据集的簇的数量，用户需要给定一系列不同的k值并运行算法，然后比较结果。实际上，也没有具体的算法能直接给出合适的k值，但存在一些措施来辅助确定较为准确的K值</p>
<p>对于不同k值的度量方式：数据点与其质心的平均距离。</p>
<p>由于增加簇的数量将总是减少到数据点的距离，即增加 <em>K</em> 将<em>总是</em>减小该度量值。而当<em>K</em> 与数据点的数量相同时，该度量值就会达到零的极值。</p>
<p>故该指标不能用作唯一目标。，到质心的平均距离可以看做是一个关于K的函数，下图对该函数进行绘制，其中下降率急剧变化的“驻点”，可用于粗略地确定<em>ķ</em>。</p>
<p>​ 也存在许多其他用于验证<em>K的</em>技术，包括交叉验证，信息标准，信息理论跳跃方法，轮廓方法和G均值算法。此外，监视跨组的数据点分布可以深入了解算法如何分割每个<em>K</em>的数据 。</p>
<h1 id="算法伪代码描述">算法伪代码描述</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function K-Means(数据data, 中心点k) </span><br><span class="line">	获取输入数据的维度Dim 和 个数 N</span><br><span class="line">	随机生成 K 个 Dim 维的点作为中心点</span><br><span class="line">	while(未收敛)		</span><br><span class="line">			对 N 个点：计算每个点属于的类别</span><br><span class="line">			对 K 个中心点 ：</span><br><span class="line">				1、找出所有与该点同类的所有数据点</span><br><span class="line">				2、把自己的坐标修改为这些数据点的中心</span><br><span class="line">	end	</span><br><span class="line">	output</span><br><span class="line">end </span><br></pre></td></tr></table></figure>
<h1 id="python-实现">Python 实现</h1>
<h2 id="python-codeuse-pca-to-reduct-dimensions">python code(use PCA to reduct dimensions)</h2>
<p>选用数据集：</p>
<ol type="1">
<li><p>sklearn 库中的鸢尾花，降维后绘制图象。</p></li>
<li><p>自设数据集，给定不同的协方差矩阵和均值生成符合分布的随机数据</p></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> PCA <span class="keyword">import</span> PCA</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">K_Means</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n_clusters, max_iter=<span class="number">200</span>, n_init=<span class="number">5</span></span>):</span></span><br><span class="line">        self.n_cluster = n_clusters</span><br><span class="line">        self.max_iter = max_iter</span><br><span class="line">        self.n_init = n_init</span><br><span class="line"></span><br><span class="line">        self.data = <span class="literal">None</span></span><br><span class="line">        self.dim = <span class="literal">None</span></span><br><span class="line">        self.n = <span class="literal">None</span></span><br><span class="line">        self.center_point = <span class="literal">None</span></span><br><span class="line">        self.data_label = <span class="literal">None</span></span><br><span class="line">        self.init_point = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rand_points</span>(<span class="params">self</span>):</span>  <span class="comment"># 初始化中心点</span></span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        index = []</span><br><span class="line"></span><br><span class="line">        center_point = np.zeros((self.n_cluster, self.dim), dtype=np.float32)</span><br><span class="line">        self.init_point = np.zeros((self.n_cluster, self.dim), dtype=np.float32)</span><br><span class="line">        <span class="keyword">while</span> counter &lt; self.n_cluster:</span><br><span class="line">            i = np.random.randint(<span class="number">0</span>, self.n)</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> index:</span><br><span class="line">                index.append(i)</span><br><span class="line">                center_point[counter] = self.data[i]</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        self.init_point[:] = center_point[:]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_k_means</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.rand_points()</span><br><span class="line">        sign = np.zeros(self.n_cluster, dtype=np.<span class="built_in">bool</span>)</span><br><span class="line">        data_label = np.zeros((self.n, <span class="number">1</span>), dtype=np.float32)</span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        new_center_point = np.zeros_like(self.init_point)</span><br><span class="line">        new_center_point[:] = self.init_point[:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span> <span class="keyword">and</span> counter &lt; self.max_iter:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line">                d = <span class="number">1e+10</span></span><br><span class="line">                label = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.n_cluster):</span><br><span class="line">                    distance = np.linalg.norm(self.data[i] - new_center_point[j])</span><br><span class="line">                    <span class="keyword">if</span> distance &lt; d:</span><br><span class="line">                        d = distance</span><br><span class="line">                        label = j</span><br><span class="line">                data_label[i] = label</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n_cluster):</span><br><span class="line">                cluster = np.argwhere(data_label == i)[:, <span class="number">0</span>]</span><br><span class="line">                coord = self.data[cluster].T</span><br><span class="line">                ave = []</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> coord:</span><br><span class="line">                    ave.append(np.mean(j))</span><br><span class="line">                ave = np.array(ave)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> np.linalg.norm(new_center_point[i] - ave) &gt; <span class="number">1e-06</span>:</span><br><span class="line"></span><br><span class="line">                    sign[i] = <span class="literal">False</span></span><br><span class="line">                    new_center_point[i] = ave</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    sign[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> sign.<span class="built_in">all</span>() == <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">        distance = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.n_cluster):</span><br><span class="line">            data_labeld = self.data[np.argwhere(data_label == j)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> data_labeld:</span><br><span class="line">                distance += np.linalg.norm(new_center_point[j] - i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> new_center_point, data_label, distance / self.n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span>(<span class="params">self, data</span>):</span>  <span class="comment"># K-Means算法实现主体 多次运行取最优值</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.dim = data.shape[<span class="number">1</span>]</span><br><span class="line">        self.n = data.shape[<span class="number">0</span>]</span><br><span class="line">        distance = <span class="number">1e+10</span></span><br><span class="line">        init_point = np.zeros((self.n_cluster, self.dim), dtype=self.data.dtype)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.n_init):</span><br><span class="line">            new_center_point, data_label, d = self._k_means()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> d &lt; distance:</span><br><span class="line">                distance = d</span><br><span class="line">                self.center_point = new_center_point</span><br><span class="line">                self.data_label = data_label</span><br><span class="line">                init_point[:] = self.init_point[:]</span><br><span class="line"></span><br><span class="line">        self.init_point = init_point</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>, <span class="number">20</span> * <span class="string">&#x27;_&#x27;</span>, <span class="string">&quot;K-Means 数据聚类&quot;</span>, <span class="number">20</span> * <span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>, <span class="number">20</span> * <span class="string">&#x27;_&#x27;</span>, <span class="string">&quot; 初始中心点 &quot;</span>, <span class="number">20</span> * <span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;\n&#x27;</span>, init_point)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>, <span class="number">20</span> * <span class="string">&#x27;_&#x27;</span>, <span class="string">&quot; 最终中心点 &quot;</span>, <span class="number">20</span> * <span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;\n&#x27;</span>, self.center_point)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>, <span class="number">20</span> * <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27; 运行次数：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.n_init), <span class="number">20</span> * <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">label_</span>(<span class="params">self</span>):</span>  <span class="comment"># 返回标签</span></span><br><span class="line">        <span class="keyword">return</span> self.data_label.reshape(self.n)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cluster_centers</span>(<span class="params">self</span>):</span>  <span class="comment"># 最终分类中心点</span></span><br><span class="line">        <span class="keyword">return</span> self.center_point</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, data</span>):</span>  <span class="comment"># 对输入数据进行分类预测</span></span><br><span class="line">        data = np.array(data)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            n, d = data.shape</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;wrong data type&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> d != self.dim:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;wrong data type&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">            d = <span class="number">1e+10</span></span><br><span class="line">            label = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.n_cluster):</span><br><span class="line">                distance = np.linalg.norm(data[i] - self.center_point[j])</span><br><span class="line">                <span class="keyword">if</span> distance &lt; d:</span><br><span class="line">                    d = distance</span><br><span class="line">                    label = j</span><br><span class="line">            result.append(label)</span><br><span class="line">        <span class="keyword">return</span> np.array(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataProduce</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_data</span>(<span class="params">self</span>):</span></span><br><span class="line">        data1 = np.random.multivariate_normal([<span class="number">10</span>, <span class="number">0</span>], [[<span class="number">5</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">5</span>]], size=<span class="number">100</span>)</span><br><span class="line">        data2 = np.random.multivariate_normal([<span class="number">0</span>, -<span class="number">10</span>], [[<span class="number">5</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">5</span>]], size=<span class="number">100</span>)</span><br><span class="line">        data3 = np.random.multivariate_normal([<span class="number">0</span>, <span class="number">15</span>], [[<span class="number">5</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">5</span>]], size=<span class="number">100</span>)</span><br><span class="line">        data4 = np.random.multivariate_normal([-<span class="number">10</span>, <span class="number">5</span>],[[<span class="number">5</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">5</span>]], size=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">        target = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> data1]</span><br><span class="line">        target.extend([<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> data2])</span><br><span class="line">        target.extend([<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> data3])</span><br><span class="line">        target.extend([<span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> data4])</span><br><span class="line"></span><br><span class="line">        data = np.concatenate((data1,data2,data3,data4))</span><br><span class="line">        data_dict = &#123;<span class="string">&#x27;data&#x27;</span>: data, <span class="string">&#x27;target&#x27;</span>: target&#125;</span><br><span class="line">        <span class="keyword">return</span> data_dict</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iris</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> load_iris()  <span class="comment"># 鸾尾花数据集</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Draw</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_2d_draw</span>(<span class="params">self,d</span>):</span></span><br><span class="line">        data = d[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">        d_label = d[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line">        cluster_num = <span class="built_in">len</span>(<span class="built_in">set</span>(d_label))</span><br><span class="line">        <span class="comment"># --------------------------绘制网格-----------------------------</span></span><br><span class="line">        h = <span class="number">.1</span></span><br><span class="line">        x_min, x_max = data[:, <span class="number">0</span>].<span class="built_in">min</span>() - <span class="number">1</span>, data[:, <span class="number">0</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">        y_min, y_max = data[:, <span class="number">1</span>].<span class="built_in">min</span>() - <span class="number">1</span>, data[:, <span class="number">1</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">        xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))</span><br><span class="line">        kmeans = K_Means(cluster_num)</span><br><span class="line">        kmeans.fit(data)</span><br><span class="line">        centroids = kmeans.cluster_centers()</span><br><span class="line"></span><br><span class="line">        label_pred = kmeans.predict(np.c_[xx.ravel(), yy.ravel()])</span><br><span class="line"></span><br><span class="line">        z = label_pred.reshape(xx.shape)</span><br><span class="line">        fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">        ax1 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">        ax2 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        ax1.set_title(<span class="string">&quot;initial data-set&quot;</span>, size=<span class="number">20</span>)</span><br><span class="line">        ax2.set_title(<span class="string">&#x27;K-means clustering &#x27;</span>, size=<span class="number">20</span>)</span><br><span class="line">        ax2.imshow(z, interpolation=<span class="string">&#x27;nearest&#x27;</span>,</span><br><span class="line">                   extent=(xx.<span class="built_in">min</span>(), xx.<span class="built_in">max</span>(), yy.<span class="built_in">min</span>(), yy.<span class="built_in">max</span>()),</span><br><span class="line">                   cmap=plt.cm.Paired,</span><br><span class="line">                   aspect=<span class="string">&#x27;auto&#x27;</span>, origin=<span class="string">&#x27;lower&#x27;</span>)</span><br><span class="line">        ax2.plot(data[:, <span class="number">0</span>], data[:, <span class="number">1</span>], <span class="string">&#x27;k.&#x27;</span>, markersize=<span class="number">2</span>)</span><br><span class="line">        ax1.scatter(*<span class="built_in">zip</span>(*data), c=d_label, s=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        ax2.scatter(*<span class="built_in">zip</span>(*data), c=<span class="string">&#x27;black&#x27;</span>, s=<span class="number">2</span>)</span><br><span class="line">        ax2.scatter(*<span class="built_in">zip</span>(*centroids), c=<span class="string">&#x27;w&#x27;</span>, marker=<span class="string">&#x27;x&#x27;</span>, s=<span class="number">1000</span>)</span><br><span class="line">        ax2.scatter(*<span class="built_in">zip</span>(*kmeans.init_point), c=<span class="string">&#x27;r&#x27;</span>, marker=<span class="string">&#x27;1&#x27;</span>, s=<span class="number">1000</span>)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    data = DataProduce()</span><br><span class="line"></span><br><span class="line">    test_data = data.test_data()</span><br><span class="line">    iris = data.iris()</span><br><span class="line"></span><br><span class="line">    kmeans = K_Means(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --------------4维数据聚类------------</span></span><br><span class="line">    kmeans.fit(iris[<span class="string">&#x27;data&#x27;</span>])</span><br><span class="line">    <span class="comment"># --------------PCA降维---------------</span></span><br><span class="line">    pca = PCA(iris[<span class="string">&#x27;data&#x27;</span>])</span><br><span class="line">    reduced_data = &#123;<span class="string">&#x27;data&#x27;</span>: pca.pca(<span class="number">2</span>), <span class="string">&#x27;target&#x27;</span>: iris[<span class="string">&#x27;target&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ----------------绘图-----------------</span></span><br><span class="line">    draw = Draw()</span><br><span class="line">    draw._2d_draw(reduced_data)</span><br><span class="line">    draw._2d_draw(test_data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="running-result">Running Result</h2>
<p>鸢尾花数据集，k=3</p>
<p>红色y型记号代表初始随机质心，白色记号代表最终数据中心</p>
<p><img src="1.png" alt="" style="zoom:90%;" /></p>
<p>自设数据集，k=4，分类结果正确</p>
<p>红色y型记号代表初始随机质心，白色记号代表最终数据中心</p>
<p><img src="2.png" alt="" style="zoom:90%;" /></p>
]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>K-Means</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer vision with PyTorch (Dense &amp;&amp; Convolutional layers)</title>
    <url>/2021/06/24/Computer-Vision-PyTorch/</url>
    <content><![CDATA[<h2 id="task">Task</h2>
<p>use image classification tasks to learn about convolutional neural networks, and then see how pre-trained networks and transfer learning can improve our models and solve real-world problems.</p>
<span id="more"></span>
<h2 id="introduction-to-image-data">Introduction to image data</h2>
<p>In computer vision, we normally solve one of the following problems:</p>
<ul>
<li><strong>Image Classification</strong> the simplest task, when we need to classify an image into one of many pre-defined categories, for example, distinguish a cat from a dog on a photograph, or recognize a handwritten digit.</li>
<li><strong>Object Detection</strong> a bit more difficult task, in which we need to find known objects on the picture and localize them, i.e. return the <strong>bounding box</strong> for each of recognized objects.</li>
<li><strong>Segmentation</strong> similar to object detection, but instead of giving bounding box we need to return an exact pixel map outlining each of the recognized objects.</li>
</ul>
<p><img src="mFBCV.png" alt="mFBCV" style="zoom:80%;" /></p>
<p>Multi-dimensional arrays are also called <strong>tensors</strong>. Using tensors to represent images also has an advantage, because we can use an extra dimension to store a sequence of images. For example, to represent a video fragment consisting of 200 frames with 800x600 dimension, we may use the tensor of size 200x3x600x800.</p>
<h2 id="import-packages-and-load-the-mnist-dataset">Import packages and load the MNIST Dataset</h2>
<p>we are using the well-known <a href="http://yann.lecun.com/exdb/mnist/">MNIST</a> dataset of handwritten digits, available through <code>torchvison.datasets.MNIST</code> in PyTorch. The dataset object returns the data in the form of Python Imagine Library (PIL) images, which we convert to tensors by passing a <code>transform=ToTensor()</code> parameter.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms <span class="keyword">import</span> ToTensor</span><br><span class="line"></span><br><span class="line">training_data = datasets.MNIST(</span><br><span class="line">	root=<span class="string">&#x27;data&#x27;</span>,</span><br><span class="line">  train=<span class="literal">True</span>,</span><br><span class="line">  download=<span class="literal">False</span>,</span><br><span class="line">  transform=ToTensor()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">test_data = datasets.MNIST(</span><br><span class="line">	root=<span class="string">&#x27;data&#x27;</span>,</span><br><span class="line">  train=<span class="literal">False</span>,</span><br><span class="line">  download=<span class="literal">False</span>,</span><br><span class="line">  transform=ToTensor()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="1.png" alt="1" style="zoom:60%;" /></p>
<blockquote>
<p>If you are planning to load your own images, it is important to make sure that all values are scaled to the range <a href="https://docs.microsoft.com/zh-cn/learn/modules/intro-computer-vision-pytorch/2-image-data"><strong>0 - 1</strong></a> before we start training a neural network.</p>
</blockquote>
<h2 id="training-a-dense-neural-network">Training a dense neural network</h2>
<p>The handwritten digit recognition is a classification problem. We will start with the simplest possible approach for image classification - a fully-connected neural network (which is also called a <em>perceptron</em>).</p>
<h3 id="fully-connected-dense-neural-networks">Fully-connected dense neural networks</h3>
<p>A basic <strong>neural network</strong> in PyTorch consists of a number of <strong>layers</strong>. The simplest network would include just one fully-connected layer, which is called <strong>Linear</strong> layer, with 784 inputs (one input for each pixel of the input image) and 10 outputs (one output for each class).</p>
<p><img src="2.png" alt="2" style="zoom:30%;" /></p>
<p>the dimension of our digit images is 1×28×281×28×28. Because the input dimension of a fully-connected layer is 784, we need to insert another layer into the network, called <strong>Flatten</strong>, to change tensor shape from 1×28×281×28×28 to 784784.</p>
<p>We want nn-th output of the network to return the probability of the input digit being equal to nn. <strong>Because the output of a fully-connected layer is not normalized to be between 0 and 1, it cannot be thought of as probability</strong>. To turn it into a probability we need to apply another layer called <strong>Softmax</strong>.</p>
<p>In PyTorch, it is easier to use <strong>LogSoftmax</strong> function, which will also compute logarithms of output probabilities. To turn the output vector into the actual probabilities, we need to take <strong>torch.exp</strong> of the output.</p>
<p><img src="3.png" alt="3" style="zoom:30%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">        nn.Flatten(), </span><br><span class="line">        nn.Linear(<span class="number">784</span>,<span class="number">10</span>), <span class="comment"># 784 inputs, 10 outputs</span></span><br><span class="line">        nn.LogSoftmax())</span><br></pre></td></tr></table></figure>
<h3 id="training-the-network">Training the network</h3>
<blockquote>
<p>The training process steps are as follows:</p>
<ol type="1">
<li>We take a minibatch from the input dataset, which consists of input data (features) and expected result (label).</li>
<li>We calculate the predicted result for this minibatch.</li>
<li>The difference between this result and expected result is calculated using a special function called the <strong>loss function</strong></li>
<li>We calculate the gradients of this loss function with respect to model weights (parameters), which are then used to adjust the weights to optimize the performance of the network. The amount of adjustment is controlled by a parameter called <strong>learning rate</strong>, and the details of optimization algorithm are defined in the <strong>optimizer</strong> object.</li>
<li>We repeat those steps until the whole dataset is processed. One complete pass through the dataset is called <strong>an epoch</strong>.</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_epoch</span>(<span class="params">self, epoch, lr=<span class="number">1e-2</span>, optimizer=<span class="literal">None</span></span>):</span></span><br><span class="line">  optimizer = optimizer <span class="keyword">if</span> optimizer <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> torch.optim.Adam(model.parameters(), lr=lr)</span><br><span class="line">  res = &#123;<span class="string">&#x27;train_loss&#x27;</span>: [], <span class="string">&#x27;train_acc&#x27;</span>: [], <span class="string">&#x27;val_loss&#x27;</span>: [], <span class="string">&#x27;val_acc&#x27;</span>: []&#125;</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, epoch + <span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;epoch: <span class="subst">&#123;i&#125;</span>\n---------------------------------&quot;</span>)</span><br><span class="line">    self.model.train()</span><br><span class="line">    total_loss, acc, count = <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(self.training_dataloader.dataset)</span><br><span class="line">    <span class="keyword">for</span> batch, (X, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.training_dataloader):</span><br><span class="line">      pred_y = self.model(X)</span><br><span class="line">      loss = self.loss_fn(pred_y, y)</span><br><span class="line">      optimizer.zero_grad()</span><br><span class="line">      loss.backward()</span><br><span class="line">      optimizer.step()</span><br><span class="line">      total_loss += loss.item()</span><br><span class="line">      acc += (pred_y.argmax(<span class="number">1</span>) == y).<span class="built_in">type</span>(torch.<span class="built_in">float</span>).<span class="built_in">sum</span>().item()</span><br><span class="line">      <span class="keyword">if</span> batch % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;loss: <span class="subst">&#123;loss:&gt;5f&#125;</span>    [<span class="subst">&#123;batch * self.batch_size&#125;</span>/<span class="subst">&#123;count&#125;</span>]&quot;</span>)</span><br><span class="line">        res[<span class="string">&#x27;train_loss&#x27;</span>].append(total_loss / count * self.batch_size)</span><br><span class="line">        res[<span class="string">&#x27;train_acc&#x27;</span>].append(acc / count)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;train_loss: <span class="subst">&#123;total_loss / count * self.batch_size :&gt;5f&#125;</span>   train_acc: <span class="subst">&#123;acc / count:&gt;5f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self.model.<span class="built_in">eval</span>()</span><br><span class="line">        total_loss, acc, count = <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(self.test_dataloader.dataset)</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">          <span class="keyword">for</span> X, y <span class="keyword">in</span> self.test_dataloader:</span><br><span class="line">            pred_y = self.model(X)</span><br><span class="line">            loss = self.loss_fn(pred_y, y)</span><br><span class="line">            total_loss += loss.item()</span><br><span class="line">            acc += (pred_y.argmax(<span class="number">1</span>) == y).<span class="built_in">type</span>(torch.<span class="built_in">float</span>).<span class="built_in">sum</span>().item()</span><br><span class="line">            res[<span class="string">&#x27;val_loss&#x27;</span>].append(total_loss / count * self.batch_size)</span><br><span class="line">            res[<span class="string">&#x27;val_acc&#x27;</span>].append(acc / count)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;val_loss: <span class="subst">&#123;total_loss / count * self.batch_size:&gt;5f&#125;</span>  val_acc: <span class="subst">&#123;acc / count:&gt;5f&#125;</span> \n &quot;</span>)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<ul>
<li>Switch the network to training mode (<code>net.train()</code>)</li>
<li>Go over all batches in the dataset, and for each batch do the following:
<ul>
<li>compute predictions made by the network on this batch (<code>out</code>)</li>
<li>compute <code>loss</code>, which is the discrepancy between predicted and expected values</li>
<li>try to minimize the loss by adjusting weights of the network (<code>optimizer.step()</code>)</li>
<li>compute the number of correctly predicted cases (<strong>accuracy</strong>)</li>
</ul></li>
</ul>
<h3 id="visualize-history-to-better-understand-our-model-training">visualize history to better understand our model training</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">13</span>,<span class="number">5</span>))</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.plot(hist[<span class="string">&#x27;train_acc&#x27;</span>], label=<span class="string">&#x27;Training acc&#x27;</span>)</span><br><span class="line">plt.plot(hist[<span class="string">&#x27;val_acc&#x27;</span>], label=<span class="string">&#x27;Validation acc&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.plot(hist[<span class="string">&#x27;train_loss&#x27;</span>], label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(hist[<span class="string">&#x27;val_loss&#x27;</span>], label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="4.png" alt="4" style="zoom:50%;" /></p>
<blockquote>
<p>The diagram on the left shows the <code>training accuracy</code> increasing (which corresponds to the network learning to classify our training data better and better), while <code>validation accuracy</code> starts to fall. The diagram on the right show the <code>training loss</code> and <code>validation loss</code>, you can see the <code>training loss</code> decreasing (meaning its performing better) and the <code>validation loss</code> increasing (meaning its performing worse). These graphs would indicate the model is <strong>overfitted</strong>.</p>
</blockquote>
<h3 id="visualizing-network-weights">Visualizing network weights</h3>
<p>multiplying the initial image by a weight matrix allowing us to visualize the network weights with a bit of added logic.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visualize_weights</span>(<span class="params">self</span>):</span></span><br><span class="line">    weight_tensor = <span class="built_in">next</span>(self.model.parameters())</span><br><span class="line">    fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">10</span>, figsize=(<span class="number">20</span>,<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(weight_tensor):</span><br><span class="line">        ax[i].imshow(x.view(<span class="number">28</span>, <span class="number">28</span>).detach())</span><br><span class="line">        plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="5.png" alt="5" style="zoom:50%;" /></p>
<h2 id="training-a-multi-layered-perceptron">Training a multi-Layered perceptron</h2>
<p>In a multi-layer network, we will add one or more <strong>hidden layers</strong>.</p>
<p><img src="dense-multilayer-network.png" alt="dense-multilayer-network" style="zoom:25%;" /></p>
<p>A number of parameters of a neural network should be chosen depending on the dataset size, to prevent <strong>overfitting</strong>.</p>
<p>there is the non-linear activation function layer, called <strong>ReLU</strong>. if a network consisted just of a series of linear layers, it would essentially be equivalent to one linear layer.</p>
<p><img src="6.png" alt="multilayer-network-layers" style="zoom:50%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">relu_fn = torch.relu</span><br><span class="line">sigmoid_fn = torch.sigmoid</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">4</span>))</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">&quot;ReLU&quot;</span>)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(-<span class="number">10</span>,<span class="number">10</span>), [relu_fn(torch.tensor(x, dtype=torch.<span class="built_in">float</span>)).item() <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">10</span>, <span class="number">10</span>)])</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Sigmoid&quot;</span>)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(-<span class="number">10</span>,<span class="number">10</span>), [sigmoid_fn(torch.tensor(x, dtype=torch.<span class="built_in">float</span>)).item() <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">10</span>, <span class="number">10</span>)])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h3 id="network-definition">Network Definition</h3>
<blockquote>
<p>network layer structure:</p>
</blockquote>
<p><img src="multilayer-network-layers.png" alt="multilayer-network-layers" style="zoom:25%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    nn.Linear(in_features=<span class="number">28</span> * <span class="number">28</span>, out_features=<span class="number">100</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Linear(in_features=<span class="number">100</span>, out_features=<span class="number">10</span>),</span><br><span class="line">    nn.LogSoftmax(dim=<span class="number">0</span>)</span><br><span class="line">)</span><br><span class="line">summary(net, input_size=(<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line"></span><br><span class="line">==========================================================================================</span><br><span class="line">Layer (<span class="built_in">type</span>:depth-idx)                   Output Shape              Param <span class="comment">#</span></span><br><span class="line">==========================================================================================</span><br><span class="line">Model                                    --                        --</span><br><span class="line">├─Sequential: <span class="number">1</span>-<span class="number">1</span>                        [<span class="number">1</span>, <span class="number">10</span>]                   --</span><br><span class="line">│    └─Flatten: <span class="number">2</span>-<span class="number">1</span>                      [<span class="number">1</span>, <span class="number">784</span>]                  --</span><br><span class="line">│    └─Linear: <span class="number">2</span>-<span class="number">2</span>                       [<span class="number">1</span>, <span class="number">100</span>]                  <span class="number">78</span>,<span class="number">500</span></span><br><span class="line">│    └─ReLU: <span class="number">2</span>-<span class="number">3</span>                         [<span class="number">1</span>, <span class="number">100</span>]                  --</span><br><span class="line">│    └─Linear: <span class="number">2</span>-<span class="number">4</span>                       [<span class="number">1</span>, <span class="number">10</span>]                   <span class="number">1</span>,010</span><br><span class="line">│    └─LogSoftmax: <span class="number">2</span>-<span class="number">5</span>                   [<span class="number">1</span>, <span class="number">10</span>]                   --</span><br><span class="line">==========================================================================================</span><br><span class="line">Total params: <span class="number">79</span>,<span class="number">510</span></span><br><span class="line">Trainable params: <span class="number">79</span>,<span class="number">510</span></span><br><span class="line">Non-trainable params: <span class="number">0</span></span><br><span class="line">Total mult-adds (M): <span class="number">0.08</span></span><br><span class="line">==========================================================================================</span><br><span class="line">Input size (MB): <span class="number">0.00</span></span><br><span class="line">Forward/backward <span class="keyword">pass</span> size (MB): <span class="number">0.00</span></span><br><span class="line">Params size (MB): <span class="number">0.32</span></span><br><span class="line">Estimated Total Size (MB): <span class="number">0.32</span></span><br><span class="line">==========================================================================================</span><br></pre></td></tr></table></figure>
<p><img src="7.png" alt="7" style="zoom:50%;" /></p>
<ul>
<li>This network is more expressive than the one layered perceptron we have trained in the previous unit. Thus it achieves a much higher training accuracy and given sufficiently large number of parameters - it can get to almost 100%</li>
<li>Once the validation accuracy stops increasing - it means that the model has reached it's ability to generalize, and further training will likely to result in overfitting.</li>
</ul>
<h3 id="class-based-network-definitions">Class-based network definitions</h3>
<p>Defining models using a <code>Sequential</code> style as a list of layers seems very convenient but it is somewhat limited. At some point you may need to define more complex networks, which contain shared weights, or some non-linear connections between layers.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassBasedNet</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(ClassBasedNet, self).__init__()</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">        self.hidden = nn.Linear(in_features=<span class="number">28</span> * <span class="number">28</span>, out_features=<span class="number">100</span>)</span><br><span class="line">        self.out = nn.Linear(in_features=<span class="number">100</span>, out_features=<span class="number">10</span>)</span><br><span class="line">        self.relu = nn.ReLU()</span><br><span class="line">        self.log_softmax = nn.LogSoftmax(dim=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        x = self.hidden(x)</span><br><span class="line">        x = self.relu(x)</span><br><span class="line">        x = self.out(x)</span><br><span class="line">        x = self.log_softmax(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">==========================================================================================</span><br><span class="line">Layer (<span class="built_in">type</span>:depth-idx)                   Output Shape              Param <span class="comment">#</span></span><br><span class="line">==========================================================================================</span><br><span class="line">ClassBasedNet                            --                        --</span><br><span class="line">├─Flatten: <span class="number">1</span>-<span class="number">1</span>                           [<span class="number">1</span>, <span class="number">784</span>]                  --</span><br><span class="line">├─Linear: <span class="number">1</span>-<span class="number">2</span>                            [<span class="number">1</span>, <span class="number">100</span>]                  <span class="number">78</span>,<span class="number">500</span></span><br><span class="line">├─ReLU: <span class="number">1</span>-<span class="number">3</span>                              [<span class="number">1</span>, <span class="number">100</span>]                  --</span><br><span class="line">├─Linear: <span class="number">1</span>-<span class="number">4</span>                            [<span class="number">1</span>, <span class="number">10</span>]                   <span class="number">1</span>,010</span><br><span class="line">├─LogSoftmax: <span class="number">1</span>-<span class="number">5</span>                        [<span class="number">1</span>, <span class="number">10</span>]                   --</span><br><span class="line">==========================================================================================</span><br><span class="line">Total params: <span class="number">79</span>,<span class="number">510</span></span><br><span class="line">Trainable params: <span class="number">79</span>,<span class="number">510</span></span><br><span class="line">Non-trainable params: <span class="number">0</span></span><br><span class="line">Total mult-adds (M): <span class="number">0.08</span></span><br><span class="line">==========================================================================================</span><br><span class="line">Input size (MB): <span class="number">0.00</span></span><br><span class="line">Forward/backward <span class="keyword">pass</span> size (MB): <span class="number">0.00</span></span><br><span class="line">Params size (MB): <span class="number">0.32</span></span><br><span class="line">Estimated Total Size (MB): <span class="number">0.32</span></span><br><span class="line">==========================================================================================</span><br></pre></td></tr></table></figure>
<blockquote>
<p>自定义神经网络由一个继承自 <code>torch.nn.Module</code> 类的类来表示。类的定义包括两部分：</p>
<ul>
<li>在构造函数（<strong>init</strong>）中，我们定义了我们的网络将拥有的所有层。这些层被存储为类的内部变量，PyTorch自动优化这些层的参数。在内部，PyTorch使用<code>parameters()</code>方法来寻找所有可训练的参数，nn.Module自动从所有子模块中收集所有可训练的参数。</li>
<li>定义了<code>forward method</code>，对神经网络进行正向传递计算。在案例中，我们从一个参数 <code>tensor x</code>开始，明确地通过所有的层和激活函数，从<code>flatten</code>开始，直到最后的线性层<code>out</code>。当我们通过写<code>out = net(x)</code>将我们的神经网络应用于一些输入数据<code>x</code>时，前向方法被调用。</li>
</ul>
</blockquote>
<h2 id="convolutional-neural-network">convolutional neural network</h2>
<p>we will learn about <strong>Convolutional Neural Networks (CNNs)</strong>, which are specifically designed for computer vision.计算机视觉不同于一般的分类，因为当我们试图在图片中找到某个物体时，我们是在扫描图片，寻找一些特定的模式和它们的组合。例如，在寻找一只猫时，我们首先可能会寻找水平线，这可以形成胡须，然后胡须的某些组合可以告诉我们，这实际上是一张猫的照片。某些图案的相对位置和存在是重要的，而不是它们在图像上的确切位置。</p>
<h3 id="convolutional-filters">Convolutional filters</h3>
<blockquote>
<p>Convolutional filters are small windows that run over each pixel of the image and compute weighted average of the neighboring pixels.They are defined by matrices of weight coefficients. Let's see the examples of applying two different convolutional filters over our MNIST handwritten digits:</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_convolution</span>(<span class="params">training_data, kernel, title=<span class="string">&quot;&quot;</span></span>):</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        c = nn.Conv2d(kernel_size=kernel.size(), out_channels=<span class="number">1</span>, in_channels=<span class="number">1</span>)</span><br><span class="line">        c.weight.copy_(kernel)</span><br><span class="line">        fig, ax = plt.subplots(<span class="number">2</span>, <span class="number">6</span>, figsize=(<span class="number">8</span>, <span class="number">3</span>))</span><br><span class="line">        fig.suptitle(title, fontsize=<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="comment"># [1,28,28]</span></span><br><span class="line">            img = training_data[i][<span class="number">0</span>]</span><br><span class="line">            ax[<span class="number">0</span>][i].imshow(img[<span class="number">0</span>])</span><br><span class="line">            ax[<span class="number">0</span>][i].axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">            <span class="comment"># [26, 26]</span></span><br><span class="line">            ax[<span class="number">1</span>][i].imshow(c(img.unsqueeze(<span class="number">0</span>))[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">            ax[<span class="number">1</span>][i].axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">        ax[<span class="number">0</span>, <span class="number">5</span>].imshow(kernel)</span><br><span class="line">        ax[<span class="number">0</span>, <span class="number">5</span>].axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">        ax[<span class="number">1</span>, <span class="number">5</span>].axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">        plt.show()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    load_mnist()</span><br><span class="line">    Vertical_edge_filter = torch.tensor([[-<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>], [-<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>], [-<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>]])</span><br><span class="line">    Horizontal_edge_filter = torch.tensor([[-<span class="number">1.</span>,-<span class="number">1.</span>,-<span class="number">1.</span>],[<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">0.</span>],[<span class="number">1.</span>,<span class="number">1.</span>,<span class="number">1.</span>]])</span><br><span class="line">    plot_convolution(training_data, Vertical_edge_filter, <span class="string">&quot;Vertical edge filter&quot;</span>)</span><br><span class="line">    plot_convolution(training_data, Horizontal_edge_filter, <span class="string">&quot;Horizontal edge filter&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="8.png" alt="8" style="zoom:50%;" /></p>
<p><img src="9.png" alt="9" style="zoom:50%;" /></p>
<p><strong>vertical edge filter</strong>: $$ (</p>
​
<span class="math display">\[\begin{matrix}

​     -1 &amp; 0 &amp; 1 \\

​     -1 &amp; 0 &amp; 1 \\

​     -1 &amp; 0 &amp; 1 

​    \end{matrix}\]</span>
<p>) $$</p>
<h3 id="covolutional-layers">Covolutional layers</h3>
<blockquote>
<p>Convolutional layers are defined using <code>nn.Conv2d</code> construction:</p>
<ul>
<li><code>in_channels</code> - number of input channels. In our case we are dealing with a grayscale image, thus number of input channels is 1.</li>
<li><code>out_channels</code> - number of filters to use. We will use 9 different filters, which will give the network plenty of opportunities to explore which filters work best for our scenario.</li>
<li><code>kernel_size</code> is the size of the sliding window. Usually 3x3 or 5x5 filters are used.</li>
</ul>
</blockquote>
<p>Simplest CNN contains one convolutional layer.</p>
<ul>
<li><p>Given the input size 28x28, applying nine 5x5 filters</p></li>
<li><p>end up with a tensor of 9x24x24 (there are only 24 positions where a sliding interval of length 5 can fit into 28 pixels).</p></li>
<li><p>flatten 9x24x24 tensor into one vector of size 5184, and then add linear layer, to produce 10 classes. (use <code>relu</code> activation function in between layers.)</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimplestConv</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(SimplestConv, self).__init__()</span><br><span class="line">        self.conv = nn.Conv2d(kernel_size=(<span class="number">5</span>,<span class="number">5</span>), in_channels=<span class="number">1</span>, out_channels=<span class="number">9</span>)</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">        self.linear = nn.Linear(in_features=<span class="number">9</span>*<span class="number">24</span>*<span class="number">24</span>, out_features=<span class="number">10</span>)</span><br><span class="line">        self.relu = nn.ReLU()</span><br><span class="line">        self.log_softmax = nn.LogSoftmax(dim=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.conv(x)</span><br><span class="line">        x = self.relu(x)</span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        x = self.log_softmax(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">      </span><br><span class="line">==========================================================================================</span><br><span class="line">Layer (<span class="built_in">type</span>:depth-idx)                   Output Shape              Param <span class="comment">#</span></span><br><span class="line">==========================================================================================</span><br><span class="line">SimplestConv                             --                        --</span><br><span class="line">├─Conv2d: <span class="number">1</span>-<span class="number">1</span>                            [<span class="number">1</span>, <span class="number">9</span>, <span class="number">24</span>, <span class="number">24</span>]            <span class="number">234</span></span><br><span class="line">├─ReLU: <span class="number">1</span>-<span class="number">2</span>                              [<span class="number">1</span>, <span class="number">9</span>, <span class="number">24</span>, <span class="number">24</span>]            --</span><br><span class="line">├─Flatten: <span class="number">1</span>-<span class="number">3</span>                           [<span class="number">1</span>, <span class="number">5184</span>]                 --</span><br><span class="line">├─Linear: <span class="number">1</span>-<span class="number">4</span>                            [<span class="number">1</span>, <span class="number">10</span>]                   <span class="number">51</span>,<span class="number">850</span></span><br><span class="line">├─LogSoftmax: <span class="number">1</span>-<span class="number">5</span>                        [<span class="number">1</span>, <span class="number">10</span>]                   --</span><br><span class="line">==========================================================================================</span><br><span class="line">Total params: <span class="number">52</span>,084</span><br><span class="line">Trainable params: <span class="number">52</span>,084</span><br><span class="line">Non-trainable params: <span class="number">0</span></span><br><span class="line">Total mult-adds (M): <span class="number">0.19</span></span><br><span class="line">==========================================================================================</span><br><span class="line">Input size (MB): <span class="number">0.00</span></span><br><span class="line">Forward/backward <span class="keyword">pass</span> size (MB): <span class="number">0.04</span></span><br><span class="line">Params size (MB): <span class="number">0.21</span></span><br><span class="line">Estimated Total Size (MB): <span class="number">0.25</span></span><br><span class="line">==========================================================================================</span><br><span class="line"></span><br><span class="line">epoch: <span class="number">1</span></span><br><span class="line">---------------------------------</span><br><span class="line">loss: <span class="number">4.846857</span>    [<span class="number">0</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">2.922879</span>    [<span class="number">12800</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">2.829096</span>    [<span class="number">25600</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">2.816400</span>    [<span class="number">38400</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">2.833445</span>    [<span class="number">51200</span>/<span class="number">60000</span>]</span><br><span class="line">train_loss: <span class="number">2.916213</span>   train_acc: <span class="number">0.952633</span></span><br><span class="line">val_loss: <span class="number">2.824616</span>  val_acc: <span class="number">0.972700</span> </span><br><span class="line"> </span><br><span class="line">epoch: <span class="number">2</span></span><br><span class="line">---------------------------------</span><br><span class="line">loss: <span class="number">2.841105</span>    [<span class="number">0</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">2.804442</span>    [<span class="number">12800</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">2.739106</span>    [<span class="number">25600</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">2.762817</span>    [<span class="number">38400</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">2.776352</span>    [<span class="number">51200</span>/<span class="number">60000</span>]</span><br><span class="line">train_loss: <span class="number">2.796383</span>   train_acc: <span class="number">0.976933</span></span><br><span class="line">val_loss: <span class="number">2.808884</span>  val_acc: <span class="number">0.975700</span> </span><br><span class="line"> </span><br><span class="line">epoch: <span class="number">3</span></span><br><span class="line">---------------------------------</span><br><span class="line">loss: <span class="number">2.801105</span>    [<span class="number">0</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">2.779864</span>    [<span class="number">12800</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">2.730634</span>    [<span class="number">25600</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">2.752127</span>    [<span class="number">38400</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">2.773396</span>    [<span class="number">51200</span>/<span class="number">60000</span>]</span><br><span class="line">train_loss: <span class="number">2.775327</span>   train_acc: <span class="number">0.979883</span></span><br><span class="line">val_loss: <span class="number">2.806651</span>  val_acc: <span class="number">0.974600</span> </span><br><span class="line"> </span><br><span class="line">epoch: <span class="number">4</span></span><br><span class="line">---------------------------------</span><br><span class="line">loss: <span class="number">2.797673</span>    [<span class="number">0</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">2.769010</span>    [<span class="number">12800</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">2.745473</span>    [<span class="number">25600</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">2.741996</span>    [<span class="number">38400</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">2.784167</span>    [<span class="number">51200</span>/<span class="number">60000</span>]</span><br><span class="line">train_loss: <span class="number">2.764126</span>   train_acc: <span class="number">0.981950</span></span><br><span class="line">val_loss: <span class="number">2.808089</span>  val_acc: <span class="number">0.973000</span> </span><br><span class="line"> </span><br><span class="line">epoch: <span class="number">5</span></span><br><span class="line">---------------------------------</span><br><span class="line">loss: <span class="number">2.784624</span>    [<span class="number">0</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">2.738271</span>    [<span class="number">12800</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">2.741519</span>    [<span class="number">25600</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">2.739913</span>    [<span class="number">38400</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">2.778515</span>    [<span class="number">51200</span>/<span class="number">60000</span>]</span><br><span class="line">train_loss: <span class="number">2.755174</span>   train_acc: <span class="number">0.982967</span></span><br><span class="line">val_loss: <span class="number">2.819919</span>  val_acc: <span class="number">0.971700</span> </span><br></pre></td></tr></table></figure>
<p><img src="10.png" alt="10" style="zoom:50%;" /></p>
<p>visualize the weights of our trained convolutional layers, to try and make some more sense of what is going on:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visualize_weights</span>(<span class="params">self</span>):</span></span><br><span class="line">  weight_tensor = <span class="built_in">next</span>(self.model.parameters())</span><br><span class="line">  fig, ax = plt.subplots(<span class="number">1</span>,<span class="number">9</span>, figsize=(<span class="number">10</span>,<span class="number">3</span>))</span><br><span class="line">  <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(weight_tensor):</span><br><span class="line">      ax[i].imshow(x.detach().cpu().squeeze(dim=<span class="number">0</span>))</span><br><span class="line">      ax[i].axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">      plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="11.png" alt="11" style="zoom:60%;" /></p>
<h2 id="multi-layered-cnns-and-pooling-layers">Multi-layered CNNs and pooling layers</h2>
<p>reducing the spatial size of the image："scale down" the size of the image, which is done using one of the <strong>pooling layers</strong>:</p>
<ul>
<li><strong>Average Pooling</strong> takes a sliding window (for example, 2x2 pixels) and computes an average of values within the window</li>
<li><strong>Max Pooling</strong> replaces the window with the maximum value. The idea behind max pooling is to detect a presence of a certain pattern within the sliding window.</li>
</ul>
<p>in a typical CNN there would be several convolutional layers, with pooling layers in between them to decrease dimensions of the image. We would also increase the number of filters, because as patterns become more advanced - there are more possible interesting combinations that we need to be looking for.</p>
<p><img src="cnn-pyramid.png" alt="cnn-pyramid" style="zoom:50%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiLayerCNN</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MultiLayerCNN, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(in_channels=<span class="number">1</span>, out_channels=<span class="number">10</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">        self.maxPool = nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(in_channels=<span class="number">10</span>, out_channels=<span class="number">20</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">        self.linear = nn.Linear(in_features=<span class="number">20</span>*<span class="number">4</span>*<span class="number">4</span>, out_features=<span class="number">10</span>)</span><br><span class="line">        self.logSoftmax = nn.LogSoftmax(dim=<span class="number">1</span>)</span><br><span class="line">        self.relu = nn.ReLU()</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.relu(x)</span><br><span class="line">        x = self.maxPool(x)</span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = self.relu(x)</span><br><span class="line">        x = self.maxPool(x)</span><br><span class="line"></span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> self.logSoftmax(x)</span><br><span class="line">      </span><br><span class="line">==========================================================================================</span><br><span class="line">Layer (<span class="built_in">type</span>:depth-idx)                   Output Shape              Param <span class="comment">#</span></span><br><span class="line">==========================================================================================</span><br><span class="line">MultiLayerCNN                            --                        --</span><br><span class="line">├─Conv2d: <span class="number">1</span>-<span class="number">1</span>                            [<span class="number">1</span>, <span class="number">10</span>, <span class="number">24</span>, <span class="number">24</span>]           <span class="number">260</span></span><br><span class="line">├─ReLU: <span class="number">1</span>-<span class="number">2</span>                              [<span class="number">1</span>, <span class="number">10</span>, <span class="number">24</span>, <span class="number">24</span>]           --</span><br><span class="line">├─MaxPool2d: <span class="number">1</span>-<span class="number">3</span>                         [<span class="number">1</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">12</span>]           --</span><br><span class="line">├─Conv2d: <span class="number">1</span>-<span class="number">4</span>                            [<span class="number">1</span>, <span class="number">20</span>, <span class="number">8</span>, <span class="number">8</span>]             <span class="number">5</span>,020</span><br><span class="line">├─ReLU: <span class="number">1</span>-<span class="number">5</span>                              [<span class="number">1</span>, <span class="number">20</span>, <span class="number">8</span>, <span class="number">8</span>]             --</span><br><span class="line">├─MaxPool2d: <span class="number">1</span>-<span class="number">6</span>                         [<span class="number">1</span>, <span class="number">20</span>, <span class="number">4</span>, <span class="number">4</span>]             --</span><br><span class="line">├─Flatten: <span class="number">1</span>-<span class="number">7</span>                           [<span class="number">1</span>, <span class="number">320</span>]                  --</span><br><span class="line">├─Linear: <span class="number">1</span>-<span class="number">8</span>                            [<span class="number">1</span>, <span class="number">10</span>]                   <span class="number">3</span>,<span class="number">210</span></span><br><span class="line">├─LogSoftmax: <span class="number">1</span>-<span class="number">9</span>                        [<span class="number">1</span>, <span class="number">10</span>]                   --</span><br><span class="line">==========================================================================================</span><br><span class="line">Total params: <span class="number">8</span>,<span class="number">490</span></span><br><span class="line">Trainable params: <span class="number">8</span>,<span class="number">490</span></span><br><span class="line">Non-trainable params: <span class="number">0</span></span><br><span class="line">Total mult-adds (M): <span class="number">0.47</span></span><br><span class="line">==========================================================================================</span><br></pre></td></tr></table></figure>
<p><img src="12.png" alt="12" style="zoom:50%;" /></p>
<h2 id="playing-with-real-images-from-the-cifar-10-dataset">Playing with real images from the CIFAR-10 dataset</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_dataset</span>(<span class="params">dataset</span>):</span></span><br><span class="line">    cols, rows = <span class="number">2</span>, <span class="number">8</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line">    n = <span class="built_in">len</span>(dataset.classes)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows * cols + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">id</span> = torch.randint(<span class="built_in">len</span>(dataset), size=(<span class="number">1</span>,)).item()</span><br><span class="line">        mn = <span class="built_in">min</span>([dataset[<span class="built_in">id</span>][<span class="number">0</span>].<span class="built_in">min</span>() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)])</span><br><span class="line">        mx = <span class="built_in">max</span>([dataset[<span class="built_in">id</span>][<span class="number">0</span>].<span class="built_in">max</span>() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)])</span><br><span class="line">        x, y = dataset[<span class="built_in">id</span>]</span><br><span class="line">        x = np.transpose((x-mn)/(mx-mn), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>))</span><br><span class="line">        plt.subplot(cols, rows, i)</span><br><span class="line">        plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">        plt.title(dataset.classes[y])</span><br><span class="line">        plt.imshow(x)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="13.png" alt="13" style="zoom:60%;" /></p>
<blockquote>
<p>A well-known architecture for CIFAR-10 is called <a href="https://en.wikipedia.org/wiki/LeNet">LeNet</a>, and has been proposed by <em>Yann LeCun</em>. It follows the same principles as we have outlined above, the main difference being 3 input color channels instead of 1.</p>
<p>We also do one more simplification to this model - we do not use <code>log_softmax</code> as output activation function, and just return the output of last fully-connected layer. In this case we can just use <code>CrossEntropyLoss</code> loss function to optimize the model.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeNet</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(LeNet, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">6</span>, kernel_size=(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">        self.conv2 = nn.Conv2d(in_channels=<span class="number">6</span>, out_channels=<span class="number">16</span>, kernel_size=(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">        self.conv3 = nn.Conv2d(in_channels=<span class="number">16</span>, out_channels=<span class="number">120</span>, kernel_size=(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">        self.maxPool = nn.MaxPool2d(kernel_size=<span class="number">2</span>)</span><br><span class="line">        self.linear1 = nn.Linear(in_features=<span class="number">120</span>, out_features=<span class="number">64</span>)</span><br><span class="line">        self.linear2 = nn.Linear(in_features=<span class="number">64</span>, out_features=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        self.relu = nn.ReLU()</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.maxPool(self.relu(self.conv1(x)))</span><br><span class="line">        x = self.maxPool(self.relu(self.conv2(x)))</span><br><span class="line">        x = self.relu(self.conv3(x))</span><br><span class="line"></span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        x = self.linear1(x)</span><br><span class="line">        x = self.relu(x)</span><br><span class="line">        <span class="keyword">return</span> self.linear2(x)</span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    DataSet.load_cifar_10()</span><br><span class="line">    model = LeNet()</span><br><span class="line">    summary(model, input_size=(<span class="number">1</span>,<span class="number">3</span>,<span class="number">32</span>,<span class="number">32</span>))</span><br><span class="line">    </span><br><span class="line">==========================================================================================</span><br><span class="line">Layer (<span class="built_in">type</span>:depth-idx)                   Output Shape              Param <span class="comment">#</span></span><br><span class="line">==========================================================================================</span><br><span class="line">LeNet                                    --                        --</span><br><span class="line">├─Conv2d: <span class="number">1</span>-<span class="number">1</span>                            [<span class="number">1</span>, <span class="number">6</span>, <span class="number">28</span>, <span class="number">28</span>]            <span class="number">456</span></span><br><span class="line">├─ReLU: <span class="number">1</span>-<span class="number">2</span>                              [<span class="number">1</span>, <span class="number">6</span>, <span class="number">28</span>, <span class="number">28</span>]            --</span><br><span class="line">├─MaxPool2d: <span class="number">1</span>-<span class="number">3</span>                         [<span class="number">1</span>, <span class="number">6</span>, <span class="number">14</span>, <span class="number">14</span>]            --</span><br><span class="line">├─Conv2d: <span class="number">1</span>-<span class="number">4</span>                            [<span class="number">1</span>, <span class="number">16</span>, <span class="number">10</span>, <span class="number">10</span>]           <span class="number">2</span>,<span class="number">416</span></span><br><span class="line">├─ReLU: <span class="number">1</span>-<span class="number">5</span>                              [<span class="number">1</span>, <span class="number">16</span>, <span class="number">10</span>, <span class="number">10</span>]           --</span><br><span class="line">├─MaxPool2d: <span class="number">1</span>-<span class="number">6</span>                         [<span class="number">1</span>, <span class="number">16</span>, <span class="number">5</span>, <span class="number">5</span>]             --</span><br><span class="line">├─Conv2d: <span class="number">1</span>-<span class="number">7</span>                            [<span class="number">1</span>, <span class="number">120</span>, <span class="number">1</span>, <span class="number">1</span>]            <span class="number">48</span>,<span class="number">120</span></span><br><span class="line">├─ReLU: <span class="number">1</span>-<span class="number">8</span>                              [<span class="number">1</span>, <span class="number">120</span>, <span class="number">1</span>, <span class="number">1</span>]            --</span><br><span class="line">├─Flatten: <span class="number">1</span>-<span class="number">9</span>                           [<span class="number">1</span>, <span class="number">120</span>]                  --</span><br><span class="line">├─Linear: <span class="number">1</span>-<span class="number">10</span>                           [<span class="number">1</span>, <span class="number">64</span>]                   <span class="number">7</span>,<span class="number">744</span></span><br><span class="line">├─ReLU: <span class="number">1</span>-<span class="number">11</span>                             [<span class="number">1</span>, <span class="number">64</span>]                   --</span><br><span class="line">├─Linear: <span class="number">1</span>-<span class="number">12</span>                           [<span class="number">1</span>, <span class="number">10</span>]                   <span class="number">650</span></span><br><span class="line">==========================================================================================</span><br></pre></td></tr></table></figure>
<p><img src="14.png" alt="13" style="zoom:60%;" /></p>
<h3 id="pre-trained-models-and-transfer-learning">Pre-trained models and transfer learning</h3>
<p>训练CNN可能需要很多时间，而且这项任务需要大量的数据。然而，大部分时间是用来学习网络用来从图像中提取模式的<code>best low-level filters</code>。</p>
<p><code>转移学习</code>，将一些知识从一个神经网络模型转移到另一个。在迁移学习中，我们通常从一个预先训练好的模型开始，这个模型已经在一些大型图像数据集上训练过了，比如ImageNet。这些模型已经可以很好地从通用图像中提取不同的特征，在很多情况下，只要在这些提取的特征之上建立一个分类器就可以产生一个好的结果。</p>
<h2 id="playing-with-cats-vs.-dogs-dataset">Playing with Cats vs. Dogs Dataset</h2>
<blockquote>
<p>solving a real-life problem of classifying images of cats and dogs. we will use <a href="https://www.kaggle.com/c/dogs-vs-cats">Kaggle Cats vs. Dogs Dataset</a>, which can also be downloaded <a href="https://www.microsoft.com/en-us/download/details.aspx?id=54765">from Microsoft</a>.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_url = <span class="string">&quot;https://download.microsoft.com/download/3/E/1/3E1C3F21-ECDB-4869-8368-6DEBA77B919F/kagglecatsanddogs_3367a.zip&quot;</span></span><br><span class="line">data_path = <span class="string">&#x27;data/kagglecatsanddogs_3367a.zip&#x27;</span></span><br><span class="line">data_dir = <span class="string">&#x27;data/PetImages&#x27;</span></span><br><span class="line">frame_name = <span class="string">&#x27;kagglecatsanddogs_3367a.zip&#x27;</span></span><br><span class="line">root = <span class="string">&#x27;data&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span>():</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(data_path):</span><br><span class="line">        wget.download(data_url, data_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(data_dir):</span><br><span class="line">        <span class="keyword">with</span> zipfile.ZipFile(data_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zip_ref:</span><br><span class="line">            zip_ref.extractall(root)</span><br><span class="line">    check_image_dir(data_dir + <span class="string">&#x27;/Cat/*.jpg&#x27;</span>)</span><br><span class="line">    check_image_dir(data_dir + <span class="string">&#x27;/Dog/*.jpg&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_image</span>(<span class="params">fn</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        im = Image.<span class="built_in">open</span>(fn)</span><br><span class="line">        im.verify()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_image_dir</span>(<span class="params">path</span>):</span></span><br><span class="line">    <span class="keyword">for</span> fn <span class="keyword">in</span> glob.glob(path):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> check_image(fn):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Corrupt image: <span class="subst">&#123;fn&#125;</span>&quot;</span>)</span><br><span class="line">            os.remove(fn)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>load the images into PyTorch dataset, converting them to tensors and doing some normalization. We will apply <code>std_normalize</code> transform to bring images to the range expected by pre-trained VGG network:</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">std_normalize = torchvision.transforms.Normalize(mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>],std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">transform = torchvision.transform.Compose(</span><br><span class="line">		[</span><br><span class="line">      	torchvision.transforms.Resize(<span class="number">256</span>),</span><br><span class="line">      	torchvision.transforms.CenterCrop(<span class="number">224</span>),</span><br><span class="line">      	torchvision.transforms.ToTensor(),</span><br><span class="line">      	std_normalize</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line">dataset = torchvision.datasets.ImageFolder(data_dir, transform=transform)</span><br><span class="line">training_data, test_data = torch.utils.data.random_split(dataset, [<span class="number">20000</span>, <span class="built_in">len</span>(dataset)-<span class="number">20000</span>])</span><br><span class="line">training_dataloader = torch.utils.data.DataLoader(training_data, bach_size)</span><br><span class="line">test_dataloader = torch.utils.data.DataLoader(test_data, bach_size)</span><br><span class="line"></span><br><span class="line">plot_dataset(dataset, dataset.classes)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_dataset</span>(<span class="params">dataset, classes</span>):</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line">    cols, rows = <span class="number">2</span>, <span class="number">8</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cols * rows + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">id</span> = torch.randint(<span class="built_in">len</span>(dataset), size=(<span class="number">1</span>,)).item()</span><br><span class="line">        x, y = dataset[<span class="built_in">id</span>]</span><br><span class="line">        mn = <span class="built_in">min</span>([dataset[<span class="built_in">id</span>][<span class="number">0</span>].<span class="built_in">min</span>() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(classes))])</span><br><span class="line">        mx = <span class="built_in">max</span>([dataset[<span class="built_in">id</span>][<span class="number">0</span>].<span class="built_in">max</span>() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(classes))])</span><br><span class="line">        x = transpose((x - mn) / (mx - mn), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">        plt.subplot(cols, rows, i)</span><br><span class="line">        plt.title(classes[y])</span><br><span class="line">        plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">        plt.imshow(x)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="15.png" alt="15" style="zoom:60%;" /></p>
<h3 id="pre-trained-models">pre-trained models</h3>
<p>There are many different pre-trained models available inside <code>torchvision</code> module, and even more models can be found on the Internet. Let's see how simplest VGG-16 model can be loaded and used:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vgg = torchvision.models.vgg16(pretrained=True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">==========================================================================================</span><br><span class="line">Layer (type:depth-idx)                   Output Shape              Param #</span><br><span class="line">==========================================================================================</span><br><span class="line">Vgg16                                    --                        --</span><br><span class="line">├─VGG: 1-1                               [1, 1000]                 --</span><br><span class="line">│    └─Sequential: 2-1                   [1, 512, 7, 7]            --</span><br><span class="line">│    │    └─Conv2d: 3-1                  [1, 64, 224, 224]         1,792</span><br><span class="line">│    │    └─ReLU: 3-2                    [1, 64, 224, 224]         --</span><br><span class="line">│    │    └─Conv2d: 3-3                  [1, 64, 224, 224]         36,928</span><br><span class="line">│    │    └─ReLU: 3-4                    [1, 64, 224, 224]         --</span><br><span class="line">│    │    └─MaxPool2d: 3-5               [1, 64, 112, 112]         --</span><br><span class="line">│    │    └─Conv2d: 3-6                  [1, 128, 112, 112]        73,856</span><br><span class="line">│    │    └─ReLU: 3-7                    [1, 128, 112, 112]        --</span><br><span class="line">│    │    └─Conv2d: 3-8                  [1, 128, 112, 112]        147,584</span><br><span class="line">│    │    └─ReLU: 3-9                    [1, 128, 112, 112]        --</span><br><span class="line">│    │    └─MaxPool2d: 3-10              [1, 128, 56, 56]          --</span><br><span class="line">│    │    └─Conv2d: 3-11                 [1, 256, 56, 56]          295,168</span><br><span class="line">│    │    └─ReLU: 3-12                   [1, 256, 56, 56]          --</span><br><span class="line">│    │    └─Conv2d: 3-13                 [1, 256, 56, 56]          590,080</span><br><span class="line">│    │    └─ReLU: 3-14                   [1, 256, 56, 56]          --</span><br><span class="line">│    │    └─Conv2d: 3-15                 [1, 256, 56, 56]          590,080</span><br><span class="line">│    │    └─ReLU: 3-16                   [1, 256, 56, 56]          --</span><br><span class="line">│    │    └─MaxPool2d: 3-17              [1, 256, 28, 28]          --</span><br><span class="line">│    │    └─Conv2d: 3-18                 [1, 512, 28, 28]          1,180,160</span><br><span class="line">│    │    └─ReLU: 3-19                   [1, 512, 28, 28]          --</span><br><span class="line">│    │    └─Conv2d: 3-20                 [1, 512, 28, 28]          2,359,808</span><br><span class="line">│    │    └─ReLU: 3-21                   [1, 512, 28, 28]          --</span><br><span class="line">│    │    └─Conv2d: 3-22                 [1, 512, 28, 28]          2,359,808</span><br><span class="line">│    │    └─ReLU: 3-23                   [1, 512, 28, 28]          --</span><br><span class="line">│    │    └─MaxPool2d: 3-24              [1, 512, 14, 14]          --</span><br><span class="line">│    │    └─Conv2d: 3-25                 [1, 512, 14, 14]          2,359,808</span><br><span class="line">│    │    └─ReLU: 3-26                   [1, 512, 14, 14]          --</span><br><span class="line">│    │    └─Conv2d: 3-27                 [1, 512, 14, 14]          2,359,808</span><br><span class="line">│    │    └─ReLU: 3-28                   [1, 512, 14, 14]          --</span><br><span class="line">│    │    └─Conv2d: 3-29                 [1, 512, 14, 14]          2,359,808</span><br><span class="line">│    │    └─ReLU: 3-30                   [1, 512, 14, 14]          --</span><br><span class="line">│    │    └─MaxPool2d: 3-31              [1, 512, 7, 7]            --</span><br><span class="line">│    └─AdaptiveAvgPool2d: 2-2            [1, 512, 7, 7]            --</span><br><span class="line">│    └─Sequential: 2-3                   [1, 1000]                 --</span><br><span class="line">│    │    └─Linear: 3-32                 [1, 4096]                 102,764,544</span><br><span class="line">│    │    └─ReLU: 3-33                   [1, 4096]                 --</span><br><span class="line">│    │    └─Dropout: 3-34                [1, 4096]                 --</span><br><span class="line">│    │    └─Linear: 3-35                 [1, 4096]                 16,781,312</span><br><span class="line">│    │    └─ReLU: 3-36                   [1, 4096]                 --</span><br><span class="line">│    │    └─Dropout: 3-37                [1, 4096]                 --</span><br><span class="line">│    │    └─Linear: 3-38                 [1, 1000]                 4,097,000</span><br><span class="line">==========================================================================================</span><br><span class="line">Total params: 138,357,544</span><br><span class="line">Trainable params: 138,357,544</span><br><span class="line">Non-trainable params: 0</span><br><span class="line">Total mult-adds (G): 15.48</span><br><span class="line">==========================================================================================</span><br><span class="line">Input size (MB): 0.60</span><br><span class="line">Forward/backward pass size (MB): 108.45</span><br><span class="line">Params size (MB): 553.43</span><br><span class="line">Estimated Total Size (MB): 662.49</span><br><span class="line">==========================================================================================</span><br></pre></td></tr></table></figure>
<blockquote>
<p>DropOut: 正则化对学习算法做了轻微的修改，因此模型的泛化效果更好。在训练过程中，剔除层丢弃了前一层的某些比例（大约30%）的神经元，在没有它们的情况下进行训练。这有助于使优化过程脱离局部最小值，并在不同的神经路径之间分配决定性的力量，从而提高网络的整体稳定性。</p>
</blockquote>
<h3 id="extracting-vgg-features">Extracting VGG features</h3>
<p>If we want to use VGG-16 to extract features from our images, we need the model without final classification layers. In fact, this "feature extractor" can be obtained using <code>vgg.features</code> method:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = vgg.features(sample_image).cpu()</span><br><span class="line">plt.figure(figsize=(<span class="number">15</span>,<span class="number">3</span>))</span><br><span class="line">plt.imshow(res.detach().view(-<span class="number">1</span>,<span class="number">512</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="16.png" alt="16" style="zoom:60%;" /></p>
<p>those features can be used to classify images. Let's manually take some portion of images (800 in our case), and pre-compute their feature vectors. store the result in one big tensor called <code>feature_tensor</code>, and also labels into <code>label_tensor</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">manual_feature_extraction</span>(<span class="params">training_dataloader</span>):</span></span><br><span class="line">    <span class="comment"># The dimension of feature tensor is 512x7x7,</span></span><br><span class="line">    num = batch_size * <span class="number">100</span></span><br><span class="line">    vgg = vgg16(pretrained=<span class="literal">True</span>).to(device)</span><br><span class="line">    feature_tensor = torch.zeros(num, <span class="number">512</span> * <span class="number">7</span> * <span class="number">7</span>).to(device)</span><br><span class="line">    label_tensor = torch.zeros(num).to(device)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> batch, (x, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(training_dataloader):</span><br><span class="line">            f = vgg.features(x.to(device))</span><br><span class="line">            feature_tensor[batch:batch + batch_size] = f.view(batch_size, -<span class="number">1</span>)</span><br><span class="line">            label_tensor[batch:batch + batch_size] = y</span><br><span class="line">            <span class="keyword">if</span> batch * batch_size &gt; num:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    vgg_dataset = TensorDataset(feature_tensor, label_tensor.to(torch.long))</span><br><span class="line">    size, train_size = <span class="built_in">len</span>(vgg_dataset), <span class="built_in">int</span>(<span class="built_in">len</span>(vgg_dataset) / <span class="number">7</span> * <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    training_data, test_data = random_split(vgg_dataset, [train_size, size - train_size])</span><br><span class="line">    training_dataloader = DataLoader(training_data, batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">    test_dataloader = DataLoader(test_data, batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> training_dataloader, test_dataloader</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    load_data()</span><br><span class="line">    net = nn.Sequential(nn.Linear(<span class="number">512</span>*<span class="number">7</span>*<span class="number">7</span>, <span class="number">2</span>), nn.Softmax()).to(device)</span><br><span class="line">    train_feature_loader, test_feature_loader = manual_feature_extraction(training_dataloader)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;features extraction done&quot;</span>)</span><br><span class="line">    hist = train(net, train_feature_loader, test_feature_loader)</span><br><span class="line">    displayutils.plot_acc_loss(hist)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">features extraction done</span><br><span class="line">epoch: <span class="number">1</span></span><br><span class="line">------------------------------------------</span><br><span class="line">train loss: <span class="number">0.6915339231491089</span>  [<span class="number">0</span>/<span class="number">2742</span>]</span><br><span class="line">train_loss: <span class="number">0.692696</span>     train_acc: <span class="number">0.920496</span>     <span class="number">2742</span></span><br><span class="line">val_loss: <span class="number">0.675718</span>     val_acc: <span class="number">0.989083</span>     <span class="number">458</span></span><br><span class="line">    </span><br><span class="line">epoch: <span class="number">2</span></span><br><span class="line">------------------------------------------</span><br><span class="line">train loss: <span class="number">0.6835835576057434</span>  [<span class="number">0</span>/<span class="number">2742</span>]</span><br><span class="line">train_loss: <span class="number">0.676036</span>     train_acc: <span class="number">0.998906</span>     <span class="number">2742</span></span><br><span class="line">val_loss: <span class="number">0.664526</span>     val_acc: <span class="number">0.993450</span>     <span class="number">458</span></span><br><span class="line">    </span><br><span class="line">epoch: <span class="number">3</span></span><br><span class="line">------------------------------------------</span><br><span class="line">train loss: <span class="number">0.6631014347076416</span>  [<span class="number">0</span>/<span class="number">2742</span>]</span><br><span class="line">train_loss: <span class="number">0.664522</span>     train_acc: <span class="number">0.999635</span>     <span class="number">2742</span></span><br><span class="line">val_loss: <span class="number">0.652398</span>     val_acc: <span class="number">0.993450</span>     <span class="number">458</span></span><br><span class="line">    </span><br><span class="line">epoch: <span class="number">4</span></span><br><span class="line">------------------------------------------</span><br><span class="line">train loss: <span class="number">0.6546106338500977</span>  [<span class="number">0</span>/<span class="number">2742</span>]</span><br><span class="line">train_loss: <span class="number">0.654346</span>     train_acc: <span class="number">1.000000</span>     <span class="number">2742</span></span><br><span class="line">val_loss: <span class="number">0.643583</span>     val_acc: <span class="number">0.993450</span>     <span class="number">458</span></span><br></pre></td></tr></table></figure>
<p><img src="17.png" alt="17" style="zoom:60%;" /></p>
<h3 id="transfer-learning-using-one-vgg-network">Transfer learning using one VGG network</h3>
<p>the VGG contains:</p>
<ul>
<li>feature extractor (<code>features</code>), comprised of a number of convolutional and pooling layers</li>
<li>average pooling layer (<code>avgpool</code>)</li>
<li>final <code>classifier</code>, consisting of several dense layers, which turns 25088 input features into 1000 classes (which is the number of classes in ImageNet)</li>
</ul>
<p>To train the end-to-end model that will classify our dataset, we need to:</p>
<ul>
<li><strong>replace the final classifier</strong> with the one that will produce required number of classes. In our case, we can use one <code>Linear</code> layer with 25088 inputs and 2 output neurons.</li>
<li><strong>freeze weights of convolutional feature extractor</strong>, so that they are not trained. It is recommended to initially do this freezing, because otherwise untrained classifier layer can destroy the original pre-trained weights of convolutional extractor. Freezing weights can be accomplished by setting <code>requires_grad</code> property of all parameters to <code>False</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransferVgg16</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(TransferVgg16, self).__init__()</span><br><span class="line">        self.vgg16 = vgg16(pretrained=<span class="literal">True</span>).to(device)</span><br><span class="line">        self.vgg16.classifier = nn.Sequential(</span><br><span class="line">            nn.Linear(in_features=<span class="number">512</span> * <span class="number">7</span> * <span class="number">7</span>, out_features=<span class="number">2</span>),</span><br><span class="line">            nn.Softmax()</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.vgg16.features.parameters():</span><br><span class="line">            x.requires_grad = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.vgg16(x)</span><br><span class="line">      </span><br><span class="line">==========================================================================================</span><br><span class="line">Layer (<span class="built_in">type</span>:depth-idx)                   Output Shape              Param <span class="comment">#</span></span><br><span class="line">==========================================================================================</span><br><span class="line">TransferVgg16                            --                        --</span><br><span class="line">├─VGG: <span class="number">1</span>-<span class="number">1</span>                               [<span class="number">1</span>, <span class="number">2</span>]                    --</span><br><span class="line">│    └─Sequential: <span class="number">2</span>-<span class="number">1</span>                   [<span class="number">1</span>, <span class="number">512</span>, <span class="number">7</span>, <span class="number">7</span>]            --</span><br><span class="line">│    │    └─Conv2d: <span class="number">3</span>-<span class="number">1</span>                  [<span class="number">1</span>, <span class="number">64</span>, <span class="number">244</span>, <span class="number">244</span>]         (<span class="number">1</span>,<span class="number">792</span>)</span><br><span class="line">│    │    └─ReLU: <span class="number">3</span>-<span class="number">2</span>                    [<span class="number">1</span>, <span class="number">64</span>, <span class="number">244</span>, <span class="number">244</span>]         --</span><br><span class="line">│    │    └─Conv2d: <span class="number">3</span>-<span class="number">3</span>                  [<span class="number">1</span>, <span class="number">64</span>, <span class="number">244</span>, <span class="number">244</span>]         (<span class="number">36</span>,<span class="number">928</span>)</span><br><span class="line">│    │    └─ReLU: <span class="number">3</span>-<span class="number">4</span>                    [<span class="number">1</span>, <span class="number">64</span>, <span class="number">244</span>, <span class="number">244</span>]         --</span><br><span class="line">│    │    └─MaxPool2d: <span class="number">3</span>-<span class="number">5</span>               [<span class="number">1</span>, <span class="number">64</span>, <span class="number">122</span>, <span class="number">122</span>]         --</span><br><span class="line">│    │    └─Conv2d: <span class="number">3</span>-<span class="number">6</span>                  [<span class="number">1</span>, <span class="number">128</span>, <span class="number">122</span>, <span class="number">122</span>]        (<span class="number">73</span>,<span class="number">856</span>)</span><br><span class="line">│    │    └─ReLU: <span class="number">3</span>-<span class="number">7</span>                    [<span class="number">1</span>, <span class="number">128</span>, <span class="number">122</span>, <span class="number">122</span>]        --</span><br><span class="line">│    │    └─Conv2d: <span class="number">3</span>-<span class="number">8</span>                  [<span class="number">1</span>, <span class="number">128</span>, <span class="number">122</span>, <span class="number">122</span>]        (<span class="number">147</span>,<span class="number">584</span>)</span><br><span class="line">│    │    └─ReLU: <span class="number">3</span>-<span class="number">9</span>                    [<span class="number">1</span>, <span class="number">128</span>, <span class="number">122</span>, <span class="number">122</span>]        --</span><br><span class="line">│    │    └─MaxPool2d: <span class="number">3</span>-<span class="number">10</span>              [<span class="number">1</span>, <span class="number">128</span>, <span class="number">61</span>, <span class="number">61</span>]          --</span><br><span class="line">│    │    └─Conv2d: <span class="number">3</span>-<span class="number">11</span>                 [<span class="number">1</span>, <span class="number">256</span>, <span class="number">61</span>, <span class="number">61</span>]          (<span class="number">295</span>,<span class="number">168</span>)</span><br><span class="line">│    │    └─ReLU: <span class="number">3</span>-<span class="number">12</span>                   [<span class="number">1</span>, <span class="number">256</span>, <span class="number">61</span>, <span class="number">61</span>]          --</span><br><span class="line">│    │    └─Conv2d: <span class="number">3</span>-<span class="number">13</span>                 [<span class="number">1</span>, <span class="number">256</span>, <span class="number">61</span>, <span class="number">61</span>]          (<span class="number">590</span>,080)</span><br><span class="line">│    │    └─ReLU: <span class="number">3</span>-<span class="number">14</span>                   [<span class="number">1</span>, <span class="number">256</span>, <span class="number">61</span>, <span class="number">61</span>]          --</span><br><span class="line">│    │    └─Conv2d: <span class="number">3</span>-<span class="number">15</span>                 [<span class="number">1</span>, <span class="number">256</span>, <span class="number">61</span>, <span class="number">61</span>]          (<span class="number">590</span>,080)</span><br><span class="line">│    │    └─ReLU: <span class="number">3</span>-<span class="number">16</span>                   [<span class="number">1</span>, <span class="number">256</span>, <span class="number">61</span>, <span class="number">61</span>]          --</span><br><span class="line">│    │    └─MaxPool2d: <span class="number">3</span>-<span class="number">17</span>              [<span class="number">1</span>, <span class="number">256</span>, <span class="number">30</span>, <span class="number">30</span>]          --</span><br><span class="line">│    │    └─Conv2d: <span class="number">3</span>-<span class="number">18</span>                 [<span class="number">1</span>, <span class="number">512</span>, <span class="number">30</span>, <span class="number">30</span>]          (<span class="number">1</span>,<span class="number">180</span>,<span class="number">160</span>)</span><br><span class="line">│    │    └─ReLU: <span class="number">3</span>-<span class="number">19</span>                   [<span class="number">1</span>, <span class="number">512</span>, <span class="number">30</span>, <span class="number">30</span>]          --</span><br><span class="line">│    │    └─Conv2d: <span class="number">3</span>-<span class="number">20</span>                 [<span class="number">1</span>, <span class="number">512</span>, <span class="number">30</span>, <span class="number">30</span>]          (<span class="number">2</span>,<span class="number">359</span>,<span class="number">808</span>)</span><br><span class="line">│    │    └─ReLU: <span class="number">3</span>-<span class="number">21</span>                   [<span class="number">1</span>, <span class="number">512</span>, <span class="number">30</span>, <span class="number">30</span>]          --</span><br><span class="line">│    │    └─Conv2d: <span class="number">3</span>-<span class="number">22</span>                 [<span class="number">1</span>, <span class="number">512</span>, <span class="number">30</span>, <span class="number">30</span>]          (<span class="number">2</span>,<span class="number">359</span>,<span class="number">808</span>)</span><br><span class="line">│    │    └─ReLU: <span class="number">3</span>-<span class="number">23</span>                   [<span class="number">1</span>, <span class="number">512</span>, <span class="number">30</span>, <span class="number">30</span>]          --</span><br><span class="line">│    │    └─MaxPool2d: <span class="number">3</span>-<span class="number">24</span>              [<span class="number">1</span>, <span class="number">512</span>, <span class="number">15</span>, <span class="number">15</span>]          --</span><br><span class="line">│    │    └─Conv2d: <span class="number">3</span>-<span class="number">25</span>                 [<span class="number">1</span>, <span class="number">512</span>, <span class="number">15</span>, <span class="number">15</span>]          (<span class="number">2</span>,<span class="number">359</span>,<span class="number">808</span>)</span><br><span class="line">│    │    └─ReLU: <span class="number">3</span>-<span class="number">26</span>                   [<span class="number">1</span>, <span class="number">512</span>, <span class="number">15</span>, <span class="number">15</span>]          --</span><br><span class="line">│    │    └─Conv2d: <span class="number">3</span>-<span class="number">27</span>                 [<span class="number">1</span>, <span class="number">512</span>, <span class="number">15</span>, <span class="number">15</span>]          (<span class="number">2</span>,<span class="number">359</span>,<span class="number">808</span>)</span><br><span class="line">│    │    └─ReLU: <span class="number">3</span>-<span class="number">28</span>                   [<span class="number">1</span>, <span class="number">512</span>, <span class="number">15</span>, <span class="number">15</span>]          --</span><br><span class="line">│    │    └─Conv2d: <span class="number">3</span>-<span class="number">29</span>                 [<span class="number">1</span>, <span class="number">512</span>, <span class="number">15</span>, <span class="number">15</span>]          (<span class="number">2</span>,<span class="number">359</span>,<span class="number">808</span>)</span><br><span class="line">│    │    └─ReLU: <span class="number">3</span>-<span class="number">30</span>                   [<span class="number">1</span>, <span class="number">512</span>, <span class="number">15</span>, <span class="number">15</span>]          --</span><br><span class="line">│    │    └─MaxPool2d: <span class="number">3</span>-<span class="number">31</span>              [<span class="number">1</span>, <span class="number">512</span>, <span class="number">7</span>, <span class="number">7</span>]            --</span><br><span class="line">│    └─AdaptiveAvgPool2d: <span class="number">2</span>-<span class="number">2</span>            [<span class="number">1</span>, <span class="number">512</span>, <span class="number">7</span>, <span class="number">7</span>]            --</span><br><span class="line">│    └─Sequential: <span class="number">2</span>-<span class="number">3</span>                   [<span class="number">1</span>, <span class="number">2</span>]                    --</span><br><span class="line">│    │    └─Linear: <span class="number">3</span>-<span class="number">32</span>                 [<span class="number">1</span>, <span class="number">2</span>]                    <span class="number">50</span>,<span class="number">178</span></span><br><span class="line">│    │    └─Softmax: <span class="number">3</span>-<span class="number">33</span>                [<span class="number">1</span>, <span class="number">2</span>]                    --     --</span><br><span class="line">==========================================================================================</span><br><span class="line">Total params: <span class="number">14</span>,<span class="number">764</span>,<span class="number">866</span></span><br><span class="line">Trainable params: <span class="number">50</span>,<span class="number">178</span></span><br><span class="line">Non-trainable params: <span class="number">14</span>,<span class="number">714</span>,<span class="number">688</span></span><br><span class="line">Total mult-adds (G): <span class="number">17.99</span></span><br><span class="line">==========================================================================================</span><br></pre></td></tr></table></figure>
<blockquote>
<p>this model contain around 15 million total parameters, but only 50k of them are trainable - those are the weights of classification layer.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = <span class="string">&#x27;data/cats_dogs.pth&#x27;</span></span><br><span class="line">net = TransferVgg16()</span><br><span class="line">summary(net, input_size=(<span class="number">1</span>, <span class="number">3</span>, <span class="number">244</span>, <span class="number">244</span>))</span><br><span class="line">sub_dataset(<span class="number">2000</span>)</span><br><span class="line">hist = train(net, training_dataloader, test_dataloader)</span><br><span class="line">plot_acc_loss(hist)</span><br><span class="line">torch.save(net, path)</span><br><span class="line"></span><br><span class="line">epoch: <span class="number">10</span></span><br><span class="line">------------------------------------------</span><br><span class="line">train loss: <span class="number">0.315983</span>   [<span class="number">0</span>/<span class="number">1500</span>]</span><br><span class="line">train loss: <span class="number">0.319530</span>   [<span class="number">320</span>/<span class="number">1500</span>]</span><br><span class="line">train loss: <span class="number">0.315883</span>   [<span class="number">640</span>/<span class="number">1500</span>]</span><br><span class="line">train loss: <span class="number">0.315727</span>   [<span class="number">960</span>/<span class="number">1500</span>]</span><br><span class="line">train loss: <span class="number">0.315908</span>   [<span class="number">1280</span>/<span class="number">1500</span>]</span><br><span class="line">train_loss: <span class="number">0.323956</span>     train_acc: <span class="number">0.999333</span>     <span class="number">1500</span></span><br><span class="line">val_loss: <span class="number">0.322157</span>     val_acc: <span class="number">0.994000</span>     <span class="number">500</span></span><br></pre></td></tr></table></figure>
<p><img src="18.png" alt="18" style="zoom:60%;" /></p>
<h3 id="fine-tuning-transfer-learning">Fine-tuning transfer learning</h3>
<blockquote>
<p>In the previous section, we have trained the final classifier layer to classify images in our own dataset. However, we did not re-train the feature extractor, and our model relied on the features that the model has learned on ImageNet data. If your objects visually differ from ordinary ImageNet images, this combination of features might not work best. Thus it makes sense to start training convolutional layers as well.</p>
<p>we can unfreeze the convolutional filter parameters that we have previously frozen.</p>
</blockquote>
<h2 id="other-computer-vision-models">Other computer vision models</h2>
<p>VGG-16 is one of the simplest computer vision architectures. <code>torchvision</code> package provides many more pre-trained networks. The most frequently used ones among those are <strong>ResNet</strong> architectures, developed by Microsoft, and <strong>Inception</strong> by Google.</p>
]]></content>
      <categories>
        <category>PyTorch</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>LDA线性判别分析基本原理及Python实现</title>
    <url>/2019/05/26/LDA%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8APython%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="the-basic-principle-and-implementation-of-lda">The basic principle and implementation of LDA</h1>
<blockquote>
<p>LDA（Linear Discriminant Analysis）线性判别分析，是一种典型的有监督学习分类技术。最常用作模式分类和机器学习应用的预处理步骤中的降维技术。目标是将数据集从高维空间投影到具有良好类别可分性的低维空间，以避免过度拟合（“维数灾难”），在降低计算成本同时，又最大的保持了高维数据的特性。</p>
</blockquote>
<span id="more"></span>
<h1 id="introduction">Introduction</h1>
<blockquote>
<p>LDA由费舍尔（Ronald A. Fisher）于1936年提出，因此LDA又被称为 Fisher’s Linear Discriminant，最初的LDA算法仅仅是适用于二分类问题，于1948年被 C. R. Rao 泛化为多类别线性判别分析。一般的LDA算法与PCA降维算法不论是算法过程还是最终目的都有着极大的相似性，LDA是在降维后保留最大数据方差的同时，也使得对多个数据类别仍然尽可能可分。</p>
</blockquote>
<p><img src="2.png" alt="" style="zoom:50%;" /></p>
<h1 id="the-difference-between-pca-and-lda">The difference between PCA and LDA</h1>
<blockquote>
<p>PCA与LDA都是常用的降维线性变换技术。PCA由于不需要数据标签，属于unsupervised learning，其目标是找到最大化数据集方差的方向，即主成分。LDA则是supervised learning，适用于已知类标签的数据集，其目的是最大化各类数据之间协方差。对于已知标签的多类分类任务，LDA似乎优于PCA。但实际情况中，对于各类样本较少的数据集，PCA降维后的数据分类准确性往往优优LDA。故先对数据进行PCA降维到合适维度，再使用LDA进行二次降维是常用的方法。</p>
</blockquote>
<h1 id="mathematical-principles">Mathematical principles</h1>
<blockquote>
<p>LDA的目的是将高维特征投影到一个低维子空间中同时保持类间的良好可分性和类内的最大化方差。如周志华老师书中图所示</p>
</blockquote>
<p><img src="1.png" alt="" style="zoom:90%;" /></p>
<ol type="1">
<li><p><strong>前提条件</strong></p>
<p>假设数据集有N类，第i类数据有<span class="math inline">\(x_{i}\)</span>个</p></li>
<li><p><strong>全局散度矩阵</strong></p>
<p>其中$$是所有示例的均值向量</p></li>
</ol>
<p>​ <span class="math inline">\(S_{t} = S_{b} + S_{w}\)</span></p>
<p>​ <span class="math inline">\(= \sum_{i=1}^{m}(x-\mu _{i})(x-\mu _{i})^{T}\)</span></p>
<ol start="3" type="1">
<li><p><strong>类内散度矩阵</strong></p>
<p>$_{i} $为第i个类的均值向量</p>
<p>​ <span class="math inline">\(S_{w} = \sum_{i=1}^{N} \sum_{x\epsilon x_{i}}(x-\mu_{i})(x-\mu_{i})^{T}\)</span></p></li>
<li><p><strong>类间散度矩阵</strong></p>
<p>计算不同类之间的方差</p>
<p>​ <span class="math inline">\(S_{b}=S_{t}-S_{w}\)</span></p>
<p>​ <span class="math inline">\(S_{b} = \sum_{i=1}^{N}m_{i}(\mu_{i}-\mu)(\mu_{i}-\mu)^{T}\)</span></p>
<p>数学推导：</p>
<p><img src="3.png" alt="" style="zoom:70%;" /></p></li>
<li><p><strong>优化目标</strong></p>
<p>tr{·}表示矩阵的迹</p>
<p>​ $_{w} =  $</p>
<p><img src="4.png" alt="" style="zoom:70%;" /></p>
<p><img src="5.png" alt="" style="zoom:70%;" /></p>
<p>求解得表达式：</p>
<p>​ <span class="math inline">\(S_{b}W = \lambda S_{w} W\)</span></p>
<p>W 即为<span class="math inline">\(S_{w}^{-1}S_{b}\)</span> 的N-1个最大广义特征值所对应的特征向量组成的矩阵</p>
<p><strong>NOTE</strong>：</p>
<p><strong>在LDA中，线性判别器的数量最多为C-1个，C是数据的类标签数量。因为对于类间散度矩阵Sb的秩最多为C（Sb是由C个矩阵相加得来，具体可以看公式）。又因为前C-1个<span class="math inline">\(\mu\)</span>可以线性表示第C个$ $，故Sb的秩最多为C-1，即特征向量最多有C-1个。</strong></p>
<p><strong>对于 Iris数据集，C=3，即LDA降维最多只能降维到2维</strong></p></li>
</ol>
<h1 id="iris-data-analysis">IRIS Data Analysis</h1>
<blockquote>
<p>实验数据iris数据集，数据集共3类，维度4维，实验前对数据分布进行粗略了解统计同特征不同类的分布，如图所示：</p>
</blockquote>
<p>​ <img src="6.png" alt="" style="zoom:90%;" /></p>
<blockquote>
<p>通过观察这些特征的简单图形表示，我们已经可以看出花瓣长度和宽度可能更适合作为三个花类之间的两个独立的潜在特征。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">data = load_iris()[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">label = load_iris()[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line">feature_names = load_iris()[<span class="string">&#x27;feature_names&#x27;</span>]</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line">df[<span class="string">&#x27;label&#x27;</span>] = label</span><br><span class="line">X = df[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]].values</span><br><span class="line">y = df[<span class="string">&#x27;label&#x27;</span>].values+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">feature_dict = &#123;i: label <span class="keyword">for</span> i, label <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">4</span>),feature_names)&#125;</span><br><span class="line">label_dict = &#123;<span class="number">1</span>: <span class="string">&#x27;Setosa&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Versicolor&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;Virginica&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">2</span>, figsize=(<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, cnt <span class="keyword">in</span> <span class="built_in">zip</span>(axes.ravel(), <span class="built_in">range</span>(<span class="number">4</span>)):</span><br><span class="line"></span><br><span class="line">    min_b = math.floor(np.<span class="built_in">min</span>(X[:, cnt]))</span><br><span class="line">    max_b = math.ceil(np.<span class="built_in">max</span>(X[:, cnt]))</span><br><span class="line">    bins = np.linspace(min_b, max_b, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> lab, col <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)):</span><br><span class="line">        ax.hist(X[y == lab, cnt],</span><br><span class="line">                color=col,</span><br><span class="line">                label=<span class="string">&#x27;class %s&#x27;</span> % label_dict[lab],</span><br><span class="line">                bins=bins,</span><br><span class="line">                alpha=<span class="number">0.5</span>, )</span><br><span class="line">    ylims = ax.get_ylim()</span><br><span class="line"></span><br><span class="line">    leg = ax.legend(loc=<span class="string">&#x27;upper right&#x27;</span>, fancybox=<span class="literal">True</span>, fontsize=<span class="number">8</span>)</span><br><span class="line">    leg.get_frame().set_alpha(<span class="number">0.5</span>)</span><br><span class="line">    ax.set_ylim([<span class="number">0</span>, <span class="built_in">max</span>(ylims) + <span class="number">2</span>])</span><br><span class="line">    ax.set_xlabel(feature_dict[cnt])</span><br><span class="line">    ax.set_title(<span class="string">&#x27;Iris: %s&#x27;</span> % <span class="built_in">str</span>(cnt + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    ax.tick_params(axis=<span class="string">&quot;both&quot;</span>, which=<span class="string">&quot;both&quot;</span>, bottom=<span class="string">&quot;off&quot;</span>, top=<span class="string">&quot;off&quot;</span>,</span><br><span class="line">                   labelbottom=<span class="string">&quot;on&quot;</span>, left=<span class="string">&quot;off&quot;</span>, right=<span class="string">&quot;off&quot;</span>, labelleft=<span class="string">&quot;on&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 去除边框</span></span><br><span class="line">    ax.spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;bottom&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">axes[<span class="number">0</span>][<span class="number">0</span>].set_ylabel(<span class="string">&#x27;count&#x27;</span>)</span><br><span class="line">axes[<span class="number">1</span>][<span class="number">0</span>].set_ylabel(<span class="string">&#x27;count&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h1 id="lda-python-implementation">LDA Python Implementation</h1>
<h2 id="读取-iris-数据组合数据为dataframe格式">读取 Iris 数据，组合数据为DataFrame格式</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LDA</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data, label</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.X = pd.DataFrame(data)</span><br><span class="line">        self.label = label</span><br><span class="line">        self.class_count = <span class="built_in">len</span>(<span class="built_in">set</span>(label))		<span class="comment"># 数据类别计数</span></span><br><span class="line">        self.X_lda = <span class="literal">None</span>			<span class="comment"># lda 降维数据</span></span><br></pre></td></tr></table></figure>
<h2 id="计算每一类的平均向量mi将mi组合为向量矩阵m">计算每一类的平均向量Mi，将Mi组合为向量矩阵M</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = self.X</span><br><span class="line">X[<span class="string">&quot;label&quot;</span>] = self.label</span><br><span class="line">label = self.label</span><br><span class="line">N = np.array([<span class="built_in">len</span>(X[label == <span class="number">0</span>]), <span class="built_in">len</span>(X[label == <span class="number">1</span>]), <span class="built_in">len</span>(X[label == <span class="number">2</span>])])</span><br><span class="line">Mi = pd.DataFrame([np.mean(X[label == <span class="number">0</span>]), np.mean(X[label == <span class="number">1</span>]),</span><br><span class="line">                   np.mean(X[label == <span class="number">2</span>])]).T</span><br><span class="line">M = pd.DataFrame([np.mean(X)] * <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h2 id="计算散度矩阵-sw">计算散度矩阵 Sw</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_mean = X.apply(<span class="keyword">lambda</span> x: x - Mi[x[<span class="string">&quot;label&quot;</span>]], axis=<span class="number">1</span>).drop(columns=<span class="string">&quot;label&quot;</span>)</span><br><span class="line">Sw = np.dot(X_mean.T, X_mean)</span><br></pre></td></tr></table></figure>
<h2 id="计算散度矩阵-sb">计算散度矩阵 Sb</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Mi_M = (Mi - M.T).drop(index=<span class="string">&#x27;label&#x27;</span>)</span><br><span class="line">Mi_M_N = Mi_M * N</span><br><span class="line">Sb = np.dot(Mi_M, Mi_M_N.T)</span><br></pre></td></tr></table></figure>
<h2 id="计算s_w-1s_b矩阵并特征值分解">计算<span class="math inline">\(S_{w}^{-1}S_{b}\)</span>矩阵，并特征值分解</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">eig_vals, eig_vecs = np.linalg.eig(np.linalg.inv(Sw).dot(Sb))</span><br><span class="line">val_vecs = pd.DataFrame()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特征值与特征向量组合转为DataFrame</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(eig_vals)):</span><br><span class="line">		val_vecs[eig_vals[i]] = eig_vecs[:, i]</span><br></pre></td></tr></table></figure>
<h2 id="选择前k个最大特征值对应的特征向量组成矩阵w">选择前K个最大特征值对应的特征向量组成矩阵W</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">columns = <span class="built_in">sorted</span>(val_vecs.columns, reverse=<span class="literal">True</span>)</span><br><span class="line">W = val_vecs[columns]</span><br></pre></td></tr></table></figure>
<h2 id="根据w-计算降维数据维度不可大于c-1">根据W 计算降维数据(维度不可大于C-1)</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> dim&gt;self.class_count:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;The dim cannot more than C-1 witch is &#123;&#125; here&quot;</span>.<span class="built_in">format</span>(self.class_count-<span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">w = self.create_w()</span><br><span class="line">new_data = np.dot(self.X.drop(columns=<span class="string">&#x27;label&#x27;</span>), w.values[:, :dim])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Variance explained:&quot;</span>)</span><br><span class="line">eigv_sum = w.columns.values.<span class="built_in">sum</span>()</span><br><span class="line">eigenvalue = w.columns / eigv_sum</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(eigenvalue):</span><br><span class="line">    <span class="keyword">if</span> j &lt; <span class="number">0</span>:</span><br><span class="line">        j = -j</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;eigenvalue &#123;0:&#125;:     &#123;1:.2%&#125;&#x27;</span>.<span class="built_in">format</span>(i + <span class="number">1</span>, j))</span><br><span class="line">self.X_lda = new_data</span><br></pre></td></tr></table></figure>
<h2 id="对降维数据作图">对降维数据作图</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_lda</span>(<span class="params">self</span>):</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(self.X_lda):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  X_lda = self.X_lda</span><br><span class="line">  dim = X_lda.shape[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">if</span> X_lda.shape[<span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">    X_lda = np.array([[i[<span class="number">0</span>],<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> X_lda])</span><br><span class="line">    ax = plt.subplot(<span class="number">111</span>)</span><br><span class="line">    y = self.label</span><br><span class="line">    label_dict = &#123;<span class="number">0</span>: <span class="string">&#x27;Setosa&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;Versicolor&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Virginica&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> label, marker, color <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">      <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>), (<span class="string">&#x27;^&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;o&#x27;</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)):</span><br><span class="line">      plt.scatter(x=X_lda[:, <span class="number">0</span>][y == label],</span><br><span class="line">                  y=X_lda[:, <span class="number">1</span>][y == label],</span><br><span class="line">                  marker=marker,</span><br><span class="line">                  color=color,</span><br><span class="line">                  alpha=<span class="number">0.5</span>,</span><br><span class="line">                  label=label_dict[label]</span><br><span class="line">                 )</span><br><span class="line"></span><br><span class="line">      leg = plt.legend(loc=<span class="string">&#x27;upper right&#x27;</span>, fancybox=<span class="literal">True</span>)</span><br><span class="line">      leg.get_frame().set_alpha(<span class="number">0.5</span>)</span><br><span class="line">      plt.title(<span class="string">&#x27;LDA: Iris onto the first &#123;&#125; linear discriminants&#x27;</span>.<span class="built_in">format</span>(dim))</span><br><span class="line"></span><br><span class="line">      <span class="comment"># hide axis ticks</span></span><br><span class="line">      plt.tick_params(axis=<span class="string">&quot;both&quot;</span>, which=<span class="string">&quot;both&quot;</span>, bottom=<span class="string">&quot;off&quot;</span>, top=<span class="string">&quot;off&quot;</span>,</span><br><span class="line">                      labelbottom=<span class="string">&quot;on&quot;</span>, left=<span class="string">&quot;off&quot;</span>, right=<span class="string">&quot;off&quot;</span>, labelleft=<span class="string">&quot;on&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># remove axis spines</span></span><br><span class="line">      ax.spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">      ax.spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">      ax.spines[<span class="string">&quot;bottom&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">      ax.spines[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">      plt.grid()</span><br><span class="line">      plt.tight_layout()</span><br><span class="line">      plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="7.png" alt="" style="zoom:50%;" /><img src="8.png" alt="" style="zoom:50%;" /></p>
<h2 id="与pca比较">与PCA比较</h2>
<p><img src="9.png" alt="" style="zoom:70%;" /></p>
]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>PCA</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 by 李宏毅(3)</title>
    <url>/2021/07/01/ML3-CNN/</url>
    <content><![CDATA[<h2 id="convolutional-neural-network">Convolutional Neural Network</h2>
<p>常用于图像领域</p>
<span id="more"></span>
<h3 id="image-classification">Image Classification</h3>
<p>All the images to be classified have the same size</p>
<p>One-hot encoding, Dimension 对于识别的种类</p>
<p><img src="1.png" alt="1" style="zoom:60%;" /></p>
<p>对于一个 Machine 来说,<strong>一张图片其实是一个三维的 Tensor</strong>，一维代表图片的<strong>宽</strong>,另外一维代表图片的<strong>高</strong>,还有一维代表图片的 <strong>Channel</strong></p>
<p><strong>把这一个三维的 Tensor 展平, 就可以输入到一个 Network </strong></p>
<p><img src="2.png" alt="1" style="zoom:60%;" /></p>
<p>每一个 Neuron 跟输入的向量的每一个数值都有一个 Weight, 所以如果输入的向量长度是 100 × 100×3, 有 1000 个 Neuron,那第一层的 Weight,就有 1000×100 × 100×3,也就是 3×10 的 7 次方</p>
<p><img src="3.png" alt="1" style="zoom:60%;" /></p>
<h3 id="simplification1-on-full-connected">Simplification1 on Full Connected</h3>
<p>设定一个区域 Receptive Field,<strong>每一个 Neuron 都只关心自己的 Receptive Field</strong>，如图所示Receptive Field 里面有 3×3×3 个pixel</p>
<p><img src="4.png" alt="1" style="zoom:60%;" /></p>
<ul>
<li>把这 3×3×3 的数值Flatten, 变成一个长度是 3×3×3 的 27 维的向量,再输入到neuron中</li>
<li>Neuron 会给 27 维的向量的,<strong>每一个 Dimension 一个 Weight, </strong>所以这个 Neuron 有 3×3×3 27个 Weight,</li>
<li>再<strong>加上 Bias</strong> 得到的输出,这个输出再送给下一层的 Neuron 当作输入</li>
</ul>
<h3 id="typical-setting">Typical Setting</h3>
<ul>
<li>考虑所有的channel</li>
</ul>
<p>一般在做影像识别的时候会看全部的 Channel，我们在描述一个 Receptive Field 的时候,**只讲它的高跟宽*, 不用讲它的深度,反正<strong>深度一定是考虑全部的 Channel</strong>,而这个高跟宽合起来叫做 Kernel Size</p>
<p><strong>一般同一个 Receptive Field,不会只有一个 Neuron 去考虑它,往往会有一组 Neuron </strong></p>
<ul>
<li>Stride</li>
</ul>
<p>把你在最左上角的这个 Receptive Field,往右移一点,然后製造一个另外一个 Receptive Field,这个移动的量叫做 Stride。Receptive Field 高度重叠从而获取所有的 Pattern</p>
<ul>
<li>Padding</li>
</ul>
<p>超出范围你就做 <strong>Padding</strong>,<strong>Padding 就是补数值</strong></p>
<p><img src="5.png" alt="1" style="zoom:70%;" /></p>
<h3 id="simplification2">Simplification2</h3>
<p><strong>同样的 Pattern,它可能会出现在不同的Receptive Field</strong>，所以不同 Receptive Field 的 Neuron共享参数,也就是 <strong>Parameter Sharing权值共享，两个 Neuron 它们的 weights完全是一样</strong></p>
<p><img src="6.png" alt="1" style="zoom:60%;" /></p>
<p>每一个 Receptive Field,它都有一组 Neuron，不同的Receptive Field 的neuron之间共享参数</p>
<p><img src="7.png" alt="1" style="zoom:60%;" /></p>
<h3 id="benifit-of-convolutional-layer">Benifit of Convolutional Layer</h3>
<p><img src="8.png" alt="1" style="zoom:60%;" /></p>
<h3 id="卷积">卷积</h3>
<p>Filter的做法就是,先把 Filter 放在图片的左上角,然后<strong>把 Filter 裡面所有的值,跟左上角这个范围内的 9 个值做相乘</strong></p>
<p><img src="9.gif" alt="1" style="zoom:60%;" /></p>
<p>Filter 每次移动的距离叫做 Stride，如果我们有 64 个 Filter,我们就得到 64 组的数字,叫做 <strong>Feature Map</strong>，可以看成是,另外一张新的图片，只是这个图片的 Channel 有 64 个。</p>
<p>虽然例子 Filter 只有 3 × 3,但它在图像上考虑的范围是比较大的 是 5 × 5, 所以 N<strong>etwork 越深,同样是 3 × 3 的大小的 Filter, 它看的范围就会越来越大</strong>, 所以 Network 够深就可以侦测到比较大的 Pattern</p>
<p><img src="10.png" alt="1" style="zoom:60%;" /></p>
<h3 id="pooling">Pooling</h3>
<p>图像的放缩不影响对图像中对象的识别</p>
<p>Pooling 本身没有参数,所以它不是一个 Layer, 没有 Weight, 没有要 Learn 的东西, 所以 Pooling 比较像是一个 Activation Function,比较像是 Sigmoid ， ReLU ,它就是一个 Operator, 它的行為都是固定好的,没有要根据 Data 学任何东西。</p>
<p><img src="11.png" alt="1" style="zoom:60%;" /></p>
<p><img src="12.png" alt="1" style="zoom:60%;" /></p>
<p>不过 <strong>Pooling, 对于你的 Performance, 还是可能会带来一点伤害的</strong>,因為假设要侦测的是非常微细的东西, 那你随便做 Subsampling,Performance 可能会稍微差一点</p>
<p>所以近年来, 很多影像电视的 Network 的设计,往往也开始丢弃 Pooling ,他会做 Full Convolution 的 Neural Network, 整个 Network 统统都是 Convolution，例如 AlphaGo</p>
<h2 id="whole-cnn">Whole CNN</h2>
<p><img src="13.png" alt="1" style="zoom:60%;" /></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 by 李宏毅(4)</title>
    <url>/2021/07/02/ML3-self-attention/</url>
    <content><![CDATA[<h1 id="self-attention">Self-Attention</h1>
<p>常见的Network 架构 - <strong>Self-attention</strong></p>
<span id="more"></span>
<h2 id="sophisticated-input">Sophisticated Input</h2>
<p>输入是多个向量，向量的数目会发生改变</p>
<p><img src="1.png" alt="1" style="zoom:80%;" /></p>
<h3 id="vector-set-as-input">Vector Set as Input</h3>
<ol type="1">
<li>若Network输入是一个句子，每一个句子的长度都不一样,每个句子裡面词汇的数目都不一样。如果把一个句子裡面的每一个词汇, 都描述成一个向量, 那<strong>Model的输入是一个Vector Set</strong>, 而且每次句子的长度不一样, Vector Set的大小就不一样</li>
</ol>
<ul>
<li><strong>One-Hot Encoding 把词汇表示为向量</strong>，但这种表示方法有一个非常严重的问题,它假设所有的**词汇彼此之间都是没有关系的,从这个向量裡面你看不到：Cat跟Dog都是动物所以他们比较接近。这个向量中,没有任何语义的信息</li>
</ul>
<p><img src="2.png" alt="1" style="zoom:80%;" /></p>
<ul>
<li>Word Embedding：给每一个词汇一个向量,而这个<strong>向量具有语义信息</strong>，相似的类别聚集在一起</li>
</ul>
<p><img src="3.png" alt="1" style="zoom:100%;" /></p>
<ol start="2" type="1">
<li>声音信号，一段声音信号其实是一排向量, 把一段声音信号取一个范围, 这个范围叫做一个<strong>Window</strong></li>
</ol>
<p><img src="4.png" alt="1" style="zoom:50%;" /></p>
<p>Window 里的信号描述为一个向量，称为 <strong>Frame</strong>，通常Window 的长度是25ms，一整段的信号需要 Window 向右滑动一般10ms，一秒的声音信号有100个 Frame，一分钟则有6000个Frame</p>
<ol start="3" type="1">
<li>Graph，is a set of vectors。在Social Network上每一个节点就是一个人<strong>,然后</strong>节点跟节点之间的edge就是他们两个的关系连接，每个节点可以看做一个向量（性别，年龄，工作等等）</li>
</ol>
<p><img src="5.png" alt="1" style="zoom:30%;" /></p>
<ol start="4" type="1">
<li>分子信息，可以看做一个Graph。<strong>一个分子可以看作是一个Graph</strong>,分子上面的每一个原子，可以表述成一个向量<strong>，一个</strong>原子可以用One-Hot Vector</li>
</ol>
<p><img src="6.png" alt="1" style="zoom:60%;" /></p>
<h2 id="output">output</h2>
<ul>
<li>Each vector has a label，输入多少向量，输出多少对应label</li>
</ul>
<p><img src="7.png" alt="1" style="zoom:40%;" /></p>
<p>Application：POS tagging（词性标注）、Phonetic tagging（拼音标注）、商品推荐</p>
<p><img src="8.png" alt="1" style="zoom:40%;" /></p>
<ul>
<li>The whole sequence has a label</li>
</ul>
<p>Application：Sentiment analysis（情绪分析），语者辨认、分子性质分析</p>
<p><img src="9.png" alt="1" style="zoom:40%;" /></p>
<ul>
<li>Model decides the number of labels itself（又sequence to sequence）</li>
</ul>
<p><img src="10.png" alt="1" style="zoom:40%;" /></p>
<p>Application：机器翻译、语音识别</p>
<h3 id="sequence-labeling">Sequence Labeling</h3>
<p>输入跟输出数目一样多的情况又叫做 <strong>Sequence Labeling</strong>，模型如何设计？</p>
<ol type="1">
<li>Fully-Connected Network</li>
</ol>
<p><img src="11.png" alt="1" style="zoom:50%;" /></p>
<p>问题：如词性标注，单词和单词之间存在关系，同一个单词不同位置具有不同的词性，需要考虑上下文，把前后几个向量都作为一个neuron的输入</p>
<p><img src="12.png" alt="1" style="zoom:50%;" /></p>
<ol start="2" type="1">
<li>Self-attention</li>
</ol>
<p><img src="13.png" alt="1" style="zoom:60%;" /></p>
<p><strong>Self-Attention会考虑整个Sequence的信息，Input几个Vector 就输出几个Vector，输出的 Vector 都是考虑一整个Sequence以后才得到的</strong></p>
<p><strong>Self-Attention不是只能用一次, 可以叠加很多次</strong></p>
<p><img src="14.png" alt="1" style="zoom:60%;" /></p>
<p><strong>可以把Fully-Connected的Network,跟Self-Attention交替使用</strong></p>
<ul>
<li>Self-Attention处理整个Sequence的信息</li>
<li>Fully-Connected的Network, 专注于处理某一个位置的信息</li>
<li>再用Self-Attention,再把整个 Sequence 信息再处理一次</li>
<li>然后交替使用Self-Attention跟Fully-Connected</li>
</ul>
<h4 id="实现">实现</h4>
<p><strong>Self-Attention的Input, 是一串的Vector, Vector可能是整个Network的 Input, 也可能是某个Hidden Layer的 Output，所以用a来表示它，每一个b都是考虑了所有的a以后才生成出来的</strong></p>
<p><img src="15.png" alt="1" style="zoom:60%;" /></p>
<p><span class="math inline">\(b_1\)</span>产生步骤：</p>
<ul>
<li>根据<span class="math inline">\(a_1\)</span>找到与之想关联的向量，每一个向量跟<span class="math inline">\(a_1\)</span>的关联的程度,用一个数值α来表示</li>
</ul>
<p><img src="16.png" alt="1" style="zoom:60%;" /></p>
<p><strong>计算attention的模组可以自动计算两个向量之间的关联性<span class="math inline">\(\alpha\)</span>: Dot-product or Addictive</strong></p>
<p><img src="17.png" alt="1" style="zoom:60%;" /></p>
<p>Dot-product: <strong>输入的这两个向量分别乘上两个不同的矩阵，再把 q 跟 k 做dot product, 做 element-wise 的相乘, 再全部加起来以后就得到一个 scalar, 这个scalar就是α</strong>，最常用的方法,也<strong>是用在Transformer里面的方法</strong></p>
<p><img src="18.png" alt="1" style="zoom:60%;" /></p>
<p>q有一个名字叫Query，k叫做 Key，<strong>Query q1,跟Key k2, 计算 Inner-Product 就得到<span class="math inline">\(\alpha_{1,2}\)</span>，表示Query是<span class="math inline">\(a_1\)</span>提供，key是<span class="math inline">\(a_2\)</span>提供</strong>，一般实际中也会计算<span class="math inline">\(a_1\)</span>和自己的关联度</p>
<ul>
<li>计算出<span class="math inline">\(a_1\)</span>跟每一个向量的关联性以后, 接入一个Soft-Max(<strong>用别的 Activation Function 替代也没问题</strong>)</li>
</ul>
<p><img src="19.png" alt="1" style="zoom:60%;" /></p>
<ul>
<li>得到这个 <span class="math inline">\(\alpha^{&#39;}\)</span> 以后,我们就要根据 <span class="math inline">\(\alpha^{&#39;}\)</span> 抽取出 Sequence 里重要的信息
<ul>
<li>首先把<span class="math inline">\(a_1\)</span>到<span class="math inline">\(a_4\)</span>这边每一个向量,乘上<span class="math inline">\(W^v\)</span>得到新的向量<span class="math inline">\(v_1\)</span>到<span class="math inline">\(v_4\)</span></li>
<li>接下来把这边的<span class="math inline">\(v_1\)</span>到<span class="math inline">\(v_4\)</span>, 每一个向量都乘上attention的分数<span class="math inline">\(\alpha^{&#39;}\)</span></li>
<li>把4个结果相加得到<span class="math inline">\(b^1\)</span></li>
</ul></li>
</ul>
<p><img src="20.png" alt="1" style="zoom:60%;" /></p>
<p>如果某一个向量它得到的分数越高, 比如如果<span class="math inline">\(a^1\)</span>跟<span class="math inline">\(a^2\)</span>的关联性很强, 得到的<span class="math inline">\(\alpha^{&#39;}_{1,2}\)</span>值很大,那我们今天在做 Weighted Sum 以后,得到的值,就可能会比较接近<span class="math inline">\(v^2\)</span></p>
<p>矩阵角度</p>
<ul>
<li>每个a向量都要计算 q k v，因此可以把a向量拼接为矩阵I，q向量拼接为矩阵Q，同理得到矩阵K，V，其中<span class="math inline">\(W^q,W^k,W^v\)</span>是Network的参数，需要learn</li>
</ul>
<p><img src="21.png" alt="1" style="zoom:80%;" /></p>
<ul>
<li>计算 <span class="math inline">\(attention\ score = inner\ product（k^T, q）\)</span></li>
</ul>
<p><img src="22.png" alt="1" style="zoom:80%;" /></p>
<p>拼接成矩阵后</p>
<img src="23.png" alt="1" style="zoom:80%;" /> $$ A^{'}=softmax(A)=softmax
<span class="math display">\[\begin{pmatrix}
 \alpha_{1,1} &amp;\alpha_{2,1}   &amp;\alpha_{3,1} &amp;\alpha_{4,1} \\
  \alpha_{1,2} &amp; \alpha_{2,2}  &amp;\alpha_{3,2}  &amp;\alpha_{4,2}\\
  \alpha_{1,3} &amp;\alpha_{2,3}   &amp;\alpha_{3,3}  &amp;\alpha_{4,3}\\
\alpha_{1,4} &amp;\alpha_{2,4}   &amp;\alpha_{3,4}  &amp;\alpha_{4,4}\\
\end{pmatrix}\]</span>
= softmax
<span class="math display">\[\begin{pmatrix}
 {k^1}^T\\
 {k^2}^T\\
 {k^3}^T\\
 {k^4}^T\\

\end{pmatrix}
\begin{pmatrix}
 q^1 q^2 q^3 q^4\\
\end{pmatrix}\]</span>
<p>= softmax(K^T Q) $$</p>
<p><span class="math display">\[
attention\ score = softmax(K^TQ)
\]</span></p>
<ul>
<li>计算<span class="math inline">\(b^1,b^2,b^3,b^4\)</span></li>
</ul>
$$ b^1 = <em>{1,1}v^1+</em>{1,2}v<sup>2+<em>{1,3}v^3+</em>{1,4}v</sup>4=(v<sup>1v</sup>2v<sup>3v</sup>4)
<span class="math display">\[\begin{pmatrix}
\alpha_{1,1}\\
\alpha_{1,2}\\
\alpha_{1,2}\\
\alpha_{1,3}
\end{pmatrix}\]</span>
<p>\</p>
O = (b<sup>1b</sup>2b<sup>3b</sup>4)=(v<sup>1v</sup>2v<sup>3v</sup>4)   softmax
<span class="math display">\[\begin{pmatrix}
 \alpha_{1,1} &amp;\alpha_{2,1}   &amp;\alpha_{3,1} &amp;\alpha_{4,1} \\
  \alpha_{1,2} &amp; \alpha_{2,2}  &amp;\alpha_{3,2}  &amp;\alpha_{4,2}\\
  \alpha_{1,3} &amp;\alpha_{2,3}   &amp;\alpha_{3,3}  &amp;\alpha_{4,3}\\
\alpha_{1,4} &amp;\alpha_{2,4}   &amp;\alpha_{3,4}  &amp;\alpha_{4,4}\\
\end{pmatrix}\]</span>
<p>= V A<sup>{'}=Vsoftmax(K</sup>TQ) $$</p>
<p><img src="25.png" alt="1" style="zoom:50%;" /></p>
<ul>
<li>需要learn的参数<span class="math inline">\((W^K,W^q,W^v)\)</span></li>
</ul>
<h2 id="multi-head-self-attention">Multi-head Self-attention</h2>
<p>Self-attention 有一个进阶的版本,叫做 <strong>Multi-head Self-attention</strong></p>
<p><img src="26.png" alt="1" style="zoom:70%;" /></p>
<p>Self-attention 的时候, 用 q 去找相关的 k, 但是<strong>相关这件事情有很多种不同的形式</strong>, 有很多种不同的定义, 所以应该要有多个 q, <strong>不同的 q 负责不同种类的相关性</strong></p>
<p>在Self-attention 的基础上得到的q，再乘另外两个不同的矩阵，得到<span class="math inline">\(q^1 \  q^2\)</span>，同理得到 <span class="math inline">\(k^1,k^2,v^1,v^2\)</span></p>
<p><img src="27.png" alt="1" style="zoom:60%;" /></p>
<p><img src="28.png" alt="1" style="zoom:60%;" /></p>
<p>然后把<span class="math inline">\(b^{i,1}\)</span>跟<span class="math inline">\(b^{i,2}\)</span>接起来,然后再通过一个 transform 得到<span class="math inline">\(b^i\)</span></p>
<p><img src="29.png" alt="1" style="zoom:60%;" /></p>
<h2 id="positional-encoding">Positional Encoding</h2>
<p>Self-attention 机制产生的<span class="math inline">\(b^1到b^4\)</span>操作完全一样，向量<span class="math inline">\(a^1到a^4\)</span>对于self-attention 而言次序的信息被忽略，而次序信息在特定的情况下十分重要，比如 POS tagging, 语音识别等。</p>
<p>所以在self-attention 中加入位置信息，就是通过 position encoding 技术</p>
<h3 id="each-positon-has-a-unique-positional-vector">Each positon has a unique positional vector</h3>
<p>为每个位置设置 positional vector <span class="math inline">\(e^i\)</span>，i 代表不同的位置，然后加到<span class="math inline">\(a^i\)</span>上，每个位置的e是唯一的</p>
<p><img src="30.png" alt="1" style="zoom:80%;" /></p>
<h3 id="self-attention-for-speech">Self-attention for Speech</h3>
<p>把一段声音讯号,表示成一组向量的话可能会非常地长，vector 的 sequence 它的长度是非常可观会造成 attention score 的计算量十分大，所以需要 <strong>Truncated Self-attention</strong></p>
<p><img src="31.png" alt="1" style="zoom:80%;" /></p>
<p>Truncated Self-attention 做的事情就是, 在 Self-attention 的时候,<strong>不看一整句话, 只看一个小的范围就好</strong>，这个范围是一个超参数</p>
<h3 id="self-attention-for-image">Self-attention for Image</h3>
<p><strong>一张图片,可以换一个观点, 把它看作是一个 vector 的 set，如图所示的图像</strong></p>
<p><img src="32.png" alt="1" style="zoom:80%;" /></p>
<p>把每一个位置的 pixel,看作是一个三维的向量, 那<strong>整张图片,其实就是 5 乘以 10 个向量的set</strong></p>
<p><img src="33.png" alt="1" style="zoom:100%;" /></p>
<h3 id="self-attention-v.s.-cnn">Self-attention v.s. CNN</h3>
<p>用 Self-attention 来处理一张图片, 假设一个 pixel 产生 query, 其他 pixel 產生 key，做 inner product 的时候, 考虑的不是一个小的receptive field的信息, 而是整张图像的信息，而CNN的 filter 只考虑Receptive field 内的信息</p>
<ul>
<li>CNN 相当于简化的 Self-attention</li>
<li>CNN中的 Receptive Field 是一个超参数，self-attention 则是自动学习出来的</li>
<li>CNN是self-attention的特例</li>
</ul>
<p><img src="34.png" alt="1" style="zoom:70%;" /></p>
<p>这个实验结果,来自 An image is worth 16 X16 words, 把图像拆成 16 乘以 16 个 patch, 把每一个 patch想像成是一个 word,</p>
<p><strong>随著数据量越来越多, Self-attention 的结果越来越好, 最终在数据量最多的时候, Self-attention 超过 CNN, 但在数据量少的时候, CNN 它是可以比 Self-attention,得到更好的结果</strong></p>
<h3 id="self-attention-v.s.-rnn">Self-attention v.s. RNN</h3>
<p>RNN（recurrent neural network）</p>
<p><img src="35.png" alt="1" style="zoom:70%;" /></p>
<p>第二个 vector 作为 input 的时候, 也会把前一个时间点的output, 当做下一个时间点的输入,再输入 RNN 裡面,然后再产生新的 vector, 再输入 fully connected network</p>
<p>区别：</p>
<ul>
<li>对 RNN 来说,假设最右边这个黄色的 vector, 要考虑最左边的这个输入, 那它必须要把最左边的输入存在 memory 里面, 一直保存到最右边, 才能够在最后一个时间点被考虑。但对 Self-attention 来说没有这个问题, 它只要输出一个 query, 输出一个 key, 可以从整个 sequence 上非常远的 vector, 轻易地抽取信息</li>
<li>RNN 在处理的时候, input 一组 sequence, output 一组 sequence 的时候, <strong>RNN 没有办法平行化处理</strong>，self-attention 可以并行化处理</li>
<li>在运算速度上,Self-attention 会比 RNN 更有效率。目前很多的应用都往往把 RNN 的架构,逐渐改成 Self-attention 的架构</li>
</ul>
<h3 id="self-attention-for-graph">Self-attention for Graph</h3>
<p><img src="36.png" alt="1" style="zoom:70%;" /></p>
<p>之前做 Self-attention 的时候, 所谓的关联性是 network 自己找出来, 但是现在既然有了 Graph 的 edge 的信息, edge 已经暗示node 跟 node 之间的关联性</p>
<p>所以 Self-attention 用在 Graph 上面的时候, 在做这个 Attention Matrix 计算的时候,你可以<strong>只计算有 edge 相连的 node ，也就是有关系的向量<span class="math inline">\(a\)</span>，无关的node之间的attention score 设为0</strong></p>
<p>Self-attention 最早用在 Transformer 上面, 所以很多人讲 Transformer 的时候, 指的就是 Self-attention, 所以后来各式各样的 Self-attention 的变形都叫xxformer, 比如 Linformer Performer Reformer 等等。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 by 李宏毅(5)</title>
    <url>/2021/07/08/ML5/</url>
    <content><![CDATA[<h2 id="unsupervised-learning-----word-embedding">Unsupervised Learning --- Word Embedding</h2>
<blockquote>
<p>World Class : 对 word vector 进行聚类</p>
<p>Word Embedding：将每一个word project 到 High dimensional space 中，使得含义相近的 word 在空间的距离相近，且不同的dimension 代表不同的含义</p>
<span id="more"></span>
</blockquote>
<p><img src="1.png" alt="1" style="zoom:40%;" /></p>
<ul>
<li><p>Machine learn the meaning of word by reading lots of documents without supervison</p>
<ul>
<li><p>Generateing Word Vector is <strong>unsupervised</strong>. （unkown what to output）</p></li>
<li><p><img src="2.png" alt="1" style="zoom:40%;" /></p></li>
<li><p>A word can be understood by its context</p>
<ul>
<li>E.g： 相同的句式中的词大概率有相同的词性</li>
</ul></li>
<li><p>How to exploit the context?</p>
<ul>
<li><p>Count based: If two words <span class="math inline">\(w_i\)</span> and <span class="math inline">\(w_j\)</span> frequently co-occur, <span class="math inline">\(V(w_i)\)</span>and <span class="math inline">\(V(w_j)\)</span>would be close to each other</p>
<ul>
<li>E.g. <a href="http://nlp.stanford.edu/projects/glove/">Glove Vector</a></li>
<li><img src="3.png" alt="1" style="zoom:40%;" /></li>
</ul></li>
<li><p>Prediction-based</p>
<ul>
<li><p>train a model</p></li>
<li><p><span class="math inline">\(W_i\)</span> as Inout, <span class="math inline">\(W_j\)</span> as output</p></li>
<li><p>Take out the first input Z of hidden layer, Use Z present a word</p></li>
<li><p><img src="4.png" alt="1" style="zoom:30%;" /></p></li>
<li><p>E.g : Training Text: (1) <span class="math inline">\(W_{i,1} W_j\)</span> (2) <span class="math inline">\(W_{i,2} W_j\)</span></p>
<p>​ if Model(<span class="math inline">\(W_{i,1}\)</span>) = Model(<span class="math inline">\(W_{j,2}\)</span>) =&gt; <span class="math inline">\(W_{i,1}\)</span> 与 <span class="math inline">\(W_{i,2}\)</span> 属于一类</p></li>
<li><p>对其扩展，输入多个<span class="math inline">\(W_i\)</span>作为参数，需要进行 Sharing Parameters。将word vector flatten 后，相同维度的输入共享参数</p></li>
<li><p><img src="5.png" alt="1" style="zoom:30%;" /></p></li>
<li><p>The length of <span class="math inline">\(X_{i-1}\)</span> and <span class="math inline">\(X_{i-2}\)</span> are both |V|. The length of z is |Z|</p></li>
<li><p><span class="math display">\[
  Z = W_1X_{i-2} + W_2X_{i-1}
  \]</span></p></li>
<li><p>The weight matrix <span class="math inline">\(W_1\)</span> and <span class="math inline">\(W_2\)</span> are both |Z| X |V| matrices</p></li>
<li><p><span class="math display">\[
  W_1 = W_2 = W \ \ \ \ =&gt; \ \ \ \ z=W(X_{i-2}+X_{i-1})
  \]</span></p></li>
<li><p>如何保证在 train 的过程中 W矩阵一致？</p></li>
<li><p><img src="6.png" alt="1" style="zoom:30%;" /></p></li>
<li><p>Training Process</p></li>
<li><p><img src="7.png" alt="1" style="zoom:30%;" /></p></li>
<li><p>Various Architectures</p>
<ul>
<li><img src="8.png" alt="1" style="zoom:30%;" /></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>Multi-lingual Embedding: 额外train model进行 transform，transform的在dimension space的位置应该与原语言的词汇一致</p></li>
<li><p>Document Embedding ( document to Bag-of-Word )</p>
<ul>
<li><p>word sequences with different lengths -&gt; the vector with the same length</p></li>
<li><p>The vector representing the meaning of the word Sequence</p></li>
<li><p>A word sequence can be a document or a paragraph</p></li>
<li><p>Beyond Bag of Word: 要理解一个词序的含义，不能忽视词的顺序。</p></li>
</ul></li>
</ul></li>
</ul>
<h2 id="spatial-transformer-layer">Spatial Transformer Layer</h2>
<blockquote>
<p>对 input image 进行旋转缩放，使其具有不变性</p>
</blockquote>
<ul>
<li>CNN is not invariant to scaling and rotation</li>
<li><img src="9.png" alt="1" style="zoom:30%;" /></li>
<li>还可以 transform CNN 的 feature map</li>
</ul>
<h3 id="how-to-transform-an-imagefeature-map">How to transform an image/feature map</h3>
<p>E.g 对图像进行平移只需要改变 W 参数矩阵</p>
<p><img src="10.png" alt="1" style="zoom:30%;" /></p>
<p>Train 一个NN，使Layer l-1 变为 Layer l</p>
<p><img src="11.png" alt="1" style="zoom:30%;" /></p>
<p>线性代数中用变换矩阵可以进行图像的变换</p>
<ul>
<li>缩放</li>
<li><img src="12.png" alt="1" style="zoom:30%;" /></li>
<li>旋转</li>
<li><img src="13.png" alt="1" style="zoom:30%;" /></li>
</ul>
<p>在NN中只需要6个参数就可以实现平移和旋转</p>
<p><img src="14.png" alt="1" style="zoom:30%;" /></p>
<p>x，y 为value的下标，在旋转时会出现问题，如果四舍五入x，y，导致小的变化得到结果不变，所以微分为0，无法梯度下降。</p>
<p><img src="15.png" alt="1" style="zoom:30%;" /></p>
<p>进行 Interpolation</p>
<p><img src="16.png" alt="1" style="zoom:30%;" /></p>
<p>Spacial Transformer 将Input 进行变换为CNN可以识别的图像</p>
<p><img src="17.png" alt="1" style="zoom:30%;" /></p>
<h2 id="recurrent-neural-network">Recurrent Neural Network</h2>
<p>Store the older value in the memory</p>
<ul>
<li>Elman Network</li>
</ul>
<p><img src="18.png" alt="1" style="zoom:40%;" /></p>
<ul>
<li>Jordan Network, 可以清楚放入memory的是什么</li>
</ul>
<p><img src="19.png" alt="1" style="zoom:50%;" /></p>
<ul>
<li>Bidirection RNN，双向，根据整个input 输出 y</li>
</ul>
<p><img src="20.png" alt="1" style="zoom:40%;" /></p>
<h3 id="long-short-term-memory">Long Short-term Memory</h3>
<p>引入3个gate：forget gate，input gate，output gate</p>
<p><img src="21.png" alt="1" style="zoom:40%;" /></p>
<p><img src="22.png" alt="1" style="zoom:40%;" /></p>
<p>LSTM的参数量是一般NN的4倍</p>
<p><img src="23.png" alt="1" style="zoom:40%;" /></p>
<p><img src="24.png" alt="1" style="zoom:40%;" /></p>
<h2 id="gragh-neural-network">Gragh Neural Network</h2>
<h3 id="introduction">Introduction</h3>
<p>Gragh: Node + edge (interaction)</p>
<p>GNN: Gragh as Input, let NN know the structure of Gragh</p>
<p>Application:</p>
<ul>
<li>Classification</li>
<li><img src="25.png" alt="1" style="zoom:40%;" />
<ul>
<li>Identity analysis：根据人物关系分析凶手</li>
</ul></li>
<li>Generation</li>
<li>化学分子生成：输入 noise + y</li>
<li><img src="26.png" alt="1" style="zoom:40%;" /></li>
</ul>
<p>Data have underlying structure and relationship</p>
<h3 id="question">Question</h3>
<ul>
<li>How do we utilize the structures and relationship to help our model?</li>
<li>What if the graph is larger, like 20k nodes?</li>
<li>What if we don t have the all the labels?
<ul>
<li>E.g 利用相邻节点</li>
<li><img src="27.png" alt="1" style="zoom:40%;" /></li>
<li>How to embed node into a feature space using <strong>convolution</strong>?
<ul>
<li>Solution 1 Generalize the concept of convolution (correlation) to graph &gt;&gt; Spatial-based convolution</li>
<li>Solution 2 Back to the definition of convolution in signal processing &gt;&gt; Spectral-based convolution</li>
</ul></li>
</ul></li>
</ul>
<h3 id="embed-node-into-a-feature-space-using-convolution">embed node into a feature space using <strong>convolution</strong></h3>
<p><img src="28.png" alt="1" style="zoom:40%;" /></p>
<h3 id="tasks-dataset-and-benchmark">Tasks, Dataset, and Benchmark</h3>
<p>Tasks + semi-supervised node classification + Regression + Graph classification + Graph representation learning + Link prediction</p>
<p>Common dataset</p>
<ul>
<li>CORA: citation network. 2.7k nodes and 5.4k links</li>
<li>TU-MUTAG: 188 molecules with 18 nodes on average</li>
</ul>
<h3 id="spatial-based-gnn">Spatial-based GNN</h3>
<p>Convolution:</p>
<p><img src="29.png" alt="1" style="zoom:40%;" /></p>
<p><strong>Aggregate: How to update the hidden state of next layer with neighbor feature</strong></p>
<p><strong>Readout: collect all node feature to represent the graph</strong></p>
<p><img src="30.png" alt="1" style="zoom:40%;" /></p>
<ul>
<li>NN4G (Neural Network for Gragh)
<ul>
<li>Input layer : Inout gragh node <span class="math inline">\(V_i\)</span>, node feature <span class="math inline">\(X_i\)</span></li>
<li>Hidden layer 0: 对 node feature <span class="math inline">\(X_i\)</span> 进行 embedding （Embedding matrix）</li>
<li><img src="31.png" alt="1" style="zoom:40%;" /></li>
<li>Hidden Layer1：aggregate</li>
<li><img src="32.png" alt="1" style="zoom:40%;" /></li>
<li>Readout : each layer node feature 加起来</li>
<li><img src="33.png" alt="1" style="zoom:40%;" /></li>
</ul></li>
<li>DCNN ( Diffusion-Convolution Neural Network )
<ul>
<li><strong>将距离v3节点距离为1的 feature 相加再取平均</strong></li>
<li><img src="34.png" alt="1" style="zoom:35%;" /></li>
<li><strong>将距离v3节点距离为2的 feature 相加再取平均</strong></li>
<li><img src="35.png" alt="1" style="zoom:35%;" /></li>
<li>分别将每层的节点的feature拼接矩阵H</li>
<li><img src="36.png" alt="1" style="zoom:35%;" /></li>
<li>transform之后输出 y</li>
<li><img src="37.png" alt="1" style="zoom:35%;" /></li>
</ul></li>
<li>MoNET（Mixture Model Networks）
<ul>
<li>Define a measure on node distances</li>
<li><img src="38.png" alt="1" style="zoom:35%;" /></li>
<li>Use weighted sum (mean)instead of simply summing up(averaging neighbor features</li>
<li><img src="39.png" alt="1" style="zoom:35%;" /></li>
</ul></li>
<li>GAN（Gragh Attention Network）<strong>常用</strong>
<ul>
<li>对 neighbor node 进行 attention</li>
<li><img src="40.png" alt="1" style="zoom:35%;" /></li>
<li>f means feature、e means energy</li>
<li><img src="41.png" alt="1" style="zoom:35%;" /></li>
</ul></li>
<li>GIN（Gragh Isomorphism Network）
<ul>
<li>A GNN can be at most as powerful as WL isomorphic test</li>
<li>Theoretical proofs were provided
<ul>
<li>mean or max pooling will fail</li>
<li><img src="42.png" alt="1" style="zoom:45%;" /></li>
</ul></li>
</ul></li>
</ul>
<h3 id="gragh-signal-processing-and-spectral-based-gnn">Gragh Signal Processing and Spectral-based GNN</h3>
<p>对Graph和Filter进行Transform到 Fourier domain 中做 Multiplication，得到结果再inverse Transform，实现Convolution</p>
<p><img src="43.png" alt="1" style="zoom:45%;" /></p>
<ul>
<li>Fourier transform</li>
</ul>
<p><img src="44.png" alt="1" style="zoom:35%;" /></p>
<ul>
<li>Spectual Graph Theory：</li>
</ul>
<p>adjacency matrix 表示相连节点的权值，degree matrix (对角阵) 表示每个节点有几个邻居</p>
<p><img src="45.png" alt="1" style="zoom:45%;" /></p>
<p>U 为 eigen vector, <span class="math inline">\(\lambda\)</span> 代表eigen value</p>
<p><img src="46.png" alt="1" style="zoom:45%;" /></p>
<p>Example:</p>
<p><img src="47.png" alt="1" style="zoom:35%;" /></p>
<p><img src="48.png" alt="1" style="zoom:35%;" /></p>
<p>频率越大，相邻点的变化量越大.</p>
<p><img src="49.png" alt="1" style="zoom:35%;" /></p>
<p>Lf 的第i个element表示：<span class="math inline">\(V_i\)</span> 的 frequency 分别与 neighbor node 的frequency差的总和 <span class="math display">\[
Lf(v_i) = \sum_{v_j\in V} w_{i,j}(f(v_i)-f(v_j)), where\ w_{i,j}\ is\ the\ (i,j)^{th}\ entry\  of\ A
\]</span> 所以<strong>"Power" of signal variation between nodes i.e smoothness of graph signal</strong> <span class="math display">\[
f^TLf=f^T \sum_{v_j\in V} w_{i,j}(f(v_i)-f(v_j))=\sum_{v_i \in V}f(v_i)\sum_{v_j\in V} w_{i,j}(f(v_i)-f(v_j))
\]</span></p>
<p><span class="math display">\[
=\sum_{v_i \in V}\sum_{v_j\in V}w_{i,j}(f^2(v_i)-f(v_i)f(v_j))
\]</span></p>
<p><span class="math display">\[
=\frac{1}{2}\{ \sum_{v_i \in V}\sum_{v_j\in V}w_{i,j}(f^2(v_i)-f(v_i)f(v_j))+\sum_{v_i \in V}\sum_{v_j\in V}w_{i,j}(f^2(v_j)-f(v_j)f(v_i))\}
\]</span></p>
<p><span class="math display">\[
=\frac{1}{2}\sum_{v_i \in V}\sum_{v_j\in V}w_{i,j}(f(v_i)-f(v_j))^2
\]</span></p>
<p><span class="math display">\[f^T Lf\]</span> represents "power" of signal variation between nodes</p>
<p><img src="50.png" alt="1" style="zoom:35%;" /> <span class="math display">\[
Thus,let\space u_i = f,\space \space Then  \space \space u_i^TLu_i = u_i^T\lambda_i u_i = \lambda_i
\]</span> small <span class="math inline">\(\lambda\)</span> means the low-pass part of a graph signal, <span class="math inline">\(u_i\)</span> means the frequency</p>
<p>例如：如图一个直线graph</p>
<p><img src="51.png" alt="1" style="zoom:35%;" /></p>
<h3 id="how-to-tansform">How to tansform？</h3>
<p><img src="52.png" alt="1" style="zoom:35%;" /></p>
<p><span class="math inline">\(\hat x\)</span> 表示<span class="math inline">\(x\)</span>在不同频率成分<span class="math inline">\(\lambda\)</span> 上的大小</p>
<p>Inverse Graph Fourier Transform of signal <span class="math inline">\(\hat x: x=U\hat x\)</span></p>
<p><img src="53.png" alt="1" style="zoom:35%;" /></p>
<h3 id="filtering">Filtering</h3>
<p>modifying the amplitude/ phase of the different frequency components in a signal, including eliminating some frequency components entirely</p>
<p><img src="54.png" alt="1" style="zoom:35%;" /></p>
<p>Filter in img --- Impulse response</p>
<p>E.g , Convolution in time domain is multiplication in frequency domain</p>
<p><img src="55.png" alt="1" style="zoom:35%;" /></p>
<p><span class="math inline">\(\hat y\)</span> in spectual domain need to de transformed to vertex domain y <span class="math display">\[
y = U\hat y = Ug_\theta (\wedge) \hat x = U g_\theta(\wedge)U^Tx=g_\theta(U\wedge U^T)x
\]</span></p>
<p><span class="math display">\[
Let, \space \space L = U\wedge U^T
\]</span></p>
<p><span class="math display">\[
y = g_\theta(L)x
\]</span></p>
<p><span class="math display">\[
where, \space g_\theta(·)\space can\space be\space any\space function, 
\]</span></p>
<p><span class="math display">\[
for\space example, g_\theta (L) = log(1+L)=L-\frac{L^2}{2}+\frac{L^3}{3}...,\lambda_{max}&lt;1
\]</span></p>
<p><img src="56.png" alt="1" style="zoom:35%;" /></p>
<p>Problems :</p>
<ol type="1">
<li><p><span class="math inline">\(\theta_i\)</span> is the parameters to be learned, the number of <span class="math inline">\(\theta\)</span> depends on the number of nodes. Learning complexity is O(N)</p></li>
<li><p><span class="math inline">\(g_\theta (·)\)</span> is not localization,</p>
<p><img src="57.png" alt="1" style="zoom:35%;" /></p></li>
</ol>
<h3 id="chebnet">ChebNet</h3>
<p>Solution to problem 1 and 2:</p>
<ul>
<li>use polynomial to parameterize <span class="math inline">\(g_\theta (L)\)</span></li>
</ul>
<p><img src="58.png" alt="1" style="zoom:35%;" /></p>
<p>Solution to problem 3:</p>
<ul>
<li><p>Use a polynomial function that can be computed recursively (递归) from L</p></li>
<li><p>Chebyshev polynomial: <span class="math inline">\(T_0(x) = 1, T_1(x)=x,T_k(x) = 2xT_{k-1}(x)-T_{k-2}(x), x\in[-1,1]\)</span></p>
<ul>
<li><p><span class="math display">\[
  T_0(\tilde \wedge) = I, T_1(\tilde \wedge)=x,T_k(\tilde \wedge) = 2\tilde \wedge T_{k-1}(\tilde \wedge )-T_{k-2}(\tilde \wedge)
  \]</span></p></li>
<li><p><span class="math display">\[
  where \space \tilde \wedge =\frac{2\wedge}{\lambda_{max}}-I,\space \tilde \wedge \in [-1,1], \space I=indentity \space matrix
  \]</span></p></li>
<li><p><img src="59.png" alt="1" style="zoom:35%;" /></p></li>
<li><p><img src="60.png" alt="1" style="zoom:40%;" /></p></li>
<li><p><img src="61.png" alt="1" style="zoom:40%;" /></p></li>
</ul></li>
</ul>
<p><img src="62.png" alt="1" style="zoom:40%;" /></p>
<h3 id="gcn-常用">GCN （常用）</h3>
<p><img src="63.png" alt="1" style="zoom:35%;" /></p>
<p><span class="math inline">\(\tilde \space\)</span> means self-loop</p>
<p><img src="64.png" alt="1" style="zoom:35%;" /></p>
<h3 id="benchmark-tasks">Benchmark tasks</h3>
<ul>
<li>Graph Classification: SuperPixel MNIST and CIFAR10</li>
</ul>
<p><img src="65.png" alt="1" style="zoom:35%;" /></p>
<ul>
<li>Regression ZINC molecule graphs dataset</li>
</ul>
<p><img src="66.png" alt="1" style="zoom:50%;" /></p>
<ul>
<li>Node classification: Stochastic Block Model dataset
<ul>
<li>graph pattern recognition and semi-supervised graph clustering</li>
</ul></li>
</ul>
<p><img src="67.png" alt="1" style="zoom:50%;" /></p>
<ul>
<li>Edge classification: Traveling Salesman Problem</li>
</ul>
<p><img src="68.png" alt="1" style="zoom:45%;" /></p>
<h3 id="result">Result</h3>
<p><img src="69.png" alt="1" style="zoom:45%;" /></p>
<p><img src="70.png" alt="1" style="zoom:45%;" /></p>
<p><img src="71.png" alt="1" style="zoom:45%;" /></p>
<p><img src="72.png" alt="1" style="zoom:45%;" /></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 by 李宏毅(2)</title>
    <url>/2021/07/01/Machine-Learning2/</url>
    <content><![CDATA[<h2 id="adaptive-learning-rate">Adaptive Learning Rate</h2>
<p>each parameters different learning rate</p>
<span id="more"></span>
<h3 id="training-stuck-small-gradient">Training stuck != Small Gradient</h3>
<p>训练过程中，随着不断地update，loss逐渐变小直到不再下降，此时不一定是<strong>critical poin</strong>t但gradient不一定很小</p>
<p><img src="1.png" alt="1" style="zoom:40%;" /></p>
<p><strong>gradient</strong> 有可能在<strong>error surface</strong> 来回震荡，loss 不能在下降。</p>
<h3 id="training-can-be-difficult-even-without-critical-points">Training can be difficult even without critical points</h3>
<p>如图 **Error Surface是convex形状（ Convex Optimization）， 最低点在黄色X处，</p>
<p><img src="2.png" alt="1" style="zoom:40%;" /></p>
<p>lr = 0.01，gradient 震荡，loss无法达到local minima。lr=<span class="math inline">\(10^{-7}\)</span>，停止震荡但由于lr太小无法到达</p>
<h3 id="different-parameters-needs-different-learning-rate">Different parameters needs different learning rate</h3>
<p><strong>如果在某一个方向上, gradient 的值很小,非常的平坦,那 learning rate 调大一点,如果在某一个方向上非常的陡峭,坡度很大, learning rate 可以小一点</strong></p>
<p><img src="3.png" alt="1" style="zoom:40%;" /></p>
<p><strong>不同的参数我们要给它不同的σ,同时它也是iteration dependent的,不同的iteration也会有不同的σ</strong>，σ的计算常见类型</p>
<h4 id="root-mean-square-adagurd">Root mean square (Adagurd)</h4>
<p><img src="4.png" alt="1" style="zoom:40%;" /></p>
<p><strong>坡度比较大的时候,learning rate就减小,坡度比较小的时候,learning rate就大</strong></p>
<p><img src="5.png" alt="1" style="zoom:40%;" /></p>
<h4 id="rmsprop">RMSProp</h4>
<p>RMS Prop方法,<strong>第一步跟oot Mean Square,（Apagrad）一样</strong>，<strong>但在RMS Prop裡面, 你可以自己调整 gradient 的重要性</strong></p>
<p><img src="6.png" alt="1" style="zoom:40%;" /></p>
<p><strong>α 是一个hyperparameter</strong></p>
<ul>
<li>如果α 很小趋近於0<strong>,就代表我觉得</strong>gᵢ¹相较於之前所算出来的gradient而言,比较重要**</li>
<li><strong>α 很大趋近於1</strong>,那就代表我觉得<strong>现在算出来的gᵢ¹比较不重要,之前算出来的gradient比较重要</strong></li>
</ul>
<p><img src="7.png" alt="1" style="zoom:40%;" /></p>
<p>原来的<strong>Adagrad</strong> 相比于 <strong>RMSProp</strong> 对当前的gradient的反应要慢</p>
<h4 id="adam">Adam</h4>
<p>今天最常用的optimization的策略（optimizer），就是<strong>Adam：PMSProp+Momentum</strong></p>
<p><img src="8.png" alt="1" style="zoom:50%;" /></p>
<h3 id="adam-vs-sgdm">Adam VS SGDM</h3>
<ul>
<li>Adam：fast training，large generalization gap， unstable</li>
<li>SGDM：stable， little generalization， better convergence</li>
</ul>
<h4 id="learning-rate-scheduling">Learning Rate Scheduling</h4>
<p><strong>Adagrad</strong></p>
<p><img src="9.png" alt="1" style="zoom:50%;" /></p>
<p>快走到终点的时候突然在纵轴震荡？</p>
<ul>
<li><p>纵轴方向,初始的gradient很大</p></li>
<li><p>走到谷底,纵轴的方向,gradient算出来都很小,所以纵轴这个方向,就累积了很小的σ，累积到一个地步以后, step 变大,然后就向纵轴偏离</p></li>
<li><p>因為偏移出去以后, gradient 变大, σ又慢慢的变大, 参数 update 的步伐就慢慢的变小，所以不会永远就是震荡,不会做简谐运动停不下来,有摩擦力让它慢慢地又回到中间这个峡谷来。</p></li>
<li><p>累计一段时间以后周而复始</p></li>
</ul>
<p>一个方法可以解决这个问题,叫做<strong>learning rate scheduling</strong>，<strong>不把η当一个常数, 让它跟时间有关</strong>最常见的策略叫做Learning Rate Decay，<strong>随著时间的不断地进行, 随著参数不断的update, 使η越来越小</strong></p>
<p><img src="10.png" alt="1" style="zoom:40%;" /></p>
<h4 id="warm-up">Warm Up</h4>
<p><strong>让learning rate, 先变大后变小</strong></p>
<p><img src="11.png" alt="1" style="zoom:50%;" /></p>
<h3 id="summary">Summary</h3>
<p><img src="12.png" alt="1" style="zoom:50%;" /></p>
<ul>
<li>有Momentum, 现在不是完全顺著 gradient 的方向,现在不是完全顺著这一个时间点算出来的gradient的方向,来update参数,而是把过去,所有算出来gradient的方向,做一个加总当作update的方向,这个是momentum</li>
<li>update 多大的步伐, 要除掉 gradient 的<strong>Root Mean Square</strong></li>
<li><strong>Momentum是直接把所有的 gradient 通通都加起来, 有考虑方向和gradient正负号，但是 Root Mean Square 不考虑gradient的方向了,它只考虑gradient的大小</strong></li>
</ul>
<h2 id="classification-as-regression">Classification as Regression</h2>
<p><strong>把Classification,当作是Regression来看输入一个东西以后,我们的输出仍然是一个scaler y，我们要让它跟正确答案越接近越好,但是 y 是一个数字，我们必须把Class也变成数字</strong></p>
<p><img src="13.png" style="zoom:70%"/></p>
<p>假设说Class one就是编号1,Class two就是编号2,Class3就是编号3,意味<strong>Class1跟Class2比较像,Class1跟Class3 比较不像</strong>,像这样子的表示Class的方式,有时候不可行</p>
<h3 id="class-as-one-hot-vector">Class as one-hot vector</h3>
<p>常见的做法是把Class,用 One-hot vector来表示</p>
<p><img src="14.png" style="zoom:50%"/></p>
<p>用One-hot vector来表示的话,就没有Class1跟Class2比较接近,Class1跟Class3比较远这样子的问题,<strong>如果计算Class之间的距离 两两它们的距离都是一样</strong>。使用one-hot vector，network要Output的维度也是三个数字</p>
<p><img src="15.png" style="zoom:70%"/></p>
<p><strong>Regression的问题,只需要Output一个数字，其实从一个数值改到三个数值,本质上没有什么不同</strong></p>
<h3 id="softmaxlogistic-regression">Softmax（Logistic Regression）</h3>
<p>Classification的时候,往往会<strong>把y再通过一个叫做Soft-max的function得到y'</strong>,然后我们才去计算,y'跟y hat之间的距离</p>
<p><img src="16.png" style="zoom:70%"/></p>
<p>Softmax 除了Normalized,让 y₁' y₂' y₃',<strong>变成0到1之间</strong>,还有<strong>和为1</strong>以外, 还会让大的值跟小的值的差距更大</p>
<p>然后这个Softmax的输入,往往称之为 logit</p>
<p><img src="17.png" style="zoom:40%"/></p>
<p>两个class 用sigmoid,跟softmax两个class 是等价的</p>
<h3 id="loss-of-classification">Loss of Classification</h3>
<ul>
<li>Mean Square Error (MSE)</li>
<li>Cross-entropy</li>
</ul>
<p><span class="math display">\[
e =- \sum_{i} \hat{y_i}  ln{y_i}&#39; 
\]</span></p>
<p><img src="18.png" style="zoom:60%"/></p>
<h2 id="quick-introduction-of-batch-normalization">Quick Introduction of Batch Normalization</h2>
<p><strong>Error surface</strong> 如果很崎嶇的时候,它比较难 train,那我们能不能够直接改变 <strong>landscape</strong>,让它变得比较好 <strong>train</strong> 呢？<strong>固定的 learning rate</strong>,可能很难得到好的结果,所以需要 adaptive 的 learning rate、 Adam 等等比较好的 optimization 的方法,才能够得到好的结果。</p>
<p>假设两个参数啊对 <strong>Loss 的斜率差别非常大</strong>,在<span class="math inline">\(w_1\)</span>这个方向上面,你的斜率变化很小,在<span class="math inline">\(w_2\)</span>这个方向上面斜率变化很大</p>
<p><img src="20.png" style="zoom:40%"/></p>
<p>什么情况会产生像上面这种<strong>难 train 的 error surface</strong> ？</p>
<ul>
<li><span class="math inline">\(x_1\)</span> input 中的值都很小，所以输出对y的影响也很小，对Loss的影响也会小</li>
<li><span class="math inline">\(x_2\)</span> 中的值都很大，以输出对y的影响也很大，对Loss的影响也会大</li>
</ul>
<p><img src="19.png" style="zoom:40%"/></p>
<p>当我们 input 的 feature,<strong>每一个 dimension 的值,它的 scale 差距很大</strong>的时候,就可能产生像这样的 error surface,就可能产生<strong>不同方向,斜率非常不同,坡度非常不同的 error surface</strong></p>
<p>所以可能给 feature不同的 dimension,让它有同样的数值的范围，从而使error surface 更加平坦。这些不同的方法,往往就合起来统称 Feature Normalization</p>
<h3 id="feature-normalization">Feature Normalization</h3>
<p><img src="21.png" style="zoom:40%"/></p>
<p><img src="22.png" style="zoom:40%"/></p>
<p>对z或者a进行normalization差别不大</p>
<p>如何对z ？ <span class="math display">\[
\mu =\frac{1}{3} \sum_{i=1}^{3} z^i \ \ \ \ \ \ \ \  \ \sigma =\sqrt{\frac{1}{3} \sum_{i=1}^{3}(z_i-\mu )^2}
\]</span> <img src="23.png" style="zoom:40%"/></p>
<p>所以如果没有 Feature Normalization , 改变了 <span class="math inline">\(z^1\)</span> 的值, 就会改变 <span class="math inline">\(a^1\)</span> 的值</p>
<p>但由于 Feature Normalization 是在 dimension 上操作的, 所以当改变<span class="math inline">\(z^1\)</span>的值的时候, <span class="math inline">\(\mu 和 \sigma\)</span> 也会跟着改变, <span class="math inline">\(\mu 和 \sigma\)</span> 改变以后, <span class="math inline">\(z^2 a^2 z^3 a^3\)</span> 的值,也会跟着改变，三个 example,变得<strong>彼此关联</strong>。Feature Normalization 的时候, 把这一整个 process,就是收集一堆 feature,把这堆 feature 算出 <span class="math inline">\(\mu 和 \sigma\)</span> ,当做是 network 的一部分。</p>
<p><img src="24.png" style="zoom:60%"/></p>
<p>实际的数据无法全部放入network中，所以只对一个 batch 中的data 进行 normalization，称为<code>Batch Normalization</code>，适用batch size 比较大的时候, 只有 batch size 比较大,<strong>这个 batch size data, 才有可能足以表示整个 corpus 的分布</strong></p>
<p>在 Batch Normalization 的时候,往往还会有这样的设计，算出 $ $ 以后</p>
<ul>
<li>再乘上另外一个向量 <span class="math inline">\(\gamma\)</span> , 做 element wise 的相乘</li>
<li>再加上向量 <span class="math inline">\(\beta\)</span>,得到 <span class="math inline">\(\hat{z}\)</span> , <span class="math inline">\(\beta\)</span>和<span class="math inline">\(\hat{z}\)</span> 是需要 Network learn</li>
</ul>
<p><img src="25.png" style="zoom:60%"/></p>
<p>让 Network 训练的时候决定feature的平均，而不是限制为0</p>
<h3 id="testing-inference">Testing （ inference）</h3>
<p>假如在 testing 的时候,根本就没有 batch,那我们要怎么计算 <span class="math inline">\(\mu \ \ \sigma\)</span>?</p>
<p>在 training 的时候, 每一个 batch 计算出来的 <span class="math inline">\(\mu \ \ \sigma\)</span> ,都会拿出来算 <strong>moving average</strong></p>
<p><img src="26.png" style="zoom:60%"/></p>
<p>Pytorch 中设置 p 为0.1，testing中直接使用<span class="math inline">\(\bar\mu\)</span> 和 <span class="math inline">\(\bar\sigma\)</span></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown 语法概述</title>
    <url>/2019/04/02/MarkDown-%E8%AF%AD%E6%B3%95%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<figure>
<img src="http://att.bbs.duowan.com/forum/201504/02/1438274e9zpgxamhqaszee.jpg" alt="m" /><figcaption aria-hidden="true">m</figcaption>
</figure>
<span id="more"></span>
<h2 id="宗旨">宗旨</h2>
<p>MarkDown 的目标是「易读易写」。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。</p>
<h2 id="目录">目录</h2>
<p>在需要目录出现的地方放置一个标记，这样会自动生成一个嵌套的包含所有标题的列表。默认的标记是 [TOC]。</p>
<blockquote>
<p><strong>[TOC]</strong></p>
</blockquote>
<h2 id="标题">标题</h2>
<blockquote>
<p>在标题开头 加上1~6个#，依次代表一级标题、二级标题....六级标题</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">##### 四级标题</span><br><span class="line">###### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="兼容-html">兼容 HTML</h2>
<p>Markdown 语法的目标是：成为一种适用于网络的书写语言。</p>
<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p>
<p>要制约的只有一些 HTML 区块元素――比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进，Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;p&gt; 标签。</p>
<blockquote>
<p>&lt;table&gt;</p>
<p>​ &lt;tr&gt;</p>
<p>​ &lt;td&gt;Foo&lt;/td&gt;</p>
<p>​ &lt;/tr&gt;</p>
<p>&lt;/table&gt;</p>
</blockquote>
<hr />
<h2 id="特殊字符转换">特殊字符转换</h2>
<p>在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &lt; 和 &amp;。</p>
<blockquote>
<p>&lt; 转化为 &amp; lt;</p>
<p>&amp; 转化为 &amp;amp;</p>
<p>/ 反斜杠转义</p>
</blockquote>
<hr />
<h2 id="列表list">列表(List)</h2>
<blockquote>
<p>MarkDown 支持有序和无序列表</p>
</blockquote>
<h3 id="无序列表">1. 无序列表</h3>
<blockquote>
<p>无序列表使用-、+和*作为列表标记：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*   Red</span><br><span class="line">*   Green</span><br><span class="line">*   Blue</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+   Red</span><br><span class="line">+   Green</span><br><span class="line">+   Blue</span><br></pre></td></tr></table></figure>
<p>也等同于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-   Red</span><br><span class="line">-   Green</span><br><span class="line">-   Blue</span><br></pre></td></tr></table></figure>
</blockquote>
<hr />
<h3 id="有序列表-ordered-list">2. 有序列表 (ordered list)</h3>
<blockquote>
<p>有序列表则使用数字加英文句点来表示：</p>
</blockquote>
<ol type="1">
<li>一</li>
<li>二</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.  Bird</span><br><span class="line">2.  McHale</span><br><span class="line">3.  Parish</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>：你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>Bird<span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>McHale<span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>Parish<span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>如果你的列表标记写成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.  Bird</span><br><span class="line">1.  McHale</span><br><span class="line">1.  Parish</span><br></pre></td></tr></table></figure>
<p>或甚至是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. Bird</span><br><span class="line">1. McHale</span><br><span class="line">8. Parish</span><br></pre></td></tr></table></figure>
<p>你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。</p>
<h2 id="引用reference">引用（Reference）</h2>
<blockquote>
<p>引用以&gt;来表示，引用中支持多级引用、标题、列表、代码块、分割线等常规语法。</p>
</blockquote>
<h3 id="常见的引用写法">常见的引用写法：</h3>
<ul>
<li><p>分级（嵌套）引用（只要根据层次加上不同数量的 &gt; ）：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">This is the first level of quoting.</span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; &gt; This is nested blockquote.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; Back to the first level.</span></span><br></pre></td></tr></table></figure></li>
<li><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; ## 这是一个标题。</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; 1.   这是第一行列表项。</span></span><br><span class="line"><span class="quote">&gt; 2.   这是第二行列表项。</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; 给出一些例子代码：</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt;     return shell<span class="emphasis">_exec(&quot;echo $input | $markdown_</span>script&quot;);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>演示</strong>：</p>
<blockquote>
<p>一级引用</p>
<blockquote>
<p>二级引用</p>
<blockquote>
<p>三级引用</p>
<blockquote>
<p>四级引用</p>
<blockquote>
<p>五级引用</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<hr />
<h2 id="文字样式-text-style">文字样式 (TEXT STYLE)</h2>
<h3 id="基本语法">1. 基本语法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**加粗文本** 或  __加粗__</span><br><span class="line">*斜体* 或 _斜体_</span><br><span class="line">***斜粗体***  或者___斜粗体___</span><br><span class="line">~~删除文本~~</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="非基本语法">2. 非基本语法</h3>
<blockquote>
<p>&lt;sup&gt;上标文字&lt;/sup&gt;</p>
<p>&lt;sub&gt;下标文字&lt;/sub&gt;</p>
<p>&lt;u&gt;下划线&lt;/u&gt;</p>
<p>&lt;!--注释--&gt;</p>
<p>脚注：[^1]</p>
<p>[^1]: 这里是脚注</p>
</blockquote>
<ul>
<li>演示：</li>
<li>这是<sup>上标文字</sup></li>
<li>这是<sub>下标文字</sub></li>
<li>这是<u>下划线</u></li>
<li><!--注释--></li>
<li>脚注例子：[^1]</li>
</ul>
<hr />
<h2 id="图片与链接-images-links">图片与链接 (Images &amp; Links)</h2>
<p>图片与链接的语法很像，区别在一个 ! 号。 注：Markdown 不能设置图片大小，如果必须设置则应使用HTML标记 &lt;img&gt;</p>
<h3 id="链接">链接</h3>
<p>Markdown 支持三种形式的链接语法： 行内式，参考式和自动连接。</p>
<p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p>
<p>要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">This is [<span class="string">an example</span>](<span class="link">http://example.com/ &quot;Title&quot;</span>) inline link.</span><br><span class="line"></span><br><span class="line">[<span class="string">This link</span>](<span class="link">http://example.net/</span>) has no title attribute.</span><br></pre></td></tr></table></figure>
<p>会产生：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>This is <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com/&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Title&quot;</span>&gt;</span></span></span><br><span class="line">an example<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span> inline link.<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://example.net/&quot;</span>&gt;</span></span>This link<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span> has no</span><br><span class="line">title attribute.<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="行内链接式">行内链接式</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是行内式链接：[Baidu](https://www.baidu.com/)。</span><br></pre></td></tr></table></figure>
<p><strong>行内链接式</strong>：<a href="https://www.baidu.com/">Baidu</a></p>
<p><strong>这是参考式链接</strong>：[Baidu][url]，其中url为链接标记，可置于文中任意位置。</p>
<p>[url]: https://www.baidu.com/  "liuyang"</p>
<hr />
<h4 id="自动链接">自动链接</h4>
<blockquote>
<p>链接标记格式为：[链接标记文本]: 链接地址 链接title(可忽略)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是自动链接：直接使用&lt;&gt;括起来&lt;http://www.baidu.com&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>这是自动链接：直接使用&lt;&gt;括起来<a href="http://www.baidu.com" class="uri">http://www.baidu.com</a></li>
</ul>
<hr />
<h4 id="参考链接式">参考链接式</h4>
<p>参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是参考链接式： [an example][url] </span><br><span class="line">[url]: http://example.com/  &quot;Optional Title Here&quot;</span><br><span class="line">其中url为链接标记，可置于文中任意位置。</span><br></pre></td></tr></table></figure>
<p>链接内容定义的形式为：</p>
<ul>
<li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li>
<li>接着一个冒号</li>
<li>接着一个以上的空格或制表符</li>
<li>接着链接的网址</li>
<li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li>
</ul>
<p>下面这三种链接的定义都是相同：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">foo</span>]: <span class="link">http://example.com/  &quot;Optional Title Here&quot;</span></span><br><span class="line">[<span class="symbol">foo</span>]: <span class="link">http://example.com/  &#x27;Optional Title Here&#x27;</span></span><br><span class="line">[<span class="symbol">foo</span>]: <span class="link">http://example.com/  (Optional Title Here)</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。</p>
<hr />
<p>链接网址也可以用方括号包起来：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">url</span>]: <span class="link">&quot;Optional Title Here&quot;</span></span><br></pre></td></tr></table></figure>
<p>你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">url</span>]: <span class="link">http://example.com/longish/path/to/resource/here</span></span><br><span class="line"><span class="code">    &quot;Optional Title Here&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中</strong>。</p>
<hr />
<p>链接辨别标签可以有字母、数字、空白和标点符号，但是<strong>并不区分大小写</strong>，因此下面两个链接是一样的：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">[<span class="string">link text</span>][<span class="symbol">a</span>]</span><br><span class="line">[<span class="string">link text</span>][<span class="symbol">A</span>]</span><br></pre></td></tr></table></figure>
<p>隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 "Google" 链接到 google.com，你可以简化成：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">[<span class="string">Google</span>][<span class="symbol"></span>]</span><br></pre></td></tr></table></figure>
<p>然后定义链接内容：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">Google</span>]: <span class="link">http://google.com/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><a href="http://google.com/">google</a></p></li>
<li></li>
</ul>
<hr />
<p>由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">Visit [<span class="string">Daring Fireball</span>][<span class="symbol"></span>] for more information.</span><br></pre></td></tr></table></figure>
<p>然后接着定义链接</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">Daring Fireball</span>]: <span class="link">http://daringfireball.net/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Visit <a href="http://www.baidu.com/">Baidu</a> for more information.</p>
</blockquote>
<p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p>
<p>下面是一个参考式链接的范例：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">I get 10 times more traffic from [Google] [1] than from</span><br><span class="line">[Yahoo] [2] or [MSN] [3].</span><br><span class="line"></span><br><span class="line">  [1]: http://google.com/        &quot;Google&quot;</span><br><span class="line">  [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;</span><br><span class="line">  [3]: http://search.msn.com/    &quot;MSN Search&quot;</span><br></pre></td></tr></table></figure>
<p>如果改成用链接名称的方式写：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">I get 10 times more traffic from [<span class="string">Google</span>][<span class="symbol"></span>] than from</span><br><span class="line">[<span class="string">Yahoo</span>][<span class="symbol"></span>] or [<span class="string">MSN</span>][<span class="symbol"></span>].</span><br><span class="line"></span><br><span class="line">  [google]: http://google.com/        &quot;Google&quot;</span><br><span class="line">  [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;</span><br><span class="line">  [msn]:    http://search.msn.com/    &quot;MSN Search&quot;</span><br></pre></td></tr></table></figure>
<p>上面两种写法都会产生下面的 HTML。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>I get 10 times more traffic from <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://google.com/&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml"><span class="attr">title</span>=<span class="string">&quot;Google&quot;</span>&gt;</span></span>Google<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span> than from</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://search.yahoo.com/&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Yahoo Search&quot;</span>&gt;</span></span>Yahoo<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">or <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://search.msn.com/&quot;</span> <span class="attr">title</span>=<span class="string">&quot;MSN Search&quot;</span>&gt;</span></span>MSN<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>.<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<hr />
<p>下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">I get 10 times more traffic from [<span class="string">Google</span>](<span class="link">http://google.com/ &quot;Google&quot;</span>)</span><br><span class="line">than from [<span class="string">Yahoo</span>](<span class="link">http://search.yahoo.com/ &quot;Yahoo Search&quot;</span>) or</span><br><span class="line">[<span class="string">MSN</span>](<span class="link">http://search.msn.com/ &quot;MSN Search&quot;</span>).</span><br></pre></td></tr></table></figure>
<p>参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。</p>
<p>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。</p>
<hr />
<h3 id="图片链接">图片链接</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是图片：![][image]</span><br><span class="line"></span><br><span class="line">[image]: https://ws1.sinaimg.cn/large/d63ab74bly1frvek4v8eoj20a10dwae6.jpg</span><br></pre></td></tr></table></figure>
<p><img src="http://img1.comic.zymk.cn/comic/2011-11-26/110056_5229.jpg" /></p>
<hr />
<p>参考式的图片语法则长得像这样：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">![<span class="string">Alt text</span>][<span class="symbol">id</span>]</span><br></pre></td></tr></table></figure>
<p>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">id</span>]: <span class="link">url/to/image  &quot;Optional title attribute&quot;</span></span><br></pre></td></tr></table></figure>
<p>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <img> 标签。</p>
<hr />
<h2 id="代码块引用">代码块引用</h2>
<blockquote>
<p>代码分为行内代码和代码块。</p>
</blockquote>
<h3 id="行内代码">行内代码</h3>
<blockquote>
<p>行内代码使用 <code>代码</code> 标识，可嵌入文字中 需要引用代码时，如果引用的语句只有一段，不分行，可以用 ` 将语句包起来。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`Hello world`</span><br></pre></td></tr></table></figure>
<p><code>Hello world</code></p>
<hr />
<h3 id="代码框">代码框</h3>
<blockquote>
<p>两对「 」包裹,如果引用的语句为多行，可以将` 置于这段代码的首行和末行。 代码前加四个空格键 代码前加一个 tab 键</p>
</blockquote>
<p>代码语法高亮在 ```后面加上空格和语言名称即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">​``` python</span><br><span class="line">//注意语言前面有空格</span><br><span class="line">这里是代码</span><br><span class="line">​```</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="表格">表格</h2>
<blockquote>
<p>表格对齐格式 居左：:---- 居中：:----:或----- 居右：----:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|你|我|他|</span><br><span class="line">|:---|:---:|---:|</span><br><span class="line">|居左|居中|居右|</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">你</th>
<th style="text-align: center;">我</th>
<th style="text-align: right;">他</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">居左</td>
<td style="text-align: center;">居中</td>
<td style="text-align: right;">居右</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="分割线">分割线</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">---</span><br><span class="line">_____</span><br><span class="line"></span><br><span class="line">* * *</span><br></pre></td></tr></table></figure>
<h2 id="弥补markdown的html标签">弥补Markdown的Html标签</h2>
<h3 id="字体">字体</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;font face=&quot;微软雅黑&quot; color=&quot;red&quot; size=&quot;6&quot;&gt;字体及字体颜色和大小&lt;/font&gt;</span><br><span class="line">&lt;font color=&quot;#0000ff&quot;&gt;字体颜色&lt;/font&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font face="微软雅黑" color="red" size="6">字体及字体颜色和大小</font> <font color="#0000ff">字体颜色</font></p>
</blockquote>
<hr />
<h3 id="换行">换行</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用html标签`&lt;br/&gt;`&lt;br/&gt;换行</span><br></pre></td></tr></table></figure>
<p>使用html标签<code>&lt;br/&gt;</code> 换行</p>
<hr />
<h3 id="文本对齐方式">文本对齐方式</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p align=&quot;left&quot;&gt;居左文本&lt;/p&gt;</span><br><span class="line">&lt;p align=&quot;center&quot;&gt;居中文本&lt;/p&gt;</span><br><span class="line">&lt;p align=&quot;right&quot;&gt;居右文本&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p align="left">
居左文本
</p>
<p align="center">
居中文本
</p>
<p align="right">
居右文本
</p>
<hr />
<p><strong>这里是脚注</strong>：[^1]</p>
]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 项目管理</title>
    <url>/2020/03/14/Maven-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="maven">Maven</h1>
<p>Apache 旗下项目管理工具，由纯 Java 语言开发，可以更方便的帮助我们管理和构建 Java 项目</p>
<span id="more"></span>
<h1 id="特点">特点</h1>
<ul>
<li>jar 包管理：
<ul>
<li>从 maven 中央仓库获取标准的规范 jar 包以及相关依赖的 jar 包，免去自己下载的繁琐</li>
<li>本地仓库统一管理 jar 包，使 jar包与项目分离，减轻项目体积</li>
</ul></li>
<li>跨平台使用</li>
<li>项目结构清晰</li>
<li>多工程开发，将模块拆分成若干工程，利于团队协作开发</li>
<li>一键构筑项目</li>
</ul>
<h1 id="maven-常用命令">Maven 常用命令</h1>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>MobileNet</title>
    <url>/2021/06/28/MobileNet/</url>
    <content><![CDATA[<h2 id="lightweight-networks-and-mobilenet">Lightweight networks and MobileNet</h2>
<p>复杂的网络需要大量的计算资源，如GPU。然而，事实证明在大多数情况下，一个参数数量少得多的模型仍然可以被训练得表现相当好。换句话说，模型复杂性的增加通常会导致模型性能的小幅（非比例）提高。我们在模块的开始阶段训练MNIST数字分类时观察到了这一点。<span id="more"></span>简单的密集模型的准确率与强大的CNN差距并不明显，增加CNN层数和分类器中的神经元数量使我们最多可以获得几个百分点的准确率。</p>
<p>可以尝试轻量级的网络架构使得模型训练地更快。如果我们想在移动设备上执行我们的模型，这一点尤其重要。这个模块将依赖于我们在上一单元中下载的猫和狗的数据集。首先，我们要确保数据集是可用的。</p>
<h2 id="mobilenet">MobileNet</h2>
<p>More lightweight analog of ResNet is <strong>MobileNet</strong>, which uses so-called <strong><em>Inverted Residual Blocks</em></strong>. Let's load pre-trained mobilenet and see how it works:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = torch.hub.load(<span class="string">&#x27;pytorch/vision:v0.6.0&#x27;</span>, <span class="string">&#x27;mobilenet_v2&#x27;</span>, pretrained=<span class="literal">True</span>)</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> model.parameters():</span><br><span class="line">    x.requires_grad = <span class="literal">False</span></span><br><span class="line">device = <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line">model.classifier = nn.Linear(<span class="number">1280</span>,<span class="number">2</span>)</span><br><span class="line">model = model.to(device)</span><br><span class="line">summary(model,input_size=(<span class="number">1</span>,<span class="number">3</span>,<span class="number">244</span>,<span class="number">244</span>))</span><br><span class="line">device = <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line">model.classifier = nn.Linear(<span class="number">1280</span>,<span class="number">2</span>)</span><br><span class="line">model = model.to(device)</span><br><span class="line">summary(model,input_size=(<span class="number">1</span>,<span class="number">3</span>,<span class="number">244</span>,<span class="number">244</span>))</span><br><span class="line">==========================================================================================</span><br><span class="line">Layer (<span class="built_in">type</span>:depth-idx)                   Output Shape              Param <span class="comment">#</span></span><br><span class="line">==========================================================================================</span><br><span class="line">├─Sequential: <span class="number">1</span>-<span class="number">1</span>                        [<span class="number">1</span>, <span class="number">1280</span>, <span class="number">8</span>, <span class="number">8</span>]           --</span><br><span class="line">|    └─ConvBNReLU: <span class="number">2</span>-<span class="number">1</span>                   [<span class="number">1</span>, <span class="number">32</span>, <span class="number">122</span>, <span class="number">122</span>]         --</span><br><span class="line">|    |    └─Conv2d: <span class="number">3</span>-<span class="number">1</span>                  [<span class="number">1</span>, <span class="number">32</span>, <span class="number">122</span>, <span class="number">122</span>]         (<span class="number">864</span>)</span><br><span class="line">|    |    └─BatchNorm2d: <span class="number">3</span>-<span class="number">2</span>             [<span class="number">1</span>, <span class="number">32</span>, <span class="number">122</span>, <span class="number">122</span>]         (<span class="number">64</span>)</span><br><span class="line">|    |    └─ReLU6: <span class="number">3</span>-<span class="number">3</span>                   [<span class="number">1</span>, <span class="number">32</span>, <span class="number">122</span>, <span class="number">122</span>]         --</span><br><span class="line">|    └─InvertedResidual: <span class="number">2</span>-<span class="number">2</span>             [<span class="number">1</span>, <span class="number">16</span>, <span class="number">122</span>, <span class="number">122</span>]         --</span><br><span class="line">|    |    └─Sequential: <span class="number">3</span>-<span class="number">4</span>              [<span class="number">1</span>, <span class="number">16</span>, <span class="number">122</span>, <span class="number">122</span>]         (<span class="number">896</span>)</span><br><span class="line">|    └─InvertedResidual: <span class="number">2</span>-<span class="number">3</span>             [<span class="number">1</span>, <span class="number">24</span>, <span class="number">61</span>, <span class="number">61</span>]           --</span><br><span class="line">|    |    └─Sequential: <span class="number">3</span>-<span class="number">5</span>              [<span class="number">1</span>, <span class="number">24</span>, <span class="number">61</span>, <span class="number">61</span>]           (<span class="number">5</span>,<span class="number">136</span>)</span><br><span class="line">|    └─InvertedResidual: <span class="number">2</span>-<span class="number">4</span>             [<span class="number">1</span>, <span class="number">24</span>, <span class="number">61</span>, <span class="number">61</span>]           --</span><br><span class="line">|    |    └─Sequential: <span class="number">3</span>-<span class="number">6</span>              [<span class="number">1</span>, <span class="number">24</span>, <span class="number">61</span>, <span class="number">61</span>]           (<span class="number">8</span>,<span class="number">832</span>)</span><br><span class="line">|    └─InvertedResidual: <span class="number">2</span>-<span class="number">5</span>             [<span class="number">1</span>, <span class="number">32</span>, <span class="number">31</span>, <span class="number">31</span>]           --</span><br><span class="line">|    |    └─Sequential: <span class="number">3</span>-<span class="number">7</span>              [<span class="number">1</span>, <span class="number">32</span>, <span class="number">31</span>, <span class="number">31</span>]           (<span class="number">10</span>,<span class="number">000</span>)</span><br><span class="line">|    └─InvertedResidual: <span class="number">2</span>-<span class="number">6</span>             [<span class="number">1</span>, <span class="number">32</span>, <span class="number">31</span>, <span class="number">31</span>]           --</span><br><span class="line">|    |    └─Sequential: <span class="number">3</span>-<span class="number">8</span>              [<span class="number">1</span>, <span class="number">32</span>, <span class="number">31</span>, <span class="number">31</span>]           (<span class="number">14</span>,<span class="number">848</span>)</span><br><span class="line">|    └─InvertedResidual: <span class="number">2</span>-<span class="number">7</span>             [<span class="number">1</span>, <span class="number">32</span>, <span class="number">31</span>, <span class="number">31</span>]           --</span><br><span class="line">|    |    └─Sequential: <span class="number">3</span>-<span class="number">9</span>              [<span class="number">1</span>, <span class="number">32</span>, <span class="number">31</span>, <span class="number">31</span>]           (<span class="number">14</span>,<span class="number">848</span>)</span><br><span class="line">|    └─InvertedResidual: <span class="number">2</span>-<span class="number">8</span>             [<span class="number">1</span>, <span class="number">64</span>, <span class="number">16</span>, <span class="number">16</span>]           --</span><br><span class="line">|    |    └─Sequential: <span class="number">3</span>-<span class="number">10</span>             [<span class="number">1</span>, <span class="number">64</span>, <span class="number">16</span>, <span class="number">16</span>]           (<span class="number">21</span>,056)</span><br><span class="line">|    └─InvertedResidual: <span class="number">2</span>-<span class="number">9</span>             [<span class="number">1</span>, <span class="number">64</span>, <span class="number">16</span>, <span class="number">16</span>]           --</span><br><span class="line">|    |    └─Sequential: <span class="number">3</span>-<span class="number">11</span>             [<span class="number">1</span>, <span class="number">64</span>, <span class="number">16</span>, <span class="number">16</span>]           (<span class="number">54</span>,<span class="number">272</span>)</span><br><span class="line">|    └─InvertedResidual: <span class="number">2</span>-<span class="number">10</span>            [<span class="number">1</span>, <span class="number">64</span>, <span class="number">16</span>, <span class="number">16</span>]           --</span><br><span class="line">|    |    └─Sequential: <span class="number">3</span>-<span class="number">12</span>             [<span class="number">1</span>, <span class="number">64</span>, <span class="number">16</span>, <span class="number">16</span>]           (<span class="number">54</span>,<span class="number">272</span>)</span><br><span class="line">|    └─InvertedResidual: <span class="number">2</span>-<span class="number">11</span>            [<span class="number">1</span>, <span class="number">64</span>, <span class="number">16</span>, <span class="number">16</span>]           --</span><br><span class="line">|    |    └─Sequential: <span class="number">3</span>-<span class="number">13</span>             [<span class="number">1</span>, <span class="number">64</span>, <span class="number">16</span>, <span class="number">16</span>]           (<span class="number">54</span>,<span class="number">272</span>)</span><br><span class="line">|    └─InvertedResidual: <span class="number">2</span>-<span class="number">12</span>            [<span class="number">1</span>, <span class="number">96</span>, <span class="number">16</span>, <span class="number">16</span>]           --</span><br><span class="line">|    |    └─Sequential: <span class="number">3</span>-<span class="number">14</span>             [<span class="number">1</span>, <span class="number">96</span>, <span class="number">16</span>, <span class="number">16</span>]           (<span class="number">66</span>,<span class="number">624</span>)</span><br><span class="line">|    └─InvertedResidual: <span class="number">2</span>-<span class="number">13</span>            [<span class="number">1</span>, <span class="number">96</span>, <span class="number">16</span>, <span class="number">16</span>]           --</span><br><span class="line">|    |    └─Sequential: <span class="number">3</span>-<span class="number">15</span>             [<span class="number">1</span>, <span class="number">96</span>, <span class="number">16</span>, <span class="number">16</span>]           (<span class="number">118</span>,<span class="number">272</span>)</span><br><span class="line">|    └─InvertedResidual: <span class="number">2</span>-<span class="number">14</span>            [<span class="number">1</span>, <span class="number">96</span>, <span class="number">16</span>, <span class="number">16</span>]           --</span><br><span class="line">|    |    └─Sequential: <span class="number">3</span>-<span class="number">16</span>             [<span class="number">1</span>, <span class="number">96</span>, <span class="number">16</span>, <span class="number">16</span>]           (<span class="number">118</span>,<span class="number">272</span>)</span><br><span class="line">|    └─InvertedResidual: <span class="number">2</span>-<span class="number">15</span>            [<span class="number">1</span>, <span class="number">160</span>, <span class="number">8</span>, <span class="number">8</span>]            --</span><br><span class="line">|    |    └─Sequential: <span class="number">3</span>-<span class="number">17</span>             [<span class="number">1</span>, <span class="number">160</span>, <span class="number">8</span>, <span class="number">8</span>]            (<span class="number">155</span>,<span class="number">264</span>)</span><br><span class="line">|    └─InvertedResidual: <span class="number">2</span>-<span class="number">16</span>            [<span class="number">1</span>, <span class="number">160</span>, <span class="number">8</span>, <span class="number">8</span>]            --</span><br><span class="line">|    |    └─Sequential: <span class="number">3</span>-<span class="number">18</span>             [<span class="number">1</span>, <span class="number">160</span>, <span class="number">8</span>, <span class="number">8</span>]            (<span class="number">320</span>,<span class="number">000</span>)</span><br><span class="line">|    └─InvertedResidual: <span class="number">2</span>-<span class="number">17</span>            [<span class="number">1</span>, <span class="number">160</span>, <span class="number">8</span>, <span class="number">8</span>]            --</span><br><span class="line">|    |    └─Sequential: <span class="number">3</span>-<span class="number">19</span>             [<span class="number">1</span>, <span class="number">160</span>, <span class="number">8</span>, <span class="number">8</span>]            (<span class="number">320</span>,<span class="number">000</span>)</span><br><span class="line">|    └─InvertedResidual: <span class="number">2</span>-<span class="number">18</span>            [<span class="number">1</span>, <span class="number">320</span>, <span class="number">8</span>, <span class="number">8</span>]            --</span><br><span class="line">|    |    └─Sequential: <span class="number">3</span>-<span class="number">20</span>             [<span class="number">1</span>, <span class="number">320</span>, <span class="number">8</span>, <span class="number">8</span>]            (<span class="number">473</span>,<span class="number">920</span>)</span><br><span class="line">|    └─ConvBNReLU: <span class="number">2</span>-<span class="number">19</span>                  [<span class="number">1</span>, <span class="number">1280</span>, <span class="number">8</span>, <span class="number">8</span>]           --</span><br><span class="line">|    |    └─Conv2d: <span class="number">3</span>-<span class="number">21</span>                 [<span class="number">1</span>, <span class="number">1280</span>, <span class="number">8</span>, <span class="number">8</span>]           (<span class="number">409</span>,<span class="number">600</span>)</span><br><span class="line">|    |    └─BatchNorm2d: <span class="number">3</span>-<span class="number">22</span>            [<span class="number">1</span>, <span class="number">1280</span>, <span class="number">8</span>, <span class="number">8</span>]           (<span class="number">2</span>,<span class="number">560</span>)</span><br><span class="line">|    |    └─ReLU6: <span class="number">3</span>-<span class="number">23</span>                  [<span class="number">1</span>, <span class="number">1280</span>, <span class="number">8</span>, <span class="number">8</span>]           --</span><br><span class="line">├─Linear: <span class="number">1</span>-<span class="number">2</span>                            [<span class="number">1</span>, <span class="number">2</span>]                    <span class="number">2</span>,<span class="number">562</span></span><br><span class="line">==========================================================================================</span><br><span class="line">Total params: <span class="number">2</span>,<span class="number">226</span>,<span class="number">434</span></span><br><span class="line">Trainable params: <span class="number">2</span>,<span class="number">562</span></span><br><span class="line">Non-trainable params: <span class="number">2</span>,<span class="number">223</span>,<span class="number">872</span></span><br><span class="line">Total mult-adds (M): <span class="number">196.40</span></span><br><span class="line">==========================================================================================</span><br><span class="line">Input size (MB): <span class="number">0.71</span></span><br><span class="line">Forward/backward <span class="keyword">pass</span> size (MB): <span class="number">20.12</span></span><br><span class="line">Params size (MB): <span class="number">8.91</span></span><br><span class="line">Estimated Total Size (MB): <span class="number">29.74</span></span><br><span class="line">==========================================================================================</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PyTorch</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Natural Language Processing - Bag of Word &amp;&amp; Embedding</title>
    <url>/2021/07/01/NLP/</url>
    <content><![CDATA[<h2 id="introduction">Introduction</h2>
<p>近年来，自然语言处理（NLP）作为一个领域经历了快速增长，主要是因为语言模型的性能取决于其 "理解 "文本的整体能力，并且可以在大型文本库上以无监督的方式进行训练。因此，预训练的文本模型，如BERT，简化了许多NLP任务，并极大地提高了性能。</p>
<span id="more"></span>
<p>本文专注于在PyTorch中把NLP表示为张量的基本方面，以及经典的NLP架构，如 bag-of-words, embeddings and recurrent neural networks</p>
<h3 id="natural-language-tasks">Natural Language Tasks</h3>
<ul>
<li><p><strong>Text Classification</strong>: 常用于需要将文本片段分类为几个预定义类之一的场景，例如，垃圾邮件检测、新闻分类、将支持请求分配给其中一个类别等等。</p></li>
<li><p><strong>Intent Classification：</strong>Text Classification 的特例，将对话式人工智能系统中的输入语料映射到代表该短语实际含义的意图之一，或用户的 intent。</p></li>
<li><p><strong>Sentiment Analysis</strong>：一个回归任务，我们想了解给定文本的消极程度。我们可能想把数据集中的文本从最负面的（-1）到最正面的（+1）进行标记，并训练一个模型，输出一个文本的 "正面性 "数字。</p></li>
<li><p><strong>Named Entity Recognition</strong> (NER)：从文本中提取一些实体的任务，如日期、地址、人名等。与意图分类一起，NER经常被用于对话系统，从用户的话语中提取参数。</p></li>
<li><p><strong>keyword extraction</strong> ：在文本中找到最有意义的词，然后可以将其用作标签。</p></li>
<li><p><strong>Text Summarization</strong>：提取最有意义的文本片段，为用户提供包含大部分含义的摘要</p></li>
<li><p><strong>Question/Answer</strong>： This model gets text fragment and a question as an input, and needs to find exact place within the text that contains answer. For example, the text "<em>John is a 22 year old student who loves to use Microsoft Learn</em>", and the question <em>How old is John</em> should provide us with the answer <em>22</em>.</p></li>
</ul>
<h2 id="text-classification">Text Classification</h2>
<ul>
<li>Understand how text is processed for natural language processing tasks</li>
<li>Get introduced to Recurrent Neural Networks (RNNs) and Generative Neural Networks (GNNs)</li>
<li>Learn about Attention Mechanisms</li>
<li>Learn how to build text classification models</li>
</ul>
<h3 id="representing-text-as-tensors">Representing text as Tensors</h3>
<p>In order to solve NLP tasks with neural networks, we need some way to represent text as tensors. Computers already represent textual characters as numbers that map to fonts on your screen using encodings such as ASCII or UTF-8</p>
<p>Computers by themselves do not have such an understanding of what each letter represents, neural network has to learn the meaning during train</p>
<p>Approaches of representing text:</p>
<ul>
<li>Character-level representation: treating each charater as a number. Given that we have C different characters in our text corpus, the word <em>Hello</em> would be represented by 5xC tensor (One-Hot encoding).</li>
<li>Word-level representation: creating a <strong>vocabulary</strong> of all words in text, then representing words using one-hot encoding. This approach is somehow better, because each letter by itself does not have much meaning, and thus by using higher-level semantic concepts - words - we simplify the task for the neural network. However, given large dictionary size, we need to deal with high-dimensional sparse tensor.</li>
</ul>
<h3 id="dataset">Dataset</h3>
<p>Start with a simple text classification task based on <strong>AG_NEWS</strong> dataset, which is to classify news headlines into one of 4 categories: World, Sports, Business and Sci/Tech. This dataset is built into <code>torchtext</code> module</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.makedirs(root, exist_ok=<span class="literal">True</span>)</span><br><span class="line">training_iter, test_iter = torchtext.datasets.AG_NEWS(root=root)</span><br></pre></td></tr></table></figure>
<p><code>train_dataset</code> and <code>test_dataset</code> contain iterators that return pairs of label (number of class) and text respectively, if we want to use the data multiple times we need to convert it to list</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torchtext.data.functional <span class="keyword">import</span> to_map_style_dataset</span><br><span class="line"></span><br><span class="line">builtins.classes = [<span class="string">&#x27;World&#x27;</span>, <span class="string">&#x27;Sports&#x27;</span>, <span class="string">&#x27;Business&#x27;</span>, <span class="string">&#x27;Sci/Tech&#x27;</span>]</span><br><span class="line">builtins.training_data, test_data = to_map_style_dataset(training_iter), to_map_style_dataset(test_iter)</span><br><span class="line">num_train = <span class="built_in">int</span>(<span class="built_in">len</span>(builtins.training_data) * <span class="number">0.8</span>)</span><br><span class="line"><span class="comment"># 获取训练集的 vocab</span></span><br><span class="line">builtins.vocab = get_vocab()</span><br><span class="line">builtins.vocab_size = <span class="built_in">len</span>(builtins.vocab)</span><br><span class="line"><span class="comment"># 训练集细分训练集和验证集</span></span><br><span class="line">training_data, valid_data = random_split(builtins.training_data, [num_train, <span class="built_in">len</span>(builtins.training_data) - num_train])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Convert text into numbers so that can be represented as tensor. (Word-level representation)</p>
<ul>
<li>use tokenizer to split text into tokens</li>
<li>build a vocabulary of these tokens</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_vocab</span>(<span class="params"><span class="built_in">type</span>=<span class="string">&#x27;bow&#x27;</span></span>):</span></span><br><span class="line">    counter = collections.Counter()</span><br><span class="line">    <span class="keyword">for</span> (label, line) <span class="keyword">in</span> training_data:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span> == <span class="string">&#x27;bow&#x27;</span>:</span><br><span class="line">            counter.update(tokenizer(line))</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">type</span> == <span class="string">&#x27;ngram&#x27;</span>:</span><br><span class="line">            counter.update(torchtext.data.utils.ngrams_iterator(line, ngrams=<span class="number">2</span>))</span><br><span class="line">    vocab = torchtext.vocab.vocab(counter, min_freq=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> vocab</span><br><span class="line">  </span><br><span class="line"><span class="comment"># Using vocabulary, we can easily encode out tokenized string into a set of numbers</span></span><br><span class="line">[vocab.get_stoi()[i] <span class="keyword">for</span> i <span class="keyword">in</span> tokenizer(<span class="string">&quot;I love u&quot;</span>)]</span><br><span class="line"><span class="comment"># [599, 3279, 294]</span></span><br></pre></td></tr></table></figure>
<h3 id="bag-of-words-text-representatiion">bag of words text representatiion</h3>
<p>Because words represent meaning, sometimes we can figure out the meaning of a text by just looking at the individual words, regardless of their order in the sentence. For example, when classifying news, words like <em>weather</em>, <em>snow</em> are likely to indicate <em>weather forecast</em>, while words like <em>stocks</em>, <em>dollar</em> would count towards <em>financial news</em>.</p>
<p><strong>Bag of Words</strong> (BoW) vector representation is the most commonly used traditional vector representation. Each word is linked to a vector index, vector element contains the number of occurrences of a word in a given document. But, <strong>BoW</strong> does not consider the sequence of words in text</p>
<p>Example:</p>
<blockquote>
<p>John likes to watch movies. Mary likes too.</p>
<p>John also likes to watch football games.</p>
</blockquote>
<p>Dictionary:</p>
<blockquote>
<p>{"John": 1, "likes": 2, "to": 3, "watch": 4, "movies": 5, "also": 6, "football": 7, "games": 8, "Mary": 9, "too": 10}</p>
</blockquote>
<p>Transform : the vector element means the number of occurrences of a word in a given sentence</p>
<blockquote>
<p>[1, 2, 1, 1, 1, 0, 0, 0, 1, 1]</p>
<p>[1, 1, 1, 1, 0, 1, 1, 1, 0, 0]</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bag_on_words</span>(<span class="params">x</span>):</span></span><br><span class="line">    vocab_size = <span class="built_in">len</span>(vocab)</span><br><span class="line">    <span class="comment"># each word location in vocab</span></span><br><span class="line">    location_on_vocab = [vocab[i] <span class="keyword">for</span> i <span class="keyword">in</span> tokenizer(x)]</span><br><span class="line">    bow = torch.zeros(vocab_size, dtype=torch.float32)</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> location_on_vocab:</span><br><span class="line">        <span class="keyword">if</span> l &lt; vocab_size:</span><br><span class="line">            bow[l] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> bow</span><br></pre></td></tr></table></figure>
<p>Since often vocabulary size is pretty big, we can limit the size of the vocabulary to most frequent words.</p>
<h3 id="training-bow-classifier">Training BoW classifier</h3>
<p>convert dataset for training in such a way, that all positional vector representations are converted to bag-of-words representation. This can be achieved by passing <code>bowify</code> function as <code>collate_fn</code> parameter to standard torch <code>DataLoader</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># this collate function gets list of batch_size tuples, and needs to</span></span><br><span class="line"><span class="comment"># return a pair of label-feature tensors for the whole minibatch</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bowify</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        torch.stack([bag_on_words(t[<span class="number">1</span>]) <span class="keyword">for</span> t <span class="keyword">in</span> x]),</span><br><span class="line">        torch.LongTensor([t[<span class="number">0</span>] - <span class="number">1</span> <span class="keyword">for</span> t <span class="keyword">in</span> x])</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">builtins.training_dataloader = DataLoader(training_data, batch_size=batch_size, collate_fn=bowify, shuffle=<span class="literal">True</span>)</span><br><span class="line">builtins.valid_dataloader = DataLoader(valid_data, batch_size=batch_size, collate_fn=bowify, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="one-linear-layer">One linear layer</h3>
<p>Now let's define a simple classifier neural network that contains one linear layer. The size of the input vector equals to <code>vocab_size</code>, and output size corresponds to the number of classes (4). Because we are solving classification task, the final activation function is <code>LogSoftmax()</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneLinearLayer</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(OneLinearLayer, self).__init__()</span><br><span class="line">        self.linear = nn.Sequential(</span><br><span class="line">            nn.Linear(in_features=vocab_size, out_features=<span class="number">4</span>),</span><br><span class="line">            nn.LogSoftmax(dim=<span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.linear(x)</span><br></pre></td></tr></table></figure>
<h3 id="training">training</h3>
<p>Standard training loop</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">net, training_dataloader, test_dataloader, optimizer=<span class="literal">None</span>, loss_fn=nn.CrossEntropyLoss(<span class="params"></span>)</span>):</span></span><br><span class="line">    hist = &#123;<span class="string">&#x27;train_loss&#x27;</span>: [], <span class="string">&#x27;train_acc&#x27;</span>: [], <span class="string">&#x27;val_loss&#x27;</span>: [], <span class="string">&#x27;val_acc&#x27;</span>: []&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, epoch + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;epoch: <span class="subst">&#123;i&#125;</span>\n------------------------------------------&quot;</span>)</span><br><span class="line">        net.train()</span><br><span class="line">        size, acc, total_loss, batch = <span class="built_in">len</span>(training_dataloader.dataset), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        optimizer = op.Adam(net.parameters(), lr=learning_rate) <span class="keyword">if</span> optimizer <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> optimizer</span><br><span class="line">        <span class="keyword">for</span> batch, (x, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(training_dataloader):</span><br><span class="line">            pred_y = net(x)</span><br><span class="line">            loss = loss_fn(pred_y, y)</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">            total_loss += loss.item()</span><br><span class="line">            acc += (pred_y.argmax(<span class="number">1</span>) == y).<span class="built_in">type</span>(torch.<span class="built_in">float</span>).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> batch % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;train loss: <span class="subst">&#123;loss:&gt;5f&#125;</span>   [<span class="subst">&#123;batch * batch_size&#125;</span>/<span class="subst">&#123;size&#125;</span>]&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;train_loss: <span class="subst">&#123;total_loss / batch:&gt;5f&#125;</span>     train_acc: <span class="subst">&#123;acc / size:&gt;5f&#125;</span>     <span class="subst">&#123;size&#125;</span>&quot;</span>)</span><br><span class="line">        hist[<span class="string">&#x27;train_loss&#x27;</span>].append(total_loss / batch)</span><br><span class="line">        hist[<span class="string">&#x27;train_acc&#x27;</span>].append(acc / size)</span><br><span class="line">        net.<span class="built_in">eval</span>()</span><br><span class="line">        size, acc, total_loss, count = <span class="built_in">len</span>(test_dataloader.dataset), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> test_dataloader:</span><br><span class="line">                pred_y = net(x)</span><br><span class="line">                total_loss += loss_fn(pred_y, y).item()</span><br><span class="line">                acc += (pred_y.argmax(dim=<span class="number">1</span>) == y).<span class="built_in">type</span>(torch.<span class="built_in">float</span>).<span class="built_in">sum</span>().item()</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;val_loss: <span class="subst">&#123;total_loss / count:&gt;5f&#125;</span>     val_acc: <span class="subst">&#123;acc / size:&gt;5f&#125;</span>     <span class="subst">&#123;size&#125;</span>\n&quot;</span>)</span><br><span class="line">            hist[<span class="string">&#x27;val_loss&#x27;</span>].append(total_loss / count)</span><br><span class="line">            hist[<span class="string">&#x27;val_acc&#x27;</span>].append(acc / size)</span><br><span class="line">    <span class="keyword">return</span> hist</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    load_data()</span><br><span class="line">    model = OneLinearLayer()</span><br><span class="line">    summary(model, input_size=(<span class="number">1</span>, vocab_size))</span><br><span class="line">    hist = train(model, training_dataloader, valid_dataloader, print_step=<span class="number">1000</span>)</span><br><span class="line">    plot_acc_loss(hist)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="4.png" alt="1" style="zoom:50%;" /></p>
<h3 id="bigrams-trigrams-and-n-grams">BiGrams, TriGrams and N-Grams</h3>
<blockquote>
<p><strong>Bag-of-Words</strong> 方法的一个局限性是，有些词是多词表达的一部分，例如，"热狗 "这个词与其他语境中的 "热 "和 "狗 "的含义完全不同。如果我们总是用相同的向量来表示 "热 "和 "狗 "这两个词，就会使我们的模型混乱。</p>
<p><strong>N-gram</strong> 表示经常用于文档分类的方法中，其中每个word、bi-word 或 tri-word 的频率是训练分类器的有用特征。例如，在大词表征中，除了原始词之外，我们将把所有的词对加入到<strong>vocabulary</strong>中。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bigram_vectorizer = CountVectorizer(ngram_range=(<span class="number">1</span>, <span class="number">2</span>), token_pattern=<span class="string">r&#x27;\b\w+\b&#x27;</span>, min_df=<span class="number">1</span>)</span><br><span class="line">corpus = [</span><br><span class="line">        <span class="string">&#x27;I like hot dogs.&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;The dog ran fast.&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Its hot outside.&#x27;</span>,</span><br><span class="line">    ]</span><br><span class="line">bigram_vectorizer.fit_transform(corpus)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Vocabulary:\n&quot;</span>,bigram_vectorizer.vocabulary_)</span><br><span class="line">bigram_vectorizer.transform([<span class="string">&#x27;My dog likes hot dogs on a hot day.&#x27;</span>]).toarray()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">Vocabulary:</span><br><span class="line"> &#123;<span class="string">&#x27;i&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;like&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;hot&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;dogs&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;i like&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;like hot&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;hot dogs&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;the&#x27;</span>: <span class="number">16</span>, <span class="string">&#x27;dog&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;ran&#x27;</span>: <span class="number">14</span>, <span class="string">&#x27;fast&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;the dog&#x27;</span>: <span class="number">17</span>, <span class="string">&#x27;dog ran&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;ran fast&#x27;</span>: <span class="number">15</span>, <span class="string">&#x27;its&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;outside&#x27;</span>: <span class="number">13</span>, <span class="string">&#x27;its hot&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;hot outside&#x27;</span>: <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>N-gram方法的主要缺点是，词汇量开始极速增长。在实践中，我们需要将N-gram表示法与一些降维技术结合起来，如embeddings 技术。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tokenizer = torchtext.data.utils.get_tokenizer(<span class="string">&#x27;basic_english&#x27;</span>)</span><br><span class="line">counter = collections.Counter()</span><br><span class="line"><span class="keyword">for</span> (label, line) <span class="keyword">in</span> training_data:</span><br><span class="line">		counter.update(torchtext.data.utils.ngrams_iterator(line, ngrams=<span class="number">2</span>))</span><br><span class="line">bi_vocab = torchtext.vocab.vocab(counter, min_freq=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="term-frequency-inverse-document-frequency-tf-idf">Term Frequency Inverse Document Frequency (TF-IDF)</h3>
<blockquote>
<p>在BoW表示法中，无论单词本身如何，单词出现的权重是均匀的。然而，很明显，频繁出现的词，如a、in等，对于分类来说，其重要性远远低于专业术语。事实上，在大多数NLP任务中，有些词比其他词更有意义。</p>
<p>TF-IDF是 bag of words 的一个变种，用一个浮点值代替表示一个词在文档中出现的二进制0/1值，它与语料库中的词出现频率有关。</p>
<p>the weight <span class="math inline">\(w_{ij}\)</span> of a word <span class="math inline">\(i\)</span> in the document <span class="math inline">\(j\)</span> is defined as:</p>
</blockquote>
<p><span class="math display">\[
w_{ij} = tf_{ij}\times\log({N\over df_i})
\]</span></p>
<blockquote>
<p>where</p>
<ul>
<li><span class="math inline">\(tf_{ij}\)</span> is the number of occurrences of <span class="math inline">\(i\)</span> in <span class="math inline">\(j\)</span>, i.e. the BoW value we have seen before</li>
<li><span class="math inline">\(N\)</span> is the number of documents in the collection</li>
<li><span class="math inline">\(df_i\)</span> is the number of documents containing the word <span class="math inline">\(i\)</span> in the whole collection</li>
</ul>
<p>TF-IDF value <span class="math inline">\(w_{ij}\)</span> increases proportionally to the number of times a word appears in a document and is offset by the number of documents in the corpus that contains the word, which helps to adjust for the fact that some words appear more frequently than others.</p>
<p>For example, if the word appears in <strong>every</strong> document in the collection, <span class="math inline">\(df_i=N\)</span>, then <span class="math inline">\(w_{ij}=0\)</span>, and those terms would be completely disregarded.</p>
<p>然而，即使TF-IDF表示法为不同的词提供频率权重，它们也无法表示意义或顺序。正如著名的语言学家J.R.Firth在1935年所说："一个词的完整意义总是与上下文有关的，离开了上下文，对意义的研究就无法认真对待"。</p>
</blockquote>
<h3 id="represent-words-with-embeddings">Represent words with embeddings</h3>
<blockquote>
<p>One-hot 表示法不具有记忆效率，此外，每个词都是独立处理的，即 one-hot 编码向量不表达词之间的任何语义相似性。Enbedding 的想法是用低维的密集向量来表示 word ，这在某种程度上反映了一个词的语义。我们将在后面讨论如何建立有意义的单词嵌入，但现在我们只把嵌入看作是降低单词向量维度的一种方法。</p>
<p>embedding layer 将接受一个词作为输入，并产生一个 embedding_size 的输出向量。从某种意义上说，它与线性层非常相似，但它不是取一个 one-hot 的向量，而是取一个 <strong>word number ( word 在vocabulary 中出现的位置 ) </strong>作为输入。</p>
<p>embedding向量的性质是能使距离相近的向量对应的物体有相近的含义，比如 Embedding(复仇者联盟)和Embedding(钢铁侠)之间的距离就会很接近，但 Embedding(复仇者联盟)和Embedding(乱世佳人)的距离就会远一些。</p>
<p>通过使用<strong>embedding layer</strong>作为我们网络中的第一层，我们可以从 <strong>bag of words model</strong>转换为<strong>embedding bag model </strong>，我们首先将文本中的每个字转换为相应的<strong>embeddings</strong>，然后计算所有这些 embeddings 的一些集合函数，如sum、average或最max。</p>
</blockquote>
<p><img src="1.png" alt="1" style="zoom:20%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmbedClassifier</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, vocab_size, embed_dim, num_class</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.embedding = torch.nn.Embedding(vocab_size, embed_dim)</span><br><span class="line">        self.fc = torch.nn.Linear(embed_dim, num_class)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.embedding(x)</span><br><span class="line">        x = torch.mean(x,dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.fc(x)</span><br><span class="line">       </span><br></pre></td></tr></table></figure>
<h3 id="dealing-with-variable-sequence-size">Dealing with variable sequence size</h3>
<blockquote>
<p>由于这种架构，对我们的网络的<strong>minibatches</strong>需要以某种方式创建。在上一个单元中，当使用<strong>bag of words</strong>时，不管我们的文本序列的实际长度如何，minibatch中的所有BoW张量都具有相同的大小vocab_size。</p>
<p>一旦我们使用 embedding，我们最终会发现每个文本样本中的字数是不一样的，当把这些样本合并成minibatch时，我们必须应用一些填充。这可以通过向数据源提供collate_fn函数的相同技术来完成。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">padify</span>(<span class="params">b</span>):</span></span><br><span class="line">    <span class="comment"># b is the list of tuples of length batch_size</span></span><br><span class="line">    <span class="comment">#   - first element of a tuple = label,</span></span><br><span class="line">    <span class="comment">#   - second = feature (text sequence)</span></span><br><span class="line">    <span class="comment"># build vectorized sequence</span></span><br><span class="line">    v = [encode(x[<span class="number">1</span>]) <span class="keyword">for</span> x <span class="keyword">in</span> b]</span><br><span class="line">    <span class="comment"># first, compute max length of a sequence in this minibatch</span></span><br><span class="line">    l = <span class="built_in">max</span>(<span class="built_in">map</span>(<span class="built_in">len</span>, v))</span><br><span class="line">    <span class="keyword">return</span> (  <span class="comment"># tuple of two tensors - labels and features</span></span><br><span class="line">        torch.stack(</span><br><span class="line">            [torch.nn.functional.pad(torch.tensor(t), (<span class="number">0</span>, l - <span class="built_in">len</span>(t)), mode=<span class="string">&#x27;constant&#x27;</span>, value=<span class="number">0</span>) <span class="keyword">for</span> t <span class="keyword">in</span> v]),</span><br><span class="line">        torch.LongTensor([t[<span class="number">0</span>] - <span class="number">1</span> <span class="keyword">for</span> t <span class="keyword">in</span> b]),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">train_dataloader = torch.utils.data.DataLoader(train_dataset, batch_size=<span class="number">16</span>, collate_fn=padify, shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>train</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    load_data()</span><br><span class="line">    <span class="comment"># Embedding 到 32 dimension</span></span><br><span class="line">    model = EmbedClassifier(<span class="number">32</span>, <span class="built_in">len</span>(classes))</span><br><span class="line">    summary(model)    <span class="comment"># print(model)</span></span><br><span class="line">    hist = train(model, training_dataloader, valid_dataloader, print_step=<span class="number">1000</span>)</span><br><span class="line">    plot_acc_loss(hist)</span><br><span class="line">    </span><br><span class="line">---------------------------------------------------------</span><br><span class="line">=================================================================</span><br><span class="line">Layer (<span class="built_in">type</span>:depth-idx)                   Param <span class="comment">#</span></span><br><span class="line">=================================================================</span><br><span class="line">EmbedClassifier                          --</span><br><span class="line">├─Embedding: <span class="number">1</span>-<span class="number">1</span>                         <span class="number">3</span>,065,<span class="number">920</span></span><br><span class="line">├─Linear: <span class="number">1</span>-<span class="number">2</span>                            <span class="number">132</span></span><br><span class="line">=================================================================</span><br><span class="line">Total params: <span class="number">3</span>,066,052</span><br><span class="line">Trainable params: <span class="number">3</span>,066,052</span><br><span class="line">Non-trainable params: <span class="number">0</span></span><br><span class="line">=================================================================</span><br><span class="line">....</span><br><span class="line">epoch: <span class="number">10</span></span><br><span class="line">------------------------------------------</span><br><span class="line">train loss: <span class="number">0.118139</span>   [<span class="number">0</span>/<span class="number">96000</span>]</span><br><span class="line">train loss: <span class="number">0.083000</span>   [<span class="number">32000</span>/<span class="number">96000</span>]</span><br><span class="line">train loss: <span class="number">0.061542</span>   [<span class="number">64000</span>/<span class="number">96000</span>]</span><br><span class="line">train_loss: <span class="number">0.131295</span>     train_acc: <span class="number">0.959406</span>     <span class="number">96000</span></span><br><span class="line">val_loss: <span class="number">0.258924</span>     val_acc: <span class="number">0.916708</span>     <span class="number">24000</span></span><br></pre></td></tr></table></figure>
<p><img src="5.png" alt="1" style="zoom:50%;" /></p>
<h3 id="embedding-bag-layer-and-variable-length-sequence-representation">Embedding Bag Layer and Variable-Length Sequence Representation</h3>
<p>上面，我们需要将所有序列填充到相同的长度，以便将它们装入 minibatch 中。 这不是表示可变长度序列的最有效的方法 - 另一个apporach是使用 <strong>offset vector</strong>，这将所有序列的偏移存储在一个大的向量。</p>
<p><img src="2.png" alt="1" style="zoom:20%;" /></p>
<p>To work with offset representation, we use <a href="https://pytorch.org/docs/stable/generated/torch.nn.EmbeddingBag.html"><code>EmbeddingBag</code></a> layer. It is similar to <code>Embedding</code>, but it takes content vector and offset vector as input, and it also includes averaging layer, which can be <code>mean</code>, <code>sum</code> or <code>max</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmbedClassifier</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, vocab_size, embed_dim, num_class</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.embedding = torch.nn.EmbeddingBag(vocab_size, embed_dim)</span><br><span class="line">        self.fc = torch.nn.Linear(embed_dim, num_class)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, text, off</span>):</span></span><br><span class="line">        x = self.embedding(text, off)</span><br><span class="line">        <span class="keyword">return</span> self.fc(x)</span><br></pre></td></tr></table></figure>
<p>To prepare the dataset for training, we need to provide a conversion function that will prepare the offset vector:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">offsetify</span>(<span class="params">b</span>):</span></span><br><span class="line">    <span class="comment"># first, compute data tensor from all sequences</span></span><br><span class="line">    x = [torch.tensor(encode(t[<span class="number">1</span>])) <span class="keyword">for</span> t <span class="keyword">in</span> b]</span><br><span class="line">    <span class="comment"># now, compute the offsets by accumulating the tensor of sequence lengths</span></span><br><span class="line">    o = [<span class="number">0</span>] + [<span class="built_in">len</span>(t) <span class="keyword">for</span> t <span class="keyword">in</span> x]</span><br><span class="line">    o = torch.tensor(o[:-<span class="number">1</span>]).cumsum(dim=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ( </span><br><span class="line">        torch.LongTensor([t[<span class="number">0</span>]-<span class="number">1</span> <span class="keyword">for</span> t <span class="keyword">in</span> b]), <span class="comment"># labels</span></span><br><span class="line">        torch.cat(x), <span class="comment"># text </span></span><br><span class="line">        o</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">train_loader = torch.utils.data.DataLoader(train_dataset, batch_size=<span class="number">16</span>, collate_fn=offsetify, shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note, that unlike in all previous examples, our network now accepts two parameters: data vector and offset vector, which are of different sizes. Sililarly, our data loader also provides us with 3 values instead of 2: both text and offset vectors are provided as features. Therefore, we need to slightly adjust our training function to take care of that:</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = EmbedClassifier(vocab_size,<span class="number">32</span>,<span class="built_in">len</span>(classes)).to(device)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_epoch_emb</span>(<span class="params">net,dataloader,lr=<span class="number">0.01</span>,optimizer=<span class="literal">None</span>,loss_fn = torch.nn.CrossEntropyLoss(<span class="params"></span>),epoch_size=<span class="literal">None</span>, report_freq=<span class="number">200</span></span>):</span></span><br><span class="line">    optimizer = optimizer <span class="keyword">or</span> torch.optim.Adam(net.parameters(),lr=lr)</span><br><span class="line">    loss_fn = loss_fn.to(device)</span><br><span class="line">    net.train()</span><br><span class="line">    total_loss,acc,count,i = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> labels,text,off <span class="keyword">in</span> dataloader:</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        labels,text,off = labels.to(device), text.to(device), off.to(device)</span><br><span class="line">        out = net(text, off)</span><br><span class="line">        loss = loss_fn(out,labels) <span class="comment">#cross_entropy(out,labels)</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        total_loss+=loss</span><br><span class="line">        _,predicted = torch.<span class="built_in">max</span>(out,<span class="number">1</span>)</span><br><span class="line">        acc+=(predicted==labels).<span class="built_in">sum</span>()</span><br><span class="line">        count+=<span class="built_in">len</span>(labels)</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i%report_freq==<span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;count&#125;</span>: acc=<span class="subst">&#123;acc.item()/count&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> epoch_size <span class="keyword">and</span> count&gt;epoch_size:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> total_loss.item()/count, acc.item()/count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_epoch_emb(net,train_loader, lr=<span class="number">4</span>, epoch_size=<span class="number">25000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="6.png" alt="1" style="zoom:50%;" /></p>
<h3 id="semantic-embeddings-word2vec">Semantic Embeddings: Word2Vec</h3>
<blockquote>
<p>在之前的例子中，模型的嵌入层学会了将单词映射为矢量表示，然而，这种表示并没有太多的语义意义。如果能学会这样的向量表示，即类似的词或症状词将对应于在某些向量距离（例如，欧几里得距离）上彼此接近的向量。</p>
<p>要做到这一点，我们需要以一种特定的方式在大量的文本集合上预训练我们的嵌入模型。训练语义嵌入的最初方式之一被称为Word2Vec。它是基于两个主要的架构，用来产生单词的分布式表示。</p>
<p>- <strong>Continuous bag-of-words</strong> (CBoW) — in this architecture, we train the model to predict a word from surrounding context. Given the ngram <span class="math inline">\((W_{-2},W_{-1},W_0,W_1,W_2)\)</span>, the goal of the model is to predict <span class="math inline">\(W_0\)</span> from <span class="math inline">\((W_{-2},W_{-1},W_1,W_2)\)</span>.</p>
<p>- <strong>Continuous skip-gram</strong> is opposite to CBoW. The model uses surrounding window of context words to predict the current word.</p>
</blockquote>
<p><img src="3.png" alt="1" style="zoom:80%;" /></p>
<blockquote>
<p>To experiment with word2vec embedding pre-trained on Google News dataset, we can use <strong>gensim</strong> library. Below we find the words most similar to 'neural'</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w2v = api.load(<span class="string">&#x27;word2vec-google-news-300&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> w, p <span class="keyword">in</span> w2v.most_similar(<span class="string">&#x27;neural&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;w&#125;</span> -&gt; <span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line">      </span><br><span class="line">----------------------------------------------------------</span><br><span class="line">neuronal -&gt; <span class="number">0.7804799675941467</span></span><br><span class="line">neurons -&gt; <span class="number">0.7326499819755554</span></span><br><span class="line">neural_circuits -&gt; <span class="number">0.7252851128578186</span></span><br><span class="line">neuron -&gt; <span class="number">0.7174385786056519</span></span><br><span class="line">cortical -&gt; <span class="number">0.6941086649894714</span></span><br><span class="line">brain_circuitry -&gt; <span class="number">0.6923246383666992</span></span><br><span class="line">synaptic -&gt; <span class="number">0.669911801815033</span></span><br><span class="line">neural_circuitry -&gt; <span class="number">0.6638562679290771</span></span><br><span class="line">neurochemical -&gt; <span class="number">0.6555314660072327</span></span><br><span class="line">neuronal_activity -&gt; <span class="number">0.6531826257705688</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>We can also extract vector embeddings from the word, to be used in training classification model (we only show first 20 components of the vector for clarity):</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(w2v.get_vector(<span class="string">&#x27;play&#x27;</span>)[:<span class="number">20</span>])</span><br><span class="line">&lt;<span class="built_in">input</span>&gt;:<span class="number">1</span>: DeprecationWarning: Call to deprecated `word_vec` (Use get_vector instead).</span><br><span class="line">[ <span class="number">0.01226807</span>  <span class="number">0.06225586</span>  <span class="number">0.10693359</span>  <span class="number">0.05810547</span>  <span class="number">0.23828125</span>  <span class="number">0.03686523</span></span><br><span class="line">  <span class="number">0.05151367</span> -<span class="number">0.20703125</span>  <span class="number">0.01989746</span>  <span class="number">0.10058594</span> -<span class="number">0.03759766</span> -<span class="number">0.1015625</span></span><br><span class="line"> -<span class="number">0.15820312</span> -<span class="number">0.08105469</span> -<span class="number">0.0390625</span>  -<span class="number">0.05053711</span>  <span class="number">0.16015625</span>  <span class="number">0.2578125</span></span><br><span class="line">  <span class="number">0.10058594</span> -<span class="number">0.25976562</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Great thing about semantical embeddings is that you can manipulate vector encoding to change the semantics. For example, we can ask to find a word, whose vector representation would be as close as possible to words <em>king</em> and <em>woman</em>, and as far away from the word <em>man</em>:</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>w2v.most_similar(positive=[<span class="string">&#x27;king&#x27;</span>,<span class="string">&#x27;woman&#x27;</span>],negative=[<span class="string">&#x27;man&#x27;</span>])[<span class="number">0</span>]</span><br><span class="line">(<span class="string">&#x27;queen&#x27;</span>, <span class="number">0.7118193507194519</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Both CBOW and Skip-Grams are “predictive” embeddings, in that they only take local contexts into account. Word2Vec does not take advantage of global context.</p>
<p><strong>FastText</strong>, builds on Word2Vec by learning vector representations for each word and the charachter n-grams found within each word. The values of the representations are then averaged into one vector at each training step. While this adds a lot of additional computation to pre-training it enables word embeddings to encode sub-word information.</p>
<p>Another method, <strong>GloVe</strong>, leverages the idea of co-occurence matrix, uses neural methods to decompose co-occurrence matrix into more expressive and non linear word vectors.</p>
</blockquote>
<h3 id="using-pre-trained-embeddings-in-pytorch">Using Pre-Trained Embeddings in PyTorch</h3>
<blockquote>
<p>We can modify the example above to pre-populate the matrix in our embedding layer with semantical embeddings, such as Word2Vec. We need to take into account that vocabularies of pre-trained embedding and our text corpus will likely not match, so we will initialize weights for the missing words with random values:</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PreTrainedW2VEmbed</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, w2v, embed_dim, num_class</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(PreTrainedW2VEmbed, self).__init__()</span><br><span class="line">        self.embed_size = <span class="built_in">len</span>(w2v.get_vector(<span class="string">&#x27;Hello&#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Embedding size: <span class="subst">&#123;self.embed_size&#125;</span>&#x27;</span>)</span><br><span class="line">        self.embed_classifier = EmbedOffsetClassifier(embed_dim, num_class)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Populating matrix, this will take some time...&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        found, not_found = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, w <span class="keyword">in</span> <span class="built_in">enumerate</span>(vocab.get_stoi()):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.embed_classifier.embedding.weight[i].data = torch.tensor(w2v.get_vector(w))</span><br><span class="line">                found += <span class="number">1</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                self.embed_classifier.embedding.weight[i].data = torch.normal(<span class="number">0.0</span>, <span class="number">1.0</span>, (self.embed_size,))</span><br><span class="line">                not_found += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Done, found <span class="subst">&#123;found&#125;</span> words, <span class="subst">&#123;not_found&#125;</span> words missing&quot;</span>)</span><br><span class="line">        self.embed_classifier.to(device)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, o</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.embed_classifier(x, o)</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_w2v_embed_off</span>():</span></span><br><span class="line">    load_data(<span class="string">&#x27;embedding_offset&#x27;</span>)</span><br><span class="line">    w2v = api.load(<span class="string">&#x27;word2vec-google-news-300&#x27;</span>)</span><br><span class="line">    <span class="comment"># Embedding 到 32 dimension</span></span><br><span class="line">    model = PreTrainedW2VEmbed(w2v, <span class="number">32</span>, <span class="built_in">len</span>(classes))</span><br><span class="line">    summary(model)  <span class="comment"># print(model)</span></span><br><span class="line">    hist = train_embed_offset(model, training_dataloader, valid_dataloader, print_step=<span class="number">1000</span>)</span><br><span class="line">    plot_acc_loss(hist)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    train_w2v_embed_off()</span><br><span class="line">   </span><br><span class="line">Embedding size: <span class="number">300</span></span><br><span class="line">Populating matrix, this will take some time...Done, found <span class="number">41080</span> words, <span class="number">54730</span> words missing</span><br><span class="line">=================================================================</span><br><span class="line">Layer (<span class="built_in">type</span>:depth-idx)                   Param <span class="comment">#</span></span><br><span class="line">=================================================================</span><br><span class="line">PreTrainedW2VEmbed                       --</span><br><span class="line">├─EmbedOffsetClassifier: <span class="number">1</span>-<span class="number">1</span>             --</span><br><span class="line">│    └─EmbeddingBag: <span class="number">2</span>-<span class="number">1</span>                 <span class="number">3</span>,065,<span class="number">920</span></span><br><span class="line">│    └─Linear: <span class="number">2</span>-<span class="number">2</span>                       <span class="number">132</span></span><br><span class="line">=================================================================</span><br><span class="line">Total params: <span class="number">3</span>,066,052</span><br><span class="line">Trainable params: <span class="number">3</span>,066,052</span><br><span class="line">Non-trainable params: <span class="number">0</span></span><br><span class="line">=================================================================</span><br></pre></td></tr></table></figure>
<p><img src="7.png" alt="1" style="zoom:60%;" /></p>
<blockquote>
<p>In our case we do not see huge increase in accuracy, which is likely to quite different vocalularies. To overcome the problem of different vocabularies, we can use one of the following solutions:</p>
<ul>
<li>Re-train word2vec model on our vocabulary</li>
<li>Load our dataset with the vocabulary from the pre-trained word2vec model. Vocabulary used to load the dataset can be specified during loading.</li>
</ul>
<p>The latter approach seems easiter, especially because PyTorch <code>torchtext</code> framework contains built-in support for embeddings. We can, for example, instantiate GloVe-based vocabulary in the following manner:</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vocab = torchtext.vocab.GloVe(name=<span class="string">&#x27;6B&#x27;</span>, dim=<span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Loaded vocabulary has the following basic operations:</p>
<ul>
<li><code>vocab.stoi</code> dictionary allows us to convert word into its dictionary index</li>
<li><code>vocab.itos</code> does the opposite - converts number into word</li>
<li><code>vocab.vectors</code> is the array of embedding vectors, so to get the embedding of a word <code>s</code> we need to use <code>vocab.vectors[vocab.stoi[s]]</code></li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_with_gloVe_vocab</span>():</span></span><br><span class="line">    <span class="comment"># Process finished with exit code 137 (interrupted by signal 9: SIGKILL) 内存不足</span></span><br><span class="line">    vocab = torchtext.vocab.GloVe(name=<span class="string">&#x27;6B&#x27;</span>, dim=<span class="number">50</span>)</span><br><span class="line">    load_data(<span class="string">&#x27;embedding_offset&#x27;</span>, vocab=vocab)</span><br><span class="line">    net = EmbedOffsetClassifier(vocab_size, <span class="built_in">len</span>(classes))</span><br><span class="line">    net.embedding.weight.data = vocab.vectors</span><br><span class="line">    hist = train_embed_offset(net,training_dataloader, valid_dataloader)</span><br><span class="line">    plot_acc_loss(hist)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    train_with_gloVe_vocab()</span><br></pre></td></tr></table></figure>
<p>训练过程电脑内存不足，vocab_size=400000，参数过多</p>
]]></content>
      <categories>
        <category>PyTorch</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
        <tag>python</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV三种方式</title>
    <url>/2020/03/04/OpenCV%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="android-studio使用-opencv三种方式">Android Studio使用 OpenCV三种方式</h1>
<blockquote>
<p>开发环境：Android Studio 3.5 &amp;&amp; macOS 10.15</p>
</blockquote>
<p>在 Android 使用 OpenCV，一般有三种方法：</p>
<ul>
<li>OpenCV Manager + OpenCV-Android-SDK</li>
<li>OpenCV-Android-SDK + OpenCV动态库</li>
<li>JNI + OpenCV 动态库</li>
</ul>
<span id="more"></span>
<h2 id="opencv-manager-opencv-android-sdk">OpenCV Manager + OpenCV-Android-SDK</h2>
<p>原理：利用 Android Service 与 OpenCV Manager APK 跨进程通信</p>
<figure>
<img src="1.jpeg" alt="跨进程通信" /><figcaption aria-hidden="true">跨进程通信</figcaption>
</figure>
<p>要求: 必须安装 OpenCV Manager APK</p>
<p><img src="2.png" alt="2" style="zoom:50%;" /></p>
<p><img src="3.png" alt="2" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>PCA降维算法的Python实现</title>
    <url>/2019/04/17/PCA%E9%99%8D%E7%BB%B4%E7%AE%97%E6%B3%95%E7%9A%84Python%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="摘要">摘要</h1>
<blockquote>
<p>PCA算法本质实际上是n维数据向量空间的基变换，再将数据向量投影在变化之后的基之上，从而达到降维的目的，为了使n维数据向量在降维之后仍能尽可能保持原有的信息量，这就类似于有损压缩的概念（有损压缩是指使用压缩后的数据进行重构，重构后的数据与原来的数据有所不同，但不影响人对原始资料表达的信息造成误解）。所以基的选择自然显得十分重要。</p>
</blockquote>
<span id="more"></span>
<h1 id="信息熵">信息熵</h1>
<p>PCA降维的目的首先就是要尽可能保持其原有的信息量。那么信息的度量或者量化标准则成了一个关键问题。</p>
<blockquote>
<p>所谓信息量是指从N个相等可能事件中选出一个事件所需要的信息度量或含量，也就是在辩识N个事件中特定的一个事件的过程中所需要提问"是或否"的最少次数. —《百度百科》</p>
</blockquote>
<h2 id="信息量与事件的不确定性有关">信息量与事件的不确定性有关</h2>
<p>​ 如果一个事件，不论在什么情况下，发生的结果都不会发生变化，那我们就认为它所包含的信息量为0。比如说一个程序，在代码不变的情况下，只要输入固定其结果必然一定，不论我们运行多少次都是同样的结果，我们从中所能获取的信息几乎为0，因为这件事对我们来说已经是非常确定了的。我们说科学就是探索未知，因为未知包含了无限的可能，包含了无限的信息。</p>
<blockquote>
<p>香农给出了信息度量的定义：信息是用不确定性的量度定义的.一个消息的可能性愈小，其信息愈多；而消息的可能性愈大，则其信息愈少.事件出现的概率小，不确定性越多，信息量就大，反之则少。</p>
</blockquote>
<p>换句话说，信息的度量是与概率相关的。</p>
<h2 id="熵">熵</h2>
<p>依据Boltzmann's H-theorem，香农把随机变量<em>X</em>的熵值 Η定义如下，其值域为{<em>x</em>1, ..., *x**n*}：</p>
<p><img src="5.png" alt="" style="zoom:80%;" /></p>
<p>其中，P为<em>X</em>的概率质量函数（probability mass function），E为期望函数，而I(<em>X</em>)是<em>X</em>的信息量。I(<em>X</em>)本身是个随机变数。</p>
<p>当取自有限的样本时，熵的公式可以表示为：</p>
<p><img src="6.png" alt="" style="zoom:80%;" /></p>
<p>在这里<em>b</em>是对数所使用的底，通常是2,自然常数<strong>e</strong>，或是10。当<em>b</em> = 2，熵的单位是bit；当<em>b</em> = e，熵的单位是nat；而当<em>b</em> = 10,熵的单位是Hart。</p>
<p>*p**i* = 0时，对于一些<em>i</em>值，对应的被加数0 log<em>b</em> 0的值将会是0，这与极限一致。</p>
<p><img src="7.png" alt="" style="zoom:80%;" /></p>
<p>还可以定义事件 <em>X</em> 与 <em>Y</em> 分别取 <em>xi</em> 和 <em>yj</em> 时的<strong>条件熵为</strong></p>
<p><img src="8.png" alt="" style="zoom:80%;" /></p>
<p>其中<em>p</em>(<em>xi</em>, <em>yj</em>)为 <em>X</em> = <em>xi</em> 且 <em>Y</em> = <em>yj</em> 时的概率。这个量应当理解为你知道<em>Y</em>的值前提下随机变量 <em>X</em> 的随机性的量。</p>
<h2 id="熵与方差">熵与方差</h2>
<h3 id="方差">方差</h3>
<p>方差的定义</p>
<p><img src="9.png" alt="" style="zoom:80%;" /></p>
<p>方差越大数据的波动也就越大，其不确定性自然越大,方差描述不确定度在某些情况下会失效，因为它要求数据均匀分布并且忽略极端事件的发生。熵本就是对信息的不确定度的度量，相比于方差必然更加精确。</p>
<h1 id="基的选择">基的选择</h1>
<p>举个栗子：</p>
<p>假设我们的数据由五条记录组成，将它们表示成矩阵形式：</p>
<p><img src="10.png" alt="" style="zoom:80%;" /></p>
<p>其中每一列为一条数据记录，而一行为一个字段。为了后续处理方便，我们首先将每个字段内所有值都减去字段均值，其结果是将每个字段都变为均值为0（这样做的道理和好处后面会看到）。</p>
<p>我们看上面的数据，第一个字段均值为2，第二个字段均值为3，所以变换后：</p>
<p><img src="11.png" alt="" style="zoom:80%;" /></p>
<p>我们可以看下五条数据在平面直角坐标系内的样子：</p>
<p><img src="13.png" alt="" style="zoom:40%;" /></p>
<p>如果我们必须使用一维来表示这些数据，又希望尽量保留原始的信息，你要如何选择？</p>
<p>直观的说这个问题实际上是要在二维平面中选择一个方向，将所有数据都投影到这个方向所在直线上，用投影值表示原始记录。这是一个实际的二维降到一维的问题。</p>
<p>所以数据样本投影到基后的投影值尽可能分散。也就是使得数据变化到基上的坐标后，方差最大。</p>
<h2 id="优化目标">优化目标</h2>
<p>在多维的情况下，基的维数也是多维，因此投影方向也变成了多维问题，且数据样本的字段存在相关性显然，为了使得样本不同字段之间完全独立（相关性意味着两个字段不是完全独立，必然存在重复表示的信息。），选择的基两两之间必然是正交的。即：</p>
<blockquote>
<p><strong>将一组N维向量降为K维（K大于0，小于N），其目标是选择K个单位（模为1）正交基，使得原始数据变换到这组基上后，各字段两两间协方差为0，而字段的方差则尽可能大（在正交的约束下，取最大的K个方差）</strong>。</p>
</blockquote>
<h2 id="协方差矩阵">协方差矩阵</h2>
<p>我们知道最终优化目标与字段内的方差和字段之间的协方差有关(字段之间独立)</p>
<p>对于矩阵x：</p>
<p><img src="1.png" alt="" style="zoom:80%;" /></p>
<p>X乘以X的转置，并乘上系数1/m：</p>
<p><img src="2.png" alt="" style="zoom:80%;" /></p>
<p>我们发现，对角线上的两个元素分别是两个字段的方差，而其它元素是a和b的协方差。要达到优化目前，等价于将协方差矩阵对角化：即除对角线外的其它元素化为0，并且在对角线上将元素按大小从上到下排列，这样我们就达到了优化目的。</p>
<p>设原始数据矩阵X对应的协方差矩阵为C，而P是一组基按行组成的矩阵，设Y=PX，则Y为X对P做基变换后的数据。设Y的协方差矩阵为D，我们推导一下D与C的关系：</p>
<p><img src="3.png" alt="" style="zoom:80%;" /></p>
<p>变化矩阵P就是原始协方差矩阵对角化的P。</p>
<p>我们知道：协方差矩阵C是一个是对称矩阵，在线性代数上，实对称矩阵有一系列非常好的性质：</p>
<p>1）实对称矩阵不同特征值对应的特征向量必然正交。</p>
<p>2）设特征向量λ重数为r，则必然存在r个线性无关的特征向量对应于λ，因此可以将这r个特征向量单位正交化。</p>
<p>则对协方差矩阵C有如下结论：</p>
<p><img src="4.png" alt="" style="zoom:80%;" /></p>
<p>对角元素为各特征向量对应的特征值，P对应与E的转置</p>
<p>P是协方差矩阵的特征向量单位化后按行排列出的矩阵，其中每一行都是C的一个特征向量。如果设P按照ΛΛ中特征值的从大到小，将特征向量从上到下排列，则用P的前K行组成的矩阵乘以原始数据矩阵X，就得到了我们需要的降维后的数据矩阵Y。</p>
<h1 id="pca算法">PCA算法</h1>
<p>设有m条n维数据。</p>
<p>1）将原始数据按列组成n行m列矩阵X</p>
<p>2）将X的每一行（代表一个属性字段）进行零均值化，即减去这一行的均值</p>
<p>3）求出协方差矩阵C</p>
<p>4）求出协方差矩阵的特征值及对应的特征向量</p>
<p>5）将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵P</p>
<p>6）Y=PX即为降维到k维后的数据</p>
<h1 id="结果示例">结果示例</h1>
<p>样本为符合[[-5，5]，[5，-5]]的协方差矩阵的数据</p>
<p><img src="12.png" alt="" style="zoom:80%;" /></p>
<h1 id="python实现代码">Python实现代码</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCA</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, matrix</span>):</span></span><br><span class="line">        self.sign = <span class="literal">False</span></span><br><span class="line">        self.matrix = matrix</span><br><span class="line">        self.m, self.n = matrix.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">normalization</span>(<span class="params">self</span>):</span>  <span class="comment"># 数据中心化</span></span><br><span class="line">        matrix = self.matrix.T</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> matrix:</span><br><span class="line">            i -= np.mean(i)</span><br><span class="line">        <span class="keyword">return</span> matrix</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pca</span>(<span class="params">self, dim</span>):</span></span><br><span class="line">        matrix_T = self.normalization()</span><br><span class="line">        Cov = np.dot(matrix_T, self.matrix) / (self.m - <span class="number">1</span>)</span><br><span class="line">        x, y = np.linalg.eig(Cov)</span><br><span class="line">        eig_pairs = [[np.<span class="built_in">abs</span>(x[i]), y[:, i]] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x))]</span><br><span class="line">        eig_pairs = <span class="built_in">sorted</span>(eig_pairs, reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        Lambda = np.zeros_like(Cov)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line">            Lambda[i][i] = eig_pairs[i][<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># print(&quot;\nLambda\n&quot;, Lambda)</span></span><br><span class="line">        self.sign = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> dim &gt; self.n:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;illegal dimensions&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        P = np.array([eig_pairs[i][<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dim)])  <span class="comment"># 正交变换矩阵P</span></span><br><span class="line">        <span class="comment"># print(&quot;\n正交变换矩阵P：\n&quot;, P)</span></span><br><span class="line">        D = np.dot(np.dot(P, Cov).T, P)</span><br><span class="line">        D[D &lt; <span class="number">0.000001</span>] = <span class="number">0</span></span><br><span class="line">        <span class="comment"># print(&quot;\n目标降维矩阵的协方差矩阵D\n&quot;, D)</span></span><br><span class="line">        new_data_reduced = np.dot(self.matrix, P.T)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>, <span class="number">20</span> * <span class="string">&#x27;-&#x27;</span>, <span class="string">&quot;PCA降到&#123;&#125;维数据前10项&quot;</span>.<span class="built_in">format</span>(dim), <span class="number">20</span> * <span class="string">&#x27;-&#x27;</span>, <span class="string">&quot;\n&quot;</span>, new_data_reduced[:<span class="number">10</span>])</span><br><span class="line">        <span class="keyword">return</span> new_data_reduced</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">ax, data, y</span>):</span></span><br><span class="line">    X_lda = data</span><br><span class="line">    dim = X_lda.shape[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> X_lda.shape[<span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">        X_lda = np.array([[i[<span class="number">0</span>], <span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> X_lda])</span><br><span class="line">    <span class="keyword">if</span> dim == <span class="number">3</span>:</span><br><span class="line">        ax = plt.subplot(<span class="number">111</span>, projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">    label_dict = &#123;<span class="number">0</span>: <span class="string">&#x27;Setosa&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;Versicolor&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Virginica&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> label, marker, color <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">            <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>), (<span class="string">&#x27;^&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;o&#x27;</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)):</span><br><span class="line">        plt.scatter(x=X_lda[:, <span class="number">0</span>][y == label],</span><br><span class="line">                    y=X_lda[:, <span class="number">1</span>][y == label],</span><br><span class="line">                    marker=marker,</span><br><span class="line">                    color=color,</span><br><span class="line">                    alpha=<span class="number">0.5</span>,</span><br><span class="line">                    label=label_dict[label]</span><br><span class="line">                    )</span><br><span class="line"></span><br><span class="line">    leg = plt.legend(loc=<span class="string">&#x27;upper right&#x27;</span>, fancybox=<span class="literal">True</span>)</span><br><span class="line">    leg.get_frame().set_alpha(<span class="number">0.5</span>)</span><br><span class="line">    ax.set_title(<span class="string">&#x27;PCA: Iris onto the first &#123;&#125; linear discriminants&#x27;</span>.<span class="built_in">format</span>(dim))</span><br><span class="line">    <span class="comment"># hide axis ticks</span></span><br><span class="line">    plt.tick_params(axis=<span class="string">&quot;both&quot;</span>, which=<span class="string">&quot;both&quot;</span>, bottom=<span class="string">&quot;off&quot;</span>, top=<span class="string">&quot;off&quot;</span>,</span><br><span class="line">                    labelbottom=<span class="string">&quot;on&quot;</span>, left=<span class="string">&quot;off&quot;</span>, right=<span class="string">&quot;off&quot;</span>, labelleft=<span class="string">&quot;on&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># remove axis spines</span></span><br><span class="line">    ax.spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;bottom&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.tight_layout()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    data = load_iris()[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">    label = load_iris()[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line">    label_dict = &#123;<span class="number">0</span>: <span class="string">&#x27;Setosa&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;Versicolor&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Virginica&#x27;</span>&#125;</span><br><span class="line">    pca = PCA(data)</span><br><span class="line">    pca_2d = pca.pca(<span class="number">2</span>)</span><br><span class="line">    pca_3d = pca.pca(<span class="number">3</span>)</span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line">    ax1 = fig.add_subplot(<span class="number">121</span>)</span><br><span class="line">    draw(ax1,pca_2d, label)</span><br><span class="line">    ax2 = fig.add_subplot(<span class="number">122</span>, projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">    ax2.scatter(*<span class="built_in">zip</span>(*pca_3d),c=label)</span><br><span class="line">    ax2.set_title(<span class="string">&quot;PCA: Iris onto the first 3 linear discriminants&quot;</span>,size=<span class="number">20</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>PCA</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Datasets &amp; DataLoaders &amp; Transforms</title>
    <url>/2021/06/18/PyTorch-LoadData/</url>
    <content><![CDATA[<h2 id="load-data-with-pytorch-datasets-and-dataloaders">Load data with PyTorch Datasets and DataLoaders</h2>
<p>PyTorch provides two data primitives: <code>torch.utils.data.DataLoader</code> and <code>torch.utils.data.Dataset</code> that allow you to use pre-loaded datasets as well as your own data. <code>Dataset</code> stores the samples and their corresponding labels, and <code>DataLoader</code> wraps an iterable around the <code>Dataset</code> to enable easy access to the samples.</p>
<span id="more"></span>
<h3 id="loading-a-dataset">Loading a dataset</h3>
<p>Load the <a href="https://research.zalando.com/welcome/mission/research-projects/fashion-mnist/">Fashion-MNIST</a> dataset from TorchVision. Fashion-MNIST is a dataset of Zalando’s article images consisting of of 60,000 training examples and 10,000 test examples. Each example comprises a 28×28 grayscale image and an associated label from one of 10 classes.The images show individual articles of clothing at low resolution (28 by 28 pixels), as seen here:</p>
<p><img src="1.png" alt="1" style="zoom:60%;" /></p>
<p>The <a href="https://pytorch.org/vision/stable/datasets.html#fashion-mnist">FashionMNIST Dataset</a> with the following parameters:</p>
<p>Parameters + <code>root</code> (string) – Root directory of dataset where <code>FashionMNIST/processed/training.pt</code> and <code>FashionMNIST/processed/test.pt</code>exist.</p>
<ul>
<li><p><code>train</code> (bool, optional) – If True, creates dataset from training.pt, otherwise from test.pt.</p></li>
<li><p><code>download</code> (bool, optional) – If true, downloads the dataset from the internet and puts it in root directory. If dataset is already downloaded, it is not downloaded again.</p></li>
<li><p><code>transform</code> (callable, optional) – A function/transform that takes in an PIL image and returns a transformed version. E.g, transforms.RandomCrop</p></li>
<li><p><code>target_transform</code> (callable, optional) – A function/transform that takes in the target and transforms it.</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms <span class="keyword">import</span> ToTensor, Lambda</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">training_data = datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;data&quot;</span>,</span><br><span class="line">    train=<span class="literal">True</span>,</span><br><span class="line">    download=<span class="literal">True</span>,</span><br><span class="line">    <span class="comment">#ToTensor converts a PIL image or NumPy ndarray into a FloatTensor and </span></span><br><span class="line">    <span class="comment">#scales the image&#x27;s pixel intensity values in the range [0., 1.]</span></span><br><span class="line">    transform=ToTensor()</span><br><span class="line">    <span class="comment">#define a function to turn the integer into a one-hot encoded tensor.</span></span><br><span class="line">    <span class="comment">#It first creates a zero tensor of size 10 (the number of labels in our dataset) and </span></span><br><span class="line">    <span class="comment">#calls scatter which assigns a value=1 on the index as given by the label y.</span></span><br><span class="line">    target_transform=Lambda(<span class="keyword">lambda</span> y: torch.zeros(<span class="number">10</span>, dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">                                    .scatter_(dim=<span class="number">0</span>, index=torch.tensor(y), value=<span class="number">1</span>))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">test_data = datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;data&quot;</span>,</span><br><span class="line">    train=<span class="literal">False</span>,</span><br><span class="line">    download=<span class="literal">True</span>,</span><br><span class="line">    transform=ToTensor()</span><br><span class="line">    <span class="comment">#define a function to turn the integer into a one-hot encoded tensor.</span></span><br><span class="line">    <span class="comment">#It first creates a zero tensor of size 10 (the number of labels in our dataset) and </span></span><br><span class="line">    <span class="comment">#calls scatter which assigns a value=1 on the index as given by the label y.</span></span><br><span class="line">    target_transform=Lambda(<span class="keyword">lambda</span> y: torch.zeros(<span class="number">10</span>, dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">                                    .scatter_(dim=<span class="number">0</span>, index=torch.tensor(y), value=<span class="number">1</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="iterating-and-visualizing-the-dataset">Iterating and Visualizing the Dataset</h3>
<p>We can index <code>Datasets</code> manually like a list: <code>training_data[index]</code>. We use <code>matplotlib</code> to visualize some samples in our training data.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">labels_map = &#123;</span><br><span class="line">            <span class="number">0</span>: <span class="string">&quot;T-Shirt&quot;</span>,</span><br><span class="line">            <span class="number">1</span>: <span class="string">&quot;Trouser&quot;</span>,</span><br><span class="line">            <span class="number">2</span>: <span class="string">&quot;Pullover&quot;</span>,</span><br><span class="line">            <span class="number">3</span>: <span class="string">&quot;Dress&quot;</span>,</span><br><span class="line">            <span class="number">4</span>: <span class="string">&quot;Coat&quot;</span>,</span><br><span class="line">            <span class="number">5</span>: <span class="string">&quot;Sandal&quot;</span>,</span><br><span class="line">            <span class="number">6</span>: <span class="string">&quot;Shirt&quot;</span>,</span><br><span class="line">            <span class="number">7</span>: <span class="string">&quot;Sneaker&quot;</span>,</span><br><span class="line">            <span class="number">8</span>: <span class="string">&quot;Bag&quot;</span>,</span><br><span class="line">            <span class="number">9</span>: <span class="string">&quot;Ankle Boot&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">figure = plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">training_data, test_data = DataPreparetion.data_load()</span><br><span class="line">cols, rows = <span class="number">4</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cols * rows + <span class="number">1</span>):</span><br><span class="line">    sample_idx = torch.randint(<span class="built_in">len</span>(training_data), size=(<span class="number">1</span>,)).item()</span><br><span class="line">    img, label = training_data[sample_idx]</span><br><span class="line">    figure.add_subplot(rows, cols, i)</span><br><span class="line">    plt.title(labels_map[label])</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.imshow(img.squeeze(), cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="2.png" alt="2" style="zoom:50%;" /></p>
<h3 id="creating-a-custom-dataset">Creating a Custom Dataset</h3>
<p>A custom Dataset class must implement three functions: <code>__init__</code>, <code>__len__</code>, and <code>__getitem__</code>. Take a look at this implementation; the FashionMNIST images are stored in a directory <code>img_dir</code>, and their labels are stored separately in a CSV file <code>annotations_file</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomImageDataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line">	<span class="comment"># The __init__ function is run once when instantiating the Dataset object.</span></span><br><span class="line">  <span class="comment"># We initialize the directory containing the images, the annotations file,</span></span><br><span class="line">  <span class="comment"># and both transforms (covered in more detail in the next section).</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, annotations_file, img_dir, transform=<span class="literal">None</span>, target_transform=<span class="literal">None</span></span>):</span></span><br><span class="line">    self.img_labels = pd.read_csv(annotations_file)</span><br><span class="line">    self.img_dir = img_dir</span><br><span class="line">    self.transform = transform</span><br><span class="line">    self.target_transform = target_transform</span><br><span class="line"></span><br><span class="line">  <span class="comment"># The __len__ function returns the number of samples in our dataset.</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(self.img_labels)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># The __getitem__ function loads and returns a sample from the dataset at the given index idx.</span></span><br><span class="line">  <span class="comment"># Based on the index, it identifies the image&#x27;s location on disk, converts that to a tensor using read_image,</span></span><br><span class="line">  <span class="comment"># retrieves the corresponding label from the csv data in self.img_labels,</span></span><br><span class="line">  <span class="comment"># calls the transform functions on them (if applicable),</span></span><br><span class="line">  <span class="comment"># and returns the tensor image and corresponding label in a Python dict.</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, idx</span>):</span></span><br><span class="line">    img_path = os.path.join(self.img_dir, self.img_labels.iloc[idx, <span class="number">0</span>])</span><br><span class="line">    image = tvio.read_image(img_path)</span><br><span class="line">    label = self.img_labels.iloc[idx, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> self.transform:</span><br><span class="line">    image = self.transform(image)</span><br><span class="line">    <span class="keyword">if</span> self.target_transform:</span><br><span class="line">    label = self.target_transform(label)</span><br><span class="line">    sample = &#123;<span class="string">&quot;image&quot;</span>: image, <span class="string">&quot;label&quot;</span>: label&#125;</span><br><span class="line">    <span class="keyword">return</span> sample</span><br></pre></td></tr></table></figure>
<h3 id="preparing-your-data-for-training-with-dataloaders">Preparing your data for training with DataLoaders</h3>
<p>The <code>Dataset</code> retrieves dataset's features and labels one sample at a time. While training a model, we typically want to pass samples in "minibatches", reshuffle the data at every epoch to reduce model overfitting, and use Python's <code>multiprocessing</code> to speed up data retrieval.</p>
<p><code>DataLoader</code> is an iterable that abstracts this complexity for us in an easy API.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">train_dataloader = DataLoader(training_data, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_dataloader = DataLoader(test_data, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="iterate-through-the-dataloader">Iterate through the DataLoader</h3>
<p>We have loaded that dataset into the <code>Dataloader</code> and can iterate through the dataset as needed. Each iteration below returns a batch of <code>train_features</code> and <code>train_labels</code>(containing <code>batch_size=64</code> features and labels respectively).</p>
<p>Because <code>shuffle=True</code>, after we iterate over all batches the data is shuffled (for finer-grained control over the data loading order, take a look at <a href="https://pytorch.org/docs/stable/data.html#data-loading-order-and-sampler%3E">Samplers</a>.)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">training_data, test_data = DataPreparetion.data_load()</span><br><span class="line">train_dataloader = DataLoader(training_data, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_dataloader = DataLoader(test_data, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">labels_map = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">&quot;T-Shirt&quot;</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">&quot;Trouser&quot;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&quot;Pullover&quot;</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="string">&quot;Dress&quot;</span>,</span><br><span class="line">    <span class="number">4</span>: <span class="string">&quot;Coat&quot;</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">&quot;Sandal&quot;</span>,</span><br><span class="line">    <span class="number">6</span>: <span class="string">&quot;Shirt&quot;</span>,</span><br><span class="line">    <span class="number">7</span>: <span class="string">&quot;Sneaker&quot;</span>,</span><br><span class="line">    <span class="number">8</span>: <span class="string">&quot;Bag&quot;</span>,</span><br><span class="line">    <span class="number">9</span>: <span class="string">&quot;Ankle Boot&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> train_features, train_labels <span class="keyword">in</span> <span class="built_in">iter</span>(train_dataloader):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;feature size: <span class="subst">&#123;train_features.size()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;label size: <span class="subst">&#123;train_labels.size()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    figure = plt.figure(figsize=(<span class="number">28</span>, <span class="number">28</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, train_features.size()[<span class="number">0</span>]):</span><br><span class="line">        img = train_features[i].squeeze()</span><br><span class="line">        label = train_labels[i].squeeze()</span><br><span class="line">        figure.add_subplot(<span class="number">8</span>,<span class="number">8</span>,i)</span><br><span class="line">        plt.title(labels_map[label.item()])</span><br><span class="line">        plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">        plt.imshow(img.squeeze(), cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;label: <span class="subst">&#123;label.item()&#125;</span>&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="transforms">Transforms</h2>
<p>Data does not always come in its final processed form that is required for training machine learning algorithms. We use <strong>transforms</strong> to perform some manipulation of the data and make it suitable for training.</p>
<!--more-->
<p>All TorchVision datasets have two parameters (<strong><code>transform</code> to modify the features and <code>target_transform</code> to modify the labels</strong>) that accept callables containing the transformation logic.</p>
<p>The FashionMNIST features are in PIL Image format, and the labels are integers. For training, <strong>we need the features as normalized tensors, and the labels as one-hot encoded tensors</strong>. To make these transformations, we use <code>ToTensor</code> and <code>Lambda</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define a function to turn the integer into a one-hot encoded tensor.</span></span><br><span class="line"><span class="comment">#It first creates a zero tensor of size 10 (the number of labels in our dataset) and </span></span><br><span class="line"><span class="comment">#calls scatter which assigns a value=1 on the index as given by the label y.</span></span><br><span class="line">target_transform=Lambda(<span class="keyword">lambda</span> y: torch.zeros(<span class="number">10</span>, dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">                        .scatter_(dim=<span class="number">0</span>, index=torch.tensor(y), value=<span class="number">1</span>))</span><br><span class="line">)</span><br><span class="line"><span class="comment">################################################################################################</span></span><br><span class="line">example：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="keyword">lambda</span> y: torch.zeros(<span class="number">10</span>, dtype=torch.<span class="built_in">float</span>).scatter_(dim=<span class="number">0</span>, index=torch.tensor(y), value=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y(<span class="number">3</span>)</span><br><span class="line">tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PyTorch</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Building the model layers</title>
    <url>/2021/06/22/PyTorch-Transform/</url>
    <content><![CDATA[<h2 id="build-a-neural-network">Build a neural network</h2>
<p>take a sample minibatch of 3 images of size <strong>28x28</strong></p>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input_image = torch.rand(<span class="number">3</span>,<span class="number">28</span>,<span class="number">28</span>)</span><br><span class="line"><span class="built_in">print</span>(input_image.size())</span><br></pre></td></tr></table></figure>
<h3 id="nn.flatten">nn.Flatten</h3>
<p>the <a href="https://pytorch.org/docs/stable/generated/torch.nn.Flatten.html">nn.Flatten</a> layer to convert each 2D 28x28 image into a contiguous array of 784 pixel values (the minibatch dimension (at dim=0) is maintained).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flatten = nn.Flatten()</span><br><span class="line">flat_image = flatten(input_image)</span><br></pre></td></tr></table></figure>
<h3 id="nn.linear">nn.Linear</h3>
<p>applies a linear transformation on the input using it's stored weights and biases.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">layer = nn.Linear()</span><br><span class="line">hidden = layer(flat_image)</span><br></pre></td></tr></table></figure>
<h3 id="nn.relu">nn.ReLU</h3>
<p>Non-linear activations are what create the complex mappings between the model's inputs and outputs. They are applied after linear transformations to introduce <em>nonlinearity</em>, helping neural networks learn a wide variety of phenomena.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hidden = nn.ReLu()(hidden)</span><br></pre></td></tr></table></figure>
<h3 id="nn.sequential">nn.Sequential</h3>
<p><a href="https://pytorch.org/docs/stable/generated/torch.nn.Sequential.html">nn.Sequential</a> is an ordered container of modules. The data is passed through all the modules in the same order as defined. You can use sequential containers to put together a quick network like <code>seq_modules</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seq_modules = nn.Sequential(</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    nn.Linear(in_features=<span class="number">28</span> * <span class="number">28</span>, out_features=<span class="number">20</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Linear(in_features=<span class="number">20</span>, out_features=<span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line">input_image = torch.rand(<span class="number">3</span>,<span class="number">28</span>,<span class="number">28</span>)</span><br><span class="line">logits = seq_modules(input_image)</span><br></pre></td></tr></table></figure>
<h3 id="nn.softmax">nn.Softmax</h3>
<p>The last linear layer of the neural network returns <code>logits</code> - raw values in [<code>-infty</code>, <code>infty</code>] - which are passed to the <a href="https://pytorch.org/docs/stable/generated/torch.nn.Softmax.html">nn.Softmax</a> module. The logits are scaled to values [0, 1] representing the model's predicted densities for each class. <code>dim</code> parameter indicates the dimension along which the values must sum to 1.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pred_probab = nn.Softmax(dim=<span class="number">1</span>)(logits)</span><br><span class="line">pred_y = pred_probab.argmax(dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="model-parameters">Model parameters</h3>
<p>Many layers inside a neural network are <em>parameterized</em>, i.e. have associated weights and biases that are optimized during training. Subclassing <code>nn.Module</code> automatically tracks all fields defined inside your model object, and makes all parameters accessible using your model's <code>parameters()</code> or <code>named_parameters()</code> methods.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(seq_modules)</span><br><span class="line"><span class="keyword">for</span> name, param <span class="keyword">in</span> seq_modules.named_paramters():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">f&quot;Layer: <span class="subst">&#123;name&#125;</span> | Size: <span class="subst">&#123;param.size()&#125;</span> | Value: <span class="subst">&#123;param.data&#125;</span> \n&quot;</span>)</span><br><span class="line">  </span><br><span class="line">Network(</span><br><span class="line">  (flatten): Flatten(start_dim=<span class="number">1</span>, end_dim=-<span class="number">1</span>)</span><br><span class="line">  (linear_relu_stack): Sequential(</span><br><span class="line">    (<span class="number">0</span>): Linear(in_features=<span class="number">784</span>, out_features=<span class="number">512</span>, bias=<span class="literal">True</span>)</span><br><span class="line">    (<span class="number">1</span>): ReLU()</span><br><span class="line">    (<span class="number">2</span>): Linear(in_features=<span class="number">512</span>, out_features=<span class="number">512</span>, bias=<span class="literal">True</span>)</span><br><span class="line">    (<span class="number">3</span>): ReLU()</span><br><span class="line">    (<span class="number">4</span>): Linear(in_features=<span class="number">512</span>, out_features=<span class="number">10</span>, bias=<span class="literal">True</span>)</span><br><span class="line">    (<span class="number">5</span>): ReLU()</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="automatic-differentiation">Automatic differentiation</h2>
<p><strong>back propagation：parameters (model weights) are adjusted according to the gradient of the loss function with respect to the given parameter.</strong></p>
<p>PyTorch has a built-in differentiation engine called <code>torch.autograd</code>. It supports automatic computation of gradient for any computational graph.</p>
<p>Consider the simplest one-layer neural network, with input <code>x</code>, parameters <code>w</code> and <code>b</code>, and some loss function.</p>
<p><img src="1.png" alt="1" style="zoom:30%;" /></p>
<p>In this network, <code>w</code> and <code>b</code> are <strong>parameters</strong>, which we need to optimize.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.rand(<span class="number">5</span>)</span><br><span class="line">Y = torch.zeros(<span class="number">3</span>)</span><br><span class="line">W = torch.rand(<span class="number">5</span>,<span class="number">3</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.rand(<span class="number">3</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">Z = torch.matmul(X,W)+b</span><br><span class="line">loss = torch.nn.functional.binary_cross_entropy_with_logits(Z,Y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X</span><br><span class="line">tensor([<span class="number">0.8609</span>, <span class="number">0.8016</span>, <span class="number">0.8709</span>, <span class="number">0.1333</span>, <span class="number">0.6258</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>W</span><br><span class="line">tensor([[<span class="number">0.0608</span>, <span class="number">0.7731</span>, <span class="number">0.2732</span>],</span><br><span class="line">        [<span class="number">0.9440</span>, <span class="number">0.6451</span>, <span class="number">0.7805</span>],</span><br><span class="line">        [<span class="number">0.0341</span>, <span class="number">0.4740</span>, <span class="number">0.4896</span>],</span><br><span class="line">        [<span class="number">0.7219</span>, <span class="number">0.7725</span>, <span class="number">0.3819</span>],</span><br><span class="line">        [<span class="number">0.7504</span>, <span class="number">0.3699</span>, <span class="number">0.0386</span>]], requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">tensor([<span class="number">0.1596</span>, <span class="number">0.4110</span>, <span class="number">0.6390</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Y</span><br><span class="line">tensor([<span class="number">0.8099</span>, <span class="number">0.3342</span>, <span class="number">0.7097</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Z</span><br><span class="line">tensor([<span class="number">1.5642</span>, <span class="number">2.3410</span>, <span class="number">2.0013</span>], grad_fn=&lt;AddBackward0&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>loss</span><br><span class="line">tensor(<span class="number">0.9485</span>, grad_fn=&lt;BinaryCrossEntropyWithLogitsBackward&gt;)</span><br></pre></td></tr></table></figure>
<p>Thus, we need to be able to compute the gradients of loss function with respect to those variables. set the <code>requires_grad</code> property of those tensors.</p>
<blockquote>
<p><strong>Note:</strong> You can set the value of <code>requires_grad</code> when creating a tensor, or later by using <code>x.requires_grad_(True)</code> method.</p>
</blockquote>
<h3 id="computing-gradients">Computing gradients</h3>
<p>compute the derivatives of our loss function with respect to parameters, namely, we need <span class="math inline">\(\frac{∂loss}{∂w}\)</span> and <span class="math inline">\(\frac{∂loss}{∂b}\)</span> under some fixed values of <code>x</code> and <code>y</code>. To compute those derivatives, we call <code>loss.backward()</code>, and then retrieve the values from <code>w.grad</code> and <code>b.grad</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss.backward()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>W.grad</span><br><span class="line">tensor([[<span class="number">0.0049</span>, <span class="number">0.1659</span>, <span class="number">0.0491</span>],</span><br><span class="line">        [<span class="number">0.0045</span>, <span class="number">0.1544</span>, <span class="number">0.0458</span>],</span><br><span class="line">        [<span class="number">0.0049</span>, <span class="number">0.1678</span>, <span class="number">0.0497</span>],</span><br><span class="line">        [<span class="number">0.0008</span>, <span class="number">0.0257</span>, <span class="number">0.0076</span>],</span><br><span class="line">        [<span class="number">0.0035</span>, <span class="number">0.1206</span>, <span class="number">0.0357</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.grad</span><br><span class="line">tensor([<span class="number">0.0057</span>, <span class="number">0.1927</span>, <span class="number">0.0571</span>])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: we can only perform gradient calculations using <code>backward</code> once on a given graph, for performance reasons. If we need to do several <code>backward</code> calls on the same graph, we need to pass <code>retain_graph=True</code> to the <code>backward</code> call.</p>
</blockquote>
<h3 id="disabling-gradient-tracking">Disabling gradient tracking</h3>
<p>By default, all tensors with <code>requires_grad=True</code> are tracking their computational history and support gradient computation.We can stop tracking computations by surrounding our computation code with <code>torch.no_grad()</code> block:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Z = torch.matmul(X, W)+b</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">		Z = torch.matmul(X, W)+b</span><br></pre></td></tr></table></figure>
<p>or use the <code>detach()</code> method on the tensor:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Z = torch.matmul(x, w)+b</span><br><span class="line">Z.detach_()</span><br><span class="line"><span class="comment"># or Z = Z.detach()</span></span><br></pre></td></tr></table></figure>
<p>There are reasons ( disable gradient tracking ) :</p>
<ul>
<li>To mark some parameters in your neural network at <strong>frozen parameters</strong>. This is a very common scenario for <a href="https://pytorch.org/tutorials/beginner/finetuning_torchvision_models_tutorial.html">fine tuning a pre-trained network</a></li>
<li>To <strong>speed up computations</strong> when you are only doing forward pass, because computations on tensors that do not track gradients would be more efficient.</li>
</ul>
<blockquote>
<p>TIPS:</p>
<p>Conceptually, autograd keeps a record of data (tensors) and all executed operations (along with the resulting new tensors) in a directed acyclic graph (DAG) consisting of <a href="https://pytorch.org/docs/stable/autograd.html#torch.autograd.Function">Function</a> objects. In this DAG, leaves are the input tensors, roots are the output tensors. By tracing this graph from roots to leaves, you can automatically compute the gradients using the chain rule.</p>
<p><strong>In a forward pass, autograd does two things simultaneously:</strong></p>
<ul>
<li><strong>run the requested operation to compute a resulting tensor</strong></li>
<li><strong>maintain the operation’s <em>gradient function</em> in the DAG.</strong></li>
</ul>
<p><strong>The backward pass kicks off when <code>.backward()</code> is called on the DAG root. <code>autograd</code> then:</strong></p>
<ul>
<li>**computes the gradients from each <code>.grad_fn</code>, (A reference to the backward propagation function is stored in <code>grad_fn</code> property of a tensor. )</li>
<li><strong>accumulates them in the respective tensor’s <code>.grad</code> attribute</strong></li>
<li><strong>using the chain rule, propagates all the way to the leaf tensors.</strong></li>
</ul>
<p><strong>DAGs are dynamic in PyTorch</strong></p>
<p>the graph is recreated from scratch; after each <code>.backward()</code> call, autograd starts populating a new graph. This is exactly what allows you to use control flow statements in your model; you can change the shape, size and operations at every iteration if needed.</p>
</blockquote>
<h3 id="optional-reading-tensor-gradients-and-jacobian-products">Optional reading: Tensor gradients and Jacobian products</h3>
<p>In many cases, we have a scalar loss function, and we need to compute the gradient with respect to some parameters. However, there are cases when the output function is an arbitrary tensor. In this case, PyTorch allows you to compute so-called <strong><em>*Jacobian product*</em></strong>, and not the actual gradient.</p>
<p>For a vector function <span class="math inline">\(\vec{y}=f(\vec{x})\)</span>, where <span class="math inline">\(\vec{x}=\langle x_1,\dots,x_n\rangle\)</span> and <span class="math inline">\(\vec{y}=\langle y_1,\dots,y_m\rangle\)</span>, a gradient of <span class="math inline">\(\vec{y}\)</span> with respect to <span class="math inline">\(\vec{x}\)</span> is given by <strong>Jacobian matrix</strong>:</p>
<p><span class="math display">\[
J=\left(\begin{array}{ccc} 
\frac{\partial y_{1}}{\partial x_{1}} &amp; \cdots &amp; \frac{\partial y_{1}}{\partial x_{n}}\\
\vdots &amp; \ddots &amp; \vdots\\
\frac{\partial y_{m}}{\partial x_{1}} &amp; \cdots &amp; \frac{\partial y_{m}}{\partial x_{n}}
\end{array}\right)
\]</span></p>
<p>Instead of computing the Jacobian matrix itself, PyTorch allows you to compute <strong>Jacobian Product</strong> <span class="math inline">\(v^T\cdot J\)</span> for a given input vector <span class="math inline">\(v=(v_1 \dots v_m)\)</span>. This is achieved by calling <code>backward</code> with <span class="math inline">\(v\)</span> as an argument. The size of <span class="math inline">\(v\)</span> should be the same as the size of the original tensor, with respect to which we want tocompute the product:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x1=torch.tensor(<span class="number">1</span>, requires_grad=<span class="literal">True</span>, dtype = torch.<span class="built_in">float</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x2=torch.tensor(<span class="number">2</span>, requires_grad=<span class="literal">True</span>, dtype = torch.<span class="built_in">float</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x3=torch.tensor(<span class="number">3</span>, requires_grad=<span class="literal">True</span>, dtype = torch.<span class="built_in">float</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y=torch.randn(<span class="number">3</span>) <span class="comment"># produce a random vector for vector function define</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y[<span class="number">0</span>]=x1**<span class="number">2</span>+<span class="number">2</span>*x2+x3 <span class="comment"># define each vector function</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y[<span class="number">1</span>]=x1+x2**<span class="number">3</span>+x3**<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y[<span class="number">2</span>]=<span class="number">2</span>*x1+x2**<span class="number">2</span>+x3**<span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y.backward(torch.ones(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x1.grad</span><br><span class="line">tensor(<span class="number">5.</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x2.grad</span><br><span class="line">tensor(<span class="number">18.</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x3.grad</span><br><span class="line">tensor(<span class="number">34.</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Jacobian Motrix</strong> : <span class="math display">\[
J = \begin{pmatrix}
 2x_1 &amp; 2 &amp;1 \\
 2 &amp; 3x_2^2 &amp; 2x_3\\
 1 &amp; 2x_2 &amp; 3x_3^2
\end{pmatrix}
\ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \
\left\{\begin{matrix}
y_1 = &amp; x_1^2+2x_2+x_3  \\
y_2=  &amp; x_1+x_2^3+ x_3^2 \\
y_3 = &amp; 2x_1 +x_2^2+x_3^3
\end{matrix}\right.
\]</span></p>
<p><strong>vector v :</strong> <span class="math display">\[
v = (1,1,1)
\]</span> <strong>V * J :</strong> <span class="math display">\[
v \circ J = (2x_1+2+1,\ \ \ 2+3x_2^2+2x_2,\ \ \ 1+2x_3+3x_3^2)=(5,18,34)
\]</span> <code>The above is essentially the directional derivative</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>inp = torch.eye(<span class="number">3</span>,<span class="number">3</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>out = (inp+<span class="number">1</span>).<span class="built_in">pow</span>(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>out.backward(torch.ones_like(inp))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inp.grad</span><br><span class="line">tensor([[<span class="number">4.</span>, <span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">        [<span class="number">2.</span>, <span class="number">4.</span>, <span class="number">2.</span>],</span><br><span class="line">        [<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">4.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inp.grad.zero_()</span><br><span class="line">tensor([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="optimizing-the-model-parameters">Optimizing the model parameters</h2>
<p>Training a model is an iterative process:</p>
<ul>
<li>in each iteration (called an <em>epoch</em>) the model makes a guess about the output</li>
<li>calculates the error in its guess (<em>loss</em>), collects the derivatives of the error with respect to its parameters (as we saw in the module)</li>
<li><strong>optimizes</strong> these parameters using gradient descent.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataPreparetion</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data_load</span>(<span class="params">if_download=<span class="literal">False</span></span>):</span></span><br><span class="line">        training_data = datasets.FashionMNIST(</span><br><span class="line">            root=<span class="string">&quot;data&quot;</span>,</span><br><span class="line">            train=<span class="literal">True</span>,</span><br><span class="line">            download=if_download,</span><br><span class="line">            transform=ToTensor(),</span><br><span class="line">            <span class="comment"># To One-Hot encoded (Not applicable for nn.CrossEntropyLoss)</span></span><br><span class="line">            target_transform=Lambda(<span class="keyword">lambda</span> y: torch.zeros(<span class="number">10</span>, dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">                                    .scatter_(dim=<span class="number">0</span>, index=torch.tensor(y), value=<span class="number">1</span>))</span><br><span class="line">        )</span><br><span class="line">        test_data = datasets.FashionMNIST(</span><br><span class="line">            root=<span class="string">&quot;data&quot;</span>,</span><br><span class="line">            train=<span class="literal">False</span>,</span><br><span class="line">            download=if_download,</span><br><span class="line">            transform=ToTensor(),</span><br><span class="line">            <span class="comment"># To One-Hot encoded</span></span><br><span class="line">            target_transform=Lambda(<span class="keyword">lambda</span> y: torch.zeros(<span class="number">10</span>, dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">                                    .scatter_(dim=<span class="number">0</span>, index=torch.tensor(y), value=<span class="number">1</span>))</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> training_data, test_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Network</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Network, self).__init__()</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">        self.linear_relu_stack = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">28</span> * <span class="number">28</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">10</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">       x = self.flatten(x)</span><br><span class="line">       logits = self.linear_relu_stack(x)</span><br><span class="line">       <span class="keyword">return</span> logits</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">information</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;model structure: <span class="subst">&#123;self&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> name, param <span class="keyword">in</span> self.named_parameters():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Layer: <span class="subst">&#123;name&#125;</span> | Size: <span class="subst">&#123;param.size()&#125;</span> | Value: <span class="subst">&#123;param.data&#125;</span> \n&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="setting-hyperparameters">Setting hyperparameters</h3>
<p>define the following hyperparameters for training:</p>
<ul>
<li><strong>Number of Epochs</strong> - the number times to iterate over the dataset</li>
<li><strong>Batch Size</strong> - the number of data samples seen by the model in each epoch</li>
<li><strong>Learning Rate</strong> - how much to update models parameters at each batch/epoch. Smaller values yield slow learning speed, while large values may result in unpredictable behavior during training.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">learning_rate = <span class="number">1e-3</span></span><br><span class="line">batch_size = <span class="number">64</span></span><br><span class="line">epochs = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="add-an-optimization-loop">Add an optimization loop</h3>
<p>Each epoch consists of two main parts:</p>
<ul>
<li><strong>The Train Loop</strong> - iterate over the training dataset and try to converge to optimal parameters.</li>
<li><strong>The Validation/Test Loop</strong> - iterate over the test dataset to check if model performance is improving.</li>
</ul>
<h3 id="add-a-loss-function">Add a loss function</h3>
<p><strong>Loss function</strong> measures the degree of dissimilarity of obtained result to the target value, and it is the loss function that we want to minimize during training. To calculate the loss we make a prediction using the inputs of our given data sample and compare it against the true data label value.</p>
<p><strong>Common loss functions</strong> include</p>
<ul>
<li><a href="https://pytorch.org/docs/stable/generated/torch.nn.MSELoss.html#torch.nn.MSELoss">nn.MSELoss</a> (Mean Square Error) for regression tasks</li>
<li><a href="https://pytorch.org/docs/stable/generated/torch.nn.NLLLoss.html#torch.nn.NLLLoss">nn.NLLLoss</a> (Negative Log Likelihood) for classification</li>
<li><a href="https://pytorch.org/docs/stable/generated/torch.nn.CrossEntropyLoss.html#torch.nn.CrossEntropyLoss">nn.CrossEntropyLoss</a> combines <code>nn.LogSoftmax</code> and <code>nn.NLLLoss</code>.</li>
</ul>
<p>We pass our model's output logits to <code>nn.CrossEntropyLoss</code>, which will normalize the logits and compute the prediction error.</p>
<blockquote>
<p><strong>Note: The input is expected to contain raw, unnormalized scores for each class.</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Initialize the loss function</span></span><br><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure>
<h3 id="optimization-pass">Optimization pass</h3>
<p><strong>Optimization algorithms</strong> define how this process is performed (in this example we use Stochastic Gradient Descent). All optimization logic is encapsulated in the <code>optimizer</code> object. Here, we use the SGD optimizer; additionally, there are many <a href="https://pytorch.org/docs/stable/optim.html">different optimizers</a> available in PyTorch such as ADAM and RMSProp, that work better for different kinds of models and data.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)</span><br></pre></td></tr></table></figure>
<p>optimization happens in three steps:</p>
<ul>
<li>Call <code>optimizer.zero_grad()</code> to reset the gradients of model parameters. Gradients by default add up; to prevent double-counting, we explicitly zero them at each iteration.</li>
<li>Back-propagate the prediction loss with a call to <code>loss.backwards()</code>. PyTorch deposits the gradients of the loss w.r.t. each parameter.</li>
<li>Once we have our gradients, we call <code>optimizer.step()</code> to adjust the parameters by the gradients collected in the backward pass.</li>
</ul>
<h2 id="full-implementation">Full implementation</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Get hardware device for training</span></span><br><span class="line">device = <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Using <span class="subst">&#123;device&#125;</span> device&quot;</span>)</span><br><span class="line"></span><br><span class="line">model = Network().to(device)</span><br><span class="line"><span class="built_in">print</span>(model.parameters())</span><br><span class="line"><span class="comment"># model.information()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Loss Function</span></span><br><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Optimization Algorithms: Stochastic Gradient Descent</span></span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)</span><br><span class="line"></span><br><span class="line"><span class="comment"># DataLoader</span></span><br><span class="line">training_data, test_data = DataPreparetion().data_load()</span><br><span class="line">training_dataloader = DataLoader(training_data, batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_dataloader = DataLoader(test_data, batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_loop</span>(<span class="params">dataloader</span>):</span></span><br><span class="line">    size = <span class="built_in">len</span>(dataloader.dataset)</span><br><span class="line">    <span class="keyword">for</span> batch, (X, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(training_dataloader):</span><br><span class="line">        <span class="comment"># Compute prediction and loss</span></span><br><span class="line">        pred_y = model(X)</span><br><span class="line">        loss = loss_fn(pred_y, y)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Backpropagation</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># adjust the parameters by the gradients collected in the backward pass</span></span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            loss = loss.item()</span><br><span class="line">            current = batch * <span class="built_in">len</span>(X)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;loss: <span class="subst">&#123;loss:&gt;7f&#125;</span>  [<span class="subst">&#123;current:&gt;5d&#125;</span>/<span class="subst">&#123;size:&gt;5d&#125;</span>]&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_loop</span>(<span class="params">dataloader</span>):</span></span><br><span class="line">    size = <span class="built_in">len</span>(dataloader.dataset)</span><br><span class="line">    test_loss, correct = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad:</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> dataloader:</span><br><span class="line">            pred_probab = model(X)</span><br><span class="line">            pred_y = pred_probab.argmax(<span class="number">1</span>)</span><br><span class="line">            test_loss += loss_fn(pred_probab, y)</span><br><span class="line">            correct += (pred_y == y).<span class="built_in">type</span>(torch.<span class="built_in">float</span>).<span class="built_in">sum</span>().item()</span><br><span class="line">    test_loss /= size</span><br><span class="line">    correct /= size</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Test Error: \n Accuracy: <span class="subst">&#123;(<span class="number">100</span> * correct):&gt;<span class="number">0.1</span>f&#125;</span>%, &quot;</span></span><br><span class="line">          <span class="string">f&quot;Avg loss: <span class="subst">&#123;test_loss:&gt;8f&#125;</span> \n&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line">epoch: <span class="number">10</span></span><br><span class="line">----------------------------------</span><br><span class="line">loss: <span class="number">1.258381</span>  [    <span class="number">0</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">1.305664</span>  [ <span class="number">6400</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">1.226043</span>  [<span class="number">12800</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">1.363006</span>  [<span class="number">19200</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">1.471584</span>  [<span class="number">25600</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">1.185646</span>  [<span class="number">32000</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">1.068239</span>  [<span class="number">38400</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">1.386577</span>  [<span class="number">44800</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">1.405703</span>  [<span class="number">51200</span>/<span class="number">60000</span>]</span><br><span class="line">loss: <span class="number">1.409026</span>  [<span class="number">57600</span>/<span class="number">60000</span>]</span><br><span class="line">Test Error: </span><br><span class="line"> Accuracy: <span class="number">59.1</span>%, Avg loss: <span class="number">0.019455</span> </span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="save-and-load-the-model">Save and load the model</h2>
<h3 id="saving-and-loading-model-weights">Saving and loading model weights</h3>
<p>PyTorch models store the learned parameters in an internal state dictionary, called <code>state_dict</code>. These can be persisted via the <code>torch.save</code> method:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.save(model.state_dict(), <span class="string">&#x27;data/model_weights.pth&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>To load model weights, you need to create an instance of the same model first, and then load the parameters using the <code>load_state_dict()</code> method.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.load_state_dict(torch.load(<span class="string">&#x27;data/model_weights.pth&#x27;</span>))</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note:</strong> Be sure to call <code>model.eval()</code> method before inferencing to set the dropout and batch normalization layers to evaluation mode. Failing to do this will yield inconsistent inference results.</p>
</blockquote>
<h3 id="saving-and-loading-models-with-shapes">Saving and loading models with shapes</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.save(model, <span class="string">&#x27;data/model.pth&#x27;</span>)</span><br><span class="line"></span><br><span class="line">model = torch.load(<span class="string">&#x27;data/model.pth&#x27;</span>)</span><br><span class="line">optimizers = torch.optim.SGD(model.parameters(), lr=learning_rate)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note:</strong> This approach uses Python <a href="https://docs.python.org/3/library/pickle.html">pickle</a> module when serializing the model, thus it relies on the actual class definition to be available when loading the model.</p>
</blockquote>
<h3 id="exporting-the-model-to-onnx">Exporting the model to ONNX</h3>
<p>PyTorch also has native ONNX export support. Given the dynamic nature of the PyTorch execution graph, however, the export process must traverse the execution graph to produce a persisted ONNX model. For this reason, a test variable of the appropriate size should be passed in to the export routine (in our case, we will create a dummy zero tensor of the correct size):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.onnx <span class="keyword">as</span> onnx</span><br><span class="line"></span><br><span class="line">input_image = torch.zeros(<span class="number">1</span>,<span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>)</span><br><span class="line">onnx.export(model, input_image, <span class="string">&#x27;data/model.onnx&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PyTorch</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch-Introduction</title>
    <url>/2021/05/07/Pytorch/</url>
    <content><![CDATA[<h1 id="introduction">Introduction</h1>
<ul>
<li>An open source machine learning framework</li>
<li>A Python package that provides two high-level features:
<ul>
<li>Tensor computation with strong GPU acceleration</li>
<li>Deep neural networks built on a tape-based autograd system</li>
</ul></li>
</ul>
<span id="more"></span>
<ul>
<li>Use the FashionMNIST dataset to train a neural network that predicts if an input image belongs to one of the following classes: T-shirt/top, Trouser, Pullover, Dress, Coat, Sandal, Shirt, Sneaker, Bag, or Ankle boot.</li>
</ul>
<p><img src="1.png" alt="1" style="zoom:40%;" /></p>
<h1 id="overview-of-the-dnn-training-procedure">Overview of the DNN Training Procedure</h1>
<p><img src="2.png" alt="2" style="zoom:40%;" /></p>
<h1 id="tensor">Tensor</h1>
<blockquote>
<p>High-dimensional matrix(array)</p>
</blockquote>
<h2 id="data-type">Data Type</h2>
<p><img src="3.png" alt="3" style="zoom:35%;" /></p>
<h2 id="shape-of-tensor">shape of Tensor</h2>
<p><img src="4.png" alt="4" style="zoom:35%;" /></p>
<h2 id="constructor">Constructor</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># From list / NumPy array</span></span><br><span class="line">np_x = np.array([[<span class="number">1</span>,-<span class="number">1</span>],[-<span class="number">1</span>,<span class="number">1</span>]])</span><br><span class="line">x_data = torch.from_numpy(np_x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># From another tensor</span></span><br><span class="line">x_ones = torch.ones_like(x_data) <span class="comment"># retains the properties of x_data</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Ones Tensor: \n <span class="subst">&#123;x_ones&#125;</span> \n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Ones Tensor: </span><br><span class="line"> tensor([[<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>]]) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x_rand = torch.rand_like(x_data, dtype=torch.<span class="built_in">float</span>) <span class="comment"># overrides the datatype of x_data</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Random Tensor: \n <span class="subst">&#123;x_rand&#125;</span> \n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Random Tensor: </span><br><span class="line"> tensor([[<span class="number">0.1943</span>, <span class="number">0.8950</span>],</span><br><span class="line">        [<span class="number">0.5489</span>, <span class="number">0.7244</span>]]) </span><br><span class="line"><span class="comment"># With random or constant values</span></span><br><span class="line"></span><br><span class="line">shape = (<span class="number">2</span>,<span class="number">3</span>)      <span class="comment"># a tuple of tensor dimensions. it determines the dimensionality of the output tensor.</span></span><br><span class="line">rand_tensor = torch.rand(shape)</span><br><span class="line">ones_tensor = torch.ones(shape)</span><br><span class="line">zeros_tensor = torch.zeros(shape)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">f&quot;Random Tensor: \n <span class="subst">&#123;rand_tensor&#125;</span> \n&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">f&quot;Ones Tensor: \n <span class="subst">&#123;ones_tensor&#125;</span> \n&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">f&quot;Zeros Tensor: \n <span class="subst">&#123;zeros_tensor&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">Random Tensor: </span><br><span class="line">tensor([[<span class="number">0.4687</span>, <span class="number">0.9809</span>, <span class="number">0.0818</span>],</span><br><span class="line">        [<span class="number">0.8493</span>, <span class="number">0.7848</span>, <span class="number">0.3891</span>]]) </span><br><span class="line"></span><br><span class="line">Ones Tensor: </span><br><span class="line">  tensor([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">          [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]]) </span><br><span class="line"></span><br><span class="line">Zeros Tensor: </span><br><span class="line">  tensor([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">          [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="attributes">Attributes</h2>
<p>describe their shape, data type, and the device on which they are stored</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor = torch.rand(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">f&quot;Shape of tensor: <span class="subst">&#123;tensor.shape&#125;</span>&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">f&quot;Datatype of tensor: <span class="subst">&#123;tensor.dtype&#125;</span>&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">f&quot;Device tensor is stored on: <span class="subst">&#123;tensor.device&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">Shape of tensor: torch.Size([<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">Datatype of tensor: torch.float32</span><br><span class="line">Device tensor <span class="keyword">is</span> stored on: cpu</span><br></pre></td></tr></table></figure>
<h2 id="operators">Operators</h2>
<p><a href="https://pytorch.org/docs/stable/torch.html">Over 100 tensor operations, including arithmetic, linear algebra, matrix manipulation (transposing, indexing, slicing), sampling and more are comprehensively described</a></p>
<ul>
<li>move tensor to the GPU if available</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">  tensor = tensor.to(<span class="string">&#x27;cuda&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>Standard numpy-like indexing and slicing</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tensor = torch.ones(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;First row: &#x27;</span>,tensor[<span class="number">0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;First column: &#x27;</span>, tensor[:, <span class="number">0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;Last column:&#x27;</span>, tensor[..., -<span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tensor[:,<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(tensor)</span><br><span class="line"></span><br><span class="line">First row:  tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line">First column:  tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line">Last column: tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>
<ul>
<li>Joining tensors</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># use torch.cat to concatenate a sequence of tensors along a given dimension</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = torch.cat([tensor, tensor, tensor], dim=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(t1)</span><br><span class="line"></span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>
<ul>
<li>Arithmetic operations</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This computes the matrix multiplication between two tensors. y1, y2, y3 will have the same value</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y1 = tensor @ tensor.T</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y2 = tensor.matmul(tensor.T)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y3 = torch.rand_like(tensor)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.matmul(tensor, tensor.T, out=y3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># This computes the element-wise product. z1, z2, z3 will have the same value</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z1 = tensor * tensor</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z2 = tensor.mul(tensor)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z3 = torch.rand_like(tensor)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.mul(tensor, tensor, out=z3)</span><br><span class="line"></span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>
<ul>
<li>Single-element tensors</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># aggregating all values of a tensor into one value</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>agg = tensor.<span class="built_in">sum</span>()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>agg_item = agg.item()  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(agg, agg_item, <span class="built_in">type</span>(agg_item))</span><br><span class="line"></span><br><span class="line">tensor(<span class="number">12.</span>) <span class="number">12.0</span> &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">float</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>
<ul>
<li>In-place operations</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># In-place operations save some memory, but can be problematic when computing derivatives because of an immediate loss of history. </span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(tensor, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tensor.add_(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(tensor)</span><br><span class="line"></span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>]]) </span><br><span class="line"></span><br><span class="line">tensor([[<span class="number">6.</span>, <span class="number">5.</span>, <span class="number">6.</span>, <span class="number">6.</span>],</span><br><span class="line">        [<span class="number">6.</span>, <span class="number">5.</span>, <span class="number">6.</span>, <span class="number">6.</span>],</span><br><span class="line">        [<span class="number">6.</span>, <span class="number">5.</span>, <span class="number">6.</span>, <span class="number">6.</span>],</span><br><span class="line">        [<span class="number">6.</span>, <span class="number">5.</span>, <span class="number">6.</span>, <span class="number">6.</span>]])</span><br></pre></td></tr></table></figure>
<ul>
<li>Squeeze : remove the specified dimension with length = 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.zeros([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.shape</span><br><span class="line">torch.Size([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = x.squeeze(<span class="number">0</span>) <span class="comment"># dim = 0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.shape</span><br><span class="line">torch.Size([<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>Unsqueeze: expand a new dimension</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.zeros([<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.shape</span><br><span class="line">torch.Size([<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = x.unsqueeze(<span class="number">1</span>) <span class="comment"># dim = 0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.shape</span><br><span class="line">torch.Size([<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>Bridge with NumPy &amp;&amp; Tensor to NumPy array</li>
</ul>
<blockquote>
<p>Tensors on the CPU and NumPy arrays can share their underlying memory locations, and changing one will change the other.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = torch.ones(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = t.numpy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">t: tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line">n: [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># A change in the tensor reflects in the NumPy array.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.add_(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">t: tensor([<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>])</span><br><span class="line">n: [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PyTorch</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Recurrent Neural Network</title>
    <url>/2021/07/04/RNN/</url>
    <content><![CDATA[<h2 id="introduction">Introduction</h2>
<blockquote>
<p>Rich semantic representations of text, and a simple linear classifier on top of the embeddings. What this architecture does is to capture aggregated meaning of words in a sentence, but it does not take into account the <strong>order</strong> of words, because aggregation operation on top of embeddings removed this information from the original text.</p>
<span id="more"></span>
<p>Because these models are unable to model word ordering, they cannot solve more complex or ambiguous tasks such as text generation or question answering.</p>
<p>To capture the meaning of text sequence, we need to use another neural network architecture, which is called a <strong>recurrent neural network</strong>, or RNN. In RNN, we pass our sentence through the network one symbol at a time, and the network produces some <strong>state</strong>, which we then pass to the network again with the next symbol.</p>
</blockquote>
<p><img src="1.png" alt="1" style="zoom:80%;" /></p>
<center>
Recurrent Neural Networks have loops.
</center>
<blockquote>
<p>Given the input sequence of tokens <span class="math inline">\(X_0,\dots,X_n\)</span>, RNN creates a sequence of neural network blocks, and trains this sequence end-to-end using back propagation.</p>
</blockquote>
<p><img src="RNN-unrolled.png" alt="RNN-unrolled" style="zoom:25%;" /></p>
<center>
An unrolled recurrent neural network.
</center>
<p>A recurrent neural network can be thought of as multiple copies of the same network, each passing a message to a successor. Each network block takes a pair <strong><span class="math inline">\((X_i,S_i)\)</span> as an input</strong>, and produces <strong><span class="math inline">\(S_{i+1}\)</span> as a result.</strong> <span class="math display">\[
S_{i+1}= f(X_i,S_i)
\]</span> Final state <span class="math inline">\(S_n\)</span> or output <span class="math inline">\(X_n\)</span> goes into a linear classifier to produce the result. All network blocks share the same weights, and are trained end-to-end using one backpropagation pass.</p>
<blockquote>
<p>Because state vectors <span class="math inline">\(S_0,\dots,S_n\)</span> are passed through the network, it is able to learn the sequential dependencies between words. For example, when the word <strong>not</strong> appears somewhere in the sequence, it can learn to negate certain elements within the state vector, resulting in negation.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRNN</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, embed_dim, hidden_dim, num_classes</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MyRNN, self).__init__()</span><br><span class="line">        self.embedding = nn.Embedding(vocab_size, embed_dim)</span><br><span class="line">        self.rnn = nn.RNN(input_size=embed_dim, hidden_size=hidden_dim)</span><br><span class="line">        self.fc = nn.Linear(in_features=hidden_dim, out_features=num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.embedding(x)</span><br><span class="line">        x, h = self.rnn(x)</span><br><span class="line">        x = torch.mean(x, dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.fc(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    load_data(<span class="string">&#x27;embedding&#x27;</span>)</span><br><span class="line">    net = MyRNN(<span class="number">64</span>, <span class="number">32</span>, <span class="built_in">len</span>(classes)).to(device)</span><br><span class="line">    hist = train(net, training_dataloader, valid_dataloader)</span><br><span class="line">    plot_acc_loss(hist)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="2.png" alt="1" style="zoom:50%;" /></p>
<blockquote>
<p>In our case, we will use padded data loader, so each batch will have a number of padded sequences of the same length. RNN layer will take the sequence of embedding tensors, and produce two outputs:</p>
</blockquote>
<ul>
<li><strong>x is a sequence of RNN cell outputs at each step</strong></li>
<li><strong>h is a final hidden state for the last element of the sequence</strong></li>
</ul>
<p>We then apply a fully-connected linear classifier to get the number of class.</p>
<blockquote>
<p><strong>Note:</strong> RNNs are quite difficult to train, because once the RNN cells are unrolled along the sequence length, the resulting number of layers involved in back propagation is quite large. Thus we need to select small learning rate, and train the network on larger dataset to produce good results. It can take quite a long time, so using GPU is preferred.</p>
</blockquote>
<h2 id="long-short-term-memory-lstm">Long Short Term Memory (LSTM)</h2>
<p>经典 RNN 的主要问题之一是所谓的梯度消失问题。RNNs在一次反向传播过程中进行端到端的训练，它很难将错误传播到网络的第一层，因此网络无法学习遥远的 token 之间的关系。</p>
<p>避免这个问题的方法之一是通过使用所谓的 <strong>gates</strong> 来引入明确的状态管理。有两种最著名的此类架构。长短期记忆（LSTM）和<strong>Gated Relay Unit</strong>（GRU）。</p>
<p><img src="3.png" alt="1" style="zoom:40%;" /></p>
<p><img src="15.png" alt="15" style="zoom:50%;" /></p>
<blockquote>
<p>At each unit, hidden vector <span class="math inline">\(h_i\)</span> is concatenated with input <span class="math inline">\(x_i\)</span>, and they control what happens to the state <span class="math inline">\(c\)</span> via <strong>gates</strong>. Each gate is a <strong>neural network with sigmoid activation</strong> (output in the range <span class="math inline">\([0,1]\)</span>), which can be thought of as bitwise mask when multiplied by the state vector. There are the following gates (from left to right on the picture above):</p>
<p><strong>forget gate</strong> takes hidden vector and determines, which components of the vector <span class="math inline">\(c\)</span> we need to forget, and which to pass through.</p>
<p><strong>input gate</strong> takes some information from the input and hidden vector, and inserts it into state.</p>
<p><strong>output gate</strong> transforms state via some linear layer with <span class="math inline">\(\tanh\)</span> activation, then selects some of its components using hidden vector <span class="math inline">\(h_i\)</span> to produce new state <span class="math inline">\(c_{i+1}\)</span>.</p>
</blockquote>
<p><img src="LSTM3-chain.png" alt="LSTM3-chain" style="zoom:30%;" /></p>
<center>
LSTMs also have this chain like structure, but the repeating module has a different structure
</center>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LSTMClassifier</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, embed_dim, hidden_dim, classes</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(LSTMClassifier, self).__init__()</span><br><span class="line">        self.embedding = nn.Embedding(num_embeddings=vocab_size, embedding_dim=embed_dim)</span><br><span class="line">        self.embedding.weight.data = torch.randn_like(self.embedding.weight.data) - <span class="number">.5</span></span><br><span class="line">        self.rnn = nn.LSTM(input_size=embed_dim, hidden_size=hidden_dim, batch_first=<span class="literal">True</span>)</span><br><span class="line">        self.fc = nn.Linear(in_features=hidden_dim, out_features=classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.embedding(x)</span><br><span class="line">        x, (h, c) = self.rnn(x)</span><br><span class="line">        <span class="keyword">return</span> self.fc(h[-<span class="number">1</span>])</span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    load_data(<span class="string">&#x27;embedding&#x27;</span>)</span><br><span class="line">    net = LSTMClassifier(<span class="number">64</span>, <span class="number">32</span>, <span class="built_in">len</span>(classes)).to(device)</span><br><span class="line">    summary(net)</span><br><span class="line">    hist = train(net, training_dataloader, valid_dataloader, print_step=<span class="number">1000</span>)</span><br><span class="line">    plot_acc_loss(hist)</span><br></pre></td></tr></table></figure>
<p><img src="4.png" alt="LSTM3-chain" style="zoom:50%;" /></p>
<h2 id="packed-sequences">Packed sequences</h2>
<blockquote>
<p>In our example, we had to pad all sequences in the minibatch with zero vectors. While it results in some memory waste, with RNNs it is more critical that additional RNN cells are created for the padded input items, which take part in training, yet do not carry any important input information. It would be much better to train RNN only to the actual sequence size.</p>
<p>To do that, a special format of padded sequence storage is introduced in PyTorch. Suppose we have input padded minibatch which looks like this:</p>
</blockquote>
<p><span class="math display">\[
[[1,2,3,4,5], \\
 [6,7,8,0,0],\\
 [9,0,0,0,0]]
\]</span></p>
<blockquote>
<p>Here 0 represents padded values, and the actual length vector of input sequences is <code>[5,3,1]</code>.</p>
<p>In order to effectively train RNN with padded sequence, we want to begin training first group of RNN cells with large minibatch (<code>[1,6,9]</code>), but then end processing of third sequence, and continue training with shorted minibatches (<code>[2,7]</code>, <code>[3,8]</code>), and so on. Thus, packed sequence is represented as one vector - in our case <code>[1,6,9,2,7,3,8,4,5]</code>, and length vector (<code>[5,3,1]</code>), from which we can easily reconstruct the original padded minibatch.</p>
<p>To produce packed sequence, we can use <code>torch.nn.utils.rnn.pack_padded_sequence</code> function. All recurrent layers, including RNN, LSTM and GRU, support packed sequences as input, and produce packed output, which can be decoded using <code>torch.nn.utils.rnn.pad_packed_sequence</code>.</p>
<p>To be able to produce packed sequence, we need to pass length vector to the network, and thus we need a different function to prepare minibatches:</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pad_length</span>(<span class="params">b</span>):</span></span><br><span class="line">    <span class="comment"># build vectorized sequence</span></span><br><span class="line">    v = [encode(x[<span class="number">1</span>]) <span class="keyword">for</span> x <span class="keyword">in</span> b]</span><br><span class="line">    <span class="comment"># compute max length of a sequence in this minibatch and length sequence itself</span></span><br><span class="line">    len_seq = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">len</span>, v))</span><br><span class="line">    l = <span class="built_in">max</span>(len_seq)</span><br><span class="line">    <span class="keyword">return</span> (  <span class="comment"># tuple of three tensors - length sequence,  padded features, labels</span></span><br><span class="line">        torch.tensor(len_seq),</span><br><span class="line">        torch.stack(</span><br><span class="line">            [torch.nn.functional.pad(torch.tensor(t), (<span class="number">0</span>, l - <span class="built_in">len</span>(t)), mode=<span class="string">&#x27;constant&#x27;</span>, value=<span class="number">0</span>) <span class="keyword">for</span> t <span class="keyword">in</span> v]),</span><br><span class="line">        torch.LongTensor([t[<span class="number">0</span>] - <span class="number">1</span> <span class="keyword">for</span> t <span class="keyword">in</span> b]),</span><br><span class="line">    )</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LSTMClassifierPacked</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, embed_dim, hidden_dim, classes</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(LSTMClassifierPacked, self).__init__()</span><br><span class="line">        self.embedding = nn.Embedding(num_embeddings=vocab_size, embedding_dim=embed_dim)</span><br><span class="line">        self.embedding.weight.data = torch.randn_like(self.embedding.weight.data) - <span class="number">.5</span></span><br><span class="line">        self.rnn = nn.LSTM(input_size=embed_dim, hidden_size=hidden_dim, batch_first=<span class="literal">True</span>)</span><br><span class="line">        self.fc = nn.Linear(in_features=hidden_dim, out_features=classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, length</span>):</span></span><br><span class="line">        x = self.embedding(x)</span><br><span class="line">        pad_x = nn.utils.rnn.pack_padded_sequence(x, length, batch_first=<span class="literal">True</span>, enforce_sorted=<span class="literal">False</span>)</span><br><span class="line">        pad_x, (h, c) = self.rnn(pad_x)</span><br><span class="line">        x, _ = nn.utils.rnn.pad_packed_sequence(pad_x, batch_first=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> self.fc(h.squeeze(dim=<span class="number">0</span>))</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    load_data(<span class="built_in">type</span>=<span class="string">&#x27;packed_sequence&#x27;</span>)</span><br><span class="line">    net = LSTMClassifierPacked(<span class="number">64</span>, <span class="number">32</span>, <span class="built_in">len</span>(classes)).to(device)</span><br><span class="line">    summary(net)</span><br><span class="line">    hist = train_embed_offset(net, training_dataloader, valid_dataloader, print_step=<span class="number">1000</span>)</span><br><span class="line">    plot_acc_loss(hist)</span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">Layer (<span class="built_in">type</span>:depth-idx)                   Param <span class="comment">#</span></span><br><span class="line">=================================================================</span><br><span class="line">LSTMClassifierPacked                     --</span><br><span class="line">├─Embedding: <span class="number">1</span>-<span class="number">1</span>                         <span class="number">6</span>,<span class="number">131</span>,<span class="number">840</span></span><br><span class="line">├─LSTM: <span class="number">1</span>-<span class="number">2</span>                              <span class="number">12</span>,<span class="number">544</span></span><br><span class="line">├─Linear: <span class="number">1</span>-<span class="number">3</span>                            <span class="number">132</span></span><br><span class="line">=================================================================</span><br><span class="line">Total params: <span class="number">6</span>,<span class="number">144</span>,<span class="number">516</span></span><br><span class="line">Trainable params: <span class="number">6</span>,<span class="number">144</span>,<span class="number">516</span></span><br><span class="line">Non-trainable params: <span class="number">0</span></span><br><span class="line">=================================================================</span><br></pre></td></tr></table></figure>
<p><img src="7.png" alt="LSTM3-chain" style="zoom:50%;" /></p>
<h2 id="bidirectional-and-multilayer-rnns">Bidirectional and multilayer RNNs</h2>
<blockquote>
<p>在我们的例子中，所有的递归网络都在一个方向上运行，从一个序列的开始到结束。这看起来很自然，因为它类似于我们阅读和聆听语言的方式。然而，由于在许多实际案例中，我们可以随机访问输入序列，因此在两个方向上运行递归计算可能是有意义的。这样的网络被称为双向RNN，它们可以通过向RNN/LSTM/GRU构造函数传递bidirectional=True参数来创建。</p>
<p>在处理双向网络时，我们需要两个隐藏状态向量，每个方向一个。PyTorch将这些向量编码为一个大一倍的向量，这很方便，因为你通常会将产生的隐藏状态传递给全连接的线性层，你只需要在创建层的时候考虑到这个大小的增加。 递归网络，单向或双向，捕捉序列中的某些模式，并可以将它们存储到状态向量或传递到输出。与卷积网络一样，我们可以在第一层的基础上建立另一个递归层，以捕捉更高层次的模式，这些模式是由第一层提取的低层次模式建立的。这使我们想到了多层RNN的概念，它由两个或更多的递归网络组成，上一层的输出被传递到下一层作为输入。</p>
</blockquote>
<p><img src="5.jpg" alt="LSTM3-chain" style="zoom:100%;" /></p>
<h2 id="generative-networks">Generative networks</h2>
<p>递归神经网络（RNN）及其门控单元的变体，如长短期记忆单元（LSTM）和门控递归单元（GRU）为语言建模提供了一种机制，即它们可以学习单词排序并提供对序列中下一个单词的预测。这使我们能够将RNN用于生成任务，如普通文本生成、机器翻译，甚至图像字幕。</p>
<p>在我们在上一单元讨论的RNN架构中，每个RNN单元产生下一个隐藏状态作为输出。然而，我们也可以给每个递归单元添加另一个输出，这将使我们能够输出一个序列（其长度与原始序列相等）。此外，我们可以使用RNN单元，在每一步都不接受输入，只接受一些初始状态向量，然后产生一个输出序列。</p>
<p><img src="6.jpg" alt="LSTM3-chain" style="zoom:100%;" /></p>
<ul>
<li><strong>One-to-one</strong> is a traditional neural network with one input and one output</li>
<li><strong>One-to-many</strong> is a generative architecture that accepts one input value, and generates a sequence of output values. For example, if we want to train <strong>image captioning</strong> network that would produce a textual description of a picture, we can a picture as input, pass it through CNN to obtain hidden state, and then have recurrent chain generate caption word-by-word</li>
<li><strong>Many-to-one</strong> corresponds to RNN architectures we described in the previous unit, such as text classification</li>
<li><strong>Many-to-many</strong>, or <strong>sequence-to-sequence</strong> corresponds to tasks such as <strong>machine translation</strong>, where we have first RNN collect all information from the input sequence into the hidden state, and another RNN chain unrolls this state into the output sequence.</li>
</ul>
<h3 id="building-character-vocabulary">Building character vocabulary</h3>
<p>To build character-level generative network, we need to split text into individual characters instead of words. This can be done by defining a different tokenizer:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">char_tokenizer = <span class="built_in">list</span>  <span class="comment"># [word for word in words]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span>(<span class="params"><span class="built_in">type</span>, vocab=<span class="literal">None</span>, token=<span class="string">&#x27;bow&#x27;</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param type: bow, embedding, embedding_offset, packed_sequence</span></span><br><span class="line"><span class="string">    :param vocab: Other vocab</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    os.makedirs(root, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    training_iter, test_iter = torchtext.datasets.AG_NEWS(root=root)</span><br><span class="line">    builtins.training_data, test_data = to_map_style_dataset(training_iter), to_map_style_dataset(test_iter)</span><br><span class="line">    num_train = <span class="built_in">int</span>(<span class="built_in">len</span>(builtins.training_data) * <span class="number">0.8</span>)</span><br><span class="line">    <span class="keyword">if</span> vocab <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 获取训练集的 vocab</span></span><br><span class="line">        builtins.vocab = get_vocab(token)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        builtins.vocab = vocab</span><br><span class="line">    builtins.vocab_size = <span class="built_in">len</span>(builtins.vocab)</span><br><span class="line">    <span class="comment"># 训练集细分训练集和验证集</span></span><br><span class="line">    training_data, valid_data = random_split(builtins.training_data,</span><br><span class="line">                                             [num_train, <span class="built_in">len</span>(builtins.training_data) - num_train])</span><br><span class="line"></span><br><span class="line">    builtins.training_data, builtins.valid_data, builtins.test_data = training_data, valid_data, test_data</span><br><span class="line">    <span class="comment"># bowify, padify, offsetify</span></span><br><span class="line">    collate_fn = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="string">&#x27;bow&#x27;</span>:</span><br><span class="line">        collate_fn = bowify</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">type</span> == <span class="string">&#x27;embedding&#x27;</span>:</span><br><span class="line">        collate_fn = padify</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">type</span> == <span class="string">&#x27;embedding_offset&#x27;</span>:</span><br><span class="line">        collate_fn = offsetify</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">type</span> == <span class="string">&#x27;packed_sequence&#x27;</span>:</span><br><span class="line">        collate_fn = pad_length</span><br><span class="line"></span><br><span class="line">    builtins.training_dataloader = DataLoader(training_data, batch_size=batch_size, collate_fn=collate_fn, shuffle=<span class="literal">True</span>)</span><br><span class="line">    builtins.valid_dataloader = DataLoader(valid_data, batch_size=batch_size, collate_fn=collate_fn, shuffle=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># builtins.test_dataloader = DataLoader(test_data, batch_size=batch_size, collate_fn=bowify, shuffle=True)</span></span><br><span class="line"></span><br><span class="line">    builtins.classes = [<span class="string">&#x27;World&#x27;</span>, <span class="string">&#x27;Sports&#x27;</span>, <span class="string">&#x27;Business&#x27;</span>, <span class="string">&#x27;Sci/Tech&#x27;</span>]</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_vocab</span>(<span class="params"><span class="built_in">type</span>=<span class="string">&#x27;bow&#x27;</span></span>):</span></span><br><span class="line">    counter = collections.Counter()</span><br><span class="line">    <span class="keyword">for</span> (label, line) <span class="keyword">in</span> training_data:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span> == <span class="string">&#x27;bow&#x27;</span>:</span><br><span class="line">            counter.update(tokenizer(line))</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">type</span> == <span class="string">&#x27;ngram&#x27;</span>:</span><br><span class="line">            counter.update(torchtext.data.utils.ngrams_iterator(line, ngrams=<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">type</span> == <span class="string">&#x27;char&#x27;</span>:</span><br><span class="line">            counter.update(char_tokenizer(line))</span><br><span class="line">    vocab = torchtext.vocab.vocab(counter, min_freq=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> vocab</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span>(<span class="params">x, <span class="built_in">type</span>=<span class="string">&#x27;bow&#x27;</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="string">&#x27;bow&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> [vocab[i] <span class="keyword">for</span> i <span class="keyword">in</span> tokenizer(x)]</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">type</span> == <span class="string">&#x27;char&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> [vocab[i] <span class="keyword">for</span> i <span class="keyword">in</span> char_tokenizer(x)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc_char</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> encode(x, <span class="built_in">type</span>=<span class="string">&#x27;char&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="training-a-generative-rnn">Training a generative RNN</h2>
<p>The way we will train RNN to generate text is the following. On each step, we will take a sequence of characters of length <code>nchars</code>, and ask the network to generate next output character for each input character:</p>
<p><img src="8.png" alt="LSTM3-chain" style="zoom:40%;" /></p>
<blockquote>
<p>Depending on the actual scenario, we may also want to include some special characters, such as <em>end-of-sequence</em> <code>&lt;eos&gt;</code>. In our case, we just want to train the network for endless text generation, thus we will fix the size of each sequence to be equal to <code>nchars</code> tokens. Consequently, each training example will consist of <code>nchars</code> inputs and <code>nchars</code> outputs (which are input sequence shifted one symbol to the left). Minibatch will consist of several such sequences.</p>
<p>The way we will generate minibatches is to take each news text of length <code>l</code>, and generate all possible input-output combinations from it (there will be <code>l-nchars</code> such combinations). They will form one minibatch, and size of minibatches would be different at each training step.</p>
</blockquote>
<p>Because the network takes characters as input, and vocabulary size is pretty small, we do not need embedding layer, one-hot-encoded input can directly go to LSTM cell. However, because we pass character numbers as input, we need to one-hot-encode them before passing to LSTM. This is done by calling <code>one_hot</code> function during <code>forward</code> pass. Output encoder would be a linear layer that will convert hidden state into one-hot-encoded output.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LSTMGenerator</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, hidden_dim</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.rnn = nn.LSTM(vocab_size, hidden_dim, batch_first=<span class="literal">True</span>)</span><br><span class="line">        self.fc = nn.Linear(hidden_dim, vocab_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, s=<span class="literal">None</span></span>):</span></span><br><span class="line">        x = nn.functional.one_hot(x, vocab_size).to(torch.float32)</span><br><span class="line">        x, s = self.rnn(x, s)</span><br><span class="line">        <span class="keyword">return</span> self.fc(x), s</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>During training, we want to be able to sample generated text. To do that, we will define <code>generate</code> function that will produce output string of length <code>size</code>, starting from the initial string <code>start</code>.</p>
<p>The way it works is the following. First, we will pass the whole start string through the network, and take output state <code>s</code> and next predicted character <code>out</code>. Since <code>out</code> is one-hot encoded, we take <code>argmax</code> to get the index of the character <code>nc</code> in the vocabulary, and use <code>itos</code> to figure out the actual character and append it to the resulting list of characters <code>chars</code>. This process of generating one character is repeated <code>size</code> times to generate required number of characters.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span>(<span class="params">net, size=<span class="number">100</span>, start=<span class="string">&#x27;today &#x27;</span></span>):</span></span><br><span class="line">    chars = <span class="built_in">list</span>(start)</span><br><span class="line">    out, s = net(enc_char(chars).view(<span class="number">1</span>, -<span class="number">1</span>).to(device))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        nc = out.argmax(<span class="number">2</span>)[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line">        chars.append(vocab.get_itos()[nc])</span><br><span class="line">        out, s = net(enc_char(chars).view(<span class="number">1</span>, -<span class="number">1</span>).to(device), s)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(chars)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Special attention needs to be paid to the way we compute loss. We need to compute loss given one-hot-encoded output <code>out</code>, and expected text <code>text_out</code>, which is the list of character indices. Luckily, the <code>cross_entropy</code> function expects unnormalized network output as first argument, and class number as the second, which is exactly what we have. It also performs automatic averaging over minibatch size.</p>
<p>We also limit the training by <code>samples_to_train</code> samples, in order not to wait for too long. We encourage you to experiment and try longer training, possibly for several epochs (in which case you would need to create another loop around this code).</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_generate</span>(<span class="params">net, training_dataloader, valid_dataloader, nchars, print_step=<span class="number">1000</span>, lr=learning_rate</span>):</span></span><br><span class="line">    loss_fn = torch.nn.CrossEntropyLoss()</span><br><span class="line">    hist = &#123;<span class="string">&#x27;train_loss&#x27;</span>: [], <span class="string">&#x27;train_acc&#x27;</span>: [], <span class="string">&#x27;val_loss&#x27;</span>: [], <span class="string">&#x27;val_acc&#x27;</span>: []&#125;</span><br><span class="line">    optimizer = op.Adam(net.parameters(), lr=lr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, epoch + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;epoch: <span class="subst">&#123;i&#125;</span>\n------------------------------------------&quot;</span>)</span><br><span class="line">        net.train()</span><br><span class="line">        size, total_size, acc, total_loss, batch = <span class="number">0</span>, <span class="number">1000</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> batch, (_, x) <span class="keyword">in</span> <span class="built_in">enumerate</span>(training_dataloader):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(x) - nchars &lt; <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> size &gt; total_size:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            text_in, text_out = get_batch(x)</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            out, s = net(text_in)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># out: one-hot encoding</span></span><br><span class="line">            loss = loss_fn(out.flatten(<span class="number">0</span>, <span class="number">1</span>), text_out.flatten())</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">            total_loss += loss.item()</span><br><span class="line">            acc += (out.argmax(<span class="number">2</span>) == text_out).<span class="built_in">type</span>(torch.<span class="built_in">float</span>).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> batch % print_step == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;train loss: <span class="subst">&#123;loss:&gt;5f&#125;</span>   [<span class="subst">&#123;batch&#125;</span>/<span class="subst">&#123;total_size&#125;</span>]&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(generate(net))</span><br><span class="line">            size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;train_loss: <span class="subst">&#123;total_loss / batch:&gt;5f&#125;</span>     &quot;</span></span><br><span class="line">              <span class="string">f&quot;train_acc: <span class="subst">&#123;acc / (text_out.shape[<span class="number">0</span>] * nchars * total_size):&gt;5f&#125;</span>     <span class="subst">&#123;total_size&#125;</span>&quot;</span>)</span><br><span class="line">        hist[<span class="string">&#x27;train_loss&#x27;</span>].append(total_loss / batch)</span><br><span class="line">        hist[<span class="string">&#x27;train_acc&#x27;</span>].append(acc / total_size)</span><br><span class="line"></span><br><span class="line">        net.<span class="built_in">eval</span>()</span><br><span class="line">        total_size, acc, total_loss, count = <span class="number">1000</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            <span class="keyword">for</span> _, x <span class="keyword">in</span> valid_dataloader:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(x) - nchars &lt; <span class="number">10</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> count &gt; total_size:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                size += <span class="number">1</span></span><br><span class="line">                text_in, text_out = get_batch(x)</span><br><span class="line">                out, s = net(text_in)</span><br><span class="line"></span><br><span class="line">                total_loss += loss_fn(out.flatten(<span class="number">0</span>, <span class="number">1</span>), text_out.flatten()).item()</span><br><span class="line">                acc += (out.argmax(dim=<span class="number">2</span>) == text_out).<span class="built_in">type</span>(torch.<span class="built_in">float</span>).<span class="built_in">sum</span>().item()</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;val_loss: <span class="subst">&#123;total_loss / count:&gt;5f&#125;</span>     &quot;</span></span><br><span class="line">                  <span class="string">f&quot;val_acc: <span class="subst">&#123;acc / (text_out.shape[<span class="number">0</span>] * nchars * total_size):&gt;5f&#125;</span>     <span class="subst">&#123;total_size&#125;</span>\n&quot;</span>)</span><br><span class="line">            hist[<span class="string">&#x27;val_loss&#x27;</span>].append(total_loss / count)</span><br><span class="line">            hist[<span class="string">&#x27;val_acc&#x27;</span>].append(acc / total_size)</span><br><span class="line">    <span class="keyword">return</span> hist</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    load_data(token=<span class="string">&#x27;char&#x27;</span>)</span><br><span class="line">    net = LSTMGenerator(<span class="number">64</span>)</span><br><span class="line">    hist = train_generate(net, training_data, valid_data, n_chars, <span class="number">100</span>)</span><br><span class="line">    plot_acc_loss(hist)</span><br><span class="line">    torch.save(net, <span class="string">&#x27;data/model.pth&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">=================================================================</span><br><span class="line">Layer (<span class="built_in">type</span>:depth-idx)                   Param <span class="comment">#</span></span><br><span class="line">=================================================================</span><br><span class="line">LSTMGenerator                            --</span><br><span class="line">├─LSTM: <span class="number">1</span>-<span class="number">1</span>                              <span class="number">71</span>,<span class="number">168</span></span><br><span class="line">├─Linear: <span class="number">1</span>-<span class="number">2</span>                            <span class="number">5</span>,<span class="number">330</span></span><br><span class="line">=================================================================</span><br><span class="line">Total params: <span class="number">76</span>,<span class="number">498</span></span><br><span class="line">Trainable params: <span class="number">76</span>,<span class="number">498</span></span><br><span class="line">Non-trainable params: <span class="number">0</span></span><br><span class="line">=================================================================</span><br><span class="line">epoch: <span class="number">1</span></span><br><span class="line">------------------------------------------</span><br><span class="line">train loss: <span class="number">4.440310</span>   [<span class="number">0</span>/<span class="number">1000</span>]</span><br><span class="line">today llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll</span><br><span class="line">train loss: <span class="number">2.982985</span>   [<span class="number">100</span>/<span class="number">1000</span>]</span><br><span class="line">today ton te the the the the the the the the the the the the the the the the the the the the the the the t</span><br><span class="line">train loss: <span class="number">2.483560</span>   [<span class="number">200</span>/<span class="number">1000</span>]</span><br><span class="line">today an an an an an an an an an an an an an an an an an an an an an an an an an an an an an an an an an a</span><br><span class="line">train loss: <span class="number">2.378409</span>   [<span class="number">300</span>/<span class="number">1000</span>]</span><br><span class="line">today the the the the the the the the the the the the the the the the the the the the the the the the the </span><br></pre></td></tr></table></figure>
<p>问题：</p>
<ul>
<li><p><strong>Better minibatch generation</strong>。我们准备训练数据的方式是从一个样本中生成一个小批量。这并不理想，因为minibatch都是不同大小的，其中一些甚至无法生成，因为文本比nchars小。此外，小批量加载的GPU不够充分。更明智的做法是从所有样本中获取一大块文本，然后生成所有输入输出对，将它们随机播放，并生成大小相等的小批。</p></li>
<li><p><strong>Multilayer LSTM</strong> 尝试2或3层的LSTM cell 是有意义的。正如我们在上一单元中提到的，LSTM的每一层都从文本中提取某些模式，在字符级发生器的情况下，我们可以期望较低的LSTM层负责提取音节，而较高的层负责提取单词和单词组合。这可以通过向LSTM构造器传递层数参数简单实现。</p></li>
</ul>
<h3 id="soft-text-generation-and-temperature">Soft text generation and temperature</h3>
<p>在上一个generate的定义中，我们总是将概率最高的字符作为生成文本中的下一个字符。这导致了这样一个事实，即文本经常一次又一次地在相同的字符序列之间 “循环”</p>
<p>然而，如果我们看一下下一个字符的概率分布，可能几个最高概率之间的差别并不大，例如，一个字符的概率为0.2，另一个为0.19，等等。例如，当寻找序列 "play "中的下一个字符时，下一个字符同样可以是空格，或e（如单词player）。</p>
<p>选择概率较高的字符并不总是 "公平 "的，因为选择第二高的字符仍然可能使我们得到有意义的文本。从网络输出所给出的概率分布中抽取字符是比较明智的做法。可以使用实现所谓的<code>multinomial</code> function 的 <strong>multinomial distribution</strong>来完成此采样。下面定义了实现此软文本生成的函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_soft</span>(<span class="params">net, size=<span class="number">100</span>, start=<span class="string">&#x27;today &#x27;</span>, temperature=<span class="number">1.0</span></span>):</span></span><br><span class="line">    chars = <span class="built_in">list</span>(start)</span><br><span class="line">    out, s = net(enc_char(chars).view(<span class="number">1</span>, -<span class="number">1</span>).to(device))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        <span class="comment"># nc = torch.argmax(out[0][-1])</span></span><br><span class="line">        out_dist = out[<span class="number">0</span>][-<span class="number">1</span>].div(temperature).exp()</span><br><span class="line">        nc = torch.multinomial(out_dist, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">        chars.append(vocab.get_itos()[nc])</span><br><span class="line">        out, s = net(nc.view(<span class="number">1</span>, -<span class="number">1</span>), s)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(chars)</span><br><span class="line">  </span><br><span class="line">------------------------------------------------------------------------------------------------</span><br><span class="line">train loss: <span class="number">1.953934</span>   [<span class="number">600</span>/<span class="number">1000</span>]</span><br><span class="line">Today the tom pist whel <span class="keyword">and</span> ention threurs miles to ubset <span class="keyword">in</span> morer Drovald, carl ctafpored Mayidaming todaidurs brot stuptuw lives urpires aftee rrip Jeplinvend  of Spaukious oudders on over <span class="keyword">in</span> throunces of bestrows export chamal expent nack seadanned tipt  Sevend Co. to acttulars coupive baversday of the</span><br><span class="line"></span><br><span class="line">train loss: <span class="number">1.950226</span>   [<span class="number">700</span>/<span class="number">1000</span>]</span><br><span class="line">Today perment ride they caid, bet its Aie sales Wet; Friday greame face Wolk Rajing a  third quole plam, <span class="keyword">and</span> fan has Boinn mamaloics cres, brekin kemall entownifg the Gerferder Plater, Inc..mown Surds the <span class="keyword">as</span> nech to Stour detersdes work mote Thursday ratun of the t5 <span class="keyword">in</span> Iracor XN nee stail pohon, cael <span class="keyword">in</span> H</span><br><span class="line"></span><br><span class="line">train loss: <span class="number">1.878042</span>   [<span class="number">800</span>/<span class="number">1000</span>]</span><br><span class="line">Today strowd Dyrtar Wasulys UN6 kiches Carthan tolGsherity gandsing of the larous it hald? companing enfore quo to oud erices to intity quother, osing bekeriins alnpurity the choags onler poutlomed Bassec, romoffencomer. The intand <span class="number">5L</span>...E YMANFS has migeles wath goinforsed sowe sarger off terenomes taiver</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>引入了一个叫做 <strong>temperature</strong> 的参数，用来表示我们应该多努力地坚持最高概率。如果<strong>temperature</strong>是1.0，就做公平的 <strong>fair multinomial sampling</strong> ，当温度达到无穷大时--所有的概率都变得相等，我们就随机选择下一个字符。我们可以观察到，当我们把温度提高得太多时，文本变得毫无意义，而当温度接近0时，它就像 "循环的 "硬生成的文本。</p>
<h2 id="attention-mechanisms-and-transformers">Attention mechanisms and transformers</h2>
<blockquote>
<p><strong>recurrent networks</strong>的一个主要缺点是，一个序列中的所有词对结果的影响都是一样的。这导致标准的LSTM编码器-解码器模型在序列到序列的任务中表现欠佳，如命名实体识别和机器翻译。在现实中，输入序列中的特定词往往比其他词对序列输出有更大的影响。</p>
</blockquote>
<blockquote>
<p>考虑<strong>sequence-to-sequence</strong>的模型，如机器翻译。它由两个递归网络实现，其中一个网络（编码器）将输入序列折叠成<strong>hidden</strong>状态，另一个网络（解码器）将该<strong>hidden</strong>状态展开成翻译结果。这种方法的问题是，网络的最终状态很难记住一个句子的开头，从而导致该模型在长句子上的质量不佳。</p>
</blockquote>
<p><img src="10.png" alt="LSTM3-chain" style="zoom:30%;" /></p>
<center>
The encoder-decoder model, translating the sentence “she is eating a green apple” to Chinese.
</center>
<p><strong>Attention Mechanisms</strong>提供了一种手段，可以对每个输入 <strong>vector</strong> 对RNN的每个输出预测的背景影响进行加权。它的实现方式是在输入RNN的中间状态和输出RNN之间建立捷径。这样，在生成输出符号<span class="math inline">\(y_t\)</span>时，我们将考虑到所有的输入隐藏状态<span class="math inline">\(h_i\)</span>，其权重系数<span class="math inline">\(a_{t,i}\)</span>不同。</p>
<p><img src="9.png" alt="LSTM3-chain" style="zoom:40%;" /></p>
<center>
The encoder-decoder model with additive attention mechanism in Bahdanau et al., 2015.
</center>
<p><img src="11.png" alt="LSTM3-chain" style="zoom:50%;" /></p>
<p>Attention matrix <span class="math inline">\(\{α_{i,j}\}\)</span> would represent the degree which certain input words play in generation of a given word in the output sequence. Below is the example of such a matrix:</p>
<p><img src="12.png" alt="LSTM3-chain" style="zoom:80%;" /></p>
<p><a href="https://lilianweng.github.io/lil-log/2018/06/24/attention-attention.html">More About Attention</a></p>
<p>在自然语言处理领域，注意力机制是目前技术水平现状的主要原因。然而，增加注意力大大增加了模型参数的数量，导致了RNNs的扩展问题。缩放RNN的一个关键制约因素是模型的递归性质使得批量和并行化训练具有挑战性。在RNN中，一个序列的每个元素都需要按顺序处理，这意味着它不容易被并行化。</p>
<p>注意力机制的采用与这种约束相结合，导致了现在我们所知道和使用的从BERT到OpenGPT3的最先进的<strong>Art Transformer Models</strong> 的产生。</p>
<h3 id="transformer-models">Transformer models</h3>
<blockquote>
<p><strong>Transformer models</strong> 不是将以前的每一个预测的上下文转发到下一个评估步骤中，而是使用<strong>positional encodings</strong>和<strong>attention</strong>来捕捉一个给定的输入的上下文，并在一个给定的文本窗口中。下面的图片显示了位置编码和注意力是如何在一个给定的窗口中捕捉上下文的。</p>
</blockquote>
<p><img src="13.gif" alt="LSTM3-chain" style="zoom:80%;" /></p>
<p>由于每个输入位置被独立地映射到每个输出位置，<strong>Transformer models</strong>可以比RNN更好地并行化，这使得更大和更有表现力的语言模型成为可能。每个 <strong>attention head</strong> 都可以用来学习不同的词之间的关系，从而改善下游的自然语言处理任务。</p>
<p>BERT（Bidirectional Encoder Representations from Transformers）是一个非常大的多层 <strong>transformer</strong> 网络，BERT-base有12层，BERT-large有24层。该模型首先在大型文本数据语料库（WikiPedia+书籍）上使用无监督训练（预测句子中的 masked words）进行预训练。在预训练期间，该模型吸收了大量的语言理解，然后可以通过微调来利用其他数据集。这个过程被称为迁移学习。</p>
<p><img src="14.png" alt="LSTM3-chain" style="zoom:60%;" /></p>
<h2 id="using-bert-for-text-classification">Using BERT for text classification</h2>
<p>Let's see how we can use pre-trained BERT model for solving our traditional task: sequence classification. We will classify our original AG News dataset.</p>
<blockquote>
<p>Because we will be using pre-trained BERT model, we would need to use specific tokenizer. First, we will load a tokenizer associated with pre-trained BERT model.</p>
<p>HuggingFace library contains a repository of pre-trained models, which you can use just by specifying their names as arguments to <code>from_pretrained</code> functions. All required binary files for the model would automatically be downloaded.</p>
<p>However, at certain times you would need to load your own models, in which case you can specify the directory that contains all relevant files, including parameters for tokenizer, <code>config.json</code> file with model parameters, binary weights, etc.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># To load the model from Internet repository using model name. </span></span><br><span class="line"><span class="comment"># Use this if you are running from your own copy of the notebooks</span></span><br><span class="line">bert_model = <span class="string">&#x27;bert-base-uncased&#x27;</span> </span><br><span class="line"></span><br><span class="line">tokenizer = transformers.BertTokenizer.from_pretrained(bert_model)</span><br><span class="line"></span><br><span class="line">MAX_SEQ_LEN = <span class="number">128</span></span><br><span class="line">PAD_INDEX = tokenizer.convert_tokens_to_ids(tokenizer.pad_token)</span><br><span class="line">UNK_INDEX = tokenizer.convert_tokens_to_ids(tokenizer.unk_token)</span><br></pre></td></tr></table></figure>
<p>The <code>tokenizer</code> object contains the <code>encode</code> function that can be directly used to encode text:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tokenizer.encode(<span class="string">&#x27;PyTorch is a great framework for NLP&#x27;</span>)</span><br><span class="line"></span><br><span class="line">[<span class="number">101</span>, <span class="number">1052</span>, <span class="number">22123</span>, <span class="number">2953</span>, <span class="number">2818</span>, <span class="number">2003</span>, <span class="number">1037</span>, <span class="number">2307</span>, <span class="number">7705</span>, <span class="number">2005</span>, <span class="number">17953</span>, <span class="number">2361</span>, <span class="number">102</span>]</span><br></pre></td></tr></table></figure>
<p>let's create iterators which we will use during training to access the data. Because BERT uses it's own encoding function, we would need to define a padding function similar to <code>padify</code> we have defined before:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pad_bert</span>(<span class="params">b</span>):</span></span><br><span class="line">    <span class="comment"># b is the list of tuples of length batch_size</span></span><br><span class="line">    <span class="comment">#   - first element of a tuple = label,</span></span><br><span class="line">    <span class="comment">#   - second = feature (text sequence)</span></span><br><span class="line">    <span class="comment"># build vectorized sequence</span></span><br><span class="line">    v = [tokenizer.encode(x[<span class="number">1</span>]) <span class="keyword">for</span> x <span class="keyword">in</span> b]</span><br><span class="line">    <span class="comment"># compute max length of a sequence in this minibatch</span></span><br><span class="line">    l = <span class="built_in">max</span>(<span class="built_in">map</span>(<span class="built_in">len</span>, v))</span><br><span class="line">    <span class="keyword">return</span> (  <span class="comment"># tuple of two tensors -  features and labels</span></span><br><span class="line">        torch.stack([torch.nn.functional.pad(torch.tensor(t), (<span class="number">0</span>, l - <span class="built_in">len</span>(t)), mode=<span class="string">&#x27;constant&#x27;</span>, value=<span class="number">0</span>) <span class="keyword">for</span> t <span class="keyword">in</span> v]),</span><br><span class="line">        torch.LongTensor([t[<span class="number">0</span>]-<span class="number">1</span> <span class="keyword">for</span> t <span class="keyword">in</span> b]),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>In our case, we will be using pre-trained BERT model called <code>bert-base-uncased</code>. Let's load the model using <code>BertForSequenceClassfication</code> package. This ensures that our model already has a required architecture for classification, including final classifier. You will see warning message stating that weights of the final classifier are not initialized, and model would require pre-training - that is perfectly okay, because it is exactly what we are about to do!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = transformers.BertForSequenceClassification.from_pretrained(bert_model,num_labels=<span class="number">4</span>).to(device)</span><br></pre></td></tr></table></figure>
<p>Because BERT is already pre-trained, we want to start with rather small learning rate in order not to destroy initial weights.</p>
<p>All hard work is done by <code>BertForSequenceClassification</code> model. When we call the model on the training data, it returns both loss and network output for input minibatch. We use loss for parameter optimization (<code>loss.backward()</code> does the backward pass), and <code>out</code> for computing training accuracy by comparing obtained labels <code>labs</code> (computed using <code>argmax</code>) with expected <code>labels</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_bert</span>(<span class="params">net, training_dataloader, valid_dataloader, iterations, print_step=<span class="number">1000</span>, lr=learning_rate</span>):</span></span><br><span class="line">    hist = &#123;<span class="string">&#x27;train_loss&#x27;</span>: [], <span class="string">&#x27;train_acc&#x27;</span>: [], <span class="string">&#x27;val_loss&#x27;</span>: [], <span class="string">&#x27;val_acc&#x27;</span>: []&#125;</span><br><span class="line">    optimizer = op.Adam(net.parameters(), lr=lr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, epoch + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;epoch: <span class="subst">&#123;i&#125;</span>\n------------------------------------------&quot;</span>)</span><br><span class="line">        net.train()</span><br><span class="line">        iter_times, size, acc, total_loss, batch = iterations, <span class="built_in">len</span>(training_dataloader.dataset), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> batch, (x, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(training_dataloader):</span><br><span class="line">            x, y = x.to(device), y.to(device)</span><br><span class="line">            loss, pred_y = net(x, labels=y)[:<span class="number">2</span>]</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">            total_loss += loss.item()</span><br><span class="line">            acc += (pred_y.argmax(<span class="number">1</span>) == y).<span class="built_in">type</span>(torch.<span class="built_in">float</span>).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> batch % print_step == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;train loss: <span class="subst">&#123;loss:&gt;5f&#125;</span>   [<span class="subst">&#123;batch * batch_size&#125;</span>/<span class="subst">&#123;size&#125;</span>]&quot;</span>)</span><br><span class="line">            iter_times -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> iter_times:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;train_loss: <span class="subst">&#123;total_loss / batch:&gt;5f&#125;</span>     train_acc: <span class="subst">&#123;acc / size:&gt;5f&#125;</span>     <span class="subst">&#123;size&#125;</span>&quot;</span>)</span><br><span class="line">        hist[<span class="string">&#x27;train_loss&#x27;</span>].append(total_loss / batch)</span><br><span class="line">        hist[<span class="string">&#x27;train_acc&#x27;</span>].append(acc / size)</span><br><span class="line">        net.<span class="built_in">eval</span>()</span><br><span class="line">        iter_times, size, acc, total_loss, count = iterations / <span class="number">4</span>, <span class="built_in">len</span>(valid_dataloader.dataset), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> valid_dataloader:</span><br><span class="line">                x, y = x.to(device), y.to(device)</span><br><span class="line">                loss, pred_y = net(x, labels=y)[:<span class="number">2</span>]</span><br><span class="line">                total_loss += loss.item()</span><br><span class="line">                acc += (pred_y.argmax(dim=<span class="number">1</span>) == y).<span class="built_in">type</span>(torch.<span class="built_in">float</span>).<span class="built_in">sum</span>().item()</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count &gt; iter_times:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;val_loss: <span class="subst">&#123;total_loss / count:&gt;5f&#125;</span>     val_acc: <span class="subst">&#123;acc / size:&gt;5f&#125;</span>     <span class="subst">&#123;size&#125;</span>\n&quot;</span>)</span><br><span class="line">            hist[<span class="string">&#x27;val_loss&#x27;</span>].append(total_loss / count)</span><br><span class="line">            hist[<span class="string">&#x27;val_acc&#x27;</span>].append(acc / size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hist</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  <span class="comment"># batch_size = 32</span></span><br><span class="line">    load_data(vocab=tokenizer.vocab, tokenizer=tokenizer, collate_fn=pad_bert)</span><br><span class="line">    model = transformers.BertForSequenceClassification.from_pretrained(bert_model, num_labels=<span class="number">4</span>)</span><br><span class="line">    hist = train_bert(model, training_dataloader, valid_dataloader, iterations=<span class="number">10</span>, print_step=<span class="number">2</span>, lr=<span class="number">1e-5</span>)</span><br><span class="line">    plot_acc_loss(hist)</span><br><span class="line">    </span><br><span class="line">================================================================================</span><br><span class="line">Layer (<span class="built_in">type</span>:depth-idx)                                  Param <span class="comment">#</span></span><br><span class="line">================================================================================</span><br><span class="line">BertForSequenceClassification                           --</span><br><span class="line">├─BertModel: <span class="number">1</span>-<span class="number">1</span>                                        --</span><br><span class="line">│    └─BertEmbeddings: <span class="number">2</span>-<span class="number">1</span>                              --</span><br><span class="line">│    │    └─Embedding: <span class="number">3</span>-<span class="number">1</span>                              <span class="number">23</span>,<span class="number">440</span>,<span class="number">896</span></span><br><span class="line">│    │    └─Embedding: <span class="number">3</span>-<span class="number">2</span>                              <span class="number">393</span>,<span class="number">216</span></span><br><span class="line">│    │    └─Embedding: <span class="number">3</span>-<span class="number">3</span>                              <span class="number">1</span>,<span class="number">536</span></span><br><span class="line">│    │    └─LayerNorm: <span class="number">3</span>-<span class="number">4</span>                              <span class="number">1</span>,<span class="number">536</span></span><br><span class="line">│    │    └─Dropout: <span class="number">3</span>-<span class="number">5</span>                                --</span><br><span class="line">│    └─BertEncoder: <span class="number">2</span>-<span class="number">2</span>                                 --</span><br><span class="line">│    │    └─ModuleList: <span class="number">3</span>-<span class="number">6</span>                             <span class="number">85</span>,054,<span class="number">464</span></span><br><span class="line">│    └─BertPooler: <span class="number">2</span>-<span class="number">3</span>                                  --</span><br><span class="line">│    │    └─Linear: <span class="number">3</span>-<span class="number">7</span>                                 <span class="number">590</span>,<span class="number">592</span></span><br><span class="line">│    │    └─Tanh: <span class="number">3</span>-<span class="number">8</span>                                   --</span><br><span class="line">├─Dropout: <span class="number">1</span>-<span class="number">2</span>                                          --</span><br><span class="line">├─Linear: <span class="number">1</span>-<span class="number">3</span>                                           <span class="number">3</span>,076</span><br><span class="line">================================================================================</span><br><span class="line">Total params: <span class="number">109</span>,<span class="number">485</span>,<span class="number">316</span></span><br><span class="line">Trainable params: <span class="number">109</span>,<span class="number">485</span>,<span class="number">316</span></span><br><span class="line">Non-trainable params: <span class="number">0</span></span><br><span class="line">================================================================================</span><br><span class="line">epoch: <span class="number">10</span></span><br><span class="line">------------------------------------------</span><br><span class="line">train loss: <span class="number">0.445337</span>   [<span class="number">64</span>/<span class="number">320</span>]</span><br><span class="line">train loss: <span class="number">0.496814</span>   [<span class="number">128</span>/<span class="number">320</span>]</span><br><span class="line">train loss: <span class="number">0.416397</span>   [<span class="number">192</span>/<span class="number">320</span>]</span><br><span class="line">train loss: <span class="number">0.596100</span>   [<span class="number">256</span>/<span class="number">320</span>]</span><br><span class="line">train loss: <span class="number">0.358263</span>   [<span class="number">320</span>/<span class="number">320</span>]</span><br><span class="line">train_loss: <span class="number">0.405214</span>     train_acc: <span class="number">0.890625</span>   [<span class="number">285.0</span>/<span class="number">320</span>]</span><br><span class="line">val_loss: <span class="number">0.269997</span>     val_acc: <span class="number">0.725000</span>     <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p><img src="16.png" alt="16" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>PyTorch</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
        <tag>python</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>CVPR 2021 论文分享--微软亚洲研究院</title>
    <url>/2021/07/05/cvpr2021/</url>
    <content><![CDATA[<h2 id="图像生成领域">图像生成领域</h2>
<h3 id="information-bottleneck-disentanglement-for-identity-swapping换脸"><strong>Information Bottleneck Disentanglement for Identity Swapping</strong>（换脸）</h3>
<span id="more"></span>
<ul>
<li><p>Introdution</p>
<ul>
<li><p>Definition: Identity Swapping: a person in an existing image or video is replaced with someone else's likeness.</p></li>
<li><p>Main Dificultites &amp; Previous Works</p>
<ul>
<li><blockquote>
<p>Exchanging Face in Images ( 2004 ) : Large differences in viewpoint &amp; illumination</p>
<p>Face to Face (2016) : Preservation of target expression</p>
<p>On Face Segmentation Face Swapping, and Face Perception (2017): Robust face swapping</p>
<p>FaceSwap (2017) : Real-time subject-aware identity swapping</p>
<p>FSGAN (2019) : Subject agnostic</p>
<p>FaceShifter (2020): Occusion Aware</p>
</blockquote></li>
</ul></li>
</ul></li>
<li><p>the focus of this work：<strong>Disentanglement（解耦）从 target face 解耦出 target perception</strong></p>
<ul>
<li>Generated face = source identity + target perception(expression, pose, background, lighting...)</li>
</ul>
<p><img src="2.png" alt="1" style="zoom:40%;" /></p>
<ul>
<li><p>Identity mixed</p>
<p><img src="1.png" alt="1" style="zoom:40%;" /></p></li>
</ul></li>
<li><p>Methods：Measurement</p>
<ul>
<li>Discrimination 量化标准</li>
<li><img src="3.png" alt="1" style="zoom:40%;" /></li>
<li>generated identity 和 target identity 之间距离足够远，与source identity 距离足够进</li>
<li><img src="4.png" alt="1" style="zoom:40%;" /></li>
</ul></li>
<li><p>Disentangled representation learning</p>
<p><img src="5.png" alt="1" style="zoom:35%;" /></p>
<p>Perception的组成复杂，所以学习对最小身份信息的最小表征间接得到与身份信息相关度低的部分</p>
<ul>
<li>Information Bottleneck（IB） Principle</li>
<li><img src="6.png" alt="1" style="zoom:40%;" /></li>
<li>model： InfoSwap：预训练网络，输出Compressed Itentity Information. R 为中间特征</li>
<li><img src="7.png" alt="1" style="zoom:40%;" /></li>
</ul></li>
</ul>
<p>信息瓶颈层：预测信息控制层 <span class="math inline">\(\lambda\)</span>，控制 Identity Information 的输出，范围0-1. 从与当前瓶颈层的中间特征均值方差一致的高斯分布抽样噪声，得到 Z Identity vector</p>
<p><img src="8.png" alt="1" style="zoom:40%;" /></p>
<p>Loss</p>
<p><img src="9.png" alt="1" style="zoom:40%;" /></p>
<p><img src="10.png" alt="1" style="zoom:40%;" /></p>
<h3 id="leveraging-line-point-consistent-to-preserve-structure-for-wide-parallax-image-stitching-贾棋-图像拼接">Leveraging Line-point Consistent to Preserve Structure for Wide Parallax Image Stitching 贾棋 （图像拼接）</h3>
<ul>
<li>Motivation
<ul>
<li>Points and lines are matched separately --&gt; Inconsistently and non-uniformly stretched or compressed --&gt; artifacts in the stitched images</li>
<li>Limited matched point pairs --&gt; limited constrants for warping</li>
<li>Lacking global linear structure constraints</li>
<li>Conflicts on maintaining local and global structures</li>
<li>Existing metrics (RMSE /SSIM) can't reflect the alignment of points on linear structures or the collinearity of matched line segments</li>
</ul></li>
<li>Contributions
<ul>
<li>Consistant line-point constraints (匹配共面区域)
<ul>
<li>射映不变量 characteristic number（cn) 寻找共面匹配区域</li>
<li><img src="11.png" alt="1" style="zoom:30%;" /></li>
<li>计算单应矩阵H</li>
</ul></li>
<li>Maintain and balance both local shape and global linear structures （Mesh Deformation）
<ul>
<li>Energy Function：Line Preserving Term + Point-Line Alignment Term + Distortion Control Term</li>
<li><img src="12.png" alt="1" style="zoom:30%;" /></li>
</ul></li>
<li>Evaluation on linear structures
<ul>
<li>Quality Matrix</li>
<li><img src="13.png" alt="1" style="zoom:30%;" /></li>
</ul></li>
</ul></li>
<li>Experiments</li>
</ul>
<h3 id="facelnpainter-high-fidelity-face-adaptation-to-heterogeneous-domains异构域换脸">Facelnpainter: High Fidelity Face Adaptation to Heterogeneous Domains（异构域换脸）</h3>
<ul>
<li>Motivation
<ul>
<li>Identity modification</li>
<li>Attribute preservation (pose, expression, lighting, occlusion, background) - 3D ， Contextual loss</li>
<li>Boundary artifacts - AdaRes</li>
<li>Low quality - DFT</li>
<li>Face-swapping video synthesis</li>
<li>Heterogeneous domains - FaceInpainter</li>
</ul></li>
<li>Approach
<ul>
<li><img src="14.png" alt="1" style="zoom:40%;" /></li>
</ul></li>
</ul>
<h2 id="图像处理">图像处理</h2>
<h3 id="deep-homography-for-efficient-stereo-image-compressioncvpr-2021-oral-基于单应性变换的高效双目图像压缩算法"><a href="http://buaamc2.net/pdf/cvpr21hesic.pdf">Deep Homography for Efficient Stereo Image Compression（CVPR-2021 oral）</a> 基于单应性变换的高效双目图像压缩算法</h3>
<ul>
<li><p>研究背景及思路</p>
<ul>
<li>双目图像联合压缩：双目摄影设备拍摄图片具有高重复性、相似性</li>
<li>深度学习的双目图像压缩-DSIC</li>
<li>传统双目图像匹配——单应性变换 H （双目图片基本为刚性变换）</li>
<li>基于深度学习的双目图像匹配 —— 预测图像的 Homographic 矩阵</li>
</ul></li>
<li><p>研究方法</p>
<ul>
<li><p>设计思想：将左目图像作为主视图，进行正常的Encode 和 Decode， 右目图像以左目为先验知识，关注压缩和解压缩左目不存在的信息</p></li>
<li><p>网络结构设计： H计算及压缩+双目编码、主视眼优先解码+指导辅助眼解码+交叉质量增强</p>
<p><img src="15.png" alt="1" style="zoom:50%;" /></p>
<ul>
<li>Regression Model 计算 H 矩阵，将左目变换到右目图像再进行 congnition，右目图像质量优于左目</li>
<li>Cross Quality Enhancement （QCE) ：
<ul>
<li>解压的左目、右目、Hmatrix 作为输入</li>
<li>联合指导：左目图像变换后指导右目图像，右目图像变换后指导左目。实现左右目图像均衡提升</li>
</ul></li>
<li>熵编码模型 HESIC
<ul>
<li>混合高斯双目熵模型——适应于GPU并行加速 （y1左目，y2右目）</li>
<li><img src="16.png" alt="1" style="zoom:50%;" /></li>
<li>基于上下文双目高斯熵模型</li>
<li><img src="17.png" alt="1" style="zoom:50%;" /></li>
</ul></li>
<li>Loss</li>
<li><img src="18.png" alt="1" style="zoom:50%;" /></li>
</ul></li>
<li><p>贡献</p>
<ul>
<li>提出基于深度学习的单应性双目图像压缩算法，利用神经网络计算 H 矩阵提高压缩效率</li>
<li>熵模型预测编码解码的概率分布</li>
<li>提出CQE模块，提高解码性能</li>
</ul></li>
</ul></li>
</ul>
<h3 id="learning-scalable-ell_infty-constrained-near-lossless-image-compression-via-joint-lossy-image-and-residual-compression-图像压缩">Learning Scalable <span class="math inline">\(\ell_\infty\)</span>-constrained Near-lossless Image Compression via Joint Lossy Image and Residual Compression (图像压缩)</h3>
<ul>
<li><p>Introduction</p>
<ul>
<li><p>Loss Image Compression</p>
<ul>
<li>Trade-off between bit-rates and distortion(high compression ratio)</li>
<li>DIstortion measures :
<ul>
<li>PSNR or MS-SSIM (average quality)</li>
<li>Potential problem: small average distortion but large local distortion</li>
</ul></li>
<li>Weakness: 不可靠
<ul>
<li>在专业图像领域：医学影响、遥感影像、图像归档</li>
</ul></li>
</ul></li>
<li><p>Lossless Image Compression</p>
<ul>
<li>可靠</li>
<li>理论限制：bit-rates &gt;= entropy.<br />
</li>
<li>实际：bit-rates ~= cross entropy</li>
<li>低压缩率</li>
</ul></li>
<li><p>Near-lossless Image Compression</p>
<ul>
<li><p>image compression under a tight <span class="math inline">\(\ell_\infty\)</span>error bound</p></li>
<li><p>If <span class="math inline">\(\tau = 0\)</span>, special case: lossless compression</p></li>
<li><p>Advantages: More reliable &amp;&amp; Higher compression ratio</p></li>
<li><p>Challenges: <span class="math inline">\(\ell_\infty\)</span> 不可导 &amp; 有损压缩策略不能严格保证满足 <span class="math inline">\(\ell_\infty\)</span> 失真约束</p></li>
<li><p>schemes：将有损+残差编码建模为联合优化的无监督学习问题</p>
<ul>
<li><img src="19.png" alt="1" style="zoom:50%;" /></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>Algorithm</p>
<ul>
<li>提出隐变量模型<span class="math inline">\(p_\theta\)</span>, y 为隐变量</li>
</ul></li>
</ul>
<p><img src="20.png" alt="1" style="zoom:40%;" /></p>
<p><img src="21.png" alt="1" style="zoom:40%;" /></p>
<p><img src="22.png" alt="1" style="zoom:40%;" /></p>
<h2 id="底层视觉">底层视觉</h2>
<h3 id="neighbor2-neighbor-self-supervised-denoising-from-single-noisy-images图像去噪">Neighbor2 Neighbor Self-supervised Denoising from Single Noisy Images(图像去噪)</h3>
<ul>
<li>Research Background
<ul>
<li>Image Noise： Shot noise(Poisson) 、read noise(Gaussian) 、Dark current noise 、Row/Column noise</li>
<li>Synthetic paired data based methods</li>
<li>Real-world paired data based methods</li>
<li>GroundTruth-free based methods
<ul>
<li>ztraditional methods BM3D. NLM</li>
<li>noisy-pairs based methods Noise 2noise</li>
<li>Self-supervised methods
<ul>
<li>Regularization-based methods Deep Image Prior</li>
<li>Blind-spot Network based methods Noise2self. Noise2void Laine19</li>
<li>Pseudo-noisy-pairs based methods Noisy-as-clean, Noiser2noise, Self2self</li>
</ul></li>
</ul></li>
</ul></li>
<li>Proposed Method
<ul>
<li>Revisit Noise 2noise：两个含噪声图像训练模型和干净图像训练的模型参数一致</li>
<li><img src="23.png" alt="1" style="zoom:30%;" /></li>
<li>Generalization to noisy pairs with Similar clean images</li>
<li><img src="24.png" alt="1" style="zoom:30%;" /></li>
<li>Application to single Noisy Images：设计采样器人为构造一个相近的含噪声观测
<ul>
<li><img src="25.png" alt="1" style="zoom:30%;" /></li>
</ul></li>
<li>Neighbor2Neighbor Framework</li>
<li><img src="26.png" alt="1" style="zoom:50%;" /></li>
</ul></li>
</ul>
<h3 id="event-based-synthetic-aperture-imaging-with-a-hybrid-network合成孔径成像">Event-based Synthetic Aperture Imaging with a Hybrid Network（合成孔径成像）</h3>
<ul>
<li><p>Frame-based SAL: Principle</p></li>
<li><p><img src="27.png" alt="1" style="zoom:40%;" /></p></li>
<li><p>limits</p></li>
<li><p><img src="28.png" alt="1" style="zoom:40%;" /></p></li>
<li><p>Event Camera：Biology has no notion of frames, and works continuously and asynchronously</p>
<ul>
<li>Each event contains: 1. time stamp; 2. pixel location; 3. polarity(ON, OFF</li>
<li><img src="29.png" alt="1" style="zoom:40%;" /></li>
</ul></li>
</ul>
<p><img src="30.png" alt="1" style="zoom:40%;" /></p>
<p><img src="31.png" alt="1" style="zoom:40%;" /></p>
<ul>
<li>Framework
<ul>
<li>Refocus：Align signal events, while scatter out noise events</li>
<li>Hybrid NN：SNN（encoder）+CNN（decoder)</li>
<li><img src="32.png" alt="1" style="zoom:40%;" /></li>
</ul></li>
</ul>
<h3 id="deep-animation-video-interpolation-in-the-wild-动漫视频视频拆分">Deep Animation Video Interpolation in the Wild (动漫视频视频拆分)</h3>
]]></content>
      <categories>
        <category>CVPR</category>
      </categories>
      <tags>
        <tag>CVPR</tag>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<figure>
<img src="/images/avatar.jpg" alt="avatar" /><figcaption aria-hidden="true">avatar</figcaption>
</figure>
<figure>
<img src="/images/test.png" alt="test" /><figcaption aria-hidden="true">test</figcaption>
</figure>
]]></content>
  </entry>
  <entry>
    <title>liuyang</title>
    <url>/2019/03/26/liuyang/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>Learning Summary（1）</title>
    <url>/2021/06/30/summary1/</url>
    <content><![CDATA[<h2 id="公开课">公开课</h2>
<p>Machine Learning 2021 Spring：（p1-p20）</p>
<ul>
<li>machine learning还有deep learning的基本概念（机器学习类别：<strong>Regression</strong> <strong>Classification</strong> <strong>Structured Learning</strong>）</li>
</ul>
<span id="more"></span>
<ul>
<li>training 基本步骤 (Model with unknown parameters，Define Loss，Optimization)</li>
<li>training 问题（model bias、overfitting、Gradient disappearance）
<ul>
<li>Escaping saddle points along the direction of eigenvectors of the Hessian matrix</li>
<li>Batch and Momentum</li>
<li>Adaptive Learning Rate</li>
<li>Batch Normalization</li>
</ul></li>
<li>Classification with CNN</li>
</ul>
<h2 id="pytorch">Pytorch</h2>
<p>PyTorch Fundamentals by MicroSoft</p>
<ul>
<li>了解PyTorch的基本模块及方法（Tensor, Datasets&amp;&amp;Dataloaders, Transform, nn.Module, opim）
<ul>
<li><a href="https://research.zalando.com/welcome/mission/research-projects/fashion-mnist/">Fashion-MNIST</a> dataset</li>
<li>Build a neural network（Flatten, Linear, Relu, Softmax）</li>
<li>Loss Function: CrossEntropyLoss( )</li>
<li>Optimizer: Stochastic Gradient Descent</li>
<li>Save and load the model</li>
</ul></li>
<li>Computer Vision with PyTorch
<ul>
<li>MNIST Dataset
<ul>
<li>from DNN, MLP to CNNs(nn.Conv2d)</li>
<li>Multi-layered CNNs and pooling layers(Average Pooling, Max Pooling)</li>
<li>Validation Accuracy : DNN - 89%, MLP - 96%, Simplest CNN-97%, Multi-Layers CNN-98%</li>
</ul></li>
<li>Training with real images from the CIFAR-10 dataset
<ul>
<li>LeNet proposed by <em>Yann LeCun</em>.</li>
</ul></li>
<li>Cats vs. Dogs Dataset（use 2000 pictures due to the limitation of cpu）
<ul>
<li>use pre-trained model VGG-16 from <code>torchvision</code> module</li>
<li>Extracting VGG16 features manually for training</li>
<li>Transfer Learning
<ul>
<li>replace the final classifier with 25088 inputs and 2 output neurons</li>
<li>freeze weights of convolutional feature extractor</li>
</ul></li>
<li>Validation Accuracy：99%</li>
</ul></li>
<li>Other computer vision models（ResNet、MobileNet）</li>
</ul></li>
</ul>
<p>Next Week</p>
<ul>
<li>Natural Language Processing with PyTorch</li>
<li>Audio Classification with PyTorch</li>
<li>Start learning more details of PyTorch</li>
</ul>
]]></content>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac OS实现终端科学上网</title>
    <url>/2019/04/08/mac-os%E5%AE%9E%E7%8E%B0%E7%BB%88%E7%AB%AF%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
    <content><![CDATA[<blockquote>
<p>shadowsocks 开启 Manual Mode 后，系统内软件只有通过预先设置的监听地址(例如：127.0.0.1:1086)在能通过ss进行科学上网。</p>
</blockquote>
<span id="more"></span>
<h1 id="shadowsocks-ng">ShadowSocks-NG</h1>
<blockquote>
<p>下载地址： <a href="https://github.com/shadowsocks/ShadowsocksX-NG" class="uri">https://github.com/shadowsocks/ShadowsocksX-NG</a></p>
<p>若使用 Manual Mode 推荐与 <a href="https://github.com/FelisCatus/SwitchyOmega">SwitchyOmega</a>插件一起使用</p>
</blockquote>
<h1 id="mac-os-系统下通过-proxychains-ng-实现终端科学上网">Mac OS 系统下通过 ProxyChains-NG 实现终端科学上网</h1>
<blockquote>
<p>项目主页：<a href="https://github.com/rofl0r/proxychains-ng" class="uri">https://github.com/rofl0r/proxychains-ng</a></p>
</blockquote>
<h2 id="安装">安装</h2>
<ol type="1">
<li><p>使用 HomeBrew 安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install proxychains-ng</span><br></pre></td></tr></table></figure></li>
<li><p>Git Clone</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/rofl0r/proxychains-ng.git</span><br><span class="line">cd proxychains-ng</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">cp ./src/proxychains.conf /etc/proxychains.conf</span><br><span class="line">cd .. &amp;&amp; rm -rf proxychains-ng</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="配置">配置</h2>
<p>编辑配置文件 <code>vim /usr/local/etc/proxychains.conf</code></p>
<p>在 <code>[ProxyList]</code> 下面（也就是末尾）加入代理类型，代理地址和端口 例如使用 TOR 代理，注释掉原来的代理并添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`socks5  127.0.0.1 1080`</span><br></pre></td></tr></table></figure>
<p>「注」：这里地址为 ss 本地监听地址</p>
<p><strong>推荐配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strict_chain</span><br><span class="line">proxy_dns </span><br><span class="line">remote_dns_subnet 224</span><br><span class="line">tcp_read_time_out 15000</span><br><span class="line">tcp_connect_time_out 8000</span><br><span class="line">localnet 127.0.0.0/255.0.0.0</span><br><span class="line">quiet_mode</span><br><span class="line"></span><br><span class="line">[ProxyList]</span><br><span class="line">socks5  127.0.0.1 1086</span><br></pre></td></tr></table></figure>
<h2 id="使用">使用</h2>
<p>在命令前加上 proxychains4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains4 curl https://www.twitter.com/</span><br><span class="line">proxychains4 git push origin master</span><br></pre></td></tr></table></figure>
<p>或者使用bash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains4 bash</span><br><span class="line">curl https://www.twitter.com/</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<h1 id="终端命令设置非永久">终端命令设置(非永久)</h1>
<p>简单直接且影响较小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 设置代理 </span><br><span class="line">export ALL_PROXY=socks5://127.0.0.1:1086</span><br><span class="line">// 清除代理 </span><br><span class="line">unset ALL_PROXY</span><br><span class="line">// 查看ip测试是否生效</span><br><span class="line">curl -i http://ip.cn</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>ProxyChains</tag>
      </tags>
  </entry>
  <entry>
    <title>summary2</title>
    <url>/2021/07/06/summary2/</url>
    <content><![CDATA[<h2 id="公开课">公开课</h2>
<p>Machine Learning 2021 Spring：</p>
<span id="more"></span>
<ul>
<li>Input as vector
<ul>
<li>One-Hot encoding</li>
<li>Word Embedding</li>
</ul></li>
<li>Sequence Labeling
<ul>
<li>Fully-Connected Network</li>
<li>Self-attention</li>
<li>Multi-head Self-attention</li>
<li>Positional Encoding + Self-attention</li>
</ul></li>
</ul>
<h2 id="pytorch-fundamentals-by-microsoft">PyTorch Fundamentals by MicroSoft</h2>
<ul>
<li><p>Natural Language Tasks （Text Classification、Intent Classification、Sentiment Analysis、Named Entity Recognition、Keyword extraction、Text Summarization ）</p></li>
<li><p>Text Classfication with PyTorch (<strong>torchtext</strong>)</p>
<ul>
<li><p>Representing text as Tensors : (Character-level, Word-level )</p></li>
<li><p>Dataset : AG_NEWS (4 categories)</p></li>
<li><p>Bag of words text representation</p>
<ul>
<li><p>Training Bow classifier (simple linear layer) val_acc: 90%</p></li>
<li><p>Term Frequency Inverse Document Frequency (TF-IDF)</p></li>
</ul></li>
<li><p>Embeddings text represent</p>
<ul>
<li><p>word index in vocab as Input, padding minibatch into same length</p></li>
<li><p>Training Embedding classifier (Embedding layer, linear layer)</p></li>
<li><p><code>python       train_loss: 0.131295     train_acc: 0.959406        val_loss: 0.258924     val_acc: 0.916708</code></p></li>
<li><p>Variable-Length Sequence Representation，<strong>offset vector</strong> without padding batch</p></li>
</ul></li>
<li><p>Using Pre-Trained Semantic Embeddings: Word2Vec</p>
<ul>
<li>val_acc: 92.67%</li>
</ul></li>
<li><p>using RNN</p>
<ul>
<li>use padded data loader</li>
<li>model ( Embedding layer + RNN + linear layer)</li>
<li>Val_acc : 90%</li>
</ul></li>
<li><p>Long Short Term Memory (LSTM)</p>
<ul>
<li>Packed sequences</li>
<li>Val_acc : 91%</li>
</ul></li>
<li><p>Using BERT for text classification</p>
<ul>
<li>training can not be finished by cpu</li>
</ul></li>
</ul></li>
<li><p>Generate text with LSTM</p>
<ul>
<li>Building character vocabulary</li>
<li>training generative LSTM</li>
<li>Soft text generation and temperature</li>
</ul></li>
</ul>
<h2 id="cvpr-2021-论文分享会">CVPR 2021 论文分享会</h2>
<ul>
<li><p>Session1 图像生成</p>
<ul>
<li><p>Information Bottleneck Disentanglement for Identity Swapping（换脸）</p></li>
<li><p>Leveraging Line-point Consistent to Preserve Structure for Wide Parallax Image Stitching</p></li>
<li><p>Facelnpainter: High Fidelity Face Adaptation to Heterogeneous Domains</p></li>
</ul></li>
<li><p>Session2 图像处理</p>
<ul>
<li>Deep Homography for Efficient Stereo Image Compression（CVPR-2021 oral）</li>
<li>Learning Scalable <span class="math inline">\(\ell_\infty\)</span>-constrained Near-lossless Image Compression via Joint Lossy Image and Residual Compression</li>
</ul></li>
<li><p>Session3 底层视觉</p>
<ul>
<li>Neighbor2 Neighbor Self-supervised Denoising from Single Noisy Images</li>
<li>Deep Animation Video Interpolation in the Wild</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>人脸识别系统</title>
    <url>/2020/03/13/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="人脸识别的一般系统框架">人脸识别的一般系统框架</h1>
<span id="more"></span>
<p><img src="识别系统.jpg" style="zoom:40%;" /></p>
<p>如上图人所示，脸识别系统一般分为三部分：<strong>人脸检测、特征提取、人脸识别</strong></p>
<ul>
<li><p>人脸检测</p>
<p>指输入人脸图像后，对图像进行检测，提取出人脸所在区域。因为不同的照片不可能一致，因此对提取的人脸归一化，使得人脸区域与照片中的姿态、尺寸大小、旋转角度无关。</p></li>
<li><p>特征提取</p>
<p>计算机获取的人脸图像本质上就是连续的数字，不可能直接使用。要实现人脸识别，必须将人脸的图像特征转换为数字特征，给计算机提供识别的基础条件。特征提取的好坏直接影响了后续分类的结果，一个分类器的性能表现受到多中因素影响，主要依赖于采样图像数量、特征个数和分类器发复杂度。同时由于获取到的图像数据庞大，数据维度极高，因此需要比较大的计算处理时间，极大的影响了整个系统的性能。</p>
<p>因此特征提取分为三个步骤：</p>
<ul>
<li>降低维度：所有人脸识别系统必不可少的一步。降低图像数据维度（PCA 等方法降维），减少不必要的计算量</li>
<li>特征提取：从人脸图像中提取特征。</li>
<li>特征算则：从提取的众多特征中，选取特征的最优化子集</li>
</ul></li>
<li><p>人脸识别</p>
<p>系统从数据库中揭示同一性，包括：比对、分类算法和精确测量。若输入图像与数据库比对成功，则识别成功</p></li>
</ul>
<h1 id="haar分类器">Haar分类器</h1>
<p>​ 人脸检测的研究最早开始于 20 世纪 70 年代，当时对于人脸检测的研究方向少，主要是基于固定模版或可变模版的匹配方法及子空间分析两个大方向。目前的人脸检测方法发生了很大的改变，主要有基于知识和基于统计</p>
<ul>
<li>基于知识：主要利用先验知识将人脸看做器官特征的组合，根据眼睛、鼻子、嘴巴等器官的特征以及相互之间的几何位置关系检测人脸，基于知识的人脸检测方法主要有：
<ul>
<li>模版匹配</li>
<li>人脸特征</li>
<li>形状与边缘</li>
<li>纹理特征</li>
<li>颜色特征</li>
<li>基于肤色的人脸检测</li>
</ul></li>
<li>基于统计：将人脸看做二维像素矩阵，通过大量的训练样本构造人脸模式空间，以相似度作为判断的依据，主要方法有：
<ul>
<li>神经网络</li>
<li>统计知识理论</li>
<li>支持向量机</li>
<li>基于马尔科夫随机域</li>
<li>PCA与特征脸</li>
</ul></li>
</ul>
<p>​ 目前，人脸识别的方法主要是结合 <strong>Adaboost</strong> 学习方法和 <strong>Haar-like</strong>特征的 <strong>Haar</strong> 分类器算法。通过采集训练图片的 <strong>Haar-like</strong> 特征，训练多级的 <strong>Adaboost</strong> 分类器，对获取的图像归类，对人脸进行识别。</p>
<h2 id="人脸姿态">人脸姿态</h2>
<p>​ 人脸检测所采集到的图片质量层次不齐，人脸的姿态更是千差万别，不同的人脸姿态对于分类器的影响不可忽视。一般的人脸姿态有：正脸、微角度侧脸、较大角度侧脸</p>
<h2 id="haar-like-特征">Haar-like 特征</h2>
<p>​ Haar-like 特征在很多应用领域都有着广泛的应用，比如检测人脸、车辆、行人、表情等。最初是由 Viola 和 Jones 两位将基本 Haar 特征应用到人脸检测领域当中。基本 Haar 特征有三种类型：边缘特征、线性特征以及对角特征</p>
<p><img src="haar-like.png" style="zoom:40%;" /></p>
<ul>
<li>边缘特征是计算相邻两个白色与黑色矩形区域像素总和的差分值反映了图像的边缘信息；</li>
<li>线特征是计算处于两边的两个外部的白色矩形区域的像素总和与中间单独黑色矩形区域像素总和的差分值，反映了图像线性方向上的信息；</li>
<li>对角特征是计算两条对角线上长方形内部像素总和的差分值，反映了图像整体的信息；</li>
</ul>
<p><strong>模版特征值计算</strong></p>
<ul>
<li>模板 a 的特征值计算公式为： v=Sum黑-Sum 白。</li>
<li>模板 bl 的特征值计算公式为： v=Sum黑-Sum 白。</li>
<li>模板 br 的特征值计算公式为： v=2*Sum黑-Sum 白。 （保证做差时像素的数目相等，将 Sum黑乘以 2）</li>
<li>模板 c 的特征值计算公式为： v=Sum黑-Sum 白。</li>
</ul>
<p>后来 Rainer 等人对Haar-like 特征进行了拓展，引入了中心环绕特征及原本特征的 45° 旋转特性，如下图所示</p>
<p><img src="haar-like-expand.png" alt="扩展 Haar-like 特征" style="zoom:40%;" /></p>
<center>
 扩展的 Haar-like 特征
</center>
<p>扩展后的 Haar-like 特征集的特征组合更多，扩大了特征空间，扩展了识别目标的范围，提高了识别的精度。</p>
<p>​ 通过正样本图像矩阵的大小可以计算出图像中 Haar 特征存在的数量。用特征模版在图像窗口内随意滑动，找出图像中所有子窗口的Haar-like 特征训练弱分类器。</p>
<p><img src="haar范例.png" style="zoom:40%;" /></p>
<p>​ 矩阵特征可位于图像任意位置，大小也可以任意改变，所以矩形特征值是<strong>矩形模板类别、矩形位置和矩形大小</strong>这三个因素的函数。故类别、大小和位置的变化，使得很小的检测窗口含有非常多的矩形特征。下面给出计算特征数量的公式</p>
<p><strong>对于Upright rectangle，设图像宽度为 W，高度为 H, w 和 h 分别为 Haar-like 特征的宽度和高度，X 为矩形特征 x 方向上最大的比例系数，Y 为 y 方向上最大的比例系数, 则 X 与 Y的计算值分别为</strong>: <code>X=[W/w],Y=[H/h]</code>.</p>
<p><span class="math display">\[
\begin{equation}
Rotated\ rectangle\ 特征数 = X*Y*(W+1-w*\frac{X+1}{2})*(H+1-h*\frac{Y+1}{2})
\end{equation}
\]</span></p>
<blockquote>
<p>上述公式可以理解为：</p>
<ol type="1">
<li><p>特征框竖直放大1倍，即无放大，竖直方向有(H-h+1)个特征</p></li>
<li><p>特征框竖直放大2倍，竖直方向有(H-2h+1)个特征</p></li>
<li><p>特征框竖直放大3倍，竖直方向有(H-3h+1)个特征</p></li>
<li><p>如此到竖直放大Y=floor(H/h)倍，竖直方向有1个特征，即(H-Y*h+1)</p></li>
</ol>
<p>那么竖直方向总共有<code>(H-h+1)+(H-2h+1)+(H-3h+1)+......+(H-Y*h+1)=Y[H+1-h(1+Y)/2]</code>个特征。同理在水平方向有<code>X(H+1-w*(1+X)/2)</code>由于水平方向与竖直方向的放缩是相互独立的，因此可以得到上式</p>
</blockquote>
<p>对于 45° rotated rectangle，设图像宽度为 W，高度为 H, w 和 h 分别为 Haar-like 特征的宽度和高度，特征宽度与高度均为 z=w+h，比例系数<code>X = ⌊W/z⌋,Y=⌊H/z⌋</code>**<br />
<span class="math display">\[
Rotated\ rectangle特征数 = X*Y*(W+1-z*\frac{X+1}{2})*(H+1-z*\frac{Y+1}{2})
\]</span></p>
<p>​ 例：在24*24像素大小的图像子窗口有超过18万个矩形特征，这个数字远远大于像素数。而每次计算图像特征值都要统计矩形窗口内所有像素值的和来计算特征值，即使每个特征都可以非常有效地计算，但计算完整集的代价十分昂贵。 最直接的解决方法就是用内存换取速度，把计算过的值保存起来，避免大量的重复计算。同时Paul Viola等人通过实验证明，只需要这些特征中的很小一部分就可以组合成一个有效的分类器。 主要的挑战是找到这些特征。</p>
<h2 id="积分图">积分图</h2>
<p>​ 在计算 Haar-like 特征值时，由于每次计算都要统计矩形窗口中的全部像素点，而普通的照片有大量的 Haar-like 特征，这直接导致了计算机需要做巨量的计算。针对这个问题 Viola 等人提出了使用积分图的方法加速特征值的计算。</p>
<p>​ 积分图思想：首先对图像进行预计算，从图像原点开始，计算每个像素到原点形成的矩形区域的像素和，再在内存中创建一维数组，将该像素点相对坐标转化为一维坐标作为数组索引，并将所求得的像素和存入对应数组中。故需要计算某个 Haar-like 特征时，无需计算矩形区域内的像素和，直接从预选存储的数组中查找对应索引即可。积分图本质上是一种查表算法，采取利用空间换取时间复杂度的方法降低计算量，使得仅需要对图像进行一次遍历和少量计算即可得到任意位置的 <strong>Haar-like</strong> 的特征值，大大提升了求取特征值的速度。</p>
<p>​ 积分图计算公式：积分图计算目标像素点与图像原点所组成的矩形区域的所有像素值和，计算公式如下</p>
<p><span class="math display">\[
ii(x,y) = \sum^{x}_{k=0}\sum^{y}_{l=0}f(k,l)
\]</span></p>
<p>其中，ii（x，y） 表示点（x，y）的积分图值，f（k，l）表示点（k，l）的像素值。</p>
<p><img src="积分图.png" style="zoom:50%;" /></p>
<p>​ 设 <strong><span class="math display">\[ii(-1,-1)=0,ii(0,-1)=0, ii(-1,0)=0\]</span></strong> ，则可递归计算 <span class="math display">\[ii(x,y)\]</span>，公式如下，故计算任一点的积分图值变得极其简单，只需进行3次查表，时间复杂度为O(1)。 <span class="math display">\[
ii(x,y) = i(x,y) + ii(x,y-1)+ii(x-1,y) -ii(x-1,y-1)
\]</span> 积分图构建算法：</p>
<p>​ 1）用s(i,j)表示行方向的累加和，初始化s(i,-1)=0;</p>
<p>​ 2）用ii(i,j)表示一个积分图像，初始化ii(-1,i)=0；</p>
<p>​ 3）逐行扫描图像，递归计算每个像素(i,j)行方向的累加和s(i,j)和积分图像ii(i,j)的值 <span class="math display">\[
s(i,j)=s(i,j-1)+f(i,j)
\]</span></p>
<p><span class="math display">\[
ii(i,j)=ii(i-1,j)+s(i,j)
\]</span></p>
<p>​ 4）扫描图像一遍，当到达图像右下角像素时，积分图像ii就构造好了。</p>
<p>例：计算图中 D 区域面积</p>
<p><img src="积分图计算.png" style="zoom:50%;" /></p>
<p>如图，图中分为A，B，C，D 四个区域及 a，b，c，d 四个点。点 a 与原点形成的矩形区域像素和为 <span class="math display">\[ii(a)\]</span> ，点 b 与原点形成的矩形区域像素和为 <span class="math display">\[ii(b)\]</span>，点 c 与原点形成的矩形区域像素和为 <span class="math display">\[ii(c)\]</span>，点 d 与原点形成的矩形区域像素和为 <span class="math display">\[ii(d)\]</span>。区域A的像素值和为<span class="math display">\[ii(a)\]</span>，区域B的像素值和为<span class="math display">\[ii(B) = ii(b)-ii(a)\]</span>，区域C的像素值和为 <span class="math display">\[ii(C) = ii(c)-ii(a)\]</span>，区域D的像素值和为<span class="math display">\[ii(D) = ii(d)-ii(A)-ii(B)-ii(C)=ii(d)-ii(c)-ii(b)+ii(a)\]</span>。无论矩形的尺寸大小，只需要查找积分图像4次就可以求得任意矩形内像素的和。对于 haar-like 基本特征来说，边缘特征需要查找积分图像6次、线性特征需要查找积分图像8次、对角特征需要查找积分图像9次。</p>
<p>同时，使用积分图使得在不同尺度上同时进行矩形特征的计算时间复杂度达到了常数级。物体在不同尺度下，有着不同的结构。这就表明，我们如果从不同的尺度去观察同一个物体，会得出不一样的结果。当计算机系统要对一个未知的场景进行分析时，并不能够提前预知要用什么样的尺度来对图像信息中的兴趣结构（interesting structures）进行描述才是最合适的。因此，唯一可行的方案就是将多个不同尺度的描述都考虑进来，以便捕获未知的尺度变化。为了检测图像中不同尺度大小的目标，必须对图像进行多尺度扫描。积分图弥补了图像金字塔降采样计算量大的缺点。</p>
<h2 id="adaboost-级联算法">AdaBoost 级联算法</h2>
<p>​ <strong>AdaBoost</strong> 算法由 <strong>Freund</strong> 和 <strong>Schapire</strong> 于1996年前后提出，是一个实际可用的自适应Boosting算法，并证明了AdaBoost 分类器的准确率在经过多次的训练后几乎为 1。AdaBoost 算法 Boosting 算法改进而来，弥补了 Boosting 算法的缺陷。AdaBoost 算法最早可追溯到上世纪80年代，由 Valiant 提出的概率近似正确（probably approximately correct，PAC）计算学习理论模型。Valiant 认为所谓学习就是与模式无关的获取知识的过程，即模式清晰的与否不影响知识的获取的一种过程。PAC 理论模型就是从计算角度获取该过程的一种方法，实质就是在样本训练的基础上，使算法的结果以概率接近未知的目标。PAC模型将学习的评判转化为形式化的概率。基于PAC学习模型，<strong>Valiant</strong>提出了Boosting算法。</p>
<p>​ <strong>Boosting</strong>算法是一种常用的统计学方法，基于思想：对于一个复杂任务来说，适当的综合多个专家的判断所得出的判断，要比其中任何专家的独断好。在分类问题中，它通过改变训练样本的权重，学习多个分类器，并将这些分类器进行线性组合，达到提高分类性能的目的。1990年，<strong>Schapire</strong>提出了第一个时间复杂度为多项式的 Boosting 算法。1991年，<strong>Freund </strong> 又提出了一个效率更高的Boosting算法，至此Boosting算法取得可观的效率提升。Boosting 算法还涉及弱可学习和强可学习的概念，弱学习就是指对目标类的学习算法的正确率仅比随机识别的正确率好一点；强学习与弱学习相对，其正确率要远高于随机分类。但强学习算法的设计难度要远远高于若学习算法，对此 <strong>Kearns</strong> 和<strong>Valiant</strong> 提出了弱学习和强学习等价的理论，并证明了只要有足够的样本数据，弱学习算法就能通过集成的方式，构成任意高精度的强学习方法。虽然 Boosting 算法得到了广泛验证和使用，但仍存在着几个主要的问题：</p>
<ul>
<li>Boosting算法需要预先知道弱学习算法正确率的下限，即弱分类器的误差。</li>
<li>Boosting算法可能导致后来的训练过分集中于少数特别难区分的样本。</li>
</ul>
<p>针对Boosting的上述缺陷，<strong>Freund</strong>和<strong>Schapire</strong>于1996年前后提出了一个实际可用的自适应 Boosting 算法 AdaBoost。AdaBoost目前已发展出了大概四种形式的算法：Discrete AdaBoost（AdaBoost.M1）、Real AdaBoost、LogitBoost、gentle AdaBoost，基本思想都是根据 <strong>Kearns</strong> 和<strong>Valiant</strong> 提出的弱强学习等价理论，通过对若干弱分类其进行线性组合，构建出强分类器。</p>
<h3 id="弱分类器的构建">弱分类器的构建</h3>
<p>弱分类器可以是一个基本的 Haar-like 特征值，将此特征值作为阈值与输入样本图像的 Haar-like 的特征值对比，输出结果。而这种分类器的正确率可能并不比随机判断的效果更好，因此需要对弱分类器进行训练和学习。在人脸检测的过程中，输入的人脸图像在不同尺寸的特征窗口所计算得到的 Haar-like 特征都可以作为阈值分类函数，对弱分类器的训练就是使用阈值分类函数对样本进行分类的过程。尽管弱分类器的效果不尽人意，我们仍然需要让弱分类器获取到最佳分类函数，使得其分类的正确率最大。弱分类器可以用如下数学语言定义 <span class="math display">\[
h_j(x) = \left\{\begin{matrix}
1\ \ \ \ \ \ if\ p_jf_j(x)&lt;p_j\theta_j\\ 
0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ otherwise
\end{matrix}\right.
\]</span> <span class="math display">\[h_j(x)\]</span>代表弱分类器，<span class="math display">\[p_j\]</span>代表不等号方向，<span class="math display">\[f_j(x)\]</span>代表第j个特征，<span class="math display">\[\theta_j\]</span>代表判断特征j的阈值。当样本小于阈值，为正样本输出为1；当样本大于阈值，为正样本输出为0。一个弱分类器可以看做是一棵决策树，非叶子节点代表某个对象，分叉路径代表可能的属性值，叶节点代表一种类别。一个完整的弱分类器包括：</p>
<ul>
<li>若干个 Haar 特征和对应阈值</li>
<li>若干 leftValue 和 若干 rightValue</li>
</ul>
<p><img src="弱分类器.png" style="zoom:40%;" /></p>
<p>最基本的弱分类器可以只有 一个 Haar 特征</p>
<p>训练最优的弱分类器就是对阈值不断筛选的过程，使得分类器对所有样本的分类误差最小。</p>
<p><del>阈值的选择往往根据正负样本的特征值分布选择，若样本数量足够多，其特征值分布符合正态分布，可以根据样本均值和样本方差近似得到其正态分布曲线。计算公式给出如下：</del> <span class="math display">\[
\mu = \frac{1}{n}\sum^N_{j=1}f(j)
\]</span></p>
<p><span class="math display">\[
S=\frac{1}{N-1}\sum^N_{j=1}(f(j)-\mu)^2
\]</span></p>
<p><del><span class="math display">\[f(j)\]</span>代表第j个样本特征，<span class="math display">\[\mu\]</span>代表样本均值，<span class="math display">\[S\]</span>代表样本方差，<span class="math display">\[N\]</span>代表样本数量</del></p>
<p>弱分类器训练过程如下：</p>
<ol type="1">
<li>计算所有训练样本的特征<span class="math display">\[f_j(x)\]</span>的值，并将其排序，扫描一遍排好序的特征值，对排好序的表中的每个元素，计算下面四个值：</li>
</ol>
<ul>
<li><p>全部人脸样本的权重的和 <span class="math display">\[t_1\]</span>；</p></li>
<li><p>全部非人脸样本的权重的和 <span class="math display">\[t_0\]</span>；</p></li>
<li><p>在此元素之前的人脸样本的权重的和 <span class="math display">\[s_1\]</span>；</p></li>
<li><p>在此元素之前的非人脸样本的权重的和 <span class="math display">\[s_0\]</span>；</p></li>
</ul>
<ol start="2" type="1">
<li>选取当前元素的特征值 <span class="math display">\[F_j\]</span>和它前面的一个特征值 <span class="math display">\[F_{j-1}\]</span>之间的数作为阈值，所得到的弱分类器就在当前元素处把样本分开 —— 也就是说这个阈值对应的弱分类器将当前元素前的所有元素分为人脸（或非人脸），而把当前元素后（含）的所有元素分为非人脸（或人脸）。该阈值的分类误差为：</li>
</ol>
<p><span class="math display">\[
r=min(s_1+(t_0-s_0),s_0+(t_1-s_1))
\]</span> 在表中寻找 r 值最小的元素，则该元素作为最优阈值，得到了一个最优弱分类器。</p>
<h3 id="强分类器的构建">强分类器的构建</h3>
<p>AdaBoost 算法是前向分步加法算法的特例，由基本分类器组成的加法模型。它将大量的弱分类器以某种规则进行组合为强分类器，不同的分类器赋予不同的权值，分类性能越好则权值越大。</p>
<h4 id="算法">算法</h4>
<ol type="1">
<li><p>设样本集<span class="math display">\[S={(x_1,y_1),(x_2,y_2),...,(x_N,y_N)}\]</span>，其中实例空间 <span class="math display">\[x\in X、X\in R^n\]</span>，对于回归问题，<span class="math display">\[y_i\in Y=\{0,1\}\]</span>，对于分类问题，<span class="math display">\[y_i\in Y=\{1,-1\}\]</span>，共有N个样本，正样本数为m，负样本数为n，最大循环次数为 T。</p></li>
<li><p>假设样本数据集具有均匀的权值分布，初始化训练数据的权值分布为<span class="math display">\[D_1\]</span>，每个训练样本初始赋予相同权值 <span class="math display">\[\frac{1}{N}\]</span></p></li>
<li><p>进行多轮迭代，每次迭代获得一个最优弱分类器，m = 1，2，···，M 表示迭代的轮数</p>
<ul>
<li><p>使用具有权值分布 <span class="math display">\[D_m\]</span> 的训练数据集学习，选取使误差率最低的阈值，得到基本分类器 <span class="math display">\[h_m(x)\]</span></p></li>
<li><p>计算 <span class="math display">\[h_m(x)\]</span> 在训练数据集上的分类误差，即被 <span class="math display">\[h_m(x)\]</span> 误分类的样本权值之和。</p>
<ul>
<li><p>对于AdaBoost二元分类问题</p>
<ul>
<li>分类误差为，这里的 <span class="math display">\[I(x)\]</span>为示性函数，体现事件 x 发生与否与0,1两值函数的对应关系</li>
</ul>
<p><span class="math display">\[
\varepsilon_m = P(h_m(x_i)≠y_i) = \sum^N_{i=1}w_{m,i}I(h_m(x_i)≠y_i)
\]</span></p>
<ul>
<li>计算<span class="math display">\[h_m(x)\]</span> 的系数 <span class="math display">\[\alpha_m\]</span>，表示在最终分类器中所占的权重。由式可知，<span class="math display">\[\alpha_m\]</span>随着<span class="math display">\[\varepsilon_m\]</span>的减小而增大，意味着分类误差率越小的弱分类器在最终分类器中的作用越大</li>
</ul>
<p><span class="math display">\[
\alpha_m=\frac{1}{2}log\frac{1-\varepsilon_m}{\varepsilon_m}
\]</span></p>
<ul>
<li>更新训练数据集的权值分布，用于下一轮迭代。使得被若分类器<span class="math display">\[f_m(x)\]</span>分类错误的样本权值增大，正确分类的样本权值减小，分类错误的样本权值相较于分类正确的样本权值放大了<span class="math display">\[exp(2\alpha_m)\]</span>倍</li>
</ul>
<p><span class="math display">\[
𝑤_{m+1,𝑖}=\frac{𝑤_{m,𝑖}}{𝑍_m}𝑒𝑥𝑝(−𝛼_m𝑦_𝑖h_m(𝑥_𝑖))\\
Z_m = \sum^N_{i=1}w_{m,i}𝑒𝑥𝑝(−𝛼_m𝑦_𝑖h_m(𝑥_𝑖))
\]</span></p></li>
<li><p>对于AdaBoost回归问题</p>
<ul>
<li><p>设<span class="math display">\[h_m(x)\]</span>在训练集的最大误差为<span class="math display">\[E_m\]</span>，每个样本的相对误差为<span class="math display">\[\varepsilon_{mi}\]</span> <span class="math display">\[
E_m = max|y_i-h_m(x_i)|\ \ \ \ \ i=1,2,...,N
\\
误差损失为线性时，\varepsilon_{mi} = \frac{|h_{mi}(x_i)-y_i|}{E_m}
\\
误差损失为指数时，\varepsilon_{mi} = 1-exp(\frac{-y_i+h_m(x_i)}{E_m})
\\
第m个弱分类器误差，\varepsilon_m=\sum^N_{i=1}w_{m,i} |h_i-y_i|
\]</span></p></li>
<li><p>弱分类器权值系数 <span class="math display">\[
\alpha_m=\frac{\varepsilon_m}{1-\varepsilon_m}
\]</span></p></li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<ul>
<li><p>更新训练数据集的权值分布，用于下一轮迭代。使得被若分类器<span class="math display">\[f_m(x)\]</span>分类错误的样本权值增大，正确分类的样本权值减小</p></li>
<li><p>$$ D_{m+1} = (w_{m+1,1},w_{m+1,2},...,w_{m+1,N}) \</p>
<pre><code>   \\
   w_&#123;m+1,i&#125; = \frac&#123;w_&#123;m,i&#125;&#125;&#123;Z_m&#125;\alpha^&#123;1-\varepsilon_&#123;m,i&#125;&#125;_m\ \ \ \ \ \ \ \ \ ，其中i=1,2,...,N ,\\ \ 
   规范因子，Z_m=\sum^N_&#123;i=1&#125;w_&#123;m,i&#125;\alpha^&#123;1-\varepsilon_&#123;m,i&#125;&#125;_m</code></pre>
<p>$$</p></li>
<li><p>Adaboost分类采用的是加权表决法，最终的强分类器为 <span class="math display">\[
   组合各个弱分类器，\ \ 𝑓(𝑥)=(\sum^N_{m=1}𝛼_mh_m(𝑥))
   \\
   最终分类器，\ \ h(x) = sign(f(x))
   \]</span></p>
<ul>
<li>Adaboost回归采用的是对加权的弱学习器取权重中位数对应的弱学习器作为强学习器的方法</li>
</ul></li>
</ul>
<p><span class="math display">\[
h(x)=\left\{\begin{matrix}
1\ \ \ \ \ \ if \ \sum^N_{m=1} \alpha_mh_m(x) \geq\frac{1}{2}\sum_{m=1}^{N}\alpha_m
\\
0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ otherwise
\end{matrix}\right.\\
其中，\alpha_m = log\frac{1}{\beta_m}
\]</span></p>
<h4 id="adaboost-算法的训练误差分析">AdaBoost 算法的训练误差分析</h4>
<p>设AdaBoost 算法的误差为 Error，值为分错的样本个数与样本总体N的比值，形式化表达为 <span class="math display">\[
Error = \frac{1}{N}\sum_{i=1}^NI(h(x_i)≠y_i )
\]</span></p>
<h4 id="adaboost-训练误差界">AdaBoost 训练误差界</h4>
<p>设共有M个弱分类器，f(x)为组合的弱分类器，且<span class="math display">\[f(x_i)=\sum^M_{m=1}\alpha_mh_m(x_i)\]</span>. <span class="math display">\[
Error ≤\frac{1}{N} \sum_i^Nexp⁡(-y_i f(x_i)) ≤\prod_{m=1}^MZ_m
\]</span> 下面给出证明</p>
<ol type="1">
<li><p>对于<span class="math display">\[Error ≤\frac{1}{N} \sum_i^Mexp⁡(-y_i f(x_i))\]</span>，转化为<span class="math display">\[I(h(x_i)≠y_i )≤exp⁡(-y_i f(x_i))\]</span>.</p>
<p>1）当 <span class="math display">\[I(h(x_i)≠y_i )=0\]</span>时，<span class="math display">\[h(x_i)=y_i , \ \ exp⁡(-y_i f(x_i))&gt;0\]</span></p>
<p>2）当 <span class="math display">\[I(h(x_i)≠y_i )=1\]</span>时，<span class="math display">\[|h(x_i)|=| y_i|，h(x_i)*y_i=-1\]</span>，故 <span class="math display">\[exp⁡(-y_i f(x_i))&gt;1\]</span></p>
<p>得证.</p></li>
<li><p>对于<span class="math display">\[\sum_i^Mexp⁡(-y_i f(x_i)) ≤\prod_{m=1}^MZ_m\]</span></p>
<p>1）由<span class="math display">\[w_{m+1,i}=\frac{w_{mi}}{Z_m}exp⁡(-\alpha_m y_i h_m (x_i))\]</span>可得 <span class="math display">\[
w_{m+1,i}=\frac{w_{mi}}{Z_m}exp⁡(-\alpha_m y_i h_m (x_i))=\frac{w_{m-1,i}}{Z_mZ_{m-1}}exp⁡(-\alpha_{m-1} y_i h_{m-1} (x_i))exp⁡(-\alpha_m y_i h_m (x_i))=\\
\frac{w_{m-2,i}}{Z_mZ_{m-1}Z_{m-2}}exp(-\alpha_{m-2} y_i h_{m-2})exp⁡(-\alpha_{m-1} y_i h_{m-1} (x_i))exp⁡(-\alpha_m y_i h_m (x_i))=···\\=\frac{w_{1i}}{\prod^M_{j=1}Z_j}exp(-y_i\sum^M_{m=1}\alpha_mh_m(x_i))
\]</span> 2）有<span class="math display">\[\sum^N_{i=1}w_{m,i}=1，且 w_{1,i}=\frac{1}{N}\]</span>，所以 <span class="math display">\[
\sum^N_{i=1}w_{m+1,i}=\frac{1}{N}\sum^N_{i=1}\frac{exp(-y_i\sum^M_{m=1}\alpha_mh_m(x_i))}{\prod^M_{m=1}Z_m}=1\\
即，\ \ \frac{1}{N}\sum^N_{i=1}exp(-y_i\sum^M_{m=1}\alpha_mh_m(x_i))) = \prod^M_{m=1}Z_m\\
又，f(x_i)=\sum^M_{m=1}\alpha_mh_m(x_i)，\ \ 故\ \ \frac{1}{N}\sum^N_{i=1}exp(-y_if(x_i))) = \prod^M_{m=1}Z_m
\]</span> 每一轮选取适当的弱分类器<span class="math display">\[h_m(x)\]</span>使得<span class="math display">\[Z_m\]</span>最小，可以加快训练误差的下降速度</p></li>
</ol>
<h4 id="adaboost的二分类问题训练误差界">AdaBoost的二分类问题训练误差界</h4>
<p><span class="math display">\[
 Z_m≤ exp{\left(-2\sum_{m=1}^M\gamma_m^2\right)} ≤ exp(-2M\gamma^2)\\
其中，\gamma_m = \frac{1}{2} - \varepsilon_m, \ \ 误差下限\ \gamma=min\{\gamma_1, \gamma_2, ... , \gamma_M\} &gt; 0
\]</span></p>
<p>证明 <span class="math display">\[
Z_m = \sum_{i=1}^Nw_{mi}exp⁡(-\alpha_m y_i h_m (x_i)) = \sum_{y_i=G_m(x_i)}w_{mi}exp({-\alpha_m}) +  \sum_{y_i≠G_m(x_i)}w_{mi}exp(\alpha_m)=(1-\varepsilon_m)exp(-\alpha_m)+\varepsilon_mexp(\alpha_m)\\
已知，\ \ \alpha_m=\frac{1}{2}log\frac{1-\varepsilon_m}{\varepsilon_m}，\ \ 则\ \ exp(\alpha_m)=\sqrt{\frac{1-\varepsilon_m}{\varepsilon_m}}\\
令 \ \ \gamma_m=\frac{1}{2}-\varepsilon_m， \ \ Z_m = (1-\varepsilon_m)\sqrt{\frac{\varepsilon_m}{1-\varepsilon_m}}+\varepsilon_m\sqrt{\frac{1-\varepsilon_m}{\varepsilon_m}}=2\sqrt{\varepsilon_m(1-\varepsilon_m)}=\sqrt{1-4(\frac{1}{2}-\varepsilon_m)^2}=\sqrt{1-4\gamma_m^2}\\
有泰勒公式 1-x ≤ exp(-x),\ \ Z_m = \sqrt{1-4\gamma_m^2}≤exp(-2\gamma_m^2)\\
即，\ \ \prod^M_{m=1}Z_m ≤ exp(-2\sum^M_{m=1}\gamma_m^2)≤ exp(-2M\gamma^2)\ \ \ \ \ \ \ \ \ \ \gamma=min\{\gamma_1,\gamma_2,...,\gamma_M\}&gt;0
\]</span> 该式表明，对于二分类问题，AdaBoost 算法的训练误差以指数速度下降，其次 AdaBoost 算法的自适应决定了它能适应各弱分类器的误差率，不需要预先知道误差下限</p>
<p>案例：</p>
<p>​ Java语言模拟 AdaBoost 算法，对样本 Samples 进行分类</p>
<table>
<thead>
<tr class="header">
<th>X</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
<th>17</th>
<th>18</th>
<th>19</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Y</td>
<td>1</td>
<td>1</td>
<td>-1</td>
<td>1</td>
<td>1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
</tbody>
</table>
<p>训练结果如下图，阈值为各个弱分类器学习到的阈值，权值对应弱分类器在强分类器中的比重，p 代表弱分类器的不等号方向，最终的强分类器分类错误仅为 0.05。</p>
<p><img src="案例.png" style="zoom:50%;" /></p>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaBoost</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> step;    <span class="comment">//步长</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weakErrorRate;       <span class="comment">//弱分类器错误率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> strongErrorRate;         <span class="comment">// 强分类器错误率</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; p;   <span class="comment">// 不等号方向</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Double&gt; theTa; <span class="comment">//阈值</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Double&gt; alpha; <span class="comment">//强分类器权重</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Double&gt; sampleDistribution;       <span class="comment">//样本分布</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdaBoost</span><span class="params">(<span class="keyword">double</span> step)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.theTa = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.alpha = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.p = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.sampleDistribution = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.step = step;</span><br><span class="line">        <span class="keyword">this</span>.strongErrorRate = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.weakErrorRate = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 训练弱分类器，组合为强分类器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> samples 训练数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">train</span><span class="params">(<span class="keyword">int</span>[] samples)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化概率分布</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; samples.length; i++) &#123;</span><br><span class="line">            sampleDistribution.add(i, <span class="number">1.0</span> / samples.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分类器训练，当训练次数超过 100 或强分类器错误率小于 0.1 停止</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> round = <span class="number">0</span>; strongErrorRate &gt;= <span class="number">0.1</span> &amp;&amp; round &lt; <span class="number">100</span>; round++) &#123;</span><br><span class="line">            <span class="comment">// 计算阈值</span></span><br><span class="line">            setTheTa(round, samples);</span><br><span class="line">            <span class="comment">// 计算分类器权重</span></span><br><span class="line">            setAlpha(round);</span><br><span class="line">            <span class="comment">// 更新样本数据概率分布</span></span><br><span class="line">            updateSampleDistribution(round, samples);</span><br><span class="line">            <span class="comment">// 计算当前强分类器错误率</span></span><br><span class="line">            generateStrongErrorRate(samples);</span><br><span class="line">            <span class="comment">// 打印相关信息</span></span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	使用训练好的分类器进行分类</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recognize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = Scan.scanInt();</span><br><span class="line">            System.out.println(strongClassifier(x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新样本权值分布</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> round   轮次，代表第几个弱分类器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> samples 样本数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateSampleDistribution</span><span class="params">(<span class="keyword">int</span> round, <span class="keyword">int</span>[] samples)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> Zm = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; samples.length; i++) &#123;</span><br><span class="line">            Zm += sampleDistribution.get(i) * Math.exp(-alpha.get(round) * samples[i] * f(round, i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; samples.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Zm == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            sampleDistribution.set(i, sampleDistribution.get(i) /</span><br><span class="line">                    Zm * Math.exp(-alpha.get(round) * samples[i] * f(round, i)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算弱分类器权值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> round 轮次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setAlpha</span><span class="params">(<span class="keyword">int</span> round)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (weakErrorRate == <span class="number">0</span>)</span><br><span class="line">            alpha.add(round, <span class="number">100d</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            alpha.add(round, <span class="number">0.5</span> * Math.log((<span class="number">1</span> - weakErrorRate) / weakErrorRate));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 训练弱分类器，寻找最佳阈值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> round   轮次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> samples 样本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setTheTa</span><span class="params">(<span class="keyword">int</span> round, <span class="keyword">int</span>[] samples)</span> </span>&#123;</span><br><span class="line">        weakErrorRate = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> theta = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> signTemp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> i = <span class="number">0</span>; i &lt; samples.length; i += step) &#123;</span><br><span class="line">            <span class="keyword">int</span> s;</span><br><span class="line">            <span class="keyword">double</span> calculateRate;</span><br><span class="line">            <span class="keyword">double</span> calculateRatePositive = generateErrorRate(i, samples, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">double</span> calculateRateNegative = generateErrorRate(i, samples, -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (calculateRateNegative &gt; calculateRatePositive) &#123;</span><br><span class="line">                calculateRate = calculateRatePositive;</span><br><span class="line">                s = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                calculateRate = calculateRateNegative;</span><br><span class="line">                s = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (weakErrorRate &gt; calculateRate) &#123;</span><br><span class="line">                weakErrorRate = calculateRate;</span><br><span class="line">                signTemp = s;</span><br><span class="line">                theta = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.add(round, signTemp);</span><br><span class="line">        theTa.add(round, theta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算弱分类器分类误差</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tT        给定阈值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> samples   样本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> direction 分类器符号方向</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分类误差</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">generateErrorRate</span><span class="params">(<span class="keyword">double</span> tT, <span class="keyword">int</span>[] samples, <span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> rate = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; samples.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tT &lt; i &amp;&amp; samples[i] == direction) &#123;</span><br><span class="line">                rate += sampleDistribution.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tT &gt; i &amp;&amp; samples[i] == -direction)</span><br><span class="line">                rate += sampleDistribution.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算当前组成的强分类器分类错误率</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> samples 样本数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateStrongErrorRate</span><span class="params">(<span class="keyword">int</span>[] samples)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; samples.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strongClassifier(i) != samples[i])</span><br><span class="line">                number++;</span><br><span class="line">        &#125;</span><br><span class="line">        strongErrorRate = number / samples.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弱分类器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number 弱分类器的序号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x      输入的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>       分类结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> number, <span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; theTa.get(number))</span><br><span class="line">            <span class="keyword">return</span> p.get(number);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -p.get(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 强分类器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 输入元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分类结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">strongClassifier</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; alpha.size(); j++) &#123;</span><br><span class="line">            answer += alpha.get(j) * f(j, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer &gt;= <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;错误率&quot;</span> + weakErrorRate);</span><br><span class="line">        System.out.println(<span class="string">&quot;强分类器错误率&quot;</span> + strongErrorRate);</span><br><span class="line">        System.out.print(<span class="string">&quot;阈值： &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> d : theTa</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.print(d + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.print(<span class="string">&quot;样本概率分布： &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> d : sampleDistribution</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.print(d + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;权值： &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> d : alpha</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.print(d + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.print(<span class="string">&quot;p： &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> d : p</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.print(d + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------------------------------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="级联分类器的构造">级联分类器的构造</h3>
<p>Haar 分类器包括训练和检测两部分，检测体系以现实中的照片为输入，对图片进行多区域多尺度的检测。由于训练的照片像素有明确的统一要求，因此要对图像进行区域的划分，使得符合训练的要求。但成相原理表明近距离的物体尺度大，远距离的物体尺度小，这就造成了现实拍摄的照片人脸大小不一，因此要对照片进行多尺度的扫描。扫描的方法一般有两种，一种是保持搜索窗口大小不变，不断对图片进行多尺度放缩，形成图像金字塔，再进行局部特征值的计算，效率较低。另一种是放缩窗口，先对扫描窗口初始化，再不断地扩大。以上两种扫描方法都会产生大量的子图像作为分类器的输入。</p>
<p>上述我们通过AdaBoost 算法构建出了一个强分类器，但在现实生活中，人脸识别的场景更加复杂，人们对识别的准确率要求更高。仅靠一个强分类器显然远不能达到现实应用的标准。</p>
<h3 id="总结">总结</h3>
<ol type="1">
<li>在Adaboost训练过程中，Adaboost会使得难于分类样本的权值呈指数增长，训练将会过于偏向这类困难的样本，导致Adaboost算法<strong>易受噪声干扰</strong>。此外，<strong>Adaboost依赖于弱分类器，而弱分类器的训练时间往往很长。</strong></li>
<li>Adaboost算法<strong><em>*不需要弱分类器的先验知识，最后得到的强分类器的分类精度依赖于所有弱分类器。无论是应用于人造数据还是真实数据，Adaboost都能显著的提高学习精度*</em></strong>。</li>
<li>Adaboost算法不需要预先知道弱分类器的错误率上限，且最后得到的强分类器的分类精度依赖于所有弱分类器的分类精度，可以深挖分类器的能力。<strong>Adaboost可以根据弱分类器的反馈，自适应地调整假定的错误率，执行的效率高。</strong></li>
</ol>
]]></content>
      <categories>
        <category>人脸识别</category>
      </categories>
      <tags>
        <tag>人脸识别</tag>
      </tags>
  </entry>
  <entry>
    <title>从特征分解到协方差矩阵：详细剖析和实现PCA算法</title>
    <url>/2019/04/14/%E4%BB%8E%E7%89%B9%E5%BE%81%E5%88%86%E8%A7%A3%E5%88%B0%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5%EF%BC%9A%E8%AF%A6%E7%BB%86%E5%89%96%E6%9E%90%E5%92%8C%E5%AE%9E%E7%8E%B0PCA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>转载:<a href="https://www.jianshu.com/p/2803caeadb8e?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">原文链接</a></p>
<hr />
<h1 id="引言">引言</h1>
<blockquote>
<p>本文先简要明了地介绍了特征向量和其与矩阵的关系，然后再以其为基础解释协方差矩阵和主成分分析法的基本概念，最后我们结合协方差矩阵和主成分分析法实现数据降维。本文不仅仅是从理论上阐述各种重要概念，同时最后还一步步使用 Python 实现数据降维。</p>
<span id="more"></span>
<p>首先本文的特征向量是数学概念上的特征向量，并不是指由输入特征值所组成的向量。数学上，线性变换的特征向量是一个非简并的向量，其方向在该变换下不变。该向量在此变换下缩放的比例称为特征值。一个线性变换通常可以由其特征值和特征向量完全描述。如果我们将矩阵看作物理运动，那么最重要的就是运动方向（特征向量）和速度（特征值）。因为物理运动只需要方向和速度就可以描述，同理矩阵也可以仅使用特征向量和特征值描述。</p>
<p>其实在线性代数中，矩阵就是一个由各种标量或变量构成的表格，它和 Excel 表格并没有什么本质上的区别。只不过数学上定义了一些矩阵间的运算，矩阵运算的法则和实际内部的值并没有什么关系，只不过定义了在运算时哪些位置需要进行哪些操作。因为矩阵相当于定义了一系列运算法则的表格，那么其实它就相当于一个变换，这个变换（物理运动）可以由特征向量（方向）和特征值（速度）完全描述出来。</p>
</blockquote>
<h1 id="线性变换">线性变换</h1>
<h2 id="矩阵">矩阵</h2>
<p>在解释线性变换前，我们需要先了解矩阵运算到底是什么。因为我们可以对矩阵中的值统一进行如加法或乘法等运算，所以矩阵是十分高效和有用的。如下所示，如果我们将向量 v 左乘矩阵 A，我们就会得到新的向量 b，也即可以表述说矩阵 A 对输入向量 v 执行了一次线性变换，且线性变换结果为 b。因此矩阵运算 Av = b 就代表向量 v 通过一个变换（矩阵 A）得到向量 b。下面的实例展示了矩阵乘法（该类型的乘法称之为点积）是怎样进行的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3635046-435177ba8055ac2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/258/format/webp" /></p>
<p>所以矩阵 A 将向量 v 变换为向量 b。下图展示了矩阵 A 如何将更短更低的向量 v 映射到更长更高的向量 b：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3635046-d5f0ad12f93a0892.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/497/format/webp" /></p>
<p>我们可以馈送其他正向量到矩阵 A 中，每一个馈送的向量都会投影到新的空间中且向右边变得更高更长。</p>
<p>假定所有的输入向量 V 可以排列为一个标准表格，即：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3635046-f99afddf8e222732.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/465/format/webp" /></p>
<p>而矩阵可以将所有的输入向量 V 投影为如下所示的新空间，也即所有输出向量组成的 B：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3635046-4f73f65b8bf985d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/460/format/webp" /></p>
<p>下图可以看到输入向量空间和输出向量空间的关系，</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3635046-a1bf9e5c751961f9.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/493/format/webp" /></p>
<h2 id="特征分解">特征分解</h2>
<p>如果假设矩阵就是一阵风，它通过有形的力量得出可见的结果。而这一阵风所吹向的方向就是特征向量，因此特征向量就表明矩阵所要变换的方向。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3635046-9ba4065d5a2fb241.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/479/format/webp" /></p>
<p>如上图所示，特征向量并不会改变方向，它已经指向了矩阵想要将所有输入向量都推向的方向。因此，特征向量的数学定义为：存在非零矩阵 A 和标量λ，若有向量 x 且满足以下关系式，那么 x 就为特征向量、λ为特征值。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3635046-80f580af442d9290.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/86/format/webp" /></p>
<p>特征向量同样是线性变换的不变轴，所有输入向量沿着这条轴压缩或延伸。线性变换中的线性正是表明了这种沿直线轴进行变换的特性，一般来说几阶方阵就有几个特征向量，如 3*3 矩阵有 3 个特征向量，n 阶方阵有 n 个特征向量，每一个特征向量表征一个维度上的线性变换方向。</p>
<p>因为特征向量提取出了矩阵变换的主要信息，因此它在矩阵分解中十分重要，即沿着特征向量对角化矩阵。因为这些特征向量表征着矩阵的重要特性，所以它们可以执行与深度神经网络中自编码器相类似的任务。引用 Yoshua Bengio 的话来说：</p>
<p>许多数学对象可以通过分解为更基础的组成部分而有更好的理解，因为我们会发现它们的一些广泛性属性，而不是我们选择表征它们的特性。例如整数可以分解为质因数，虽然我们表征整数的方式会因为采用二进制还是十进制而改变，但整数总可以由几个质因数表示（如 12=2 × 2 × 3），因此这种分解的性质正好是我们所需要的稳定性质。</p>
<p>我们可以分解一个整数为质因数而得到其自然属性，同样我们也可以分解矩阵以得到它的功能性属性，并且这种属性信息在矩阵表示为多组元素的阵列下是不明显的。矩阵分解最常见的是特征分解（eigen-decomposition），即我们将矩阵分解为一系列的特征向量和特征值。</p>
<h1 id="主成分分析pca">主成分分析（PCA）</h1>
<p>PCA 是一种寻找高维数据（图像等）模式的工具。机器学习实践上经常使用 PCA 对输入神经网络的数据进行预处理。通过聚集、旋转和缩放数据，PCA 算法可以去除一些低方差的维度而达到降维的效果，这样操作能提升神经网络的收敛速度和整体效果。</p>
<h2 id="均值标准差方差">均值、标准差、方差</h2>
<p>为了进一步了解 PCA 算法，我们还需要定义一些基本的统计学概念，即均值、标准差、方差和协方差。</p>
<p>样本均值可简单的表示为所有样本 X 的平均值，如下所示样本均值表示为：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3635046-5580e12b3851f3d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/149/format/webp" /></p>
<p>样本标准差即样本方差的平方根。即每一样本点到样本均值之间的平均距离。n 个样本的方差却只除以 n-1 是因为样本只是真实分布的估计量，样本方差也只是真实方差的估计量。在大学课本概率论和数理统计中有证明，如果除以 n（2 阶中心矩），那么样本方差是真实方差的一致性估计，但并不是无偏估计，也就是样本方差存在系统偏差。因此我们需要对 2 阶中心矩进行调整以消除系统偏差。如下所示，样本的标准差 s 和方差 var(X) 都是无偏估计：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3635046-350bf09b84ec8998.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/149/format/webp" /></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3635046-6795fae77bc1d828.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/233/format/webp" /></p>
<p>因为样本标准差和方差都是先求距离的平方再求平方根，因此距离一定是正数且不会抵消。假设我们有如下数据点（散点图）：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3635046-04e54827030a843c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/442/format/webp" /></p>
<p>PCA 如线性回归那样会尝试构建一条可解释性的直线贯穿所有数据点。每一条直线表示一个「主成分」或表示自变量和因变量间的关系。数据的维度数就是主成分的数量，也即每一个数据点的特征维度。PCA 的作用就是分析这些特征，并选出最重要的特征。PCA 本质上是将方差最大的方向作为主要特征，并且在各个正交方向上将数据「去相关」，也就是让它们在不同正交方向上没有相关性。通常我们认为信息具有较大的方差，而噪声有较小的方差，信噪比就是信号与噪声的方差比，所以我们希望投影后的数据方差越大越好。因此我们认为，最好的 k 维特征是将 n 维样本点转换为 k 维后，每一维上的样本方差都很大。</p>
<p>如下图所示，第一个主成分以直线（红色）的形式将散点图分为两边，并且它是保留了最大方差的。因为投影到这条直线（红色）上数据点离均值（空心点）有最大的方差，即所有蓝点到灰色线的平均距离为最大方差，所以这一个主成分将保留最多的信息。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3635046-257fc98b75afb1c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/390/format/webp" /></p>
<p>如上所示，假设第二个主成分为垂直于红线（第一个主成分）的灰色线。当数据点投影到第二个主成分上时，它们离样本均值（空心点）的方差却非常小，即数据点到红色线的平均距离。所以红色线是最优的主成分。</p>
<h2 id="协方差矩阵">协方差矩阵</h2>
<p>前面我们已经了解矩阵其实就是一种将某个向量变换为另一个的方法，另外我们也可以将矩阵看作作用于所有数据并朝向某个方向的力。同时我们还知道了变量间的相关性可以由方差和协方差表达，并且我们希望保留最大方差以实现最优的降维。因此我们希望能将方差和协方差统一表示，并且两者均可以表示为内积的形式，而内积又与矩阵乘法密切相关。因此我们可以采用矩阵乘法的形式表示。若输入矩阵 X 有两个特征 a 和 b，且共有 m 个样本，那么有：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3635046-83b44f1a7549d05c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/258/format/webp" /></p>
<p>如果我们用 X 左乘 X 的转置，那么就可以得出协方差矩阵：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3635046-55e546f02c5beb13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/364/format/webp" /></p>
<p>这个矩阵对角线上的两个元素分别是两特征的方差，而其它元素是 a 和 b 的协方差。两者被统一到了一个矩阵的，因此我们可以利用协方差矩阵描述数据点之间的方差和协方差，即经验性地描述我们观察到的数据。</p>
<p>寻找协方差矩阵的特征向量和特征值就等价于拟合一条能保留最大方差的直线或主成分。因为特征向量追踪到了主成分的方向，而最大方差和协方差的轴线表明了数据最容易改变的方向。根据上述推导，我们发现达到优化目标就等价于将协方差矩阵对角化：即除对角线外的其它元素化为 0，并且在对角线上将特征值按大小从上到下排列。协方差矩阵作为实对称矩阵，其主要性质之一就是可以正交对角化，因此就一定可以分解为特征向量和特征值。</p>
<p>当协方差矩阵分解为特征向量和特征值之后，特征向量表示着变换方向，而特征值表示着伸缩尺度。在本例中，特征值描述着数据间的协方差。我们可以按照特征值的大小降序排列特征向量，如此我们就按照重要性的次序得到了主成分排列。</p>
<p>对于 2 阶方阵，一个协方差矩阵可能如下所示：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3635046-f3b6b8ddb6f487b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/137/format/webp" /></p>
<p>在上面的协方差矩阵中，1.07 和 0.64 分别代表变量 x 和变量 y 的方差，而副对角线上的 0.63 代表着变量 x 和 y 之间的协方差。因为协方差矩阵为实对称矩阵（即 Aij=Aji），所以其必定可以通过正交化相似对角化。因为这两个变量的协方差为正值，所以这两个变量的分布成正相关性。如下图所示，如果协方差为负值，那么变量间就成负相关性。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3635046-fde71e1cbff0bb17.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/510/format/webp" /></p>
<p>注意如果变量间的协方差为零，那么变量是没有相关性的，并且也没有线性关系。因此，如果两个变量的协方差越大，相关性越大，投影到主成分后的损失就越小。我们同时可以考虑协方差和方差的计算式而了解他们的关系：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3635046-fb773c19eda2cc04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/355/format/webp" /></p>
<p>计算协方差的优处在于我们可以通过协方差的正值、负值或零值考察两个变量在高维空间中相互关系。总的来说，协方差矩阵定义了数据的形状，协方差决定了沿对角线对称分布的强度，而方差决定了沿 x 轴或 y 轴对称分布的趋势。</p>
<h2 id="基变换">基变换</h2>
<p>因为协方差矩阵的特征向量都是彼此正交的，所以变换就相当于将 x 轴和 y 轴两个基轴换为主成分一个基轴。也就是将数据集的坐标系重新变换为由主成分作为基轴的新空间，当然这些主成分都保留了最大的方差。</p>
<p>我们上面所述的 x 轴和 y 轴称之为矩阵的基，即矩阵所有的值都是在这两个基上度量而来的。但矩阵的基是可以改变的，通常一组特征向量就可以组成该矩阵一组不同的基坐标，原矩阵的元素可以在这一组新的基中表达。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3635046-43cd4df76a81262f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/529/format/webp" /></p>
<p>在上图中，我们展示了相同向量 v 如何在不同的坐标系中有不同的表达。黑色实线代表 x-y 轴坐标系而红色虚线是另外一个坐标系。在第一个坐标系中 v = (1,1)，而在第二个坐标系中 v = (1,0)。因此矩阵和向量可以在不同坐标系中等价变换。在数学上，n 维空间并没有唯一的描述，所以等价转换矩阵的基也许可以令问题更容易解决。</p>
<h2 id="总结">总结</h2>
<p>最后我们简单地总结一下 PCA 算法的基本概念和步骤：</p>
<p>首先我们得理解矩阵就相当于一个变换，变换的方向为特征向量，变换的尺度为特征值。PCA 的本质是将方差最大的方向作为主要特征，并且在各个正交方向上将数据「去相关」，即让它们在不同正交方向上没有相关性。所以我们希望将最相关的特征投影到一个主成分上而达到降维的效果，投影的标准是保留最大方差。而在实际操作中，我们希望计算特征之间的协方差矩阵，并通过对协方差矩阵的特征分解而得出特征向量和特征值。如果我们将特征值由大到小排列，相对应的特征向量所组成的矩阵就是我们所需降维后的数据。下面我们将一步步实现 PCA 算法。</p>
<p>输入数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x=np.array([<span class="number">2.5</span>,<span class="number">0.5</span>,<span class="number">2.2</span>,<span class="number">1.9</span>,<span class="number">3.1</span>,<span class="number">2.3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1.5</span>,<span class="number">1.1</span>])</span><br><span class="line">y=np.array([<span class="number">2.4</span>,<span class="number">0.7</span>,<span class="number">2.9</span>,<span class="number">2.2</span>,<span class="number">3</span>,<span class="number">2.7</span>,<span class="number">1.6</span>,<span class="number">1.1</span>,<span class="number">1.6</span>,<span class="number">0.9</span>])</span><br></pre></td></tr></table></figure>
<p>归一化数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mean_x=np.mean(x)</span><br><span class="line">mean_y=np.mean(y)</span><br><span class="line">scaled_x=x-mean_x</span><br><span class="line">scaled_y=y-mean_y</span><br><span class="line">data=np.matrix([[scaled_x[i],scaled_y[i]] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(scaled_x))])</span><br></pre></td></tr></table></figure>
<p>绘制散点图查看数据分布：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> pltplt.plot(scaled_x,scaled_y,<span class="string">&#x27;o&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>求协方差矩阵：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cov=np.cov(scaled_x,scaled_y)</span><br></pre></td></tr></table></figure>
<p>求协方差矩阵的特征值和特征向量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">eig_val, eig_vec = np.linalg.eig(cov)</span><br></pre></td></tr></table></figure>
<p>求出特征向量后，我们需要选择降维后的数据维度 k（n 维数据降为 k 维数据），但我们的数据只有两维，所以只能降一维：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">eig_pairs = [(np.<span class="built_in">abs</span>(eig_val[i]), eig_vec[:,i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(eig_val))]</span><br><span class="line">eig_pairs.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">feature=eig_pairs[<span class="number">0</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>转化得到降维后的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new_data_reduced=np.transpose(np.dot(feature,np.transpose(data))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>特征分解</tag>
        <tag>协方差矩阵</tag>
        <tag>PCA算法</tag>
      </tags>
  </entry>
  <entry>
    <title>感知机原理及Python实现</title>
    <url>/2019/04/18/%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%8E%9F%E7%90%86%E5%8F%8APython%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="摘要"><strong>摘要</strong></h1>
<p>感知机（Perceptron）被视为最简单形式的前馈神经网络，是二类线性分类模型，旨在求出将线性训练数据进行线性划分的分离超平面。本文简述了感知机的基本组成模型及原理，给出基于误分类的损失函数，利用梯度下降法对损失函数进行极小化，从而求得超平面参数，得到感知机模型，并对训练得到的模型进行测试实验。</p>
<span id="more"></span>
<p><strong>关键词</strong>：感知机（Perceptron）；梯度下降；超平面；损失函数</p>
<h1 id="principle-and-implementation-of-perceptron"><strong>Principle and implementation of perceptron</strong></h1>
<p><strong>Abstract</strong>：Perceptron, regarded as the simplest feed-forward neural network, is a second-class linear classification model, which is designed to find the separation hyperplane for linear division of linear training data. In this paper, the basic component model and principle of perceptron are briefly introduced, loss function based on misclassification is given, loss function is minimized by gradient descent method, hyperplane parameters are obtained, perceptron model is obtained, and the trained model is tested.</p>
<h1 id="正文">正文</h1>
<ol type="1">
<li><p>生成线性可分的二维空间两类样本数据，编写计算机程序，完成感知器对这组数据的学习过程:</p>
<p>A. 观察学习算法的收敛过程.</p>
<p>B. 改变算法的初始值,观察初始化对收敛结果的影响.</p>
<p>C. 观察两类数据的样本不平衡情况对性能的影响.</p></li>
<li><p>生成线性不可分的二维空间两类样本数据，做上述同样的实验。根据你的实验和分析，给出结论。</p></li>
<li><p>针对上述的线性可分问题，如果采用Cross validation来评价分类器的推广能力，你会得到怎样的观察，并请给出结果和结论。</p></li>
</ol>
<h1 id="原理">原理</h1>
<h2 id="感知机">感知机</h2>
<p>假设输入空间（特征空间）是x⊆Rn，输出空间是＝{+1,-1}。输入x∊x表示实例的特征向量，对应于输入空间（特征空间）的点；输出y∊表示实例的类别。由输入空间到输出空间的如下函数</p>
<p><img src="1.png" alt="" style="zoom:60%;" /></p>
<p>称为感知机。其中，w和b为感知机模型参数，w∊Rn叫作权值（weight）或权值向量（weight vector），b∊R叫作偏置（bias），w·x表示w和x的内积。sign是符号函数</p>
<p>​ 即：</p>
<p><img src="2.png" alt="" style="zoom:60%;" /></p>
<p>感知机是二分类的线性模型，属于判别模型。通过对网络权值的训练，可以使感知器对一组输人矢量的响应达到元素为 -1或1的目标输出，从而实现对输人矢量分类的目的，其输入是实例的特征向量，输出的是事例的类别，属于判别模型。单层感知器可以计算逻辑或，逻辑与，逻辑非等运算，但是不能计算异或。因为异或不是平面线性可分的。</p>
<h2 id="模型">模型</h2>
<p>感知机的假设空间是定义在特征空间的所以线性分类模型，或线性分类器，即函数集合：</p>
<p><img src="3.png" alt="" style="zoom:70%;" /></p>
<p><img src="4.png" alt="" style="zoom:100%;" /></p>
<p>对感知机的几何解释：</p>
<p><img src="5.png" alt="" style="zoom:60%;" /></p>
<p>其对应于特征空间中的一个超平面S，其中w是超平面的法向量，b是超平面的截距。如图，超平面将特征空间划分为两个部分。位于两部分的点分别被分为正负两类。</p>
<p><img src="5.png" alt="" style="zoom:60%;" /></p>
<p>假设训练数据集是线性可分的，感知机学习的目标是求得一个能够将训练数据集正实例点和负实例点完全正确分开的分离超平面。如果是非线性可分的数据，则最后无法获得超平面</p>
<p><img src="6.png" alt="" style="zoom:30%;" /></p>
<p>如果存在某个超平面能将数据集的正实例点和负实例点分开，则称数据集为线性可分数据集。</p>
<p>​ W·X + b = 0</p>
<p>​ w=(w0,w1,...wm)，x=(x0,x1,...xm)</p>
<h2 id="损失函数">损失函数</h2>
<p>为了找出这个超平面，需要定义一个损失函数来度量错误的程度，损失函数值越小，模型就越好。然后通过某种算法找到其极小化值</p>
<p>A、误分类点x到超平面S的距离如下： ，</p>
<p><img src="7.png" alt="" style="zoom:40%;" /></p>
<p>​ 对于分类错误的数据 <strong>(Xi，Yi)</strong></p>
<p><img src="8.png" alt="" style="zoom:50%;" /></p>
<p>​ 误分类点<strong>Xi</strong>到超平面S的距离：</p>
<p><img src="9.png" alt="" style="zoom:60%;" /></p>
<p>​ 设误分类点集为M，则所有误分类点到超平面S的总距离：</p>
<p><img src="10.png" alt="" style="zoom:60%;" /></p>
<p>​ 因为感知机不需要关心得到的超平面到平面的距离的数值，为了简化计算故不考虑<span class="math inline">\(-\frac{1}{\left \| w \right \|}\)</span>得损失函数：</p>
<p><img src="11.png" alt="" style="zoom:60%;" /></p>
<p>我们可以知道，感知机分类完全正确时，L（w，b）= 0</p>
<h2 id="算法">算法</h2>
<p>感知机学习算法是<strong>误分类</strong>驱动的，具有简单且易于实现的优点。</p>
<p>我们的目的是求参数 w，b 使得损失函数极小化，即</p>
<p><img src="12.png" alt="" style="zoom:60%;" /></p>
<p>采取梯度下降法（stochastic gradient descent）：梯度下降法不断极小化目标函数，每次随机选取一个误分点并使其梯度下降</p>
<p><img src="13.png" alt="" style="zoom:60%;" /></p>
<blockquote>
<p>算法实现描述：</p>
</blockquote>
<blockquote>
<p>输入：训练数据集 T: ，学习率</p>
<p>输出：（w，b） &amp;&amp; 感知机模型</p>
<ol type="a">
<li><p>任意取一个超平面，</p></li>
<li><p>在训练集中选取数据</p></li>
<li><p>如果 <span class="math inline">\(y_{i}\left ( w\cdot x_{i}+b \right )\leq 0\)</span></p></li>
</ol>
</blockquote>
<p><img src="14.png" alt="" style="zoom:60%;" /></p>
<blockquote>
<ol start="4" type="a">
<li>转至（b），直到训练集中没有误分类点</li>
</ol>
</blockquote>
<p><strong>原理</strong>：</p>
<p>​ 通过不断修正w，b的值，使超平面不断向误分类点移动，直到其被正确分类。</p>
<p>#实验结果</p>
<ul>
<li><p>使用python语言编写上述感知机算法的实现过程，训练数据采用python numpy生成</p>
<p>训练数据：</p>
<p>正类数据：服从均值为(5,5)、协方差矩阵为[1 0;0 1]的高斯分布数据作为样本的数据，数据量为1000.</p>
<p>负类数据：服从均值为(0,0)、协方差矩阵为[1 0;0 1]的高斯分布数据作为样本的数据，数据量也为1000.</p>
<p>数据分布情况如图所示</p></li>
</ul>
<p><img src="15.png" alt="" style="zoom:60%;" /></p>
<ul>
<li>训练得到超平面参数（w，b），学习率0.5 在图像中显示如图所示：初始值这里取（0，0），得到收敛的超平面参数（36，-5.5）</li>
</ul>
<p><img src="16.png" alt="" style="zoom:60%;" /></p>
<p>​ 修改初始值为（10，10），得到的超平面参数为（102，-9.0）如图所示</p>
<p><img src="17.png" alt="25" style="zoom:60%;" /></p>
<p>故： <strong>初始值对最后结果有影响，不通的初始值可能导致不同的解，所以感知机有多个解</strong></p>
<ul>
<li>使用非均衡训练数据集，使得感知机更容易收敛，但在测试数据集偏差会些许变高。</li>
</ul>
<figure>
<img src="18.png" alt="Screen Shot 2019-04-19 at 12.04.12 AM" /><figcaption aria-hidden="true">Screen Shot 2019-04-19 at 12.04.12 AM</figcaption>
</figure>
<ul>
<li><strong>若使用非线性可分数据作为训练集，如图所示，会造成训练失败，出现死循环，超平面无法收敛的现象。</strong></li>
</ul>
<p><img src="19.png" alt="25" style="zoom:60%;" /></p>
<ul>
<li><p>交叉验证的基本想法是重复地使用数据；把给定的数据进行切分，将切分的数据集组合为训练集与测试集，在此基础上反复地进行训练、测试以及模型选择。应用最多的是s-fold交叉验证。</p>
<blockquote>
<p>我们在这里采用5折交叉验证，随机将数据切分5个互不相交的子集，然后利用4个子集训练模型，利用余下的子集测试模型。</p>
<p>数据类型：</p>
<p>服从均值为(5,5)、协方差矩阵为[1 0;0 1]的高斯分布数据作为样本的数据，数据量为1000，服从均值为(0,0)、协方差矩阵为[1 0;0 1]的高斯分布数据作为样本的数据，数据量也为1000.</p>
<p>将上述数据随机shuffle后分为5折，进行k-折交叉验证，重复5次</p>
<p>图中分别为超平面参数（w，b），共四次训练</p>
</blockquote>
<p><img src="20.png" alt="25" style="zoom:60%;" /></p></li>
</ul>
<p>可以看到感知机采取此种方法测试的性能较好</p>
<p><img src="21.png" alt="21" style="zoom:60%;" /></p>
<h1 id="结论">结论</h1>
<p>1、感知机只能解决类似与、或、非等线性可分问题，对简单地异或非线性问题则无法收敛。</p>
<p>2、整个算法的收敛是逐步逼近的，但如果学习率设置过大则很有可能无法找到超平面。</p>
<p>3、初值设置的不同会影响获得的超平面参数，超平面的求取不是唯一的，具体现象已在三中给出</p>
<p>4、非均衡训练数据集训练得到的感知机模型，往往不能真实反映真实分布，或者样本分布不均衡，直接估计会出现很大误导性。</p>
<p>5、通过k折交叉验证来验证模型参数的调优，从而找到模型泛化性能最优的参数，找到满意的参数之后，就使用整个训练集作为训练数据来训练模型，然后通过测试集来评价模型的性能。在k折交叉验证中，每一个样本都会被划分为训练集或者测试集（验证集）的机会，因此泛化能力较好。</p>
<h1 id="python-实现">Python 实现</h1>
<p><img src="25.png" alt="25" style="zoom:40%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成线性可分的二维空间两类样本数据</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataProducing</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, mean1, mean2, cov, size,size2</span>):</span></span><br><span class="line">        self.data1 = np.random.multivariate_normal(mean=mean1, cov=cov, size=size)</span><br><span class="line">        self.data2 = np.random.multivariate_normal(mean=mean2, cov=cov, size=size2)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data_producing</span>(<span class="params">self</span>):</span></span><br><span class="line">        data1 = [[x, -<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> self.data1]</span><br><span class="line">        data2 = [[x, <span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> self.data2]</span><br><span class="line">        data1.extend(data2)</span><br><span class="line">        <span class="keyword">return</span> data1</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">self</span>):</span></span><br><span class="line">        x1, y1 = <span class="built_in">zip</span>(*self.data1)</span><br><span class="line">        x2, y2 = <span class="built_in">zip</span>(*self.data2)</span><br><span class="line">        plt.scatter(x1, y1, s=<span class="number">2</span>)</span><br><span class="line">        plt.scatter(x2, y2, s=<span class="number">2</span>)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># #感知机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PerCeptron</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, w, b, learn_ratio</span>):</span></span><br><span class="line">        self.w = w</span><br><span class="line">        self.b = b</span><br><span class="line">        self.learn_ratio = learn_ratio</span><br><span class="line">        self.index = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_error</span>(<span class="params">self, train_data, w, b</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(train_data)):</span><br><span class="line">            result = train_data[i][<span class="number">1</span>] * (np.<span class="built_in">sum</span>(w * train_data[i][<span class="number">0</span>]) + b)</span><br><span class="line">            <span class="comment"># print(&#x27;re&#x27;,result,self.train_data[i][1],w,self.train_data[i][0])</span></span><br><span class="line">            <span class="keyword">if</span> result &lt;= <span class="number">0</span>:</span><br><span class="line">                self.index = i</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">training</span>(<span class="params">self,train_data</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.w,self.b)</span><br><span class="line">        w = self.w</span><br><span class="line">        b = self.b</span><br><span class="line">        <span class="keyword">while</span> self.check_error(train_data, w, b):</span><br><span class="line">            w = w + self.learn_ratio * train_data[self.index][<span class="number">1</span>] * train_data[self.index][<span class="number">0</span>]</span><br><span class="line">            b = b + <span class="built_in">float</span>(self.learn_ratio) * train_data[self.index][<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># print(train_data[self.index], self.index, w, b)</span></span><br><span class="line">        self.w = w</span><br><span class="line">        self.b = b</span><br><span class="line">        <span class="keyword">return</span> w, b</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">testing</span>(<span class="params">self, test_data</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;测试开始&quot;</span>)</span><br><span class="line">        correct = <span class="number">0</span></span><br><span class="line">        wrong = <span class="number">0</span></span><br><span class="line">        ob = <span class="number">0</span></span><br><span class="line">        ne = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(test_data)):</span><br><span class="line">            result = test_data[i][<span class="number">1</span>] * (np.<span class="built_in">sum</span>(self.w * test_data[i][<span class="number">0</span>]) + self.b)</span><br><span class="line">            <span class="keyword">if</span> result &lt; <span class="number">0</span>:</span><br><span class="line">                wrong += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                correct += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(test_data)):</span><br><span class="line">            result = (np.<span class="built_in">sum</span>(self.w * test_data[i][<span class="number">0</span>]) + self.b)</span><br><span class="line">            <span class="keyword">if</span> result &lt; <span class="number">0</span>:</span><br><span class="line">                ne += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ob += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;object&quot;</span>,ob,<span class="string">&quot;negative&quot;</span>,ne)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;错误率：&quot;</span>,wrong/(wrong+correct))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">self</span>):</span></span><br><span class="line">        x = np.linspace(-<span class="number">4</span>, <span class="number">8</span>, <span class="number">100</span>)</span><br><span class="line">        y = -<span class="number">1</span> * (self.b + self.w[<span class="number">0</span>] * x) / self.w[<span class="number">1</span>]</span><br><span class="line">        plt.plot(x, y, label=<span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(self.b))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    dataproduing = DataProducing([<span class="number">0</span>, <span class="number">0</span>], [<span class="number">5</span>, <span class="number">5</span>], [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]], <span class="number">100</span>,<span class="number">1000</span>)</span><br><span class="line">    data = dataproduing.data_producing()</span><br><span class="line">    dataproduing2 = DataProducing([<span class="number">0</span>, <span class="number">0</span>], [<span class="number">5</span>, <span class="number">5</span>], [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]], <span class="number">1000</span>,<span class="number">1000</span>)</span><br><span class="line">    data2 = dataproduing2.data_producing()</span><br><span class="line">    dataproduing.draw()</span><br><span class="line">    dataproduing2.draw()</span><br><span class="line">    perceptron = PerCeptron(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>)</span><br><span class="line">    w, b = perceptron.training(data)</span><br><span class="line">    perceptron2 = PerCeptron(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0.5</span>)</span><br><span class="line">    perceptron2.training(data)</span><br><span class="line">    perceptron.testing(data2)</span><br><span class="line">    perceptron.draw()</span><br><span class="line">    perceptron2.draw()</span><br><span class="line">    dataproduing.draw()</span><br><span class="line">    perceptron.draw()</span><br><span class="line">    perceptron2.draw()</span><br><span class="line">    dataproduing2.draw()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Perceptron</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">dataproducing = Perceptron.DataProducing([<span class="number">0</span>, <span class="number">0</span>], [<span class="number">5</span>, <span class="number">5</span>], [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]], <span class="number">1000</span>,<span class="number">1000</span>)</span><br><span class="line">data = dataproducing.data_producing()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fold</span>(<span class="params">data</span>):</span></span><br><span class="line">    fold5 = []</span><br><span class="line">    np.random.shuffle(data)</span><br><span class="line">    split_num = <span class="built_in">len</span>(data)//<span class="number">5</span></span><br><span class="line">    fold5.append(data[<span class="number">0</span>:split_num])</span><br><span class="line">    fold5.append(data[split_num:split_num*<span class="number">2</span>])</span><br><span class="line">    fold5.append(data[split_num*<span class="number">2</span>:split_num*<span class="number">3</span>])</span><br><span class="line">    fold5.append(data[split_num*<span class="number">3</span>:split_num*<span class="number">4</span>])</span><br><span class="line">    fold5.append(data[split_num*<span class="number">4</span>:split_num*<span class="number">5</span>])</span><br><span class="line">    <span class="keyword">return</span> fold5</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"></span><br><span class="line">    perceptron = Perceptron.PerCeptron(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        x1 = []</span><br><span class="line">        y1 = []</span><br><span class="line">        x2 = []</span><br><span class="line">        y2 = []</span><br><span class="line">        data_fold = fold(data)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;第 &#123;&#125; 次&quot;</span>.<span class="built_in">format</span>(j+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> data_fold[:<span class="number">5</span>]:</span><br><span class="line">            perceptron.training(i)</span><br><span class="line">        perceptron.testing(data_fold[<span class="number">4</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> data_fold[<span class="number">4</span>]:</span><br><span class="line">            <span class="keyword">if</span> i[<span class="number">1</span>] == -<span class="number">1</span>:</span><br><span class="line">                x1.append(i[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">                y1.append(i[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> i[<span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                x2.append(i[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">                y2.append(i[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">        perceptron.draw()</span><br><span class="line">        plt.scatter(x1, y1, s=<span class="number">2</span>)</span><br><span class="line">        plt.scatter(x2, y2, s=<span class="number">2</span>)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>数学公式</title>
    <url>/2019/04/19/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<p><span class="math display">\[
\begin{equation}
e=mc^2 
\end{equation}\label{eq1}
\]</span></p>
<span id="more"></span>
<h1 id="使用-mathjax-给公式编号并引用公式">使用 MathJax 给公式编号并引用公式</h1>
<p>一般来说，你必须把所使用的 LaTeX 公式放在 <code>equation</code> 环境里面，采用旧的方法（也就是说，仅仅把公式的每一边用两个 $ 符号包含起来）是无效的。如何引用公式？你只需要在书写公式的时候给公式一个 <code>\ label&#123;&#125;</code> 标记（tag），然后在正文中，可以使用 <code>\ref&#123;&#125;</code> 或者 <code>\eqref&#123;&#125;</code> 命令来引用对应的公式。使用 <code>\eqref&#123;&#125;</code> 是推荐的方式，因为如果你使用 <code>\ref&#123;&#125;</code>，公式在文中的引用编号将没有圆括号包围。下面介绍几种常见的公式编号例子。</p>
<p>对于简单的公式，使用下面的方式给公式一个标记，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;equation&#125;</span><br><span class="line">e=mc^2</span><br><span class="line">\end&#123;equation&#125;\label&#123;eq1&#125;$$</span><br></pre></td></tr></table></figure>
<p>然后，在正文中，你可以轻松引用上述公式，一个简单的例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">著名的质能方程 $\eqref&#123;eq1&#125;$ 由爱因斯坦提出 ...</span><br></pre></td></tr></table></figure>
<p>对于多行公式，在 <code>equation</code> 环境中，你可以使用 <code>aligned</code> 环境把公式分成多行，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;equation&#125;</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">a &amp;= b + c \\</span><br><span class="line">  &amp;= d + e + f + g \\</span><br><span class="line">  &amp;= h + i</span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">\end&#123;equation&#125;\label&#123;eq2&#125;$$</span><br></pre></td></tr></table></figure>
<p>要对齐多个公式，我们需要使用 <code>align</code> 环境。align 环境中的每个公式都有自己的编号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;align&#125;</span><br><span class="line">a &amp;= b + c \label&#123;eq3&#125; \\</span><br><span class="line">x &amp;= yz \label&#123;eq4&#125;\\</span><br><span class="line">l &amp;= m - n \label&#123;eq5&#125;</span><br><span class="line">\end&#123;align&#125;$$</span><br></pre></td></tr></table></figure>
<p>在 <code>align</code> 环境中，如果你不想给某个或某几个公式编号，那么在这些公式后面使用 <a href="https://tex.stackexchange.com/questions/17528/show-equation-number-only-once-in-align-environment"><code>\nonumber</code></a> 命令即可。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;align&#125;</span><br><span class="line">-4 + 5x &amp;= 2+y \nonumber  \\</span><br><span class="line"> w+2 &amp;= -1+w \\</span><br><span class="line"> ab &amp;= cb</span><br><span class="line">\end&#123;align&#125;$$</span><br></pre></td></tr></table></figure>
<p>有时，你可能会希望采用更加奇特的方式来标记和引用你的公式，你可以通过使用 <code>\tag&#123;&#125;</code> 命令来实现，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$x+1\over\sqrt&#123;1-x^2&#125; \tag&#123;i&#125;\label&#123;eq_tag&#125;$$</span><br></pre></td></tr></table></figure>
<p>如果你想要了解更多信息，请访问 <a href="http://docs.mathjax.org/en/latest/tex.html#automatic-equation-numbering">MathJax 关于公式编号的官方文档</a>。同时，你也可以访问<a href="https://jdhao.github.io/2018/01/25/hexo-mathjax-equation-number/">这篇博客</a> 来获取更多细节信息。</p>
<hr />
<h1 id="test">Test:</h1>
<p>爱因斯坦提出了：<span class="math inline">\(\eqref{eq1}\)</span></p>
]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 by 李宏毅(1)</title>
    <url>/2021/05/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="introduction">Introduction</h2>
<p>机器具备拟合复杂数据的能力</p>
<ul>
<li>Regression：function outputs a scalar. <span id="more"></span>例如：假设预测未来某一个时间PM2.5的数值,找一个函数<strong>f</strong>,f 输出是明天中午的PM2.5的数值,输入可能是种种跟预测PM2.5 有关的指数，包括今天的PM2.5的数值,今天的平均温度,今天平均的臭氧浓度等等,输出明天中午的PM2.5的数值,那建立这个函数的任务,叫作Regression。</li>
<li>Classification：given options(classes), the function outputs the correct one.</li>
<li>Structured Learning: create something with structure (image, document)</li>
</ul>
<h2 id="case-study">Case Study</h2>
<p>YouTube观看次数预测</p>
<p><strong>输入是youtube后台资讯,输出就是某一天这个频道会有的总观看的次数</strong>.</p>
<h3 id="function-with-unknown-parameters-model">Function with Unknown Parameters (Model)</h3>
<p><span class="math display">\[
y = b + w * x_{1}
\]</span> Example:</p>
<p><img src="1.png" alt="1" style="zoom:40%;" /></p>
<p><span class="math display">\[
x: feature \\
W\ C^TB\ b : unknown\ parameters
\]</span></p>
<h3 id="define-loss-from-training-data-function-of-parameters-lbw">Define Loss from Training Data （function of parameters L(b,w)）</h3>
<p>MAE : mean absolute error</p>
<p>MSE : mean square error</p>
<p>Cross-entropy</p>
<p><img src="2.png" alt="2" style="zoom:40%;" /></p>
<p>Loss 反映了当前参数的表现，Loss越大表示当前一组参数越差</p>
<p><strong>Error Surface</strong>：为不同的w跟b的组合计算Loss,然后就可以画出以下等高线图.</p>
<p><img src="5.png" alt="5" style="zoom:60%;" /></p>
<p><strong>越偏红色,代表计算出来的Loss越大,就代表这一组w跟b越差,如果越偏蓝色,就代表Loss越小,就代表这一组w跟b越好，模型的预测越精确</strong></p>
<h3 id="optimization">Optimization</h3>
<blockquote>
<p>最佳化的问题，最佳化模型的未知参数</p>
<p>优化方法：Gradient Descent - hyper parameter : learning rate, sigmoid, batch size</p>
<p>存在的问题：local minima、Gradient disappear</p>
</blockquote>
<p><strong>模型有两个参数,有w跟b</strong>,那有两个参数的情况下,Gradient Descent：</p>
<ul>
<li><p><strong>随机初始化参数，即为<span class="math inline">\(w^0\)</span>和<span class="math inline">\(b^0\)</span></strong></p></li>
<li><p><strong>分别计算w跟loss的微分,b对loss的微分</strong></p></li>
<li><p>更新w跟b,把w⁰减掉learning rate,乘上微分的结果得到w¹,把b⁰减掉learning rate,乘上微分的结果得到b¹</p>
<p><img src="6.png" alt="6" style="zoom:50%;" /></p>
<p><img src="7.png" alt="7" style="zoom:50%;" /></p></li>
</ul>
<h3 id="sgdstochastic-gradient-descent">SGD（stochastic gradient descent）</h3>
<p><img src="31.png" alt="7" style="zoom:40%;" /></p>
<h3 id="sgdm-stochastic-gradient-descent-with-momentum">SGDM (Stochastic Gradient Descent with Momentum)</h3>
<p><img src="32.png" alt="7" style="zoom:50%;" /></p>
<h3 id="sigmoid-function">Sigmoid Function</h3>
<p><img src="8.png" alt="8" style="zoom:70%;" /></p>
<p>调整的 b 跟 w 跟 c, 就可以制造各种不同形状的 Sigmoid Function</p>
<ul>
<li>如果改w就会改变<strong>斜率</strong>你就会改变斜坡的坡度</li>
<li>如果改b 就可以把 Sigmoid Function 左右移动</li>
<li>如果你改c 你就可以改变 Sigmoid Function 的高度</li>
</ul>
<p><strong>不同的 w 不同的 b 不同的 c,你就可以製造出不同的 Sigmoid Function</strong>,把<strong>不同的 Sigmoid Function 叠起来以后,就可以逼近各种不同的,Piecewise Linear 的 Function，从而逼近各种连续函数</strong></p>
<p><img src="9.png" alt="8" style="zoom:70%;" /></p>
<p><img src="3.png" alt="3" style="zoom:40%;" /></p>
<p>​ <strong>θ 是一个长向量</strong>,表示成 θ1 θ2 θ3 等等等,我们现在就是要<strong>找一组 θ,这个 θ 可以让我们的 Loss 越小越好</strong></p>
<ul>
<li>我们一开始要<strong>随机选一个初始的数值,这边叫做<span class="math inline">\(θ_0\)</span></strong><br />
</li>
<li>接下来计算微分, 用 θ1 θ2 θ3 来表示,每一个未知的参数,都去计算它对 L 的微分,把每一个参数都拿去计算对 L 的微分以后,集合起来它就是一个向量, 用 g 来表示它, 叫做 Gradient,</li>
<li>算出 g 以后, Update 参数,本来有一个参数叫 θ1,<strong>上标 0</strong> 代表它是一个<strong>起始的值</strong>,它是一个随机选的起始的值,把这个 <strong>减掉 η 乘上微分的值,得到 ,代表 θ1 更新过一次的结果</strong>, 减掉微分乘以,减掉 η 乘上微分的值,得到,以此类推</li>
</ul>
<h2 id="general-guidance">General Guidance</h2>
<p><img src="10.png" alt="8" style="zoom:70%;" /></p>
<h3 id="model-bias">Model Bias</h3>
<p>Model 过于简单，不能拟合数据，此时需要增加Model的复杂性</p>
<p><img src="11.png" alt="8" style="zoom:70%;" /></p>
<h3 id="optimization-issue">Optimization Issue</h3>
<p>gradient descent 只能找到局部最小值，而非全局最小值。</p>
<p>Start from shallower networks (or other models), which are easier to train，If deeper networks do not obtain smaller loss on training data, then there is optimization issue.</p>
<h3 id="overfitting">Overfitting</h3>
<p><strong>model的自由度很大,它可以產生非常奇怪的曲线,导致训练集上的结果好,但是测试集上的loss很大</strong></p>
<p><img src="12.png" alt="8" style="zoom:50%;" /></p>
<h4 id="解决方向">解决方向</h4>
<ul>
<li>增加训练集，如 <strong>data augmentation</strong>：图片左右翻转、缩放、裁剪等.</li>
</ul>
<p><img src="13.png" alt="8" style="zoom:70%;" /></p>
<ul>
<li><p>model constrain</p>
<ul>
<li>less parameters or sharing parameters</li>
<li>less features</li>
<li>Early stopping</li>
<li>Dropout</li>
</ul></li>
<li><p>Cross Validation: <strong>把Training分成两半,一部分叫作Training Set,一部分是Validation Set</strong></p></li>
<li><p>N-fold Cross Validation: <strong>把训练集切成N等份,其中一份当作Validation Set,其当Training Set</strong>,然后这件事情你要重复N次</p>
<p><img src="14.png" alt="14" style="zoom:60%;" /></p></li>
</ul>
<h3 id="mismatch">mismatch</h3>
<p><strong>训练集跟测试集的分布不一样，增加训练集的数量并不会使模型更好</strong></p>
<h2 id="when-gradient-is-small">When gradient is small</h2>
<p>Optimization的时候,<strong>随著参数不断的update,training的loss不会再下降。</strong>常见的一个猜想,是这个地方参数对loss的微分为零,<strong>gradient descent</strong>就无法update参数,这个时候training停止, loss当然就不会再下降了。</p>
<p><img src="15.png" alt="14" style="zoom:70%;" /></p>
<p>gradient为零的点,统称为<strong>critical point</strong>，包括<strong>local minima</strong> and <strong>saddle point</strong></p>
<ul>
<li>区分<strong>local minima</strong> and <strong>saddle point</strong></li>
</ul>
<h5 id="tayler-series-approximation">Tayler Series Approximation</h5>
<p>在<span class="math inline">\(θ^{&#39;}\)</span>附近的loss function,可以被写出来</p>
<p><img src="16.png" alt="14" style="zoom:70%;" /></p>
<p><strong>H里面放的是L的二次微分</strong>,<strong>它第i个row,第j个column的值,就是把θ的第i个component,对L作微分,再把θ的第j个component,对L作微分,再把θ的第i个component,对L作微分,做两次微分以后的结果</strong></p>
<p>如果走到了一个critical point,意味着gradient为零,绿色的这一项为0，所以当在critical point的时候,这个loss function,它可以被近似为,L(θ)加上红色的一项</p>
<p><img src="17.png" alt="14" style="zoom:70%;" /></p>
<p><img src="18.png" alt="14" style="zoom:80%;" /></p>
<p>如果今天,positive definite的矩阵,<strong>它所有的eigen value特征值都是正的</strong></p>
<ul>
<li>对所有的v而言,都大于零,矩阵叫做<strong>positive definite 正定矩阵。</strong>算出hessian metric,它的eigen value特征值发现都是正的,它就是local minima。</li>
<li>如果对所有的v而言,小于零, hessian metric是negative definite,所有<strong>eigen value都是负的</strong>,就保证他是local maxima</li>
<li><strong>那如果eigen value有正有负</strong>,那就代表是saddle point</li>
</ul>
<p>H不只可以帮助我们判断saddle point,它还指出了参数可以update的方向</p>
<p><img src="19.png" alt="14" style="zoom:80%;" /></p>
<p><strong>你在θ'的位置加上u,沿著u的方向做update得到θ,你就可以让loss变小，</strong>也就是eigen vector的方向</p>
<h2 id="batch-and-momentum">Batch and Momentum</h2>
<p><img src="4.png" alt="4" style="zoom:40%;" /></p>
<p>把所有的 Data 分成一个一个的 <strong>Batch</strong>,或者叫<strong>Mini Batch</strong>。每一个 Batch 的大小为<strong>batch_size</strong>, 每次<strong>在 Update 参数的时候,分别对 batch 计算 Loss, 计算 Gradient, 然后Update 参数。所有的batch计算一遍称为一个epoch</strong>。（batch 进行 Shuffle）</p>
<h3 id="small-batch-v.s.-large-batch">Small Batch v.s. Large Batch</h3>
<p><img src="20.png" alt="14" style="zoom:60%;" /></p>
<p><strong>Larger batch size does not require longer time to compute gradient</strong>，GPU具有平行计算能力</p>
<p><img src="21.png" alt="14" style="zoom:60%;" /></p>
<p><strong>Smaller batch requires longer time for one epoch</strong>，,当 <strong>Batch Size 小的时候,跑完一个 Epoch,花的时间是比大的 Batch Size 还要多</strong></p>
<p><img src="22.png" alt="14" style="zoom:80%;" /></p>
<p><strong>Noisy 的 Gradient,反而可以帮助 Training，拿不同的 Batch 来训练你的模型，左边在 MNIST 上,右边在 CIFAR-10 上</strong></p>
<p><img src="23.png" alt="14" style="zoom:40%;" /></p>
<ul>
<li>横轴代表的是 Batch Size</li>
<li>纵轴代表的是正确率</li>
</ul>
<h3 id="noisy-update-is-better-for-training">“Noisy” update is better for training</h3>
<blockquote>
<p>Small Batch 因为每次选 Batch ,计算 Loss,所以相当于每一次 Update 你的参数的时候,用的 Loss Function 都是越有差异</p>
<p>Full Batch, 在 Update 参数的时候,就是沿著一个 Loss Function 来 Update 参数, 走到一个 Local Minima,走到一个 Saddle Point时, Gradient = 0,如果不去看Hession Matrix ，用 Gradient Descent 的方法, 无法再 Update Parameters</p>
</blockquote>
<p><img src="24.png" alt="14" style="zoom:70%;" /></p>
<h3 id="noisy-update-is-better-for-generalization">“Noisy” update is better for generalization</h3>
<blockquote>
<p><strong>Small Batch, Testing 的时候效果比较好</strong>,以下实验结果是引用自,<a href="https://arxiv.org/abs/1609.04836">On Large-Batch Training For Deep Learning,Generalization Gap And Sharp Minima</a></p>
</blockquote>
<p><img src="25.png" alt="14" style="zoom:90%;" /></p>
<h3 id="momentum">Momentum</h3>
<blockquote>
<p>解决 Saddle Point,或 Local Minima 的技术</p>
</blockquote>
<h4 id="small-gradient">Small Gradient</h4>
<p><img src="26.png" alt="14" style="zoom:70%;" /></p>
<p>在物理的世界裡,一个球如果从高处滚下来,就算滚到 Saddle Point,如果有<strong>惯性</strong>,它还是会继续往右走,直到它走到一个 Local Minima。</p>
<h4 id="vanilla-gradient-descent一般的-gradient-descent">Vanilla Gradient Descent：一般的 Gradient Descent</h4>
<p><img src="27.png" alt="14" style="zoom:70%;" /></p>
<h4 id="gradient-descent-momentum">Gradient Descent + Momentum</h4>
<p>加上 Momentum 以后,每一次在 Update 参数的时候,我们不是只往 Gradient Descent,我们不是只往 Gradient 的反方向来移动参数, 而是 <strong>Gradient 的反方向,加上前一步移动的方向, 两者加起来的结果, 更新参数,</strong></p>
<p><img src="28.png" alt="14" style="zoom:70%;" /></p>
<p><img src="29.png" alt="14" style="zoom:50%;" /></p>
<p>Momentum 也是 Update 的方向,不是只考虑现在的 Gradient,而是考虑过去所有 Gradient 的总和.</p>
<p><img src="30.png" alt="14" style="zoom:60%;" /></p>
<h3 id="总结">总结</h3>
<ul>
<li>Critical points have zero gradients.</li>
<li>Critical points can be either saddle points or local minima.
<ul>
<li>Can be determined by the Hessian matrix.</li>
<li>Local minima may be rare.</li>
<li>It is possible to escape saddle points along the direction of eigenvectors of the Hessian matrix</li>
</ul></li>
<li>Smaller batch size and momentum help escape critical points.</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>java学习笔记</title>
    <url>/2020/03/01/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="java">Java</h1>
<span id="more"></span>
<figure>
<img src="Java运行原理图.png" alt="Java运行原理图" /><figcaption aria-hidden="true">Java运行原理图</figcaption>
</figure>
<h2 id="定义常量">定义常量</h2>
<p>自定义常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> PI=<span class="number">3.14f</span></span><br></pre></td></tr></table></figure>
<p>字面值常量</p>
<h2 id="运算符">运算符</h2>
<ul>
<li><p>在java中，浮点数运算具有不精确性，浮点数本身是非精确存储</p></li>
<li><p>字符串可以用 + 拼接</p></li>
<li><p>字符串与整型+运算，结果仍是字符串</p></li>
<li><p>字符与整型+运算结果为ASCII码的运算结果</p></li>
</ul>
<h2 id="逻辑运算">逻辑运算</h2>
<ul>
<li>短路与：&amp;&amp; 短路或：| |</li>
<li>与：&amp; 或：|</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>,b=<span class="number">10</span>;</span><br><span class="line">System.out.println(a&gt;<span class="number">20</span> &amp; (++b) &gt; <span class="number">10</span>); <span class="comment">// false</span></span><br><span class="line">System.out.println(b); <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">System.out.println(a&gt;<span class="number">20</span> &amp;&amp; (++b) &gt; <span class="number">10</span>); <span class="comment">// false</span></span><br><span class="line">System.out.println(b); <span class="comment">// 10  短路作用，根据 a&gt;20 直接判断为false，&amp;&amp;之后不再运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//短路或 类似</span></span><br></pre></td></tr></table></figure>
<h2 id="位运算">位运算</h2>
<p>计算机正数存储原码，负数存储补码便于运算。</p>
<ul>
<li>正数：原码、反码、补码相同</li>
<li>负数：原码(符号位为1)、反码(符号位不变，其余取反)、补码(反码加一)</li>
</ul>
<blockquote>
<p>-9: 原码 1000 0000 0000 1001 反码 1111 1111 1111 0110 补码 1111 1111 1111 0111</p>
<p>-7 1000 0000 0000 0111 1111 1111 1111 1000 1111 1111 1111 1001</p>
<p>-9 &amp; -7 1000 0000 0000 1111 1111 1111 1111 0000 1111 1111 1111 0001</p>
</blockquote>
<p>~ 按位取反 ^ 按位异或 &lt;&lt; 左移(高位抛弃) &gt;&gt;右移 (高位符号位补齐，低位抛弃) &gt;&gt;&gt;&gt;无符号右移</p>
<h2 id="三元运算符">三元运算符</h2>
<p>? : 规则： 布尔表达式 | 7&gt;8 ? 表达式1 ：表达式2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(a&gt;b?a:b);</span><br></pre></td></tr></table></figure>
<h2 id="类型转换">类型转换</h2>
<h3 id="隐式类型转换">隐式类型转换</h3>
<p>​ 小类型转换为大类型会自动转换： byte -&gt; short , char -&gt; int -&gt; long -&gt; float -&gt; double</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">虽然float比long小，但因为存储方法不一致导致 float 里面可以存储的数据范围比 long 要大( java 中 float 4个字节  的范围：3.4e+38 - 1.4e-45 ; long 占用 8 个字节 范围：-2^63 - +2^63  )</span><br><span class="line"></span><br><span class="line">使用情况：</span><br><span class="line"><span class="bullet">                1.</span> 赋值语句</span><br><span class="line"><span class="bullet">                2.</span> 算术表达式</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="keyword">byte</span> a=<span class="number">10</span>;</span><br><span class="line">      <span class="keyword">short</span> b = a;</span><br><span class="line">      <span class="keyword">int</span> c = b;</span><br><span class="line">      <span class="keyword">long</span> d = c;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">float</span> e = d;</span><br><span class="line">      <span class="keyword">double</span> f = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="显式类型转换">显式类型转换</h3>
<p>强制类型转换：大类型数据赋值给小类型数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> b;</span><br><span class="line">a = (<span class="keyword">double</span>) b;</span><br></pre></td></tr></table></figure>
<h2 id="流程控制">流程控制</h2>
<h3 id="语句块">语句块</h3>
<p>语句块的执行顺序从上到下</p>
<p>语句块可以访问外面定义的变量，外面不能访问语句块内部定义变量</p>
<h3 id="流程控制-1">流程控制</h3>
<p>控制程序中语句执行的顺序</p>
<ul>
<li><p>条件语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (bool表达式)&#123;</span><br><span class="line">​    <span class="comment">// 语句，bool为 true 执行。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if( ){ ​ //语句 }else{ ​ //语句 }</p>
<p>if(){</p>
<p>}else if(){</p>
<p>}else{</p>
<p>}</p></li>
<li><p>Switch 语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(variable)&#123;        <span class="comment">// variable 可以是字符串</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>while 语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件)&#123;</span><br><span class="line">  <span class="comment">// 语句</span></span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">//赋值语句可以放在条件中</span></span><br><span class="line"><span class="keyword">while</span> ((input = fileInputStream.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>do - while 先执行一遍循环体</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">   <span class="comment">// 循环体</span></span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式)    </span><br></pre></td></tr></table></figure></li>
<li><p>for 循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(init ; condition ; update)&#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="字符串-引用数据类型---reference-type">字符串 (引用数据类型 - reference type)</h2>
<p>字符串变量声明在栈中。</p>
<p>字符串本身无法被修改，变量指向字符串存储的地址，只能分配新的内存再使变量指向其地址。</p>
<h3 id="字符串常量">字符串常量</h3>
<p>存放在<strong>方法区的运行常量</strong>区中，不可修改，栈中的变量指向内容相同的字符串常量时，不在开辟新的空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="字符串变量">字符串变量</h3>
<p>new 得到的对象存放在堆中，堆中保存String传入的字符串地址，变量 str 则保存堆中对象的地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;); <span class="comment">// &quot;asd&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串比较">字符串比较</h3>
<p>若同为字符串变量或常量，则比较引用；若二者不同则比较字符串本身</p>
<p><img src="String内存存储方式.png" /></p>
<ul>
<li><p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String str4 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较引用</span></span><br><span class="line">System.out.println(str1 == str2);  <span class="comment">//true</span></span><br><span class="line">System.out.println(str2 == str3);  <span class="comment">//false</span></span><br><span class="line">System.out.println(str1 == str4);  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较字符串</span></span><br><span class="line">str1.equals(str3);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="字符串-api">字符串 API</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">str.length();  <span class="comment">//长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找子字符串的位置，不存在返回-1</span></span><br><span class="line">str.indexOf(<span class="keyword">int</span> c);     <span class="comment">// 传递一个字符  &#x27;A&#x27; == 65</span></span><br><span class="line">str.indexOf(String str);</span><br><span class="line">str.lastIndexOf(String str); <span class="comment">// 从后向前查找子串位置</span></span><br><span class="line">str.charAt(<span class="keyword">int</span> c); <span class="comment">//获取指定位置字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取子字符串</span></span><br><span class="line">str.substring(<span class="keyword">int</span> beginIndex); <span class="comment">//从 c 开始的位置截取子串</span></span><br><span class="line">str.substring(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断字符串的开始和结尾是否是</span></span><br><span class="line">str.startsWith(String prefix);</span><br><span class="line">str.endsWith(String suffix);</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较</span></span><br><span class="line">str.equals(String str);</span><br><span class="line">str.equalsIgnoreCase(String str);    <span class="comment">//忽略大小写</span></span><br><span class="line"></span><br><span class="line">str.compareTo(String str); <span class="comment">//从字符串开头，相同字符跳过，直至不同的字符并返回该字符ASCII码的差，若比较的字符串长度不同，且其中一个字符串是另一个的前缀，返回长度差</span></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">EXAMPLE：</span><br><span class="line">String str = <span class="string">&quot;abcDde&quot;</span>;</span><br><span class="line">System.out.println(str.compareTo(<span class="string">&quot;abc&quot;</span>)); <span class="comment">// 3</span></span><br><span class="line">System.out.println(str.compareTo(<span class="string">&quot;abcd&quot;</span>)); <span class="comment">// -32</span></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">str.contains(String str); <span class="comment">//判断是否包含</span></span><br><span class="line">str.isEmpty();   <span class="comment">//判断是否为空 即 str = &quot;&quot;;  而不是 str = null;空对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换</span></span><br><span class="line">str.toLowerCase();  <span class="comment">//小写</span></span><br><span class="line">str.toUpperCase();  <span class="comment">//大写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分割</span></span><br><span class="line">String[] strs = str.split(<span class="string">&quot;\\.&quot;</span>);   <span class="comment">// 按照输入对字符串分割,返回字符串数组 java中的存储为 \. 故\\.</span></span><br><span class="line"><span class="keyword">for</span>(String s : strs)&#123;</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">str.trim(); <span class="comment">// 去除前边和后边的空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串替换</span></span><br><span class="line">str.replace(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar);</span><br><span class="line">str.replace(String oldStr, String newStr);</span><br></pre></td></tr></table></figure>
<h2 id="数组">数组</h2>
<h3 id="引用类型和基本类型变量创建的不同">引用类型和基本类型变量创建的不同</h3>
<ul>
<li><p>所有局部变量都存放在栈里，在方法里创建的变量都是局部变量</p></li>
<li><p>基本类型不管是否赋值，都已经分配了空间</p></li>
<li><p>引用类型，声明只在栈分配内存(存储引用)、初始化在堆或者方法区里</p></li>
</ul>
<h3 id="声明">声明</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; <span class="comment">//按照默认值初始化0</span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">32</span>,<span class="number">34</span>&#125;; </span><br><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">3</span>,<span class="number">32</span>,<span class="number">34</span>&#125;;</span><br><span class="line"></span><br><span class="line">array.length;   <span class="comment">//长度属性</span></span><br></pre></td></tr></table></figure>
<h3 id="数据类型默认值">数据类型默认值</h3>
<p>基本类型是0 (0 0.0 0所代表的字符 false)</p>
<p>引用类型是null , null数组不能访问其属性及内容。</p>
<p>数组名的赋值只赋值引用</p>
<h3 id="赋值">赋值</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line">Arrays.fill(<span class="keyword">int</span>[], fromIndex, toIndex, val);</span><br></pre></td></tr></table></figure>
<h3 id="特殊创建">特殊创建</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][];</span><br><span class="line">array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">array[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="方法">方法</h2>
<p>java中引用类型传入方法会同步修改，对指针进行封装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> [] a)</span></span>&#123;</span><br><span class="line">  a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">  method(a);            <span class="comment">// 方法中将引用复制到方法局部变量a，对引用a初始化，不影响 main 的数组a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法重载">方法重载</h3>
<p>相同方法名，不同参数</p>
<h3 id="方法重写-override">方法重写 override</h3>
<p>子类对父类，参数相同，方法名相同</p>
<h2 id="帮助文档生成">帮助文档生成</h2>
<p>必须 public 类才能生成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javadoc -d 要生成的文件夹名 xxx.java</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个处理数组的静态工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTool</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array shuzu</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value zhi</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find_index</span><span class="params">(<span class="keyword">float</span>[] array, <span class="keyword">float</span> value)</span></span>&#123;&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="类和面向对象">类和面向对象</h2>
<p>类中的属性未初始化不可使用，默认为null；</p>
<blockquote>
<p>面向对象程序设计以对象为核心，该方法认为程序由一系列对象组成。类是对现实世界的抽象，包括表示静态属性的数据和对数据的操作，<strong>对象是类的实例化</strong>。对象间通过消息传递相互通信，来模拟现实世界中不同实体间的联系。在面向对象的程序设计中，对象是组成程序的基本模块。</p>
<p>面向对象程序设计（Object Oriented Programming，OOP）是一种计算机编程架构。OOP的一条基本原则是计算机程序由单个能够起到子程序作用的单元或对象组合而成。OOP达到了软件工程的三个主要目标：重用性、灵活性和扩展性。OOP=对象+类+继承+多态+消息，其中核心概念是类和对象。</p>
</blockquote>
<p>匿名对象：</p>
<p>​ new Object(); //适用只使用一次</p>
<h3 id="成员变量">成员变量</h3>
<p>在类中定义的变量，不占任何内存。在其创建对象时分配空间，堆。</p>
<p>局部变量则在栈中存储，方法调用结束销毁，且必须初始化</p>
<p>可将对象作为类的成员变量</p>
<h3 id="垃圾回收机制-gc">垃圾回收机制 (GC)</h3>
<p>堆是垃圾回收的主要区域，可以分为新生代和老年代(tenured)。新生代用于存放刚创建的对象以及年轻的 对象，如果对象一直没有被回收，生存得足够长，老年对象就会被移入老年代。</p>
<p>标记-清除算法(Mark-Sweep)从根节点开始标记所有可达对象，其余没标记的即为垃圾对象，执行清除。但回收后的空间是不连续的。</p>
<p>复制算法(copying)将内存分成两块，每次只使用其中一块，垃圾回收时，将标记的对象拷贝到另外一块中，然后完全清除原来使用的那块内存。复制后的空间是连续的。</p>
<p>复制算法适用于新生代，因为垃圾对象多于存活对象，复制算法更高效。 标记-压缩算法(Mark-compact)适合用于老年代的算法(存活对象多于垃圾对象)。</p>
<h3 id="构造方法">构造方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Object</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//对成员变量赋值，与c++构造函数类似；可以对构造方法重载</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Object</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//当工具类都为静态方法，使构造方法私有化，防止对其进行实例化</span></span><br></pre></td></tr></table></figure>
<h3 id="this指针">this指针</h3>
<p>this 代表当前类，可以通过 this 访问方法和成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">  datatype attribute;</span><br><span class="line">  <span class="function">datatype <span class="title">method</span><span class="params">(datatype attribute)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.attribute = attribute;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="private-public">private &amp; public</h3>
<p>私有化与公有化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将属性全部私有，利用get、set方法对属性操作,体现了封装性及安全性</span></span><br><span class="line"><span class="keyword">private</span> datatype attribute;</span><br><span class="line"><span class="function"><span class="keyword">public</span> datatype <span class="title">getAttribute</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> attribute;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(datatype attribute)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.attribute = attribute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="static关键字静态变量">static关键字（静态变量）</h3>
<ul>
<li><p>可修饰成员变量和成员方法</p></li>
<li><p>修饰成员变量表示静态变量，静态变量对所有对象共用，在内存中保存一份</p></li>
<li><p>修饰成员变量表示静态方法，<strong>静态方法只能访问静态变量</strong>(在静态区中存储) 可以把成员变量作为参数传递给静态方法。</p></li>
<li><p>静态成员变量通过类名访问；Object.variable；其实例化的所有对象值一致</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object ob)</span></span>&#123;</span><br><span class="line">    <span class="comment">//  通过参数对对象进行访问；</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    Object.name = <span class="string">&quot;asdf&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li><p>static 随着类的加载而加载，优先于对象存在。所有对象共享(可以通过对象或者类来访问)</p></li>
<li><p>main 放法 为特殊的静态方法</p></li>
<li><p>main(String[] args); 中 args 用来传递参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java Object 参数</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li><p>static 实现工具类</p>
<p>工具类不需要存储数据，不需要实例化，利用 static 构造静态方法</p></li>
</ul>
<h3 id="静态代码块">静态代码块</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//放在类里，只会执行一次</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">          pi = <span class="number">3.14</span>;    <span class="comment">//因为只运行一次，里面的变量必须是静态变量；</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承">继承</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> gender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name, <span class="keyword">char</span> gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> classNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name, <span class="keyword">int</span> classNumber,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">char</span> gender, <span class="keyword">int</span> rank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(age, name, gender);    <span class="comment">//通过 super() 调用父类的构造方法, 且必须在第一行</span></span><br><span class="line">        <span class="keyword">this</span>.classNumber = classNumber;</span><br><span class="line">        <span class="keyword">this</span>.rank = rank;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tips：</p>
<ul>
<li><p>java不支持多继承，即同时继承多个类，但支持多层继承</p></li>
<li><p>子类不能访问父类的私有成员，但子类包含父类的私有成员不能直接访问</p></li>
<li><p>子类和父类中有同名的变量，就近原则</p></li>
<li><p>可以通过<strong>super</strong>访问父类的 public 变量、方法和构造方法；<strong>this</strong> 访问当前类的成员变量，方法，构造</p></li>
<li><p>super 和 this 调用构造方法必须在第一行</p></li>
<li><p>子类构造子类对象时，会调用父类的构造放法，如果父类没有无参数构造方法，则必须在子类构造方法显式的调用父类的有参数构造方法(利用 super 和 this)</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> gender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name, <span class="keyword">char</span> gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> classNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rank;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//报错，父类无无参数构造方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>this 通常用于存在多个构造方法时，在其中一个构造方法中调用同类的其他构造方法，从而简洁代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name)</span></span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name, <span class="keyword">char</span> gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(age, name);</span><br><span class="line">          <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="方法重写override或覆盖">方法重写(override)或覆盖</h3>
<p>子类的方法名、参数、返回值和父类相同</p>
<p>意义：子类和父类有相同功能，但是子类有自己的特定内容和特定实现方式。为了见名知意，保持父类的名字，自己重新实现方法体。</p>
<p>tips：</p>
<ul>
<li>不能重写private方法, 否则相当于在子类创建新的方法</li>
<li>重写的时候访问权限不能更低(public 最高)</li>
</ul>
<h3 id="方法重载overload">方法重载(overload)</h3>
<ul>
<li>同一个类中，相同的方法名，参数不同，返回值不要求</li>
</ul>
<h3 id="final-关键字">final 关键字</h3>
<ul>
<li><p>final 类 (表示类不可继承)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>fianl 方法(表示这个方法不能被子类重写)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>final 变量 (常量)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> con;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="java-类包package">java 类包(package)</h3>
<p>通过包对类进行管理，避免重名问题。不同包里可以包含同名的类</p>
<p>包的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> xx.xx.xx; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名规则，以域名开头，都小写</span></span><br><span class="line">com.liuyang.xxx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包文件自动生成，再把源文件放到路径下</span></span><br><span class="line">javac -d . xxxx.java</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行包文件</span></span><br><span class="line">java com.liuyang.xxx.xxxx</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">import</span> com.liuyang.xxx.xxxx.Object;</span><br></pre></td></tr></table></figure>
<h3 id="权限修饰符">权限修饰符</h3>
<p>应用：类、成员变量、成员方法</p>
<blockquote>
<p>default 在同一个包里使用，不能在包外使用；在成员函数定义时，没有加访问限制符的函数，其访问等级为default</p>
<p>父类中的 protected 成员变量在子类可以直接访问</p>
</blockquote>
<figure>
<img src="类.png" alt="image" /><figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="内部类">内部类</h3>
<p>内部类寄生在外部类对象，外部类对象中可以有多个内部类对象，内部类对象只有一个外部类对象</p>
<p>内部类不能单独存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer1 = <span class="keyword">new</span> Outer(<span class="string">&quot;outer&quot;</span>);</span><br><span class="line">        outer1.test(<span class="number">1.2f</span>, <span class="string">&quot;sss&quot;</span>).method();</span><br><span class="line"></span><br><span class="line">        Outer outer2 = <span class="keyword">new</span> Outer(<span class="string">&quot;outer2&quot;</span>, <span class="number">1.2f</span>, <span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">        outer2.inner.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部类 不能直接访问内部类成员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> Inner inner;        <span class="comment">//内部类实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">(String name, <span class="keyword">float</span> weight, String innerName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        inner = <span class="keyword">new</span> Inner(weight,innerName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">test</span><span class="params">(<span class="keyword">float</span> weight, String name)</span> </span>&#123;</span><br><span class="line">        inner = <span class="keyword">new</span> Inner(weight, name);</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类 public default protect private static</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">float</span> weight;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">(<span class="keyword">float</span> weight, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;this a inner class&quot;</span>);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.weight);</span><br><span class="line">            System.out.println(<span class="string">&quot;外部类：&quot;</span> + Outer.<span class="keyword">this</span>.name); <span class="comment">//内部类访问外部类成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从外部类直接访问<strong>public</strong>内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.Inner inner = <span class="keyword">new</span> Outer().<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//--------------------------------------------</span></span><br><span class="line"></span><br><span class="line">Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">Outer.Inner inner = out.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="局部内部类">局部内部类</h4>
<p>方法内定义的局部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">                        <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">                  System.out.println(age);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Person p1 = <span class="keyword">new</span> Person(<span class="number">12</span>);</span><br><span class="line">      p1.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="抽象匿名内部类">抽象匿名内部类</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Plane</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> speed;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plane</span><span class="params">(<span class="keyword">float</span> speed, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id =id;</span><br><span class="line">        <span class="keyword">this</span>.speed =speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.speed+<span class="string">&quot; &quot;</span>+<span class="keyword">this</span>.id);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">========================================================================================</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonNameInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">          <span class="comment">// 匿名内部类</span></span><br><span class="line">        <span class="keyword">new</span> Plane(<span class="number">1.2f</span>,<span class="number">12</span>)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.speed+<span class="string">&quot; &quot;</span>+<span class="keyword">this</span>.id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有名内部类</span></span><br><span class="line">        Plane plane = <span class="keyword">new</span> Plane(<span class="number">1.2f</span>,<span class="number">12</span>) &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">this</span>.show();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">          plane.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多态">多态</h3>
<p>多态指同一个实体同时具有多种形式。它是面向对象程序设计（OOP）的一个重要特征。如果一个语言只支持类而不支持多态，只能说明它是<u><strong>基于对象</strong></u>的，而不是<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a>的。C++中的多态性具体体现在运行和编译两个方面。运行时多态是动态多态，其具体引用的对象在运行时才能确定。编译时多态是静态多态，在<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91">编译</a>时就可以确定对象使用的形式。</p>
<p>多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。即<strong>父类的引用在运行过程中存在不同的状态</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BaseClass bc = <span class="keyword">null</span>;</span><br><span class="line">bc = SubClass1();</span><br><span class="line">bc = SubClass2();</span><br><span class="line"><span class="comment">// bc在运行过程中有多种状态</span></span><br></pre></td></tr></table></figure>
<p>java多态的前提：</p>
<ul>
<li>继承</li>
<li>重写</li>
<li>父类对象的引用指向子类对象</li>
</ul>
<p>继承关系：IS-A；组合关系Has-A；依赖关系 USE-A</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">20</span>;        <span class="comment">// 静态成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;        <span class="comment">// 静态方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;动物在睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在奔跑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cat is a kind of animal</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">80</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">90</span>;</span><br><span class="line">        String name = <span class="string">&quot;tomCat&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫在睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchMouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫在抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//测试用类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">    Animal am = <span class="keyword">new</span> Cat();        <span class="comment">// 父类对象的引用指向子类对象</span></span><br><span class="line">    am.eat();        <span class="comment">//--&gt; 猫吃饭        </span></span><br><span class="line">    am.sleep();        <span class="comment">//--&gt; 动物在睡觉    // 静态方法</span></span><br><span class="line">    am.run();        <span class="comment">//--&gt;动物在奔跑       // 未重写方法</span></span><br><span class="line"></span><br><span class="line">    am.catchMouse(); <span class="comment">// 报错  不能使用子类特有的属性和方法</span></span><br><span class="line">    System.out.println(am.name); <span class="comment">//报错  不能使用子类特有的属性和方法</span></span><br><span class="line"></span><br><span class="line">    System.out.println(am.num); <span class="comment">// 10</span></span><br><span class="line">    System.out.println(am.age); <span class="comment">// 20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类 Cat 重写了父类Animal的非静态成员方法am.eat();的输出结果为：猫吃饭。 子类 Cat 重写了父类(Animal)的静态成员方法am.sleep();的输出结果为：动物在睡觉 未被子类（Cat）重写的父类（Animal）方法am.run()输出结果为：动物在奔跑</p>
<p><strong>成员变量</strong> 编译看左边(父类),运行看左边(父类) <strong>成员方法</strong> 编译看左边(父类)，运行看右边(子类)。<strong>动态绑定</strong> <strong>静态方法</strong> 编译看左边(父类)，运行看左边(父类)。 (静态和类相关，算不上重写，所以，访问还是左边的) <strong>只有非静态的成员方法,编译看左边,运行看右边</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BaseClass bc = <span class="keyword">new</span> SubClass();</span><br></pre></td></tr></table></figure>
<h3 id="继承的弊端">继承的弊端</h3>
<p><strong>不能使用子类特有的成员属性和子类特有的成员方法。</strong></p>
<p>解决: 强制转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cat cat = (Cat) animal;</span><br></pre></td></tr></table></figure>
<h3 id="抽象类">抽象类</h3>
<p>抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法的声明格式为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>抽象方法必须用<strong>abstract</strong>关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用<strong>abstract</strong>关键字修饰。</p>
<p>因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象, 抽象类就是为了继承而存在的.</p>
<p>包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类的主要有三点区别：</p>
<hr />
<p>　　<strong>1. 抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</strong></p>
<p>　　<strong>2. 抽象类不能用来创建对象；</strong></p>
<p>　　<strong>3. 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。</strong></p>
<p>　　在其他方面，抽象类和普通的类并没有区别。</p>
<hr />
<h3 id="类特殊方法重写override">类特殊方法重写（override）</h3>
<h4 id="tostring方法">toString方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object ob = <span class="keyword">new</span> Object();</span><br><span class="line">System.out.println(ob.toString());    <span class="comment">//打印对象ob的地址</span></span><br><span class="line">System.out.println(ob);            <span class="comment">//打印对象ob的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 toString() override 打印需要的参数</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;B&#123;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;c=&quot;</span> + c +</span><br><span class="line">    <span class="string">&quot;, d=&#x27;&quot;</span> + d + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">    <span class="string">&quot;&#125; &quot;</span> ;</span><br><span class="line">&#125;                                                    <span class="comment">// B&#123;c=12, d=&#x27;dxwec&#x27;&#125; </span></span><br></pre></td></tr></table></figure>
<h4 id="equals方法">equals方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(o == <span class="keyword">this</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span>(o == <span class="keyword">null</span> || o.getClass() != <span class="keyword">this</span>.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      This_Object o1 = (This_Object)o;</span><br><span class="line">      <span class="keyword">return</span> o1.variable == <span class="keyword">this</span>.variable &amp;&amp; string.equals(o1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口interface">接口（interface）</h2>
<p>软件工程中，接口泛指供别人调用的方法或者函数，Java语言设计者的初衷，它是对行为的抽象</p>
<p>接口的形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">public</span>] <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceName</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>接口内只能是抽象方法（接口是完全抽象化的类，里面没有完整的方法），方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现</strong></li>
<li><strong>接口中可以含有变量，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误）</strong> ，静态常量</li>
<li><strong>接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。</strong></li>
</ul>
<hr />
<p>要让一个类遵循某组特地的接口需要使用implements关键字，具体格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> <span class="keyword">implements</span> <span class="title">Interface1</span>,<span class="title">Interface2</span>,[....]</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>允许一个类遵循多个特定的接口</strong></li>
<li><strong>一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法</strong></li>
</ul>
<h3 id="接口和类的区别">接口和类的区别</h3>
<ol type="1">
<li>语法层面上的区别</li>
</ol>
<p>　　1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</p>
<p>　　2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</p>
<p>　　3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</p>
<p>　　4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<p>2.设计层面上的区别</p>
<ul>
<li><p>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。</p></li>
<li><p>继承是一个 "<strong>IS-A</strong>"的关系，而 接口实现则是 "<strong>HAS-A</strong>"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p></li>
<li><p>抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。</p></li>
<li><p>对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p></li>
</ul>
<p><strong>Example</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对门添加 alarm() 功能</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Alarm</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlarmDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> <span class="keyword">implements</span> <span class="title">Alarm</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// specific implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// specific implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// specific implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口与匿名内部类">接口与匿名内部类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonNameInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Alarm()&#123;        <span class="comment">// 定义实现 Alarm 接口的子类</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>&#123;        <span class="comment">//必须加 public， interface里的方法默认 public</span></span><br><span class="line">                System.out.println(<span class="string">&quot;alarm&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.alarm();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用类">常用类</h2>
<h3 id="scanner">Scanner</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.utils.Scanner;</span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">scanner.next(); <span class="comment">//输入字符串 遇到空格停止扫描</span></span><br><span class="line">scanner.nextLine(); <span class="comment">// 输入字符串 遇到 &quot;\r&quot; 停止扫描</span></span><br><span class="line">scanner.nextInt();</span><br><span class="line">scanner.next().charAt(<span class="number">0</span>); <span class="comment">//输入字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// haxNext**() 是否有下一个，返回 boolean 类型</span></span><br><span class="line">scanner.hasNext(); <span class="comment">//输入数据，检测是否有下一个字符串，返回</span></span><br><span class="line">scanner.hasNextInt(); <span class="comment">// 是否有下一个整型</span></span><br><span class="line">scanner.hasNextFloat();</span><br></pre></td></tr></table></figure>
<h3 id="stringbuffer-stringbuilder">StringBuffer &amp;&amp; StringBuilder</h3>
<p>创建的字符串可以被修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();<span class="comment">// 可以指定容量</span></span><br><span class="line"></span><br><span class="line">sb.append(<span class="string">&quot;sd&quot;</span>)</span><br><span class="line">  .append(<span class="string">&quot;.com&quot;</span>)</span><br><span class="line">  .append(<span class="string">&quot;.cn&quot;</span>);   <span class="comment">// 使用该方法进行字符串的连接，将比String更加节约内容</span></span><br><span class="line">sb.insert(<span class="keyword">int</span> offset,String str);  <span class="comment">//在StringBuffer对象中插入内容，然后形成新的字符串</span></span><br><span class="line">sb.deleteCharAt(<span class="keyword">int</span> p); <span class="comment">//删除指定位置的字符，然后将剩余的内容形成新的字符串。</span></span><br><span class="line">sb.delete(<span class="keyword">int</span> start,<span class="keyword">int</span> end) <span class="comment">//该方法的作用是删除指定区间以内的所有字符，包含start，不包含end索引值的区间</span></span><br><span class="line"></span><br><span class="line">sb.reverse(); <span class="comment">//将StringBuffer对象中的内容反转</span></span><br><span class="line">sb.setCharAt(<span class="keyword">int</span> index, <span class="keyword">char</span> ch)    <span class="comment">// 该方法的作用是修改对象中索引值为index位置的字符为新的字符ch</span></span><br><span class="line"></span><br><span class="line">sb.capacity();  <span class="comment">//返回缓冲区容量，默认16;</span></span><br><span class="line"></span><br><span class="line">sb.substring(<span class="keyword">int</span> start, <span class="keyword">int</span> end); <span class="comment">//截取包含start，不包含end索引值</span></span><br><span class="line">sb.replace(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String ch); <span class="comment">//替换 包含start，不包含end索引值 的字符串</span></span><br></pre></td></tr></table></figure>
<h4 id="区别">区别</h4>
<p>执行速度，<strong>在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String</strong></p>
<p><strong>String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。</strong></p>
<p>Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多</p>
<p>StringBuilder和StringBuffer一样，都是继承自抽象类AbstractStringBuilder类，也是一个可变的字符序列。StringBuilder和StringBuffer非常相似，甚至有互相兼容的API，不过，<strong>StringBuilder不是线程安全的，这是和StringBuffer的主要区别</strong></p>
<p>当 StringBuffer 的缓冲区满之后，java会申请2倍大小的空间把原来的值赋值过去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="string">&quot;abc&quot;</span>+<span class="string">&quot;de&quot;</span>;</span><br><span class="line">StringBuilder stringBuilder = newStringBuilder().append(<span class="string">&quot;abc&quot;</span>).append(<span class="string">&quot;de&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line">System.out.println(stringBuilder.toString());</span><br></pre></td></tr></table></figure>
<p>　　这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多，这是因为第1行中的操作和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="string">&quot;abcde&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>是完全一样的，所以会很快，而如果写成下面这种形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String str2=<span class="string">&quot;de&quot;</span>;</span><br><span class="line">String str=str1+str2;</span><br></pre></td></tr></table></figure>
<p>那么JVM就会像上面说的那样，不断的创建、回收对象来进行这个操作了。速度就会很慢。所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更加适合一些。</p>
<p>字符的存储，JDK9之前是char存储，JDK9之后是byte存储</p>
<p>####互相转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str= <span class="string">&quot;qwert&quot;</span>;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(str);    <span class="comment">//String转换为StringBuffer</span></span><br><span class="line">String str2 = sb.toString(); <span class="comment">//StringBuffer转换为String</span></span><br></pre></td></tr></table></figure>
<h3 id="arrays">Arrays</h3>
<p>静态工具类</p>
<p>method：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>&#125;</span><br><span class="line">Arrays.sort(array);    <span class="comment">// 排序</span></span><br><span class="line">Arrays.toString(array); <span class="comment">//返回 String [1,2,3,3,6]</span></span><br><span class="line">Arrays.BinarySearch(array, <span class="number">3</span>); <span class="comment">// 二分查找，数组有序</span></span><br></pre></td></tr></table></figure>
<h3 id="math">Math</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.E;        <span class="comment">//自然对数e</span></span><br><span class="line">Math.abs(); <span class="comment">//取绝对值</span></span><br><span class="line">Math.round(<span class="number">3.4</span>);<span class="comment">//四舍五入</span></span><br><span class="line">Math.aqurt(); <span class="comment">//平方根</span></span><br><span class="line">Math.pow(<span class="keyword">double</span> a, <span class="keyword">double</span> b);  <span class="comment">//第一个参数的值，该值是第二个参数的幂</span></span><br><span class="line">Math.ceil(<span class="keyword">double</span>); <span class="comment">// 向上取整</span></span><br><span class="line">Math.floor(); <span class="comment">//向下取整</span></span><br><span class="line">Math.random(); <span class="comment">//生成随机数，[0,1)</span></span><br></pre></td></tr></table></figure>
<h3 id="bigdecimal-biginteger">BigDecimal &amp; BigInteger</h3>
<p><code>BigDecimal</code>由<code>任意精度</code>整数非<em>标度值</em>和32位整数<em>标度组成</em> 。</p>
<p><code>BigInteger</code>由不可变的<code>任意长度</code>整数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal bd = <span class="keyword">new</span> BigDecimal(String str);  <span class="comment">// 小数字符串</span></span><br><span class="line">BigDecimal bd = BigDecimal.valueOf(<span class="number">0.01</span>);    <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>Tips：<code>BigDecimal bd = new BigDecimal(0.02); // 0.0200000000000000004163336</code>: $ $</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bd.divide(BigDecimal divisor,<span class="keyword">int</span> scale, <span class="keyword">int</span> roundingMode);</span><br><span class="line">bd.multiply(BigDecimal nultiplicand);</span><br><span class="line">bd.subtract(BigDecimal subtrahend);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger bigInteger = <span class="keyword">new</span> BigInteger(String str);</span><br><span class="line"><span class="comment">//其他方法与BigDecimal 类似</span></span><br></pre></td></tr></table></figure>
<h3 id="date-calendar">Date &amp;&amp; Calendar</h3>
<p>时间类，<code>Date</code>被 <code>Calendar</code> 取代</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">Date d = <span class="keyword">new</span> Date(<span class="keyword">long</span> date);<span class="comment">//使用给定的毫秒时间值构造Date对象。date - 自1970年1月1日00:00:00 GMT以来的毫秒数不超过8099年的毫秒表示。</span></span><br><span class="line">d.toString(); <span class="comment">//以日期转义格式yyyy-mm-dd格式化日期。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">System.out.println(calendar.getTime());</span><br></pre></td></tr></table></figure>
<h3 id="包装类">包装类</h3>
<p>存于栈上</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">包装类</th>
<th style="text-align: center;">基本类</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Byte</td>
<td style="text-align: center;">byte</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">short</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Integer</td>
<td style="text-align: center;">int</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Long</td>
<td style="text-align: center;">long</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">double</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">char</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">boolean</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.parseInt(String str); <span class="comment">// 整数字符串转为int</span></span><br><span class="line">Integer.valueOf(<span class="keyword">int</span> i); <span class="comment">//Returns an Integer instance representing the specified int value.</span></span><br><span class="line">Integer.valueOf(String i); <span class="comment">//Returns an Integer object holding the value of the specified String.</span></span><br></pre></td></tr></table></figure>
<hr />
<h3 id="集合类-collection">集合类 Collection</h3>
<p><strong>java.util 库提供了一套相当完整的集合类(collection classes)来解决这个问题，其中基本的类型有 List 、Set 、Queue 和 Map。这些类型也被称作容器类(container classes)，集合还有一些其它特性。例如，Set 对于每个值都只保存一个对象，Map 是一个 关联数组，允许将某些对象与其他对象关联起来。Java 集合类都可以自动地调整自己 的大小。</strong></p>
<blockquote>
<p>ArrayList LinkedList Vector // 元素可重复，有序</p>
<p>HashSet TreeSet LinkedSet //不可重复，无序</p>
<p>HashMap TreeMap LinkedMap //</p>
</blockquote>
<h4 id="基本概念">基本概念</h4>
<ul>
<li>集合(Collection): 一个独立元素的序列，这些元素都服从一条或多条规则。List 必须以插入的顺序保存元素，Set 不能包含重复元素，Queue 按照排队规则来确 定对象产生的顺序(通常与它们被插入的顺序相同)。</li>
<li>映射(Map):一组成对的“键值对”对象，允许使用键来查找值。map 允 许我们使用一个对象来查找另一个对象，它也被称作关联数组(associative array)， 因为它将对象和其它对象关联在一起;或者称作字典(dictionary)，</li>
</ul>
<h4 id="案例-集合打印">案例-集合打印</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合的打印</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintingCollections</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Collection&lt;String&gt; <span class="title">fill</span><span class="params">(Collection&lt;String&gt; collection)</span></span>&#123;</span><br><span class="line">        collection.add(<span class="string">&quot;rat&quot;</span>);                    <span class="comment">//Map.put(key, value) </span></span><br><span class="line">        collection.add(<span class="string">&quot;cat&quot;</span>);                    <span class="comment">//添加一个所想要添加的值并将它与一个键(用来查找值)相关联。</span></span><br><span class="line">        collection.add(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> collection;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Map&lt;String,String&gt; <span class="title">fill</span><span class="params">(Map&lt;String,String&gt; map)</span></span>&#123;</span><br><span class="line">        map.put(<span class="string">&quot;rat&quot;</span>,<span class="string">&quot;Fuzzy&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;Rags&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;Bosco&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;Spot&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> ArrayList&lt;&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> LinkedList&lt;&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> HashSet&lt;&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> TreeSet&lt;&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> LinkedHashSet&lt;&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> HashMap&lt;&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> TreeMap&lt;&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> LinkedHashMap&lt;&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[rat, cat, dog, dog]</span></span><br><span class="line"><span class="comment">[rat, cat, dog, dog]</span></span><br><span class="line"><span class="comment">[rat, cat, dog]</span></span><br><span class="line"><span class="comment">[cat, dog, rat]</span></span><br><span class="line"><span class="comment">[rat, cat, dog]</span></span><br><span class="line"><span class="comment">&#123;rat=Fuzzy, cat=Rags, dog=Spot&#125; </span></span><br><span class="line"><span class="comment">&#123;cat=Rags, dog=Spot, rat=Fuzzy&#125; </span></span><br><span class="line"><span class="comment">&#123;rat=Fuzzy, cat=Rags, dog=Spot&#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>结论：</p>
<ul>
<li><code>Collection</code> &amp;&amp; <code>Map</code> 区别在于集合中的每个 “槽”(slot) 保存的元素个数。Collection 类型在每个槽中只能保存一个元素，Map 在每个槽中存放了两个元素，即键和与之关联的值。</li>
<li>ArrayList 和 LinkedList 都是 List 的类型，从输出中可以看出，它们都按插入顺序保存元素。HashSet ，TreeSet 和 LinkedHashSet 是 Set 的类型。从输出中可以看到，Set 仅保存每个相同项中的一个，并且不同的 Set 实现存储元素的方式也不同。</li>
<li>HashSet ，TreeSet 和 LinkedHashSet 是 Set 的类型。从输出中可以看到，Set 仅保存每个相同项中的一个</li>
<li>Set是检索元素的最快方法， TreeSet 按比较结果的升序保存对象； LinkedHashSet 按照被添加的先后顺序保存对象。</li>
<li>HashMap 实现使用了非常快速的算法来控制顺序，键和值不是插入顺序保存在 HashMap 中</li>
<li>TreeMap 通过比较结果的升序来保存键</li>
<li>LinkedHashMap 在保持 HashMap 查找速度的同时按键的插入顺序保存键。</li>
</ul>
<h4 id="list">List</h4>
<p>List 接口在 Collection 的基础上添加了 许多方法，允许在 List 的中间插入和删除元素。</p>
<p>有两种类型的 List :</p>
<ul>
<li><p>基本的 ArrayList ，内部通过数组实现，擅长随机访问元素，但在 List 中间插入和删除元素时速度较慢。</p></li>
<li><p>LinkedList ，链表通过代价较低的在 List 中间进行的插入和删除操作，提供了优化的顺序访问。LinkedList 对于随机访问来说相对较慢，但它具有比 ArrayList 更大的特征集。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">linkedList.addFirst();</span><br><span class="line">linkedList.addLast();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>ArrayList &amp;&amp; Vector</p>
<blockquote>
<p>ArrayList &amp;&amp; Vector 几乎一样，区别在于 Vector 线程安全，因此效率低于ArrayList</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//constructors</span></span><br><span class="line">ArrayList al = <span class="keyword">new</span> ArrayList();  <span class="comment">//默认容量为10；</span></span><br><span class="line">ArrayList al = <span class="keyword">new</span> ArrayList(<span class="keyword">int</span> initialCapacity); <span class="comment">//给定初始化容量</span></span><br><span class="line">ArrayList al = <span class="keyword">new</span> ArrayList(Collection &lt;? extends E&gt; c);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用范型，指定集合可以保存的类型，使用泛型，从 List 中获取元素不需要强制类型转换。因为 List 知道它持有什么类型，因此当调用 get() 时，它会替你执行转型。</span></span><br><span class="line">ArrayList&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// methods</span></span><br><span class="line">al.add(E element);  <span class="comment">//在列表末尾加入元素 element</span></span><br><span class="line">al.add(<span class="keyword">int</span> index, E element);</span><br><span class="line">al.addAll(Collection &lt;? extends E&gt; c); <span class="comment">// 将指定集合加入列表的末尾</span></span><br><span class="line">al.remove(Object o); <span class="comment">//在列表中删除第一个给定元素</span></span><br><span class="line">al.removeAll(Collection &lt;? extends E&gt; c);</span><br><span class="line">al.get(<span class="keyword">int</span> index);</span><br><span class="line"><span class="comment">//ubList() 方法可以轻松地从更大的列表中创建切片,对所返回列表的更改都将会反映在原始列表中</span></span><br><span class="line">al.subList();</span><br><span class="line">al.isEmpty();</span><br><span class="line">al.contains(); <span class="comment">//是否包含指定元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转数组</span></span><br><span class="line">Object[] ob = al.toArray();        <span class="comment">//Object 类型元素在for循环时可强制转换其他类型</span></span><br><span class="line">al.toArray(T[] a); <span class="comment">// a - 要存储列表元素的数组</span></span><br></pre></td></tr></table></figure>
<p>Example：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*##########################################################*/</span></span><br><span class="line"></span><br><span class="line">ArrayList al = <span class="keyword">new</span> ArrayList();</span><br><span class="line">al.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">al.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">Object[] s = al.toArray();</span><br><span class="line"></span><br><span class="line">String[] a = <span class="keyword">new</span> String[<span class="number">2</span>];</span><br><span class="line">al.toArray(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Object o: al)&#123;</span><br><span class="line">  System.out.println((String)o);    <span class="comment">// 强制转换为String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*##########################################################*/</span></span><br><span class="line">ArrayList&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  apples.add(<span class="keyword">new</span> Apple(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Apple a:apples)&#123;</span><br><span class="line">  a.showInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Apple[] apples1 = apples.toArray(Apple[]::<span class="keyword">new</span>); <span class="comment">//必须加范型才可使用， 转换为Apple数组</span></span><br></pre></td></tr></table></figure>
<p><strong>Arrays.asList() 方法接受一个数组或是逗号分隔的元素列表(使用可变参数)， 并将其转换为 List 对象。Collections.addAll() 方法接受一个 Collection 对象，以 及一个数组或是一个逗号分隔的列表，将其中元素添加到 Collection 中。下边的示例展示了这两个方法，以及更通用的 addAll() 方法，所有 Collection 类型都包含该方 法:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Arrays.asList(); 转化为 List 对象，继承于 Collection </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Collection 的构造器可以接受另一个 Collection，用它来将自身初始化。因此，可以 使用 Arrays.asList() 来为这个构造器产生输入。</span></span><br><span class="line"><span class="comment">但是，Collections.addAll() 运行得更快，而且很容易构建一个不包含元素的 Collection ，然后调用 Collections.addAll()，因此这是首选方式。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">Collection&lt;Integer&gt; collection = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line"><span class="comment">// Integer 数组</span></span><br><span class="line">Integer[] moreInts = &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(moreInts);</span><br><span class="line">list.set(<span class="number">0</span>,-<span class="number">10</span>);</span><br><span class="line">collection.addAll(list);</span><br><span class="line">System.out.println(collection.toString());</span><br></pre></td></tr></table></figure>
<hr />
<p>####Stack 栈</p>
<p>堆栈是 “后进先出”(LIFO)集合。它有时被称为叠加栈(pushdown stack)，因为 最后 “压入”(push)栈的元素，第一个被 “弹出”(pop)</p>
<p>Java 1.0 中附带了一个 Stack 类，结果设计得很糟糕，Java 6 添加了 ArrayDeque ，其中包含直接实现堆栈功能的方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Deque&lt;String&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String s : <span class="string">&quot;My dog has fleas&quot;</span>.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">        stack.push(s); </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">        System.out.print(stack.pop() + <span class="string">&quot; &quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">fleas has dog My</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<hr />
<h4 id="set-集合">Set 集合</h4>
<p>Set 不保存重复的元素。Set 最常见的用途是测试归属性，可以很轻松地询问某个对象是否 在一个 Set 中。因此，查找通常是 Set 最重要的操作，因此通常会选择 HashSet 实 现，该实现针对快速查找进行了优化。</p>
<p>Set 具有与 Collection 相同的接口，因此没有任何额外的功能，不像前面两种不同类型的 List 那样。实际上，Set 就是一个 Collection ，只是行为不同</p>
<p>由 HashSet 维护的顺序与 TreeSet 或 LinkedHashSet 不同，因为它们的实现具有不同的元素存储方式。TreeSet 将元素存储在红-黑树数据结构中，而 HashSet 使用散列函数。LinkedHashSet 因为查询速度的原因也使用了散列，但是使用了链表来维护元素的插入顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>); </span><br><span class="line">Set&lt;Integer&gt; intset = <span class="keyword">new</span> HashSet&lt;&gt;(); </span><br><span class="line"><span class="comment">//在 0 到 29 之间的 10000 个随机整数被添加到 Set 中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        intset.add(rand.nextInt(<span class="number">30</span>)); </span><br><span class="line">System.out.println(intset);</span><br></pre></td></tr></table></figure>
<h4 id="map-映射">Map 映射</h4>
<p>保存键值对 Key ， Value、Key不可重复</p>
<p>衍生类：HashMap、TreeMap、LinkedMap</p>
<p>HashMap &amp;&amp; HashTable</p>
<blockquote>
<p>相同点：</p>
<p>实现原理相同，功能相同，底层都是哈希表结构，查询速度快，在很多情况下可以互用</p>
</blockquote>
<blockquote>
<p>不同点：</p>
<p>1、Hashtable是早期提供的接口，HashMap是新版JDK提供的接口。</p>
<p>2、Hashtable继承Dictionary类，HashMap实现Map接口。</p>
<p>3、Hashtable线程安全，HashMap线程非安全。</p>
<p>4、Hashtable不允许null值，HashMap允许null值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Integer value = map.get(key);</span><br><span class="line"><span class="comment">// 不存在的key，返回 null</span></span><br><span class="line">map.put(key,value==<span class="keyword">null</span>? <span class="number">1</span> : value+<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 遍历不支持 foreach</span></span><br><span class="line">map.keySet() <span class="comment">//返回 Set 类型</span></span><br><span class="line">map.values() <span class="comment">//返回 Collection 类型</span></span><br><span class="line"><span class="keyword">for</span>(Object key:map.keySet())&#123;</span><br><span class="line">      System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="queue-队列">Queue 队列</h4>
<h3 id="范型">范型</h3>
<p>利用范型自我实现ArrayList</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuyang.Tools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">        capacity = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyArrayList</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">capacityExpend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= capacity) &#123;</span><br><span class="line">            capacity = capacity * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            Object[] objects = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">            <span class="keyword">if</span> (size + <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                System.arraycopy(data, <span class="number">0</span>, objects, <span class="number">0</span>, size);</span><br><span class="line">            data = objects;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        capacityExpend();</span><br><span class="line">        data[size] = t;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; size)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> (T) data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o :</span><br><span class="line">                data) &#123;</span><br><span class="line">            s.append(o).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="iterators-迭代器">Iterators 迭代器</h3>
<p>目标：不重写代码就可以应用于不 同类型的集合</p>
<p>迭代器是一个对象，它在一个序列中移动并选择该序列中的每个对象，而客户端程序员不知道或不关心该序列的底 层结构。</p>
<p>迭代器通常被称为轻量级对象(lightweight object):创建它的代价小。 可以看到一些对迭代器有些奇怪的约束。例如，Java 的 Iterator 只能单向移动。这个 Iterator 只能用来:</p>
<ol type="1">
<li>使用 iterator() 方法要求集合返回一个 Iterator。Iterator 将准备好返回序列中的第一个元素。</li>
<li>使用next()方法获得序列中的下一个元素。</li>
<li>使用hasNext()方法检查序列中是否还有元素。</li>
<li>使用remove()方法将迭代器最近返回的那个元素删除。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化列表，元素为Apple</span></span><br><span class="line">List&lt;Apple&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">      list.add(<span class="keyword">new</span> Apple(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterator 迭代， 迭代器初始化一次，使用一次</span></span><br><span class="line">Iterator&lt;Apple&gt; it = list.iterator();        </span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">      Apple apple = it.next();</span><br><span class="line">      apple.showInfo();</span><br><span class="line">&#125;</span><br><span class="line">it.remove();        <span class="comment">//删除由 next() 生成的最后一个元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;size: &quot;</span>+list.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">Apple ID: 0</span></span><br><span class="line"><span class="comment">Apple ID: 1</span></span><br><span class="line"><span class="comment">Apple ID: 2</span></span><br><span class="line"><span class="comment">Apple ID: 3</span></span><br><span class="line"><span class="comment">Apple ID: 4</span></span><br><span class="line"><span class="comment">Apple ID: 5</span></span><br><span class="line"><span class="comment">Apple ID: 6</span></span><br><span class="line"><span class="comment">Apple ID: 7</span></span><br><span class="line"><span class="comment">Apple ID: 8</span></span><br><span class="line"><span class="comment">Apple ID: 9</span></span><br><span class="line"><span class="comment">size: 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>Iterator 的真正威力:能够将遍历序列的操作与该序列的底层结构分离。出于这个原因，我们有 时会说:迭代器统一了对集合的访问方式。</p>
<h4 id="listiterator">ListIterator</h4>
<ul>
<li>ListIterator 是一个更强大的 Iterator 子类型，它只能由各种 List 类生成。</li>
<li>It- erator 只能向前移动，而 ListIterator 可以双向移动。</li>
<li>还可以生成相对于迭代器在列表中指向的当前位置的后一个和前一个元素的索引，并且可以使用 set() 方法替换它访问过的最近一个元素。</li>
<li>通过调用 <strong>listIterator</strong>() 方法来生成指向 List 开头 处的 <strong>ListIterator</strong> ，还可以通过调用 <strong>listIterator(n)</strong> 创建一个一开始就指向列表索 引号为 n 的元素处的 <strong>ListIterator</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListIterator&lt;Apple&gt; it = list.listIterator();</span><br><span class="line"><span class="comment">//输出 toString，nextIndex，previousIndex</span></span><br><span class="line"><span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">  System.out.println(it.next()+</span><br><span class="line">                     <span class="string">&quot;,&quot;</span>+it.nextIndex()+</span><br><span class="line">                     <span class="string">&quot;,&quot;</span>+it.previousIndex());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (it.hasPrevious())&#123;</span><br><span class="line">  System.out.println(it.previous().toString());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">// 从 3 开始替换list中的元素</span></span><br><span class="line">it = list.listIterator(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">  Apple apple = it.next();</span><br><span class="line">  it.set(<span class="keyword">new</span> Apple(apple.getId()+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Apple ID: 0,1,0</span></span><br><span class="line"><span class="comment">Apple ID: 1,2,1</span></span><br><span class="line"><span class="comment">Apple ID: 2,3,2</span></span><br><span class="line"><span class="comment">Apple ID: 3,4,3</span></span><br><span class="line"><span class="comment">Apple ID: 4,5,4</span></span><br><span class="line"><span class="comment">Apple ID: 5,6,5</span></span><br><span class="line"><span class="comment">Apple ID: 6,7,6</span></span><br><span class="line"><span class="comment">Apple ID: 7,8,7</span></span><br><span class="line"><span class="comment">Apple ID: 8,9,8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Apple ID: 8</span></span><br><span class="line"><span class="comment">Apple ID: 7</span></span><br><span class="line"><span class="comment">Apple ID: 6</span></span><br><span class="line"><span class="comment">Apple ID: 5</span></span><br><span class="line"><span class="comment">Apple ID: 4</span></span><br><span class="line"><span class="comment">Apple ID: 3</span></span><br><span class="line"><span class="comment">Apple ID: 2</span></span><br><span class="line"><span class="comment">Apple ID: 1</span></span><br><span class="line"><span class="comment">Apple ID: 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[Apple ID: 0, Apple ID: 1, Apple ID: 2, Apple ID: 4, Apple ID: 5, Apple ID: 6, Apple ID: 7, Apple ID: 8, Apple ID: 9]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="异常处理">异常处理</h2>
<p><code>try&#123;&#125;catch&#123;&#125;</code> 语句</p>
<p>Java 中所有异常类继承自 Java.lang.Exception</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(IndexOutOfBoundsException e)&#123;</span><br><span class="line">      e.printStackTrace();    <span class="comment">//打印错误信息，但不终止程序</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ClassCastException e)&#123;</span><br><span class="line">      <span class="comment">// 强制类型转换错误</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者在方法中抛出错误</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拆箱-装箱">拆箱 &amp;&amp; 装箱</h2>
<p>装箱：<code>Integer i = 10;</code> 自动包装机制把基本类型 10 封装为Integer类型</p>
<p>拆箱：<code>i = i + 100</code> Integer 拆箱转为 基本类型 int，再加法运算.</p>
<h2 id="文件操作">文件操作</h2>
<p>文件： 文本文件、非文本文件（二进制文件）</p>
<p>文件操作对象包括文件和文件夹（目录）</p>
<p>Java的文件操作通过File对象实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//File 对象构造方法 </span></span><br><span class="line">File file = <span class="keyword">new</span> File(File parent, String child);<span class="comment">//从父抽象路径名和子路径名(文件名)字符串创建新的 File实例</span></span><br><span class="line">File file = <span class="keyword">new</span> File(String pathname);<span class="comment">//将给定的路径名字符串转换为抽象路径名来创建新的 File实例</span></span><br><span class="line">File file = <span class="keyword">new</span> File(String parent, String child)<span class="comment">//从父路径名字符串和子路径名字符串创建新的 File实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">canExecute</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//测试应用程序是否可以执行此抽象路径名表示的文件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">canRead</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//测试应用程序是否可以读取此抽象路径名表示的文件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">canWrite</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//测试应用程序是否可以修改此抽象路径名表示的文件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">compareTo</span><span class="params">(File pathname)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//按字典顺序比较两个抽象路径名。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">createNewFile</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//当且仅当具有此名称的文件尚不存在时，以原子方式创建由此抽象路径名命名的新空文件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> File    <span class="title">createTempFile</span><span class="params">(String prefix, String suffix)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//在默认临时文件目录中创建一个空文件，使用给定的前缀和后缀生成其名称。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> File    <span class="title">createTempFile</span><span class="params">(String prefix, String suffix, File directory)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">delete</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//删除此抽象路径名表示的文件或目录。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">equals</span><span class="params">(Object obj)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//测试此抽象路径名与给定对象的相等性。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">exists</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//测试此抽象路径名表示的文件或目录是否存在。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//get类</span></span></span><br><span class="line"><span class="function">File    <span class="title">getAbsoluteFile</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回此抽象路径名的绝对形式。</span></span></span><br><span class="line"><span class="function">String    <span class="title">getAbsolutePath</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回此抽象路径名的绝对路径名字符串。</span></span></span><br><span class="line"><span class="function">File    <span class="title">getCanonicalFile</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回此抽象路径名的规范形式。</span></span></span><br><span class="line"><span class="function">String    <span class="title">getCanonicalPath</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回此抽象路径名的规范路径名字符串。</span></span></span><br><span class="line"><span class="function">String    <span class="title">getName</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回此抽象路径名表示的文件或目录的名称。</span></span></span><br><span class="line"><span class="function">String    <span class="title">getParent</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回此抽象路径名父项的路径名字符串，如果此路径名未指定父目录，则返回 null 。</span></span></span><br><span class="line"><span class="function">File    <span class="title">getParentFile</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回此抽象路径名父项的抽象路径名，如果此路径名未指定父目录，则返回 null 。</span></span></span><br><span class="line"><span class="function">String    <span class="title">getPath</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//将此抽象路径名转换为路径名字符串，即返回定义的路径名字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">hashCode</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//计算此抽象路径名的哈希码。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">isAbsolute</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//测试此抽象路径名是否为绝对路径。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">isDirectory</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//测试此抽象路径名表示的文件是否为目录。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">isFile</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//测试此抽象路径名表示的文件是否为普通文件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">isHidden</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//测试此抽象路径名指定的文件是否为隐藏文件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span>    <span class="title">lastModified</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回上次修改此抽象路径名表示的文件的时间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span>    <span class="title">length</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回此抽象路径名表示的文件的长度。</span></span></span><br><span class="line"><span class="function">String[]    <span class="title">list</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回一个字符串数组，用于命名此抽象路径名表示的目录中的文件和目录。</span></span></span><br><span class="line"><span class="function">String[]    <span class="title">list</span><span class="params">(FilenameFilter filter)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回一个字符串数组，用于命名由此抽象路径名表示的目录中的文件和目录，以满足指定的过滤器。</span></span></span><br><span class="line"><span class="function">File[]    <span class="title">listFiles</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回一个抽象路径名数组，表示此抽象路径名表示的目录中的文件。</span></span></span><br><span class="line"><span class="function">File[]    <span class="title">listFiles</span><span class="params">(FileFilter filter)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回一个抽象路径名数组，表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</span></span></span><br><span class="line"><span class="function">File[]    <span class="title">listFiles</span><span class="params">(FilenameFilter filter)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回一个抽象路径名数组，表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> File[]    <span class="title">listRoots</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//列出可用的文件系统根目录。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">mkdir</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//创建此抽象路径名指定的目录。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">mkdirs</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//创建此抽象路径名指定的目录，包括任何必需但不存在的父目录。多级创建</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    renameTo​<span class="params">(File dest)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//重命名此抽象路径名表示的文件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    setExecutable​<span class="params">(<span class="keyword">boolean</span> executable)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//一种方便的方法，用于设置此抽象路径名的所有者执行权限。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    setExecutable​<span class="params">(<span class="keyword">boolean</span> executable, <span class="keyword">boolean</span> ownerOnly)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//设置此抽象路径名的所有者或每个人的执行权限。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    setLastModified​<span class="params">(<span class="keyword">long</span> time)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//设置此抽象路径名指定的文件或目录的上次修改时间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    setReadable​<span class="params">(<span class="keyword">boolean</span> readable)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//一种方便的方法，用于设置此抽象路径名的所有者读取权限。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    setReadable​<span class="params">(<span class="keyword">boolean</span> readable, <span class="keyword">boolean</span> ownerOnly)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//设置此抽象路径名的所有者或每个人的读取权限。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    <span class="title">setReadOnly</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//标记此抽象路径名指定的文件或目录，以便仅允许读取操作。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    setWritable​<span class="params">(<span class="keyword">boolean</span> writable)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//一种方便的方法，用于设置此抽象路径名的所有者写入权限。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>    setWritable​<span class="params">(<span class="keyword">boolean</span> writable, <span class="keyword">boolean</span> ownerOnly)</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//设置此抽象路径名的所有者或每个人的写入权限。</span></span></span><br><span class="line"><span class="function">Path    <span class="title">toPath</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回从此抽象路径构造的java.nio.file.Path对象。</span></span></span><br><span class="line"><span class="function">String    <span class="title">toString</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//返回此抽象路径名的路径名字符串。</span></span></span><br><span class="line"><span class="function">URI    <span class="title">toURI</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"><span class="comment">//构造一个表示此抽象路径名的 file: URI。</span></span></span><br></pre></td></tr></table></figure>
<p>Tip:</p>
<blockquote>
<p>可以通过renameTo（）方法实现文件和文件夹的剪切操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 文件拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path 文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetPath 目标文件路径</span></span><br><span class="line"><span class="comment"> */</span>        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileCopy</span><span class="params">(String path, String targetPath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">         FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(targetPath);) &#123;</span><br><span class="line">          <span class="keyword">int</span> sigh = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//数组缓冲区</span></span><br><span class="line">          <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">          <span class="keyword">while</span> ((sigh = fileInputStream.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">           outputStream.write(b, <span class="number">0</span>, sigh);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 文件移动</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path 文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetPath 目标文件路径</span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">fileMove</span><span class="params">(String path, String targetPath)</span> </span>&#123;</span><br><span class="line">    String[] s1 = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    String[] s2 = targetPath.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    file = <span class="keyword">new</span> File(path);</span><br><span class="line">    <span class="keyword">if</span> (s1[s1.length - <span class="number">1</span>].equals(s2[s1.length - <span class="number">1</span>])) &#123;</span><br><span class="line">        String name = file.getPath();</span><br><span class="line">        File file1 = <span class="keyword">new</span> File(name + <span class="string">&quot;`&quot;</span>);</span><br><span class="line">        file.renameTo(file1);</span><br><span class="line">        (<span class="keyword">new</span> File(name)).mkdirs();</span><br><span class="line">        <span class="keyword">return</span> file1.renameTo(<span class="keyword">new</span> File(targetPath));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> file.renameTo(<span class="keyword">new</span> File(targetPath));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归删除文件  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path 待删除文件目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回bool值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">fileDelete</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(path);</span><br><span class="line">    <span class="keyword">if</span> (delete(file))</span><br><span class="line">      <span class="keyword">return</span> file.delete();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (files == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> file.delete();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">      <span class="keyword">if</span> (f.isFile())</span><br><span class="line">        result = f.delete();</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        result = delete(f) &amp;&amp; f.delete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###数据流（IO流）基类</p>
<ul>
<li><p>字节流 可以读取任意类型数据</p>
<p>​ 抽象基类： InputStream、OutputStream</p></li>
<li><p>字符流 只可以读取文本数据</p>
<p>​ 抽象基类： Reader、Writer</p></li>
</ul>
<p><strong>字节流和字符流的区别</strong>： <strong>（1）读写单位不同</strong>：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。 <strong>（2）处理对象不同</strong>：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。 <strong>（3）缓冲区</strong>：字节流在操作的时候本身是不会用到缓冲区的，是文件本身的直接操作的；而字符流在操作的时候下后是会用到缓冲区的，是通过缓冲区来操作文件。</p>
<p>结论：优先选用字节流。首先因为硬盘上的所有文件都是以字节的形式进行传输或者保存的，包括图片等内容。但是字符只是在内存中才会形成的，所以在开发中，字节流使用广泛。</p>
<h3 id="io字节流">IO字节流</h3>
<p>IO流操作结束必须调用 <code>close()</code> 方法</p>
<h4 id="fileoutputstream">FileOutputStream</h4>
<p>文件输出流是用于将数据写入<code>File</code>或<code>FileDescriptor</code>的输出流。 文件是否可用或是否可以创建取决于底层平台。 特别是某些平台允许一次仅打开一个文件以供写入<code>FileOutputStream</code> （或其他文件写入对象）。 在这种情况下，如果涉及的文件已经打开，则此类中的构造函数将失败。</p>
<p><code>FileOutputStream</code>用于写入诸如图像数据的原始字节流。 要编写字符流，请考虑使用<code>FileWriter</code> 。</p>
<p><strong>Note:</strong></p>
<p>要释放此流使用的资源，应直接或通过通过（Java7 以后）<strong>try-with-resources</strong>调用<a href="chm://33031dcc470bf81a5f5e8595b0905ec1/java.base/java/io/FileOutputStream.html#close()"><code>close()</code></a> 。 子类负责清理子类获取的资源。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream​(File file)    </span><br><span class="line">  <span class="comment">//创建文件输出流以写入由指定的 File对象表示的文件。</span></span><br><span class="line">FileOutputStream​(FileDescriptor fdObj)    </span><br><span class="line">    <span class="comment">//创建要写入指定文件描述符的文件输出流，该文件描述符表示与文件系统中实际文件的现有连接。</span></span><br><span class="line">FileOutputStream​(File file, <span class="keyword">boolean</span> append)    </span><br><span class="line">    <span class="comment">//创建文件输出流以写入由指定的 File对象表示的文件。</span></span><br><span class="line">FileOutputStream​(String name)    </span><br><span class="line">    <span class="comment">//创建文件输出流以写入具有指定名称的文件。</span></span><br><span class="line">FileOutputStream​(String name, <span class="keyword">boolean</span> append)    </span><br><span class="line">    <span class="comment">//创建文件输出流以写入具有指定名称的文件。append 如果是 true ，那么字节将被写入文件的末尾而不是开头</span></span><br></pre></td></tr></table></figure>
<p><strong>实例方法</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>close()</code></td>
<td style="text-align: left;">关闭此文件输出流并释放与此流关联的所有系统资源。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FileChannel</code></td>
<td style="text-align: left;"><code>getChannel()</code></td>
<td style="text-align: left;">返回与此文件输出流关联的唯一<a href="chm://33031dcc470bf81a5f5e8595b0905ec1/java.base/java/nio/channels/FileChannel.html"><code>FileChannel</code></a>对象。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FileDescriptor</code></td>
<td style="text-align: left;"><code>getFD()</code></td>
<td style="text-align: left;">返回与此流关联的文件描述符。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>write(byte[] b)</code></td>
<td style="text-align: left;">将指定字节数组中的 <code>b.length</code>字节写入此文件输出流。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>write(byte[] b, int off, int len)</code></td>
<td style="text-align: left;">将从偏移量 <code>off</code>开始的指定字节数组中的 <code>len</code>字节写入此文件输出流。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>write(int b)</code></td>
<td style="text-align: left;">将指定的字节写入此文件输出流。</td>
</tr>
</tbody>
</table>
<h4 id="fileinputstream">FileInputStream</h4>
<p><strong>实例方法</strong></p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 29%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>available()</code></td>
<td>返回可以从此输入流中读取（或跳过）的剩余字节数的估计值，而不会被下一次调用此输入流的方法阻塞。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>close()</code></td>
<td>关闭此文件输入流并释放与该流关联的所有系统资源。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FileChannel</code></td>
<td style="text-align: left;"><code>getChannel()</code></td>
<td>返回与此文件输入流关联的唯一[<code>FileChannel</code>]对象。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FileDescriptor</code></td>
<td style="text-align: left;"><code>getFD()</code></td>
<td>返回 <code>FileDescriptor</code>对象，该对象表示与此<code>FileInputStream</code>正在使用的文件系统中的实际文件的连接。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>read()</code></td>
<td>从此输入流中读取一个字节的数据，末尾返回-1</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>read(byte[] b)</code></td>
<td>从此输入流中读取最多 <code>b.length</code>字节的数据到字节数组b中，返回每次读取长度</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>read(byte[] b, int off, int len)</code></td>
<td>从此输入流 <code>len</code>最多 <code>len</code>字节的数据读入一个字节数组。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>long</code></td>
<td style="text-align: left;"><code>skip(long n)</code></td>
<td>跳过并从输入流中丢弃 <code>n</code>字节的数据。</td>
</tr>
</tbody>
</table>
<p>字节数组使用</p>
<p>数组大小不可过大，否则会导致内存不足，读取到数组时按数组大小一次读取，合适的数组大小会提升性能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//read</span></span><br><span class="line"><span class="keyword">int</span> input = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> ((input = fileInputStream.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">  System.out.println(input);</span><br><span class="line">  ArrayTool.print(b, <span class="number">0</span>, input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="string">&quot;中国🇨🇳我爱你&quot;</span>.getBytes();</span><br><span class="line">fileOutputStream.write(b);</span><br></pre></td></tr></table></figure>
<p><strong>关闭方法</strong></p>
<blockquote>
<p>JAVA的流不单在内存中分配了空间，也在操作系统占有了资源，比如占用的端口,文件句柄,网络操作数据库应用等。java的垃圾回收机制GC是能从内存中回收不使用的对象，但对操作系统分配的资源是无法干预的，所以就要调用close()方法来通知系统来释放这个资源。</p>
</blockquote>
<p>Java7 以前</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream is = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(is != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      is.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException)&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java7 以后，使用<code>try-with-resources</code>,将需要关闭的流对象放在try的()中创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(InputStream fileInputStream = <span class="keyword">new</span> FileInputStream(text)) &#123;</span><br><span class="line">  <span class="keyword">int</span> input;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    input = fileInputStream.read();    <span class="comment">//指针到达末尾返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (input == -<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>)input);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bufferinputstream">BufferInputStream</h4>
<p><code>BufferedInputStream</code>向另一个输入流添加功能 - 即缓冲输入并支持<code>mark</code>和<code>reset</code>方法的功能。</p>
<p>创建<code>BufferedInputStrea</code>会创建内部缓冲区阵列。 当读取或跳过来自流的字节时，会根据需要从包含的输入流中一次多个字节向内部缓冲区重新填充。 <code>mark</code>操作会记住输入流中的一个点，并且<code>reset</code>操作会导致在从包含的输入流中获取新字节之前重新读取自最近的<code>mark</code>操作以来读取的所有字节。</p>
<p><strong>buffer 性能较高，使用字节数组的性能略低但差别不大。</strong></p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 23%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>available()</code></td>
<td style="text-align: left;">返回可以从此输入流中读取（或跳过）的字节数的估计值，而不会被下一次调用此输入流的方法阻塞。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>close()</code></td>
<td style="text-align: left;">关闭此输入流并释放与该流关联的所有系统资源。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>mark(int readlimit)</code></td>
<td style="text-align: left;">标记此输入流中的当前位置，随后对<code>reset</code>方法的调用会在最后标记的位置重新定位此流，以便后续读取重新读取相同的字节。 readlimit<code>- 标记位置变为无效之前可读取的最大字节数限制 | |</code>boolean<code>|</code>markSupported()<code>| 测试此输入流是否支持</code>mark<code>和</code>reset<code>方法。                                                                         | |</code>int<code>|</code>read()<code>| 从输入流中读取下一个数据字节。                                                                                       | |</code>int<code>|</code>read(byte[] b, int off, int len)<code>| 从给定的偏移量开始，将此字节输入流中的字节读入指定的字节数组。                                                                       | |</code>void<code>|</code>reset()<code>| 将此流重新定位到上次在此输入流上调用</code>mark<code>方法时的位置                                                                        | |</code>long<code>|</code>skip(long n)<code>| 见的总承包</code>skip<code>的方法</code>InputStream` 。</td>
</tr>
</tbody>
</table>
<h4 id="bufferoutputstream-包装流">BufferOutputStream 包装流</h4>
<p>该类实现缓冲输出流。 通过设置这样的输出流，应用程序可以将字节写入基础输出流，而不必为写入的每个字节调用底层系统，节约性能。</p>
<p>对OutputStream类进行包装，内部设置缓冲区</p>
<p><strong>构造方法</strong></p>
<p>FileOutputStream 继承自 OutputStream，也可作为参数</p>
<table>
<colgroup>
<col style="width: 58%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">构造器</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>BufferedOutputStream(OutputStream out)</code></td>
<td style="text-align: left;">创建新的缓冲输出流以将数据写入指定的基础输出流。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>BufferedOutputStream(OutputStream out, int size)</code></td>
<td style="text-align: left;">创建新的缓冲输出流，以使用指定的缓冲区大小将数据写入指定的基础输出流。</td>
</tr>
</tbody>
</table>
<p><strong>实例方法</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>void</code></td>
<td style="text-align: left;"><code>flush()</code></td>
<td style="text-align: left;">刷新此缓冲的输出流。</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>void</code></td>
<td style="text-align: left;"><code>write(byte[] b, int off, int len)</code></td>
<td style="text-align: left;">将从偏移量 <code>off</code>开始的指定字节数组中的 <code>len</code>字节写入此缓冲输出流。</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>void</code></td>
<td style="text-align: left;"><code>write(int b)</code></td>
<td style="text-align: left;">将指定单个字节写入此缓冲区的输出流，减少对硬盘的io次数</td>
</tr>
</tbody>
</table>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> path 待删除文件目录</span></span><br><span class="line"><span class="comment">* <span class="doctag">@append</span> true 则写入文件的末尾而不是开头</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileWrite</span><span class="params">(String path, String string, <span class="keyword">boolean</span> append)</span></span>&#123;</span><br><span class="line">    file = <span class="keyword">new</span> File(path);</span><br><span class="line">    <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Can not be a directory&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>(BufferedOutputStream bufferedOutputStream =</span><br><span class="line">        <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(path, append))) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = string.getBytes();</span><br><span class="line">        bufferedOutputStream.write(b,<span class="number">0</span>,b.length);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="io字符流">IO字符流</h3>
<p>抽象基类： System.io.write、System.io.read</p>
<p>用于写入字符流的抽象类。 子类必须实现的唯一方法是write（char []，int，int），flush（）和close（）。 但是，大多数子类将覆盖此处定义的一些方法，以提供更高的效率，附加功能或两者兼而有之。</p>
<h4 id="outputstreamwriter">OutputStreamWriter</h4>
<p><strong>包装流</strong></p>
<p>从字符流到字节流的桥接器：使用指定的<code>charset</code>将写入其中的字符编码为字节。 它使用的字符集可以通过名称指定，也可以明确指定，或者可以接受平台的默认字符集。</p>
<p><strong>每次调用write（）方法都会导致在给定字符上调用编码转换器。 生成的字节在写入底层输出流之前在缓冲区中累积。</strong></p>
<p><strong>注意： 传递给write（）方法的单个字符不会被缓冲。</strong></p>
<p>为了获得最高效率，考虑在BufferedWriter中包装OutputStreamWriter，以避免频繁的转换器调用。 例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Writer out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out)); </span><br></pre></td></tr></table></figure>
<p><strong>构造方法</strong></p>
<table>
<colgroup>
<col style="width: 61%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">构造器</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>OutputStreamWriter(OutputStream out)</code></td>
<td style="text-align: left;">创建使用默认字符编码的OutputStreamWriter。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>OutputStreamWriter(OutputStream out, String charsetName)</code></td>
<td style="text-align: left;">创建使用指定charset的OutputStreamWriter。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>OutputStreamWriter(OutputStream out, Charset cs)</code></td>
<td style="text-align: left;">创建使用给定charset的OutputStreamWriter。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>OutputStreamWriter(OutputStream out, CharsetEncoder enc)</code></td>
<td style="text-align: left;">创建使用给定charset编码器的OutputStreamWriter。</td>
</tr>
</tbody>
</table>
<p><strong>实例方法</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>flush()</code></td>
<td style="text-align: left;">刷新流。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;"><code>getEncoding()</code></td>
<td style="text-align: left;">返回此流使用的字符编码的名称。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>write(char[] cbuf, int off, int len)</code></td>
<td style="text-align: left;">写一个字符数组的一部分。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>write(int c)</code></td>
<td style="text-align: left;">写一个字符。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>write(String str, int off, int len)</code></td>
<td style="text-align: left;">写一个字符串的一部分。</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法写</span></span><br><span class="line"><span class="comment">//@param charset 编码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String path, <span class="keyword">char</span>[] chars,String charset, <span class="keyword">int</span> off, <span class="keyword">int</span> length, <span class="keyword">boolean</span> append)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (OutputStreamWriter outputStreamWriter =</span><br><span class="line">         <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(path, append),charset)) &#123;</span><br><span class="line">          outputStreamWriter.write(chars, off, length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="inputstreamreader">InputStreamReader</h4>
<p>InputStreamReader是从字节流到字符流的桥接器：它使用指定的[<code>charset</code>]读取字节并将其解码为字符。 它使用的字符集可以通过名称指定，也可以明确指定，或者可以接受平台的默认字符集。</p>
<p>为了获得最高效率，在BufferedReader中包装InputStreamReader。 例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)); </span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 59%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">构造器</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>InputStreamReader(InputStream in)</code></td>
<td style="text-align: left;">创建一个使用默认字符集的InputStreamReader。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>InputStreamReader(InputStream in, String charsetName)</code></td>
<td style="text-align: left;">创建一个使用指定charset的InputStreamReader。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>InputStreamReader(InputStream in, Charset cs)</code></td>
<td style="text-align: left;">创建一个使用给定charset的InputStreamReader。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>InputStreamReader(InputStream in, CharsetDecoder dec)</code></td>
<td style="text-align: left;">创建一个使用给定charset解码器的InputStreamReader。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;"><code>getEncoding()</code></td>
<td style="text-align: left;">返回此流使用的字符编码的名称。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>read()</code></td>
<td style="text-align: left;">读一个字符。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>read(char[] cbuf, int offset, int length)</code></td>
<td style="text-align: left;">将字符读入数组的一部分。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>ready()</code></td>
<td style="text-align: left;">判断此流是否可以读取。</td>
</tr>
</tbody>
</table>
<p>字符读取**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">read</span><span class="params">(String path, String charset)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStreamReader inputStreamReader =</span><br><span class="line">         <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(path),charset))&#123;</span><br><span class="line">      <span class="keyword">if</span> (!inputStreamReader.ready())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">      StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">int</span> sigh;</span><br><span class="line">      <span class="keyword">while</span> ((sigh = inputStreamReader.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sigh;i++)&#123;</span><br><span class="line">          stringBuilder.append(chars[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="filewriter-filereader">FileWriter &amp;&amp; FileReader</h4>
<ul>
<li><p><strong>java.lang.Object</strong></p></li>
<li><ul>
<li><p><strong>java.io.Writer</strong></p>
<ul>
<li><ul>
<li><strong>java.io.OutputStreamWriter</strong>
<ul>
<li><ul>
<li><strong>java.io.FileWriter</strong></li>
</ul></li>
</ul></li>
</ul></li>
<li><ul>
<li><p><strong>java.io.InoutStreamReader</strong></p>
<ul>
<li><ul>
<li><strong>Java.io.FileReader</strong></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p>与父类类似，封闭性更好，创建简单</p>
<p>调用时默认使用平台的<strong>charset</strong></p>
<p><strong>FileWriter</strong></p>
<table>
<colgroup>
<col style="width: 44%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">构造器</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>FileWriter(File file)</code></td>
<td style="text-align: left;">给 <code>File</code>写一个 <code>FileWriter</code> ，使用平台的 [default charset]</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FileWriter(FileDescriptor fd)</code></td>
<td style="text-align: left;">构造一个 <code>FileWriter</code>给出的文件描述符，使用该平台的 [default charset]</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FileWriter(File file, boolean append)</code></td>
<td style="text-align: left;">在给出要写入的 <code>FileWriter</code>下构造 <code>File</code> ，并使用平台的 [default charset构造] 一个布尔值，指示是否附加写入的数据。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FileWriter(File file, Charset charset)</code></td>
<td style="text-align: left;">构造一个<code>FileWriter</code>给予<code>File</code>编写和[charset]</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FileWriter(File file, Charset charset, boolean append)</code></td>
<td style="text-align: left;">构造<code>FileWriter</code>给出<code>File</code>写入， [charset] 和一个布尔值，指示是否附加写入的数据。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FileWriter(String fileName)</code></td>
<td style="text-align: left;">构造一个 <code>FileWriter</code>给出文件名，使用平台的 [default charset]</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FileWriter(String fileName, boolean append)</code></td>
<td style="text-align: left;">使用平台的 [default charset] 构造一个 <code>FileWriter</code>给定一个文件名和一个布尔值，指示是否附加写入的数据。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FileWriter(String fileName, Charset charset)</code></td>
<td style="text-align: left;">构造一个<code>FileWriter</code>给出文件名和[charset]。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FileWriter(String fileName, Charset charset, boolean append)</code></td>
<td style="text-align: left;">构造一个<code>FileWriter</code>给定一个文件名， [charset] 和一个布尔值，指示是否附加写入的数据。</td>
</tr>
</tbody>
</table>
<p><strong>FileReader</strong></p>
<table>
<colgroup>
<col style="width: 40%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">构造器</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>FileReader(File file)</code></td>
<td style="text-align: left;">使用平台 <code>FileReader</code> ，在 <code>File</code>读取时创建一个新的 FileReader。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FileReader(FileDescriptor fd)</code></td>
<td style="text-align: left;">使用平台 [default charset] 创建一个新的 <code>FileReader</code> ，给定 <code>FileDescriptor</code>进行读取。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FileReader(File file, Charset charset)</code></td>
<td style="text-align: left;">创建一个新的<code>FileReader</code> ，给出<code>File</code>读取和[charset]。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FileReader(String fileName)</code></td>
<td style="text-align: left;">使用平台 [default charset] 创建一个新的 <code>FileReader</code> ，给定要读取的文件的 [名称] 。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FileReader(String fileName, Charset charset)</code></td>
<td style="text-align: left;">给定要读取的文件的名称和<code>FileReader</code> ，创建一个新的[FileReader]</td>
</tr>
</tbody>
</table>
<h4 id="bufferedwriter-bufferedreader">BufferedWriter &amp;&amp; BufferedReader</h4>
<p><strong>BufferedWriter</strong></p>
<p>BufferedWriter将文本写入字符输出流，缓冲字符，以便有效地写入单个字符，数组和字符串。</p>
<p>可以指定缓冲区大小，或者可以接受默认大小。 对于大多数用途，默认值足够大。</p>
<p>提供了一个newLine（）方法，它使用平台自己的行分隔符概念，由系统属性<code>line.separator</code>定义。 并非所有平台都使用换行符（' n'）来终止行。 因此，调用此方法终止每个输出行比直接编写换行符更为可取。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">构造器</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>BufferedWriter(Writer out)</code></td>
<td style="text-align: left;">创建使用默认大小的输出缓冲区的缓冲字符输出流。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>BufferedWriter(Writer out, int sz)</code></td>
<td style="text-align: left;">创建一个使用给定大小的输出缓冲区的新缓冲字符输出流。</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedWriter bufferedWriter = </span><br><span class="line">          <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(path));</span><br><span class="line"></span><br><span class="line">BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(path);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>flush()</code></td>
<td style="text-align: left;">刷新流。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>newLine()</code></td>
<td style="text-align: left;">写一个行分隔符。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>write(char[] cbuf, int off, int len)</code></td>
<td style="text-align: left;">写一个字符数组的一部分。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>write(int c)</code></td>
<td style="text-align: left;">写一个字符。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>write(String s, int off, int len)</code></td>
<td style="text-align: left;">写一个字符串的一部分。</td>
</tr>
</tbody>
</table>
<p><strong>BufferedReader</strong></p>
<p>由Reader构成的每个读取请求都会导致相应的读取请求由基础字符或字节流构成。 因此，建议将BufferedReader包装在任何read（）操作可能代价高昂的Reader上，例如FileReaders和InputStreamReaders。 例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader in</span><br><span class="line"> = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;foo.in&quot;</span>)); </span><br></pre></td></tr></table></figure>
<p>将缓冲指定文件的输入。 如果没有缓冲，read（）或readLine（）的每次调用都可能导致从文件中读取字节，转换为字符，然后返回，这可能是非常低效的。</p>
<p>使用DataInputStreams进行文本输入的程序可以通过用适当的BufferedReader替换每个DataInputStream来进行本地化。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">构造器</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>BufferedReader(Reader in)</code></td>
<td style="text-align: left;">创建使用默认大小的输入缓冲区的缓冲字符输入流。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>BufferedReader(Reader in, int sz)</code></td>
<td style="text-align: left;">创建使用指定大小的输入缓冲区的缓冲字符输入流。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Stream</code></td>
<td style="text-align: left;"><code>lines()</code></td>
<td style="text-align: left;">返回 <code>Stream</code> ，其元素是从此 <code>BufferedReader</code>读取的行。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>mark(int readAheadLimit)</code></td>
<td style="text-align: left;">标记流中的当前位置。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>markSupported()</code></td>
<td style="text-align: left;">判断此流是否支持mark（）操作。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>read()</code></td>
<td style="text-align: left;">读一个字符。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>read(char[] cbuf, int off, int len)</code></td>
<td style="text-align: left;">将字符读入数组的一部分。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;"><code>readLine()</code></td>
<td style="text-align: left;">读一行文字。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>ready()</code></td>
<td style="text-align: left;">判断此流是否可以读取。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>reset()</code></td>
<td style="text-align: left;">将流重置为最新标记。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>long</code></td>
<td style="text-align: left;"><code>skip(long n)</code></td>
<td style="text-align: left;">跳过字符。</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="并发">并发</h2>
<p>• 并发是关于正确有效地控制对共享资源的访问。</p>
<p>• 并行是使用额外的资源来更快地产生结果。</p>
<p>将一个程序转换成多个独立运行的子任务，像这样的每个子任务都叫作一个“线程”（Thread）。编写程序时，可将每个线程都想象成独立运行，而且都有自己的专用CPU。一些基础机制实际会为我们自动分割CPU的时间。我们通常不必关心这些细节问题，所以多线程的代码编写是相当简便的。</p>
<p>Java 并发的核心机制是 Thread 类，在该语言最初版本中，Thread (线程)是由 程序员直接创建和管理的。随着语言的发展以及人们发现了更好的一些方法，中间层机制 - 特别是 Executor 框架 - 被添加进来，以消除自己管理线程时候的心理负担(及错误)</p>
<hr />
<h3 id="thread线程">Thread(线程)</h3>
<p>将任务关联到处理器的软件概念，当创建一个 Thread 时，JVM 将分配一大块内存到专为线程保留的特殊区域上，用于提供运行任务时所需 的一切，包括:</p>
<p>• 程序计数器，指明要执行的下一个 JVM 字节码指令。 • 用于支持 Java 代码执行的栈，包含有关此线程已到达当时执行位置所调用方法的信息。它也包含每个正在执行的方法的所有局部变量 (包括原语和堆对象的引用)。 每个线程的栈通常在 64K 到 1M 之间 。</p>
<p>• 第二个则用于 native code(本机方法代码)执行的栈</p>
<p>• thread-local variables (线程本地变量)的存储区域</p>
<p>• 用于控制线程的状态管理变量</p>
<hr />
<p><strong>Thread 类</strong></p>
<p>每个线程都有优先权。 具有较高优先级的线程优先于具有较低优先级的线程执行。 每个线程可能也可能不会被标记为守护进程。 当在某个线程中运行的代码创建一个新的<code>Thread</code>对象时，新线程的优先级最初设置为等于创建线程的优先级，并且当且仅当创建线程是守护进程时才是守护进程线程。</p>
<p>当Java虚拟机启动时，通常会有一个非守护进程线程（通常调用某个指定类的名为<code>main</code>的方法）。 Java虚拟机继续执行线程，直到发生以下任一情况：</p>
<ul>
<li>已调用类<code>Runtime</code>的<code>exit</code>方法，并且安全管理器已允许执行退出操作。</li>
<li>通过调用<code>run</code>方法返回或抛出超出<code>run</code>方法传播的异常，所有非守护程序线程的线程都已死亡。</li>
</ul>
<p><strong>有两种方法可以创建新的执行线程</strong>。</p>
<p>一种是将类声明为<code>Thread</code>的子类。 此子类应覆盖类<code>Thread</code>的<code>run</code>方法。 然后可以分配和启动子类的实例。 例如，计算大于规定值的素数的线程可以写成如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> minPrime;</span><br><span class="line">    PrimeThread(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">          <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">                 <span class="comment">//. . .</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下代码将创建一个线程并开始运行：</span></span><br><span class="line">PrimeThread p = <span class="keyword">new</span> PrimeThread(<span class="number">143</span>);</span><br><span class="line">p.start();</span><br></pre></td></tr></table></figure>
<p>另一种方法是声明一个实现<code>Runnable</code>接口的类。 该类然后实现<code>run</code>方法。 然后可以分配类的实例，在创建<code>Thread</code>时作为参数传递，然后启动。 此其他样式中的相同示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">PrimeRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> minPrime;</span><br><span class="line">     PrimeRun(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">       <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">       . . .</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下代码将创建一个线程并开始运行：</span></span><br><span class="line"></span><br><span class="line">PrimeRun p = <span class="keyword">new</span> PrimeRun(<span class="number">143</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(p).start();</span><br></pre></td></tr></table></figure>
<p>每个线程都有一个用于识别目的的名称。 多个线程可能具有相同的名称。 如果在创建线程时未指定名称，则会为其生成新名称</p>
<p>Example</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程用例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread: &quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">        ThreadTest.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MainThread: &quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">MainThread: 0</span></span><br><span class="line"><span class="comment">MyThread: 0</span></span><br><span class="line"><span class="comment">MainThread: 1</span></span><br><span class="line"><span class="comment">MyThread: 1</span></span><br><span class="line"><span class="comment">MyThread: 2</span></span><br><span class="line"><span class="comment">MainThread: 2</span></span><br><span class="line"><span class="comment">MyThread: 3</span></span><br><span class="line"><span class="comment">MainThread: 3</span></span><br><span class="line"><span class="comment">MyThread: 4</span></span><br><span class="line"><span class="comment">MainThread: 4</span></span><br><span class="line"><span class="comment">MyThread: 5</span></span><br><span class="line"><span class="comment">MainThread: 5</span></span><br><span class="line"><span class="comment">MyThread: 6</span></span><br><span class="line"><span class="comment">MainThread: 6</span></span><br><span class="line"><span class="comment">MyThread: 7</span></span><br><span class="line"><span class="comment">MainThread: 7</span></span><br><span class="line"><span class="comment">MyThread: 8</span></span><br><span class="line"><span class="comment">MainThread: 8</span></span><br><span class="line"><span class="comment">MyThread: 9</span></span><br><span class="line"><span class="comment">MainThread: 9</span></span><br><span class="line"><span class="comment">MyThread: 10</span></span><br><span class="line"><span class="comment">MainThread: 10</span></span><br><span class="line"><span class="comment">MyThread: 11</span></span><br><span class="line"><span class="comment">MainThread: 11</span></span><br><span class="line"><span class="comment">MyThread: 12</span></span><br><span class="line"><span class="comment">MainThread: 12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><img src="并发线程.png" style="zoom:60%;" /></p>
<ul>
<li><p>测试类为父线程，Mythread类创建子线程</p></li>
<li><p>子线程和父线程同时运行，因此结果具有随机性，打印出的数据顺序非线性。</p></li>
</ul>
<p><strong>字段</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">字段</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>static int</code></td>
<td style="text-align: left;"><code>MAX_PRIORITY</code></td>
<td style="text-align: left;">线程可以拥有的最大优先级 (10)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>static int</code></td>
<td style="text-align: left;"><code>MIN_PRIORITY</code></td>
<td style="text-align: left;">线程可以拥有的最低优先级。(1)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static int</code></td>
<td style="text-align: left;"><code>NORM_PRIORITY</code></td>
<td style="text-align: left;">分配给线程的默认优先级。(5)</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">构造器</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Thread()</code></td>
<td style="text-align: left;">分配新的 <code>Thread</code>对象。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Thread(Runnable target)</code></td>
<td style="text-align: left;">分配新的 <code>Thread</code>对象。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Thread(Runnable target, String name)</code></td>
<td style="text-align: left;">分配新的 <code>Thread</code>对象。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Thread(String name)</code></td>
<td style="text-align: left;">分配新的 <code>Thread</code>对象。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Thread(ThreadGroup group, Runnable target)</code></td>
<td style="text-align: left;">分配新的 <code>Thread</code>对象。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Thread(ThreadGroup group, Runnable target, String name)</code></td>
<td style="text-align: left;">分配新的 <code>Thread</code>对象，使其具有 <code>target</code>作为其运行对象，具有指定的 <code>name</code>作为其名称，并且属于 <code>group</code>引用的线程组。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Thread(ThreadGroup group, Runnable target, String name, long stackSize)</code></td>
<td style="text-align: left;">分配新的 <code>Thread</code>对象，使其具有 <code>target</code>作为其运行对象，具有指定的 <code>name</code>作为其名称，并且属于 <code>group</code>引用的线程组，并具有指定的 <em>堆栈大小</em> 。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Thread(ThreadGroup group, Runnable target, String name, long stackSize, boolean inheritThreadLocals)</code></td>
<td style="text-align: left;">分配新的<code>Thread</code>对象，使其具有<code>target</code>作为其运行对象，具有指定的<code>name</code>作为其名称，属于<code>group</code>引用的线程组，具有指定的<code>stackSize</code>，并且如果<code>inheritThreadLocals</code>是<code>true</code> ，则继承<a href="chm://33031dcc470bf81a5f5e8595b0905ec1/java.base/java/lang/InheritableThreadLocal.html">inheritable thread-local</a>变量的初始值。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Thread(ThreadGroup group, String name)</code></td>
<td style="text-align: left;">分配新的 <code>Thread</code>对象。</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 33%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>static int</code></td>
<td style="text-align: left;"><code>activeCount()</code></td>
<td style="text-align: left;">返回当前线程<a href="chm://33031dcc470bf81a5f5e8595b0905ec1/java.base/java/lang/ThreadGroup.html">thread group</a>及其子组中活动线程数的估计值。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>checkAccess()</code></td>
<td style="text-align: left;">确定当前运行的线程是否具有修改此线程的权限。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>protected Object</code></td>
<td style="text-align: left;"><code>clone()</code></td>
<td style="text-align: left;">抛出CloneNotSupportedException，因为无法有意义地克隆线程。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>static Thread</code></td>
<td style="text-align: left;"><code>currentThread()</code></td>
<td style="text-align: left;">返回对当前正在执行的线程对象的引用。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static void</code></td>
<td style="text-align: left;"><code>dumpStack()</code></td>
<td style="text-align: left;">将当前线程的堆栈跟踪打印到标准错误流。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>static int</code></td>
<td style="text-align: left;"><code>enumerate(Thread[] tarray)</code></td>
<td style="text-align: left;">将当前线程的线程组及其子组中的每个活动线程复制到指定的数组中。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static Map</code></td>
<td style="text-align: left;"><code>getAllStackTraces()</code></td>
<td style="text-align: left;">返回所有活动线程的堆栈跟踪映射。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ClassLoader</code></td>
<td style="text-align: left;"><code>getContextClassLoader()</code></td>
<td style="text-align: left;">返回此线程的上下文 <code>ClassLoader</code> 。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>long</code></td>
<td style="text-align: left;"><code>getId()</code></td>
<td style="text-align: left;">返回此Thread的标识符。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;"><code>getName()</code></td>
<td style="text-align: left;">返回此线程的名称。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>getPriority()</code></td>
<td style="text-align: left;">返回此线程的优先级。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>StackTraceElement[]</code></td>
<td style="text-align: left;"><code>getStackTrace()</code></td>
<td style="text-align: left;">返回表示此线程的堆栈转储的堆栈跟踪元素数组。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Thread.State</code></td>
<td style="text-align: left;"><code>getState()</code></td>
<td style="text-align: left;">返回此线程的状态。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ThreadGroup</code></td>
<td style="text-align: left;"><code>getThreadGroup()</code></td>
<td style="text-align: left;">返回此线程所属的线程组。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Thread. UncaughtExceptionHandler</code></td>
<td style="text-align: left;"><code>getUncaughtExceptionHandler()</code></td>
<td style="text-align: left;">返回此线程由于未捕获的异常而突然终止时调用的处理程序。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>static boolean</code></td>
<td style="text-align: left;"><code>holdsLock(Object obj)</code></td>
<td style="text-align: left;">当且仅当当前线程在指定对象上保存监视器锁时，返回 <code>true</code> 。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>interrupt()</code></td>
<td style="text-align: left;">中断此线程。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>static boolean</code></td>
<td style="text-align: left;"><code>interrupted()</code></td>
<td style="text-align: left;">测试当前线程是否已被中断。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isAlive()</code></td>
<td style="text-align: left;">测试此线程是否存活。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isDaemon()</code></td>
<td style="text-align: left;">测试此线程是否为守护程序线程。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isInterrupted()</code></td>
<td style="text-align: left;">测试此线程是否已被中断。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>join()</code></td>
<td style="text-align: left;">等待这个线程死亡。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>join(long millis)</code></td>
<td style="text-align: left;">此线程最多等待 <code>millis</code>毫秒。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>join(long millis, int nanos)</code></td>
<td style="text-align: left;">此线程最多等待 <code>millis</code>毫秒加上 <code>nanos</code>纳秒。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static void</code></td>
<td style="text-align: left;"><code>onSpinWait()</code></td>
<td style="text-align: left;">表示调用者暂时无法进展，直到其他活动发生一个或多个操作为止。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>run()</code></td>
<td style="text-align: left;">如果此线程是使用单独的<code>Runnable</code>运行对象构造的，则调用该<code>Runnable</code>对象的<code>run</code>方法; 否则，此方法不执行任何操作并返回。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setContextClassLoader(   ClassLoader cl)</code></td>
<td style="text-align: left;">为此Thread设置上下文ClassLoader。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setDaemon(boolean on)</code></td>
<td style="text-align: left;">将此线程标记为 <a href="chm://33031dcc470bf81a5f5e8595b0905ec1/java.base/java/lang/Thread.html#isDaemon()">daemon</a>线程或用户线程。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static void</code></td>
<td style="text-align: left;"><code>setDefaultUncaughtExceptionHandler( Thread.UncaughtExceptionHandler  eh)</code></td>
<td style="text-align: left;">设置当线程由于未捕获的异常而突然终止时调用的默认处理程序，并且没有为该线程定义其他处理程序。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setName(String name)</code></td>
<td style="text-align: left;">将此线程的名称更改为等于参数 <code>name</code> 。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setPriority(int newPriority)</code></td>
<td style="text-align: left;">更改此线程的优先级。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setUncaughtExceptionHandler( Thread.UncaughtExceptionHandler eh)</code></td>
<td style="text-align: left;">设置当此线程由于未捕获的异常而突然终止时调用的处理程序。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static void</code></td>
<td style="text-align: left;"><code>sleep(long millis)</code></td>
<td style="text-align: left;">导致当前正在执行的线程休眠（暂时停止执行）指定的毫秒数，具体取决于系统计时器和调度程序的精度和准确性。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>static void</code></td>
<td style="text-align: left;"><code>sleep(long millis, int nanos)</code></td>
<td style="text-align: left;">导致当前正在执行的线程休眠（暂时停止执行）指定的毫秒数加上指定的纳秒数，具体取决于系统定时器和调度程序的精度和准确性。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>start()</code></td>
<td style="text-align: left;">导致此线程开始执行; Java虚拟机调用此线程的<code>run</code>方法。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;"><code>toString()</code></td>
<td style="text-align: left;">返回此线程的字符串表示形式，包括线程的名称，优先级和线程组。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static void</code></td>
<td style="text-align: left;"><code>yield()</code></td>
<td style="text-align: left;">向调度程序提示当前线程是否愿意产生其当前使用的处理</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>常用方法</strong></p>
<p><strong>start</strong></p>
<p>线程开始执行; Java虚拟机调用此线程的<code>run</code>方法，不可重复启动</p>
<p><strong>currentThread</strong></p>
<p>返回对当前正在执行的线程对象的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread mainThread = Thread.currentThread();</span><br></pre></td></tr></table></figure>
<p>**getPriority &amp;&amp; setPriority</p>
<p>返回此线程的优先级</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread.getPriority();</span><br></pre></td></tr></table></figure>
<p><strong>sleep &amp;&amp; join</strong></p>
<p>Thread.sleep() 仅代表当前线程等待时间</p>
<p><strong>join(0)时，表示等将该线程加入主线程中，共用一个CPU核心，待该线程执行结束或死亡，才继续执行下一线程</strong></p>
<p>线程 start()后再调用 join()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> millisecond)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(millisecond);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(Thread thread, <span class="keyword">int</span> millisecond)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      thread.join(millisecond);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>setDaemon</strong></p>
<p>设置守护线程</p>
<p>Java 中的线程可以分为两种：守护线程和普通线程。在 JVM 刚启动时，它创建的所有线程，除了主线程（main thread）外，其他的线程都是守护线程（比如：垃圾收集器、以及其他执行辅助操作的线程）。</p>
<p>当创建一个新线程时，新线程将会继承它线程的守护状态，默认情况下，主线程创建的所有线程都是普通线程。</p>
<p><strong>当我们希望创建一个线程来执行一些辅助的工作，但是又不希望这个线程阻碍 JVM 的关闭，在这种情况下，我们就需要使用守护线程了。</strong></p>
<p><strong>区别</strong></p>
<p>守护线程与普通线程唯一的区别是：当线程退出时，JVM 会检查其他正在运行的线程，如果这些线程都是守护线程，那么 JVM 会正常退出操作，但是如果有普通线程还在运行，JVM 是不会执行退出操作的。当 JVM 退出时，所有仍然存在的守护线程都将被抛弃，既不会执行 finally 部分的代码，也不会执行 stack unwound 操作，JVM 会直接退出</p>
<ol type="1">
<li>thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。</li>
<li>在Daemon线程中产生的新线程也是Daemon的。</li>
<li>守护线程不能用于去访问固有资源，比如读写操作或者计算逻辑。因为它会在任何时候甚至在一个操作的中间发生中断。</li>
<li>Java自带的多线程框架，比如ExecutorService，会将守护线程转换为用户线程，所以如果要使用后台线程就不能用Java的线程池。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread1 = <span class="keyword">new</span> MyThread(Thread.MAX_PRIORITY,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">Thread thread2 = <span class="keyword">new</span> MyThread(Thread.NORM_PRIORITY,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"><span class="comment">// 线程2设置为守护线程</span></span><br><span class="line">thread2.setDaemon(<span class="keyword">true</span>);    </span><br><span class="line"></span><br><span class="line">thread1.start();</span><br><span class="line"><span class="comment">//线程1 加入主线程，保证thread1在thread2之前执行</span></span><br><span class="line">join(thread1,<span class="number">0</span>);</span><br><span class="line">thread2.start();</span><br><span class="line"><span class="comment">/* output 守护线程未执行，jvm 直接退出</span></span><br><span class="line"><span class="comment">t1finished time: 1583768160516</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Process finished with exit code 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>interrupt</strong></p>
<p>修改线程为中断状态，不会直接终止线程，通知<strong>线程主动释放所占用的系统资源</strong>，并终止自己。</p>
<p>stop()方法则直接杀死线程，因此被弃用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(<span class="keyword">int</span> p, String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        setPriority(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">      <span class="comment">// 如果为中断状态，则返回</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (interrupted())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot; &quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName()+<span class="string">&quot; finished time: &quot;</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.currentThread().setPriority(<span class="number">10</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> MyThread(Thread.MAX_PRIORITY,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        sleep(<span class="number">16</span>);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">t1 42</span></span><br><span class="line"><span class="comment">t1 43</span></span><br><span class="line"><span class="comment">t1 44</span></span><br><span class="line"><span class="comment">t1 45</span></span><br><span class="line"><span class="comment">t1 46</span></span><br><span class="line"><span class="comment">t1 47</span></span><br><span class="line"><span class="comment">t1 48</span></span><br><span class="line"><span class="comment">t1 49</span></span><br><span class="line"><span class="comment">t1 50</span></span><br><span class="line"><span class="comment">interrupt</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<hr />
<h3 id="runnable-接口">Runnable 接口</h3>
<p><code>Runnable</code>接口应由任何其实例由线程执行的类实现。 该类必须定义一个名为<code>run</code>的无参数的方法。</p>
<p>此接口旨在为希望在活动时执行代码的对象提供通用协议。 例如， <code>Runnable</code>由类<code>Thread</code>实现。 活动只是意味着一个线程已经启动但尚未停止。</p>
<p>此外， <code>Runnable</code>提供了一个类活动而不是<code>Thread</code> 。 实现<code>Runnable</code>类<code>Thread</code>通过实例化<code>Thread</code>实例并将其自身作为目标传递而无需子类化<code>Thread</code> 。 在大多数情况下，如果只打算覆盖<code>run()</code>方法而不使用其他<code>Thread</code>方法，则应使用<code>Runnable</code>接口。</p>
<p><strong>Runnable 使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// To-Do</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((Thread.currentThread()).getName() + <span class="string">&quot; finished time: &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匿名内部类加Runnable</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TO_DO</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MyRunnableThread t = <span class="keyword">new</span> MyRunnableThread();</span><br><span class="line">        Thread myRunnableThread = <span class="keyword">new</span> Thread(t,<span class="string">&quot;tt1&quot;</span>);</span><br><span class="line">        myRunnableThread.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>利用Runnable实现进程共享</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StringBuilder data = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//静态信号量，控制线程执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> s = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (s==<span class="keyword">true</span>)&#123;&#125;</span><br><span class="line">        s = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            data.append(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//线程执行完毕修改静态信号量</span></span><br><span class="line">        s = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println((Thread.currentThread()).getName() + <span class="string">&quot; finished time: &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyRunnableThread myRunnableThread = <span class="keyword">new</span> MyRunnableThread();</span><br><span class="line">Thread myRunnableThread1 = <span class="keyword">new</span> Thread(myRunnableThread,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">Thread myRunnableThread2 = <span class="keyword">new</span> Thread(myRunnableThread,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">myRunnableThread1.start();</span><br><span class="line">myRunnableThread2.start();</span><br><span class="line">sleep(<span class="number">1000</span>);</span><br><span class="line">System.out.println(myRunnableThread.getData());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">t1t1t1t1t1t1t1t1t1t1t1t1t1t1t2t2t2t2t2t2t2t2t2t2t2t2t2t2t2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="线程加锁">线程加锁</h3>
<p>多线程环境下，对临界资源加锁，设置临界区</p>
<p>临界区保证同时只能有一个线程访问</p>
<h4 id="synchronized">synchronized</h4>
<p>需要利用一个类实例加锁标记</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object(); <span class="comment">// Runnable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object(); <span class="comment">// Thread</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">// 临界区</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 临界区</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p><strong>锁方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TO_DO</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>案例</strong></p>
<p>机票售卖点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 机票数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> tickets = <span class="number">10</span>; </span><br><span class="line">    <span class="comment">// 剩余机票   </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    TicketThread(<span class="keyword">int</span> t) &#123;</span><br><span class="line">        tickets = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tickets&lt;=<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                count++;</span><br><span class="line">                num++;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; --卖出第 &quot;</span> + num + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">                tickets--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 售罄 卖出了：&quot;</span> + count + <span class="string">&quot; 剩余：&quot;</span> + tickets);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主程序</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始机票 10000</span></span><br><span class="line">        TicketThread ticketThread = <span class="keyword">new</span> TicketThread(<span class="number">10000</span>);</span><br><span class="line">        <span class="comment">// 设置 10 个售卖点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(ticketThread, <span class="string">&quot;t&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">t7 售罄 卖出了：1253 剩余：0</span></span><br><span class="line"><span class="comment">t1 售罄 卖出了：574 剩余：0</span></span><br><span class="line"><span class="comment">t8 售罄 卖出了：962 剩余：0</span></span><br><span class="line"><span class="comment">t4 售罄 卖出了：989 剩余：0</span></span><br><span class="line"><span class="comment">t2 售罄 卖出了：1210 剩余：0</span></span><br><span class="line"><span class="comment">t6 售罄 卖出了：855 剩余：0</span></span><br><span class="line"><span class="comment">t9 售罄 卖出了：1176 剩余：0</span></span><br><span class="line"><span class="comment">t0 售罄 卖出了：491 剩余：0</span></span><br><span class="line"><span class="comment">t3 售罄 卖出了：1168 剩余：0</span></span><br><span class="line"><span class="comment">t5 售罄 卖出了：1322 剩余：0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="reentrantlock">ReentrantLock</h4>
<p>ReentrantLock 类实现加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure>
<p>使用中，若加锁临界区异常，会导致无法解锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// TO_DO</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;        <span class="comment">// 最后始终会解锁</span></span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>线程安全类</strong></p>
<p>StringBuffer、Vector</p>
<p><strong>线程不安全</strong></p>
<p>StringBuilder、ArrayList</p>
<hr />
<h3 id="线程组">线程组</h3>
<p>多线程中，为了方便管理一批线程，我们使用ThreadGroup来表示线程组，通过它对一批线程进行分类管理 。（默认情况下，A线程创建的线程B，B线程是属于A线程的线程组的。）</p>
<p>此外，线程组还可以包括其他线程组。线程组形成一个树，其中除初始线程组之外的每个线程组都有父节点。</p>
<p>允许线程访问有关其自己的线程组的信息，但不允许访问有关其线程组的父线程组或任何其他线程组的信息。</p>
<p><strong>构造方法</strong></p>
<table>
<thead>
<tr class="header">
<th>构造器</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ThreadGroup​(String name)</code></td>
<td>构造一个新的线程组。</td>
</tr>
<tr class="even">
<td><code>ThreadGroup​(ThreadGroup parent,String name)</code></td>
<td>创建指定父线程组，名为name的新线程组</td>
</tr>
</tbody>
</table>
<p><strong>注意:</strong></p>
<p><strong>不要把后台线程组和后台线程（守护线程）混为一谈，后台线程组的特性是最后一个线程执行完或最后一个线程被销毁时，后台线程组自动销毁，线程组只是为了统一管理线程的一个方式</strong></p>
<p><strong>常用方法</strong></p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 43%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th>变量和类型</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>int</code></td>
<td><code>activeCount()</code></td>
<td>返回此线程组及其子组中活动线程数的估计值。</td>
</tr>
<tr class="even">
<td><code>int</code></td>
<td><code>activeGroupCount()</code></td>
<td>返回此线程组及其子组中活动组数的估计值。</td>
</tr>
<tr class="odd">
<td><code>void</code></td>
<td><code>checkAccess()</code></td>
<td>确定当前运行的线程是否具有修改此线程组的权限。</td>
</tr>
<tr class="even">
<td><code>void</code></td>
<td><code>destroy()</code></td>
<td>销毁此线程组及其所有子组。</td>
</tr>
<tr class="odd">
<td><code>int</code></td>
<td><code>enumerate​(Thread[] list)</code></td>
<td>将此线程组及其子组中的每个活动线程复制到指定的数组中。</td>
</tr>
<tr class="even">
<td><code>int</code></td>
<td><code>enumerate​(Thread[] list, boolean recurse)</code></td>
<td>将此线程组中的每个活动线程复制到指定的数组中。</td>
</tr>
<tr class="odd">
<td><code>int</code></td>
<td><code>enumerate​(ThreadGroup[] list)</code></td>
<td>复制到此线程组及其子组中每个活动子组的指定数组引用。</td>
</tr>
<tr class="even">
<td><code>int</code></td>
<td><code>enumerate​(ThreadGroup[] list, boolean recurse)</code></td>
<td>复制到此线程组中每个活动子组的指定数组引用。</td>
</tr>
<tr class="odd">
<td><code>int</code></td>
<td><code>getMaxPriority()</code></td>
<td>返回此线程组的最大优先级。</td>
</tr>
<tr class="even">
<td><code>String</code></td>
<td><code>getName()</code></td>
<td>返回此线程组的名称。</td>
</tr>
<tr class="odd">
<td><code>ThreadGroup</code></td>
<td><code>getParent()</code></td>
<td>返回此线程组的父级。</td>
</tr>
<tr class="even">
<td><code>void</code></td>
<td><code>interrupt()</code></td>
<td>中断此线程组中的所有线程。</td>
</tr>
<tr class="odd">
<td><code>boolean</code></td>
<td><code>isDaemon()</code></td>
<td>测试此线程组是否为守护程序线程组。</td>
</tr>
<tr class="even">
<td><code>boolean</code></td>
<td><code>isDestroyed()</code></td>
<td>测试此线程组是否已被销毁。</td>
</tr>
<tr class="odd">
<td><code>void</code></td>
<td><code>list()</code></td>
<td>将有关此线程组的信息打印到标准输出。</td>
</tr>
<tr class="even">
<td><code>boolean</code></td>
<td><code>parentOf​(ThreadGroup g)</code></td>
<td>测试此线程组是线程组参数还是其祖先线程组之一。</td>
</tr>
<tr class="odd">
<td><code>void</code></td>
<td><code>setDaemon​(boolean daemon)</code></td>
<td>设置线程组为后台线程（当后台线程组中最后一个线程执行完成活着最后一个线程被销毁，后台线程将自动销毁）</td>
</tr>
<tr class="even">
<td><code>void</code></td>
<td><code>setMaxPriority​(int pri)</code></td>
<td>设置组的最大优先级。</td>
</tr>
<tr class="odd">
<td><code>String</code></td>
<td><code>toString()</code></td>
<td>返回此Thread组的字符串表示形式。</td>
</tr>
<tr class="even">
<td><code>void</code></td>
<td><code>uncaughtException​(Thread t,Throwable e)</code></td>
<td>t代表抛出异常的线程，e代表抛出的异常，该方法处理此线程组里所有线程抛出的未处理的异常</td>
</tr>
</tbody>
</table>
<p><strong>用例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程组 “liuyang”</span></span><br><span class="line">        ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">&quot;liuyang&quot;</span>);</span><br><span class="line">        TicketThread ticketThread = <span class="keyword">new</span> TicketThread(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// Runnable 创建线程加入线程组</span></span><br><span class="line">            <span class="keyword">new</span> Thread(threadGroup,ticketThread,i+<span class="string">&quot; 售票点&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印线程组信息</span></span><br><span class="line">        threadGroup.list();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">java.lang.ThreadGroup[name=liuyang,maxpri=10]</span></span><br><span class="line"><span class="comment">    Thread[0 售票点,5,liuyang]</span></span><br><span class="line"><span class="comment">    Thread[1 售票点,5,liuyang]</span></span><br><span class="line"><span class="comment">    Thread[2 售票点,5,liuyang]</span></span><br><span class="line"><span class="comment">    Thread[3 售票点,5,liuyang]</span></span><br><span class="line"><span class="comment">    Thread[4 售票点,5,liuyang]</span></span><br><span class="line"><span class="comment">    Thread[5 售票点,5,liuyang]</span></span><br><span class="line"><span class="comment">    Thread[6 售票点,5,liuyang]</span></span><br><span class="line"><span class="comment">    Thread[7 售票点,5,liuyang]</span></span><br><span class="line"><span class="comment">    Thread[8 售票点,5,liuyang]</span></span><br><span class="line"><span class="comment">    Thread[9 售票点,5,liuyang]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3 售票点 卖出了：100 还有：0</span></span><br><span class="line"><span class="comment">9 售票点 卖出了：109 还有：0</span></span><br><span class="line"><span class="comment">6 售票点 卖出了：215 还有：0</span></span><br><span class="line"><span class="comment">5 售票点 卖出了：66 还有：0</span></span><br><span class="line"><span class="comment">1 售票点 卖出了：18 还有：0</span></span><br><span class="line"><span class="comment">4 售票点 卖出了：78 还有：0</span></span><br><span class="line"><span class="comment">0 售票点 卖出了：73 还有：0</span></span><br><span class="line"><span class="comment">7 售票点 卖出了：65 还有：0</span></span><br><span class="line"><span class="comment">2 售票点 卖出了：139 还有：0</span></span><br><span class="line"><span class="comment">8 售票点 卖出了：137 还有：0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>通过线程组处理异常</strong></p>
<p>定义一个会抛出异常的线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 除 0 错误</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">3</span>/<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写下线程组中的void uncaughtException(Thread t, Throwable e)方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">&quot;liuyang&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.uncaughtException(t, e);</span><br><span class="line">            System.out.println(t.getName()+<span class="string">&quot; 抛出 &quot;</span>+ e);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TicketThread ticketThread = <span class="keyword">new</span> TicketThread(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(threadGroup,ticketThread,i+<span class="string">&quot; 售票点&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">3 售票点 抛出 java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">7 售票点 抛出 java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">6 售票点 抛出 java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">1 售票点 抛出 java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">8 售票点 抛出 java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">2 售票点 抛出 java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">4 售票点 抛出 java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">5 售票点 抛出 java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">9 售票点 抛出 java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">0 售票点 抛出 java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="timer-定时器">Timer 定时器</h3>
<p>本质上也是线程</p>
<ul>
<li><p>线程的工具，用于在后台线程中安排将来执行的任务。可以将任务安排为一次性执行，或者以固定间隔重复执行。</p></li>
<li><p>此类是线程安全的，多个线程可以共享单个<code>Timer</code>对象，而无需外部同步</p></li>
<li><p>Java 5.0引入了<code>java.util.concurrent</code>包，其中一个并发实用程序是<code>ScheduledThreadPoolExecutor</code>，它是一个线程池，用于以给定的速率或延迟重复执行任务。这实际上是对一个更灵活的替代<code>Timer</code>/<code>TimerTask</code>组合，因为它允许多个服务线程，接受各种时间单位，并且不需要子类<code>TimerTask</code>（只实现<code>Runnable</code>）。使用一个线程配置<code>ScheduledThreadPoolExecutor</code>使其等效于<code>Timer</code>。</p></li>
</ul>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">构造器</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Timer()</code></td>
<td style="text-align: left;">创建一个新计时器。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Timer(boolean isDaemon)</code></td>
<td style="text-align: left;">创建一个新的计时器，其关联的线程可以指定为 <a href="chm://33031dcc470bf81a5f5e8595b0905ec1/java.base/java/lang/Thread.html#setDaemon(boolean)">run as a daemon</a> 。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Timer(String name)</code></td>
<td style="text-align: left;">创建一个新的计时器，其关联的线程具有指定的名称。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Timer(String name, boolean isDaemon)</code></td>
<td style="text-align: left;">创建一个新的计时器，其关联的线程具有指定的名称，并且可以指定为 <a href="chm://33031dcc470bf81a5f5e8595b0905ec1/java.base/java/lang/Thread.html#setDaemon(boolean)">run as a daemon</a> 。</td>
</tr>
</tbody>
</table>
<p>方法</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 62%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>cancel()</code></td>
<td style="text-align: left;">终止此计时器，丢弃当前计划的任何任务。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>purge()</code></td>
<td style="text-align: left;">从此计时器的任务队列中删除所有已取消的任务。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>schedule(TimerTask task, long delay)</code></td>
<td style="text-align: left;">在指定的延迟后安排指定的任务执行。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>schedule(TimerTask task, long delay, long period)</code></td>
<td style="text-align: left;">在指定的延迟之后开始，每隔 period 执行一次</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>schedule(TimerTask task, Date time)</code></td>
<td style="text-align: left;">计划在指定时间执行指定的任务。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>schedule(TimerTask task, Date firstTime, long period)</code></td>
<td style="text-align: left;">从指定时间开始，为重复的 <em>固定延迟执行</em>安排指定的任务。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>scheduleAtFixedRate(TimerTask task, long delay, long period)</code></td>
<td style="text-align: left;">在指定的延迟之后开始，为重复的 <em>固定速率执行</em>安排指定的任务。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>scheduleAtFixedRate(TimerTask task, Date firstTime, long period)</code></td>
<td style="text-align: left;">从指定时间开始，为重复的 <em>固定速率执行</em>安排指定的任务。</td>
</tr>
</tbody>
</table>
<p><strong>计时器任务 TimerTask</strong></p>
<p>可由<code>Timer</code>一次性或重复执行的 [任务] 。计时器任务<em>不可</em>重复使用</p>
<p><strong>用例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.liuyang.Tool.ThreadTool;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTimerTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟1000 millisecond 并隔同样时长执行一次</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">     timer.schedule(<span class="keyword">new</span> MyTimerTask(), <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">     ThreadTool.sleep</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="网络编程">网络编程</h2>
<blockquote>
<ul>
<li><strong>IP地址范围</strong></li>
</ul>
<p><em>链路本地</em>地址旨在用于在单个链路上进行寻址，以用于诸如自动地址配置，邻居发现或不存在路由器的目的。</p>
<p><em>站点本地</em>地址旨在用于在站点内部进行寻址，而无需全局前缀。</p>
<p><em>全球</em>地址在互联网上是独一无二的。</p>
<ul>
<li><strong>IP地址的文本表示</strong></li>
</ul>
<p>IP地址的文本表示是特定于地址族的。</p>
<ul>
<li><strong>主机名解析</strong></li>
</ul>
<p>主机名到IP地址<em>解析</em>是通过使用本地机器配置信息和网络命名服务（如域名系统（DNS）和网络信息服务（NIS））的组合来完成的。 默认情况下，正在使用的特定命名服务是本地计算机配置的一个。 对于任何主机名，将返回其对应的IP地址。</p>
<p><em>反向名称解析</em>意味着对于任何IP地址，都会返回与IP地址关联的主机。</p>
<p>InetAddress类提供了将主机名解析为其IP地址的方法，反之亦然。</p>
</blockquote>
<h3 id="tcpip网络模型">TCP/IP网络模型</h3>
<p>TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p>
<ul>
<li>链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。</li>
<li>网络层：负责路由以及把分组报文发送给目标网络或主机。</li>
<li>传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</li>
<li>应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</li>
</ul>
<p>在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。</p>
<p><strong>TCP/IP 中代表性传输层协议—-TCP 和 UDP</strong></p>
<ul>
<li><p>TCP</p>
<p>TCP协议全称是<strong>传输控制协议</strong>，是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 仅支持单播传输，即点对点传输</p>
<p><strong>面向连接</strong>，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础</p>
<p>TCP 建立连接：</p>
<blockquote>
<p><strong>第一次握手</strong></p>
<p>客户端向服务端发送连接请求报文段<code>SYN</code>。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</p>
<p><strong>第二次握手</strong></p>
<p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答<code>SYN-ACK</code>，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</p>
<p><strong>第三次握手</strong></p>
<p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文<code>ACK</code>。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</p>
</blockquote>
<p>TCP 断开连接</p>
<blockquote>
<p>TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK</p>
<p><strong>第一次握手</strong></p>
<p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求<code>FIN</code>。</p>
<p><strong>第二次握手</strong></p>
<p>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 <code>ACK</code> 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。</p>
<p><strong>第三次握手</strong></p>
<p>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求<code>FIN</code>，然后 B 便进入 LAST-ACK 状态。</p>
<p><strong>第四次握手</strong></p>
<p>A 收到释放请求后，向 B 发送确认应答<code>ACK</code>，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p>
</blockquote></li>
<li><p>UDP</p>
<p>UDP协议全称<strong>用户数据报协议</strong>，与TCP协议一样用于处理数据包，是一种无连接的协议。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，报文发送之后，无法得知其是否安全完整到达。UDP 提供了单播，多播，广播的功能</p></li>
<li><p>区别</p></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">UDP</th>
<th style="text-align: left;">TCP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">是否连接</td>
<td style="text-align: left;">无连接</td>
<td style="text-align: left;">面向连接</td>
</tr>
<tr class="even">
<td style="text-align: left;">是否可靠</td>
<td style="text-align: left;">不可靠传输，不使用流量控制和拥塞控制</td>
<td style="text-align: left;">可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr class="odd">
<td style="text-align: left;">连接对象个数</td>
<td style="text-align: left;">支持一对一，一对多，多对一和多对多交互通信</td>
<td style="text-align: left;">只能是一对一通信</td>
</tr>
<tr class="even">
<td style="text-align: left;">传输方式</td>
<td style="text-align: left;">面向报文</td>
<td style="text-align: left;">面向字节流</td>
</tr>
<tr class="odd">
<td style="text-align: left;">首部开销</td>
<td style="text-align: left;">首部开销小，仅8字节</td>
<td style="text-align: left;">首部最小20字节，最大60字节</td>
</tr>
<tr class="even">
<td style="text-align: left;">适用场景</td>
<td style="text-align: left;">适用于实时应用（IP电话、视频会议、直播等）</td>
<td style="text-align: left;">适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody>
</table>
<h3 id="inetaddress">InetAddress</h3>
<p>此类表示Internet协议（IP）地址,</p>
<p>InetAddress类具有用于存储成功和不成功主机名解析的缓存。</p>
<p>默认情况下，安装安全管理器时，为了防止DNS欺骗攻击，可以永久缓存正主机名解析的结果。 未安装安全管理器时，默认行为是缓存有限（依赖于实现）时间段的条目。 主机名解析失败的结果将在非常短的时间（10秒）内缓存，以提高性能。</p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 51%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>equals(Object obj)</code></td>
<td style="text-align: left;">将此对象与指定的对象进行比较。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>byte[]</code></td>
<td style="text-align: left;"><code>getAddress()</code></td>
<td style="text-align: left;">返回此 <code>InetAddress</code>对象的原始IP地址。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static InetAddress[]</code></td>
<td style="text-align: left;"><code>getAllByName(String host)</code></td>
<td style="text-align: left;">根据主机的名称，根据系统上配置的名称服务返回其IP地址数组。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>static InetAddress</code></td>
<td style="text-align: left;"><code>getByAddress(byte[] addr)</code></td>
<td style="text-align: left;">给定原始IP地址返回 <code>InetAddress</code>对象。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static InetAddress</code></td>
<td style="text-align: left;"><code>getByAddress(String host, byte[] addr)</code></td>
<td style="text-align: left;">根据提供的主机名和IP地址创建InetAddress。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>static InetAddress</code></td>
<td style="text-align: left;"><code>getByName(String host)</code></td>
<td style="text-align: left;">根据主机名称确定主机的IP地址。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;"><code>getCanonicalHostName()</code></td>
<td style="text-align: left;">获取此IP地址的完全限定域名。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;"><code>getHostAddress()</code></td>
<td style="text-align: left;">返回文本表示中的IP地址字符串。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;"><code>getHostName()</code></td>
<td style="text-align: left;">获取此IP地址的主机名。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>static InetAddress</code></td>
<td style="text-align: left;"><code>getLocalHost()</code></td>
<td style="text-align: left;">返回本地主机的地址。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static InetAddress</code></td>
<td style="text-align: left;"><code>getLoopbackAddress()</code></td>
<td style="text-align: left;">返回环回地址。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>hashCode()</code></td>
<td style="text-align: left;">返回此IP地址的哈希码。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isAnyLocalAddress()</code></td>
<td style="text-align: left;">用于检查InetAddress是否为通配符地址的实用例程。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isLinkLocalAddress()</code></td>
<td style="text-align: left;">用于检查InetAddress是否为链接本地地址的实用程序例程。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isLoopbackAddress()</code></td>
<td style="text-align: left;">用于检查InetAddress是否为环回地址的实用例程。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isMCGlobal()</code></td>
<td style="text-align: left;">用于检查多播地址是否具有全局范围的实用例程。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isMCLinkLocal()</code></td>
<td style="text-align: left;">用于检查多播地址是否具有链接范围的实用例程。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isMCNodeLocal()</code></td>
<td style="text-align: left;">用于检查多播地址是否具有节点范围的实用例程。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isMCOrgLocal()</code></td>
<td style="text-align: left;">用于检查多播地址是否具有组织范围的实用例程。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isMCSiteLocal()</code></td>
<td style="text-align: left;">用于检查多播地址是否具有站点范围的实用程序例程。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isMulticastAddress()</code></td>
<td style="text-align: left;">用于检查InetAddress是否为IP多播地址的实用程序例程。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isReachable(int timeout)</code></td>
<td style="text-align: left;">测试该地址是否可达。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isReachable(NetworkInterface netif, int ttl, int timeout)</code></td>
<td style="text-align: left;">测试该地址是否可达。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isSiteLocalAddress()</code></td>
<td style="text-align: left;">用于检查InetAddress是否为站点本地地址的实用程序例程。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;"><code>toString()</code></td>
<td style="text-align: left;">将此IP地址转换为 <code>String</code> 。</td>
</tr>
</tbody>
</table>
<h3 id="socket-套接字">Socket 套接字</h3>
<blockquote>
<p>应用通过传输层进行数据通信时，TCP和UDP会遇到同时为多个应用程序进程提供并发服务的问题。为了区别不同的应用程序进程和连接，计算机操作系统就可以为应用程序与TCP/IP协议交互提供套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p>
<p>Socket是一种进程通信机制，凭借这种机制，客户/服务器系统的开发工作既可以在本地单机上进行，也可以跨网络进行。Socket是对TCP/IP协议的封装，它是一组接口。这组接口当然可以由不同的语言去实现。它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部</p>
<p>Socket是面向客户/服务器模型而设计的，针对客户和服务器程序提供不同的Socket系统调用。通过Socket建立通信连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket.</p>
</blockquote>
<p><strong>套接字之间的连接过程</strong></p>
<p>分为三个步骤：服务器监听，客户端请求，连接确认。</p>
<ol type="1">
<li>服务器监听：是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态。</li>
<li>客户端请求：是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</li>
<li>连接确认：是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</li>
</ol>
<p><img src="套接字.png" style="zoom:30%;" /></p>
<h4 id="datagramsocket---udp"><code>DatagramSocket</code> --UDP</h4>
<p>发送和接收数据报套接字</p>
<p>数据报套接字是分组传送服务的发送或接收点。 在数据报套接字上发送或接收的每个数据包都是单独寻址和路由的。 从一台机器发送到另一台机器的多个分组可以被不同地路由，并且可以以任何顺序到达</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 48%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">构造器</th>
<th style="text-align: left;">描述</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code></code></td>
<td style="text-align: left;"><code>DatagramSocket()</code></td>
<td>构造一个数据报套接字并将其绑定到本地主机上的任何可用端口。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code></code></td>
<td style="text-align: left;"><code>DatagramSocket(int port)</code></td>
<td>构造一个数据报套接字并将其绑定到本地主机上的指定端口。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code></code></td>
<td style="text-align: left;"><code>DatagramSocket(int port, InetAddress laddr)</code></td>
<td>创建绑定到指定本地地址的数据报套接字。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>protected</code></td>
<td style="text-align: left;"><code>DatagramSocket(DatagramSocketImpl impl)</code></td>
<td>使用指定的DatagramSocketImpl创建未绑定的数据报套接字。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code></code></td>
<td style="text-align: left;"><code>DatagramSocket(SocketAddress bindaddr)</code></td>
<td>创建绑定到指定本地套接字地址的数据报套接字。</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 29%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>bind(SocketAddress addr)</code></td>
<td style="text-align: left;">将此DatagramSocket绑定到特定的地址和端口。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>close()</code></td>
<td style="text-align: left;">关闭此数据报套接字。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>connect(InetAddress address, int port)</code></td>
<td style="text-align: left;">将套接字连接到此套接字的远程地址。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>connect(SocketAddress addr)</code></td>
<td style="text-align: left;">将此套接字连接到远程套接字地址（IP地址+端口号）。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>disconnect()</code></td>
<td style="text-align: left;">断开连接。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>DatagramChannel</code></td>
<td style="text-align: left;"><code>getChannel()</code></td>
<td style="text-align: left;">返回与此数据报套接字关联的唯一<a href="chm://33031dcc470bf81a5f5e8595b0905ec1/java.base/java/nio/channels/DatagramChannel.html"><code>DatagramChannel</code></a>对象（如果有）。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>InetAddress</code></td>
<td style="text-align: left;"><code>getInetAddress()</code></td>
<td style="text-align: left;">返回此套接字连接的地址。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>InetAddress</code></td>
<td style="text-align: left;"><code>getLocalAddress()</code></td>
<td style="text-align: left;">获取套接字绑定的本地地址。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>getLocalPort()</code></td>
<td style="text-align: left;">返回此套接字绑定到的本地主机上的端口号。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>SocketAddress</code></td>
<td style="text-align: left;"><code>getLocalSocketAddress()</code></td>
<td style="text-align: left;">返回此套接字绑定的端点的地址。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>T</code></td>
<td style="text-align: left;"><code>getOption(SocketOption name)</code></td>
<td style="text-align: left;">返回套接字选项的值。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>getPort()</code></td>
<td style="text-align: left;">返回此套接字连接的端口号。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>getReceiveBufferSize()</code></td>
<td style="text-align: left;">获取此 <code>DatagramSocket</code>的SO_RCVBUF选项的值，即该平台在此 <code>DatagramSocket</code>上用于输入的缓冲区大小。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>SocketAddress</code></td>
<td style="text-align: left;"><code>getRemoteSocketAddress()</code></td>
<td style="text-align: left;">返回此套接字连接到的端点的地址，如果未连接则返回 <code>null</code> 。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>getSendBufferSize()</code></td>
<td style="text-align: left;">获取此 <code>DatagramSocket</code>的SO_SNDBUF选项的值， <code>DatagramSocket</code>上的输出的缓冲区大小。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>getTrafficClass()</code></td>
<td style="text-align: left;">获取从此DatagramSocket发送的数据包的IP数据报头中的流量类或服务类型。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isBound()</code></td>
<td style="text-align: left;">返回套接字的绑定状态。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isClosed()</code></td>
<td style="text-align: left;">返回套接字是否关闭。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isConnected()</code></td>
<td style="text-align: left;">返回套接字的连接状态。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>receive(DatagramPacket p)</code></td>
<td style="text-align: left;">从此套接字接收数据报包。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>send(DatagramPacket p)</code></td>
<td style="text-align: left;">从此套接字发送数据报包。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setBroadcast(boolean on)</code></td>
<td style="text-align: left;">启用/禁用SO_BROADCAST。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>static void</code></td>
<td style="text-align: left;"><code>setDatagramSocketImplFactory(DatagramSocketImplFactory fac)</code></td>
<td style="text-align: left;">设置应用程序的数据报套接字实现工厂。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>DatagramSocket</code></td>
<td style="text-align: left;"><code>setOption(SocketOption name, T value)</code></td>
<td style="text-align: left;">设置套接字选项的值。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setSendBufferSize(int size)</code></td>
<td style="text-align: left;">将<code>DatagramSocket</code>上的输出的缓冲区大小设置为指定值。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setSoTimeout(int timeout)</code></td>
<td style="text-align: left;">使用指定的超时启用/禁用SO_TIMEOUT，以毫秒为单位。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setTrafficClass(int tc)</code></td>
<td style="text-align: left;">在IP数据报头中为从此DatagramSocket发送的数据报设置流量类或服务类型八位字节。</td>
</tr>
</tbody>
</table>
<p>####<strong>案例1-- 单向发送</strong></p>
<p>设置多个 客户机对其发送 socket、 客户机类 implement Runnable 接口，多线程执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDP_Send</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data;</span><br><span class="line">    <span class="keyword">private</span> InetAddress address;  <span class="comment">// 目标主机地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;        <span class="comment">// 目标主机端口</span></span><br><span class="line"></span><br><span class="line">    UDP_Send(String string, InetAddress address, <span class="keyword">int</span> port) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = string.getBytes();</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 客户机 Socket，端口系统分配</span></span><br><span class="line">        <span class="keyword">try</span> (DatagramSocket datagramSocket = <span class="keyword">new</span> DatagramSocket()) &#123;</span><br><span class="line"></span><br><span class="line">            DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(data, data.length, address, port);</span><br><span class="line">            datagramSocket.send(dp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置一个 主机循环接收 socket</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDP_Receive</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置监听的端口号</span></span><br><span class="line">        <span class="keyword">if</span> (args == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 接收输入端口</span></span><br><span class="line">        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 主机绑定到端口 port，监听</span></span><br><span class="line">        <span class="keyword">try</span> (DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(port)) &#123;</span><br><span class="line">            <span class="comment">// 创建数据报包对象，存储接收的数据</span></span><br><span class="line">            DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>], <span class="number">1024</span>);</span><br><span class="line">            <span class="comment">// 循环监听端口，接收数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ds.receive(dp);</span><br><span class="line">                    System.out.println(<span class="string">&quot;主机[&quot;</span> + port + <span class="string">&quot;]%  客户机地址：    &quot;</span> + dp.getSocketAddress() +</span><br><span class="line">                            <span class="string">&quot;    客户机发送信息：&quot;</span> + <span class="keyword">new</span> String(dp.getData(), <span class="number">0</span>, dp.getLength()));</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置 UDP_Main 类进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDP_Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态变量 本地 ip</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String local_address = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        <span class="comment">// 设置主机端口为 1086</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">1086</span>;</span><br><span class="line">        <span class="comment">// 创建 InetAddress 对象</span></span><br><span class="line">        InetAddress address = InetAddress.getByName(local_address);</span><br><span class="line">        <span class="comment">// 创建客户机线程组</span></span><br><span class="line">        ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">&quot;liuyang&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建 10 个客户机线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(threadGroup,</span><br><span class="line">                    <span class="keyword">new</span> UDP_Send(<span class="string">&quot;我是客户机 &quot;</span>+i,address,port), <span class="string">&quot;客户机&quot;</span>+i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印线程组信息</span></span><br><span class="line">        threadGroup.list();</span><br><span class="line">        <span class="comment">// 调用主机，传递参数</span></span><br><span class="line">        UDP_Receive.main(<span class="keyword">new</span> String[]&#123;String.valueOf(port)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出结果</strong></p>
<blockquote>
<p>java.lang.ThreadGroup[name=liuyang,maxpri=10] Thread[客户机0,5,liuyang] Thread[客户机1,5,liuyang] Thread[客户机2,5,liuyang] Thread[客户机3,5,liuyang] Thread[客户机4,5,liuyang] Thread[客户机5,5,liuyang] Thread[客户机6,5,liuyang] Thread[客户机7,5,liuyang] Thread[客户机8,5,liuyang] Thread[客户机9,5,liuyang]</p>
<p>主机[1086]% 客户机地址： /127.0.0.1:57939 客户机发送信息：我是客户机 0 主机[1086]% 客户机地址： /127.0.0.1:57932 客户机发送信息：我是客户机 1 主机[1086]% 客户机地址： /127.0.0.1:57936 客户机发送信息：我是客户机 5 主机[1086]% 客户机地址： /127.0.0.1:57938 客户机发送信息：我是客户机 9 主机[1086]% 客户机地址： /127.0.0.1:57937 客户机发送信息：我是客户机 3 主机[1086]% 客户机地址： /127.0.0.1:57941 客户机发送信息：我是客户机 6 主机[1086]% 客户机地址： /127.0.0.1:57933 客户机发送信息：我是客户机 8 主机[1086]% 客户机地址： /127.0.0.1:57935 客户机发送信息：我是客户机 4 主机[1086]% 客户机地址： /127.0.0.1:57934 客户机发送信息：我是客户机 7 主机[1086]% 客户机地址： /127.0.0.1:57940 客户机发送信息：我是客户机 2</p>
</blockquote>
<h4 id="案例2----双向发送">案例2 -- 双向发送</h4>
<p>分别设置发送线程和接收线程</p>
<ol type="1">
<li>发送线程，参数：发送数据，发送ip，发送端口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data;</span><br><span class="line">    <span class="keyword">private</span> InetAddress address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    SendThread(String string, InetAddress address, <span class="keyword">int</span> port) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = string.getBytes();</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 发送Socket，端口系统分配</span></span><br><span class="line">        <span class="keyword">try</span> (DatagramSocket datagramSocket = <span class="keyword">new</span> DatagramSocket()) &#123;</span><br><span class="line">            DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(data, data.length, address, port);</span><br><span class="line">            datagramSocket.send(dp);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>接收线程, 参数：监听的端口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReceiveThread</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(port)) &#123;</span><br><span class="line">            <span class="comment">// 创建数据报包对象，存储接收的数据</span></span><br><span class="line">            DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>], <span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ds.receive(dp);</span><br><span class="line">                    System.out.println(<span class="string">&quot;&gt;&gt; ReceivePort[&quot;</span> + port + <span class="string">&quot;]%   SendInfo：&quot;</span> + dp.getSocketAddress() +</span><br><span class="line">                            <span class="string">&quot;\n&quot;</span> + <span class="keyword">new</span> String(dp.getData(), <span class="number">0</span>, dp.getLength()));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>UDP_Service 类，对接收和发送线程包装</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDP_Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String pcName;            <span class="comment">// 主机名</span></span><br><span class="line">    <span class="keyword">private</span> InetAddress targetAddress;        <span class="comment">// 目标ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;                        <span class="comment">// 本机监听端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> targetPort;                    <span class="comment">// 发送目标端口</span></span><br><span class="line">    <span class="keyword">private</span> ThreadGroup threadGroup;        <span class="comment">//线程组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pcName 主机名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetAddress 目标ip</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port 监听端口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetPort 目标端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UDP_Service</span><span class="params">(String pcName, String targetAddress, <span class="keyword">int</span> port, <span class="keyword">int</span> targetPort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pcName = pcName;</span><br><span class="line">        toInetAddress(targetAddress);</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.targetPort = targetPort;</span><br><span class="line">        threadGroup = <span class="keyword">new</span> ThreadGroup(pcName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址转换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> address ip字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">toInetAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.targetAddress = InetAddress.getByName(address);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  发送 数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content 数据内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(threadGroup, <span class="keyword">new</span> SendThread(content, targetAddress, targetPort),</span><br><span class="line">                   pcName + <span class="string">&quot;发送&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread receive = <span class="keyword">new</span> Thread(threadGroup, <span class="keyword">new</span> ReceiveThread(port)</span><br><span class="line">                , pcName + <span class="string">&quot;监听&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置 监听 为守护线程，否则进程无法退出</span></span><br><span class="line">        receive.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        receive.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收并发送</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">udpChat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receive();</span><br><span class="line">        String content;</span><br><span class="line">        <span class="keyword">while</span> (!(content = Scan.scanString()).equals(<span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">            send(<span class="string">&quot;[&quot;</span> + pcName + <span class="string">&quot;]：&quot;</span> + content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>客户机和主机实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDP_Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UDP_Service udp_service = <span class="keyword">new</span> UDP_Service(<span class="string">&quot;Client&quot;</span>,</span><br><span class="line">                <span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1087</span>,<span class="number">1088</span>);</span><br><span class="line">        udp_service.udpChat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDP_Host</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UDP_Service udp_service = <span class="keyword">new</span> UDP_Service(<span class="string">&quot;Host&quot;</span>,</span><br><span class="line">                <span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1088</span>,<span class="number">1087</span>);</span><br><span class="line">        udp_service.udpChat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>测试效果</li>
</ol>
<ul>
<li>主机</li>
</ul>
<blockquote>
<p>你好我是主机</p>
<p>&gt;&gt;ReceivePort[1088]% SendInfo：/127.0.0.1:50749</p>
<p>[Client]：我是客户机</p>
<p>那你能帮帮我吗？</p>
<p>&gt;&gt;ReceivePort[1088]% SendInfo：/127.0.0.1:49685 [Client]：爬</p>
</blockquote>
<ul>
<li>客户机</li>
</ul>
<blockquote>
<p>&gt;&gt; ReceivePort[1087]% SendInfo：/127.0.0.1:56760 [Host]：你好我是主机 我是客户机</p>
<p>&gt;&gt; ReceivePort[1087]% SendInfo：/127.0.0.1:64583</p>
<p>[Host]：那你能帮帮我吗？ 爬</p>
</blockquote>
<h4 id="socket---tcp"><code>Socket</code> --TCP</h4>
<p>该类实现客户端套接字（也称为“套接字”），套接字是两台机器之间通信的端点.</p>
<p><strong>构造函数</strong></p>
<table>
<colgroup>
<col style="width: 66%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">描述</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Socket()</code></td>
<td>创建一个未连接的套接字，系统默认类型为SocketImpl。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Socket(String host, int port)</code></td>
<td>创建流套接字并将其连接到指定主机上的指定端口号。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Socket(String host, int port, InetAddress localAddr, int localPort)</code></td>
<td>创建套接字并将其连接到指定远程端口上的指定远程主机。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Socket(InetAddress address, int port)</code></td>
<td>创建流套接字并将其连接到指定IP地址处的指定端口号。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Socket(InetAddress address, int port, InetAddress localAddr, int localPort)</code></td>
<td>创建套接字并将其连接到指定远程端口上的指定远程地址。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Socket(Proxy proxy)</code></td>
<td>创建一个未连接的套接字，指定应该使用的代理类型（如果有），而不管其他任何设置。</td>
</tr>
</tbody>
</table>
<p><strong>常用方法</strong></p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 21%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">变量和类型</th>
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>bind(SocketAddress addr)</code></td>
<td style="text-align: left;">将此DatagramSocket绑定到特定的地址和端口。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>close()</code></td>
<td style="text-align: left;">关闭此数据报套接字。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>connect(InetAddress address, int port)</code></td>
<td style="text-align: left;">将套接字连接到此套接字的远程地址。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>connect(SocketAddress addr)</code></td>
<td style="text-align: left;">将此套接字连接到远程套接字地址（IP地址+端口号）。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>disconnect()</code></td>
<td style="text-align: left;">断开插座。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>getBroadcast()</code></td>
<td style="text-align: left;">测试是否启用了SO_BROADCAST。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>DatagramChannel</code></td>
<td style="text-align: left;"><code>getChannel()</code></td>
<td style="text-align: left;">返回与此数据报套接字关联的唯一<a href="chm://33031dcc470bf81a5f5e8595b0905ec1/java.base/java/nio/channels/DatagramChannel.html"><code>DatagramChannel</code></a>对象（如果有）。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>InetAddress</code></td>
<td style="text-align: left;"><code>getInetAddress()</code></td>
<td style="text-align: left;">返回此套接字连接的地址。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>InetAddress</code></td>
<td style="text-align: left;"><code>getLocalAddress()</code></td>
<td style="text-align: left;">获取套接字绑定的本地地址。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>getLocalPort()</code></td>
<td style="text-align: left;">返回此套接字绑定到的本地主机上的端口号。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>SocketAddress</code></td>
<td style="text-align: left;"><code>getLocalSocketAddress()</code></td>
<td style="text-align: left;">返回此套接字绑定的端点的地址。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>getPort()</code></td>
<td style="text-align: left;">返回此套接字连接的端口号。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>OutputStream</code></td>
<td style="text-align: left;"><code>getOutputStream()</code></td>
<td style="text-align: left;">返回此套接字的输出流。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>SocketAddress</code></td>
<td style="text-align: left;"><code>getRemoteSocketAddress()</code></td>
<td style="text-align: left;">返回此套接字连接到的端点的地址，如果未连接则返回 <code>null</code> 。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isBound()</code></td>
<td style="text-align: left;">返回套接字的绑定状态。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isClosed()</code></td>
<td style="text-align: left;">返回套接字是否关闭。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;"><code>isConnected()</code></td>
<td style="text-align: left;">返回套接字的连接状态。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>receive(DatagramPacket p)</code></td>
<td style="text-align: left;">从此套接字接收数据报包。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>send(DatagramPacket p)</code></td>
<td style="text-align: left;">从此套接字发送数据报包。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setBroadcast(boolean on)</code></td>
<td style="text-align: left;">启用/禁用SO_BROADCAST。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setSoTimeout(int timeout)</code></td>
<td style="text-align: left;">使用指定的超时启用/禁用SO_TIMEOUT，以毫秒为单位。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;"><code>setTrafficClass(int tc)</code></td>
<td style="text-align: left;">在IP数据报头中为从此DatagramSocket发送的数据报设置流量类或服务类型八位字节。</td>
</tr>
</tbody>
</table>
<h4 id="案例3---tcp-点对点全双工">案例3 --TCP 点对点全双工</h4>
<p>Socket 套接字，该类通过<code>SeverSocket</code> 建立TCP连接，然后即可全双工传输</p>
<p>因此，必须将 发送 和 接收 设置为2个线程，才能实现实时发送</p>
<p><strong>发送线程，传入参数为 Socket 对象</strong></p>
<p>服务端同时对多个客户端发送消息，设置输入临界区，保证对客户端的轮访</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCP_SendThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> String pcName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TCP_SendThread</span><span class="params">(Socket socket, String pcName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.pcName = pcName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (OutputStream outputStream = socket.getOutputStream()) &#123;</span><br><span class="line">            String string;</span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;To &quot;</span>+socket.getPort()+<span class="string">&quot;：&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (socket.isClosed() || (string = scanner.nextLine()).equals(<span class="string">&quot;exit&quot;</span>))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                string = <span class="string">&quot;&gt;&gt; [&quot;</span> + pcName + <span class="string">&quot;] &quot;</span> + string;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputStream.write(string.getBytes());</span><br><span class="line">                    <span class="comment">// 保证线程能轮流抢占</span></span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>接收线程，参数Socket 对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCP_ReceiveThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TCP_ReceiveThread</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;连接到 &quot;</span> + socket.getPort() + <span class="string">&quot; 本机：&quot;</span>+ socket.getLocalPort());</span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="keyword">int</span> sigh;</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((sigh = inputStream.read(data, <span class="number">0</span>, data.length)) != -<span class="number">1</span>)</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> String(data, <span class="number">0</span>, sigh));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>构建 TCP_IOSocket 类</strong></p>
<p>实现对以上两个线程的包装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCP_IOSocket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> targetPort;</span><br><span class="line">    <span class="keyword">private</span> String pcName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isServer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TCP_IOSocket</span><span class="params">(String pcName, <span class="keyword">boolean</span> isServer,</span></span></span><br><span class="line"><span class="params"><span class="function">                        String address, <span class="keyword">int</span> targetPort, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.pcName = pcName;</span><br><span class="line">        <span class="keyword">this</span>.targetPort = targetPort;</span><br><span class="line">        <span class="keyword">this</span>.isServer = isServer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建调用发送和接收线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">        Thread re = <span class="keyword">new</span> TCP_ReceiveThread(socket);</span><br><span class="line">        Thread se = <span class="keyword">new</span> TCP_SendThread(socket,pcName);</span><br><span class="line">        re.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        re.start();</span><br><span class="line">        se.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tcpIoSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">                serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">                <span class="comment">// 与多客户机建立连接</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        socket = serverSocket.accept();</span><br><span class="line">                        start(socket);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                socket = <span class="keyword">new</span> Socket(address, targetPort, InetAddress.getByName(address), port);</span><br><span class="line">                start(socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (</span><br><span class="line">                IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户机与主机</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCP_Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String pcName = <span class="string">&quot;Client&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isServer = <span class="keyword">false</span>;</span><br><span class="line">        String address = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> targetPort = <span class="number">1090</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">1089</span>;</span><br><span class="line">        TCP_IOSocket tcp_ioSocket = <span class="keyword">new</span> TCP_IOSocket(pcName, isServer,</span><br><span class="line">                address, targetPort, port);</span><br><span class="line">        tcp_ioSocket.tcpIoSocket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCP_Host</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String pcName = <span class="string">&quot;Host&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isServer = <span class="keyword">true</span>;</span><br><span class="line">        String address = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> targetPort = <span class="number">1089</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">1090</span>;</span><br><span class="line">        TCP_IOSocket tcp_ioSocket = <span class="keyword">new</span> TCP_IOSocket(pcName, isServer,</span><br><span class="line">                address, targetPort, port);</span><br><span class="line">        tcp_ioSocket.tcpIoSocket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试结果</strong></p>
<blockquote>
<p>服务器</p>
<p><img src="tcp1.png" style="zoom:60%;" /></p>
<p>客户端1</p>
<p><img src="tcp2.png" style="zoom:60%;"/></p>
<p>客户端2</p>
<p><img src="tcp3.png" style="zoom:60%;" /></p>
</blockquote>
<h2 id="枚举类型">枚举类型</h2>
<p>每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，枚举类型拥有的实例在编写的时候,就已经确定下,不能通过其他手段进行创建,且枚举变量在jvm有且只有一个对应的实例.</p>
<blockquote>
<ol type="1">
<li>枚举实例必须在 <code>enum</code>关键字声明的类中显式的指定(首行开始的以第一个分号结束)</li>
<li>除了1, 没有任何方式(new,clone,反射,序列化)可以手动创建枚举实例</li>
<li>枚举类不可被继承</li>
<li>枚举类是线程安全的</li>
<li>枚举类型是类型安全的(typesafe)，方法参数自动会对传入类型进行检查, <code>static final</code>定义的常量则不具备 类型安全的特点.</li>
<li>无法继承其他类(已经默认继承Enum)</li>
</ol>
</blockquote>
<ol type="1">
<li>常规用法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RoleTypeEnum</span> </span>&#123;</span><br><span class="line">    TEACHER, STUDENT, PRINCIPLE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们为沉默枚举创建了三个值，分别是教师、学生、校长。这段代码实际上调用了3次<code>Enum(String name, int ordinal)</code>（ordinal单词的意思为顺序），也就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Enum&lt;Chenmo&gt;(<span class="string">&quot;TEACHER&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> Enum&lt;Chenmo&gt;(<span class="string">&quot;STUDENT&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> Enum&lt;Chenmo&gt;(<span class="string">&quot;PRINCIPLE&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (RoleTypeEnum e : RoleTypeEnum.values()</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">TEACHER</span></span><br><span class="line"><span class="comment">STUDENT</span></span><br><span class="line"><span class="comment">PRINCIPLE</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>使用枚举常量比使用<code>final static</code>来实现常量定义,枚举的内存消耗比后高不止两倍. 应该严格避免在Android上使用枚举.</strong></p>
<h2 id="类的加载">类的加载</h2>
<p>我们运行写好的 java 文件时，编译器会先将 java 文件编译为 .class 字节码，再由类加载器将 .class文件加载到 JVM 中，生成 Class 对象</p>
<p><strong>类加载过程：</strong></p>
<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，包括：加载 -&gt; 连接 -&gt; 初始化 三个阶段</p>
<p><strong>1、加载</strong></p>
<p>（1）通过一个类的全限定名来获取其定义的二进制字节流</p>
<p>（2）将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构</p>
<p>（3）在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口。</p>
<p>相对于类加载的其他阶段而言，加载阶段是可控性最强的阶段，程序员可以使用系统的类加载器加载，还可以使用自己的类加载器加载。</p>
<p><strong>2、链接</strong></p>
<p>链接需要检查、准备和解析，先检查载入class文件数据的正确性然后给类的静态变量分配存储空间最后将符号引用转成直接引用。</p>
<p>（1）验证</p>
<p>​ 确保被加载的类的正确性</p>
<p>（2）准备</p>
<p>​ <strong>准备阶段主要为类变量分配内存并设置初始值</strong>。这些内存都在方法区分配。在这个阶段主要是类变量和初始值两个关键词：</p>
<ul>
<li><p>类变量（static）会分配内存，但是实例变量不会，实例变量主要随着对象的实例化一块分配到java堆中，</p></li>
<li><p>这里的初始值指的是数据类型默认值，而不是代码中被显示赋予的值</p></li>
</ul>
<p>（3）解析</p>
<p>​ 虚拟机将常量池中的符号引用转化为直接引用的过程。</p>
<ul>
<li>符号引用：以一组符号来描述所引用的目标，可以是任何形式的字面量，只要是能无歧义的定位到目标就好</li>
<li>直接引用：直接引用是可以指向目标的指针、相对偏移量或者是一个能直接或间接定位到目标的句柄。和虚拟机实现的内存有关，不同的虚拟机直接引用一般不同。</li>
</ul>
<p><strong>3、初始化</strong></p>
<p>类加载机制的最后一步，在这个阶段，java程序代码才开始真正执行</p>
<p>在初始化阶段，主要为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化</p>
<ul>
<li><p>JVM初始化步骤</p>
<p>1、假如这个类还没有被加载和连接，则程序先加载并连接该类</p>
<p>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</p>
<p>3、假如类中有初始化语句，则系统依次执行这些初始化语句</p></li>
<li><p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p>
<p>1、创建类的实例，也就是new的方式</p>
<p>2、访问某个类或接口的静态变量，或者对该静态变量赋值</p>
<p>3、调用类的静态方法</p>
<p>4、反射（如 Class.forName(“com.shengsiyuan.Test”)）</p>
<p>5、初始化某个类的子类，则其父类也会被初始化</p>
<p>6、Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类</p></li>
</ul>
<h4 id="类加载器">类加载器</h4>
<p>虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类</p>
<p><strong>Java语言系统自带有三个类加载器</strong></p>
<ul>
<li><strong>Bootstrap ClassLoader</strong> （启动类加载器）：最顶层的加载类，主要加载核心类库，也就是我们环境变量下面<code>$&#123;JAVA_HOME&#125;/lib</code>下的<code>rt.jar、resources.jar、charsets.jar和class</code>等。JVM内部 <code>C++</code> 语言实现，开发者不允许直接操作（它不是继承自ClassLoader的）</li>
<li><strong>Extention ClassLoader</strong> (扩展的类加载器)：加载目录<code>$&#123;JAVA_HOME&#125;\lib\ext</code>目录下的jar包和class文件。JAVA 层面实现，开发者可以直接操作。</li>
<li><strong>Appclass Loader</strong> (系统类加载器)：也称为SystemAppClass。 加载当前应用的classpath的所有类，它也是Java程序默认的类加载器，Java层面实现，开发者可以直接操作。</li>
</ul>
<p><img src="加载器.png" style="zoom:100%;" /></p>
<p>基本上所有的类加载器都是 <code>ClassLoader</code> 类的一个实现，除了 <code>bootStrap</code> 这个系统内部的加载器之外,也就是说除了它所有的类加载器都有一个父类加载器，可以通过图中的方法得到。当然，我们也可以自己在Java程序里通过继承 <code>ClassLoader</code> 来实现自己的类加载器。</p>
<p><strong>双亲委派原则</strong></p>
<p>当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务</p>
<p>采用双亲委派的一个好处是比如加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象</p>
<ul>
<li>可以避免重复加载，父类已经加载了，子类就不需要再次加载</li>
<li>更加安全，很好的解决了各个类加载器的基础类的统一问题，如果不使用该种方式，那么用户可以随意定义类加载器来加载核心api，会带来相关隐患</li>
</ul>
<p><strong>每一个Java类都维护一个指向定义它的类加载器的引用，可以通过getClassLoader() 就可以获取父类加载器 </strong></p>
<p><strong>ExtentionClassLoader加载器的父类加载器返回Null，因为bootStrap 加载器是C++写的，并不存在这么一个java类的实体。但在逻辑上是它的父类加载器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassLoader classLoader = ClassLoaderDemo.class.getClassLoader();</span><br><span class="line">        <span class="keyword">while</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(classLoader.toString());</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 获取上一级的类加载器</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            classLoader = classLoader.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>委托机制</strong></p>
<p>类的加载工作由 <code>ClassLoader</code> 和其子类负责，JVM在运行时会产生三个 <code>ClassLoader</code>，默认使用 AppClassLoader 状态应用程序的类。Java装载类使用 <code>全盘委托机制</code></p>
<ul>
<li><strong>全盘负责</strong> 是指一个 <code>ClassLoader</code> 装载一个类时，除非显式的使用另外一个 <code>ClassLoader</code>，否则该类所依赖的类也都是由这个 <code>ClassLoader</code> 装入。</li>
<li><code>委托机制</code> 是先委托父类装载器寻找目标类，只有在找不到的情况下才从自己的子类装载器路径中查找并装载目标类</li>
</ul>
<p><strong>自定义加载类</strong></p>
<ul>
<li><p>JVM已经提供了默认的类加载器，但是有一些弊端，比如只能加载指定目录下的<code>jar包或者class文件</code>，如果我们想加载其它位置的 <code>jar或者class文件</code> 时，比如网络上的某 class通过动态加载到内存来使用，这样的场景默认的类加载器就不能给我们提供帮助了，所以就要自己定义 <code>ClassLoader</code>。</p></li>
<li><p>自定义类的加载器继承 <code>ClassLoader</code> 然后重写父类的<code>findClass方法</code>，之所以只重写这个方法是因为JDK已经在loadClass中帮我们使用了ClassLoader搜索类的算法，当在loadClass方法中找不到类时，loadClass方法就会调用findClass方法来搜索类</p></li>
</ul>
<p>定义方式：</p>
<p>（1）遵守双亲委派模型：继承ClassLoader，重写findClass()方法。</p>
<p>（2）破坏双亲委派模型：继承ClassLoader,重写loadClass()方法。 通常我们推荐采用第一种方法自定义类加载器，最大程度上的遵守双亲委派模型。</p>
<h2 id="反射">反射</h2>
<h3 id="定义">定义</h3>
<p>JAVA 反射机制指：在程序运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。Java程序可以加载一个运行时才得知名称的class，获悉其完整构造（但不包括methods定义），并生成其对象实体、或对其fields设值、或唤起其methods</p>
<h3 id="用途">用途</h3>
<p>某个类的某个成员变量、方法或是属性是私有的或是只对系统应用开放，这时候就可以利用Java的反射机制通过反射来获取所需的私有成员或是方法。</p>
<h3 id="获取类名三种方式">获取类名三种方式</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuyang.Reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过实例</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">Class cl = user.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过类，不常用</span></span><br><span class="line">Class cl = User.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Class.forName() </span></span><br><span class="line">Class cl = Class.forName(<span class="string">&quot;com.liuyang.Reflect.User&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="获取构造函数及成员变量">获取构造函数及成员变量</h3>
<p>设置User类，对其进行反射。并重写<code>to_String()</code>便于测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuyang.Reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">public</span> String email;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> age, String userName, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String course)</span> </span>&#123;</span><br><span class="line">        System.out.println(id + <span class="string">&quot; - &quot;</span> + userName + <span class="string">&quot;: &quot;</span> + password + <span class="string">&quot;学了: &quot;</span> + course);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Studying&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">study</span><span class="params">(String course)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Studying &quot;</span> + course);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Finished&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, userName=&#x27;&quot;</span> + userName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, password=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, email=&#x27;&quot;</span> + email + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过反射得到构造函数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据类名，得到类的对象</span></span><br><span class="line">Class cl = Class.forName(<span class="string">&quot;com.liuyang.Reflect.User&quot;</span>);</span><br><span class="line"><span class="comment">// 得到 所有 公有构造方法，返回构造数组</span></span><br><span class="line">Constructor[] constructors = cl.getConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">    System.out.println(constructor);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到指定构造方法</span></span><br><span class="line">Constructor publicConstructor = cl.getConstructor(<span class="keyword">int</span>.class, <span class="keyword">int</span>.class, String.class, String.class);</span><br><span class="line"><span class="comment">// 输入参数，实例化</span></span><br><span class="line">System.out.println(publicConstructor.newInstance(<span class="number">2</span>, <span class="number">12</span>, <span class="string">&quot;dd&quot;</span>, <span class="string">&quot;wdr3434rewf324234&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到所有的构造方法，包括私有方法</span></span><br><span class="line">Constructor[] constructors1 = cl.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor c : constructors1) &#123;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到私有的构造方法</span></span><br><span class="line">Constructor privateConstructor = cl.getDeclaredConstructor(<span class="keyword">int</span>.class);</span><br><span class="line"><span class="comment">// 设置访问权限</span></span><br><span class="line">privateConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line">System.out.println(privateConstructor.newInstance(<span class="number">210</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Output</span></span><br><span class="line"><span class="comment">public com.liuyang.Reflect.User(int,int,java.lang.String,java.lang.String)</span></span><br><span class="line"><span class="comment">public com.liuyang.Reflect.User()</span></span><br><span class="line"><span class="comment">-----------------------------------------------</span></span><br><span class="line"><span class="comment">User&#123;id=2, userName=&#x27;dd&#x27;, password=&#x27;wdr3434rewf324234&#x27;, email=&#x27;null&#x27;, age=12&#125;</span></span><br><span class="line"><span class="comment">-----------------------------------------------</span></span><br><span class="line"><span class="comment">public com.liuyang.Reflect.User(int,int,java.lang.String,java.lang.String)</span></span><br><span class="line"><span class="comment">private com.liuyang.Reflect.User(int)</span></span><br><span class="line"><span class="comment">public com.liuyang.Reflect.User()</span></span><br><span class="line"><span class="comment">-----------------------------------------------</span></span><br><span class="line"><span class="comment">User&#123;id=210, userName=&#x27;null&#x27;, password=&#x27;null&#x27;, email=&#x27;null&#x27;, age=0&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>获得public成员属性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到公有成员变量</span></span><br><span class="line">Field[] objects = cl.getFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : objects) &#123;</span><br><span class="line">    System.out.println(field);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到指定的 public 成员变量</span></span><br><span class="line">Field ageField = cl.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="comment">// 通过反射的方式获取 user.age --&gt;  age.user</span></span><br><span class="line">System.out.println(ageField.getInt(<span class="keyword">new</span> User(<span class="number">2</span>,<span class="number">13</span>,<span class="string">&quot;dwsd&quot;</span>,<span class="string">&quot;ded&quot;</span>)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">User&#123;id=210, userName=&#x27;null&#x27;, password=&#x27;null&#x27;, email=&#x27;null&#x27;, age=0&#125;</span></span><br><span class="line"><span class="comment">-----------------------------------------------</span></span><br><span class="line"><span class="comment">public java.lang.String com.liuyang.Reflect.User.email</span></span><br><span class="line"><span class="comment">public int com.liuyang.Reflect.User.age</span></span><br><span class="line"><span class="comment">-----------------------------------------------</span></span><br><span class="line"><span class="comment">13</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>获得所有成员属性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到全部成员变量属性</span></span><br><span class="line">Field[] allFields = cl.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field field: allFields)&#123;</span><br><span class="line">    System.out.println(field);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到指定私有成员变量属性</span></span><br><span class="line">Field userNameField = cl.getDeclaredField(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">userNameField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(userNameField.get(<span class="keyword">new</span> User(<span class="number">102</span>,<span class="number">18</span>,<span class="string">&quot;liuyang&quot;</span>,<span class="string">&quot;123456780&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">private int com.liuyang.Reflect.User.id</span></span><br><span class="line"><span class="comment">private java.lang.String com.liuyang.Reflect.User.userName</span></span><br><span class="line"><span class="comment">private java.lang.String com.liuyang.Reflect.User.password</span></span><br><span class="line"><span class="comment">public java.lang.String com.liuyang.Reflect.User.email</span></span><br><span class="line"><span class="comment">public int com.liuyang.Reflect.User.age</span></span><br><span class="line"><span class="comment">-----------------------------------------------</span></span><br><span class="line"><span class="comment">liuyang</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>反射获取成员方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 User 对象</span></span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="number">102</span>,<span class="number">18</span>, <span class="string">&quot;liuyang&quot;</span>,<span class="string">&quot;123456780&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// public 成员方法， 包括父类</span></span><br><span class="line">Method[] publicMethods = cl.getMethods();</span><br><span class="line"><span class="keyword">for</span> (Method method: publicMethods)&#123;</span><br><span class="line">System.out.println(method);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定成员方法</span></span><br><span class="line">Method showMethod = cl.getMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line">showMethod.invoke(user, <span class="string">&quot;数学&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得所有成员方法，不包括父类</span></span><br><span class="line">Method[] allMethods = cl.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span> (Method method:allMethods)</span><br><span class="line">System.out.println(method);</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得指定的 私有 成员方法</span></span><br><span class="line">Method studyMethod = cl.getDeclaredMethod(<span class="string">&quot;study&quot;</span>, String.class);</span><br><span class="line"><span class="comment">// 取得访问权限</span></span><br><span class="line">studyMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object re = studyMethod.invoke(user,<span class="string">&quot;数学&quot;</span>);</span><br><span class="line">System.out.println(re);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">public java.lang.String com.liuyang.Reflect.User.toString()</span></span><br><span class="line"><span class="comment">public void com.liuyang.Reflect.User.study()</span></span><br><span class="line"><span class="comment">public void com.liuyang.Reflect.User.show(java.lang.String)</span></span><br><span class="line"><span class="comment">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">public boolean java.lang.Object.equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">public native int java.lang.Object.hashCode()</span></span><br><span class="line"><span class="comment">public final native java.lang.Class java.lang.Object.getClass()</span></span><br><span class="line"><span class="comment">public final native void java.lang.Object.notify()</span></span><br><span class="line"><span class="comment">public final native void java.lang.Object.notifyAll()</span></span><br><span class="line"><span class="comment">-----------------------------------------------</span></span><br><span class="line"><span class="comment">102 - liuyang: 123456780学了: 数学</span></span><br><span class="line"><span class="comment">-----------------------------------------------</span></span><br><span class="line"><span class="comment">public java.lang.String com.liuyang.Reflect.User.toString()</span></span><br><span class="line"><span class="comment">public void com.liuyang.Reflect.User.study()</span></span><br><span class="line"><span class="comment">private java.lang.String com.liuyang.Reflect.User.study(java.lang.String)</span></span><br><span class="line"><span class="comment">public void com.liuyang.Reflect.User.show(java.lang.String)</span></span><br><span class="line"><span class="comment">-----------------------------------------------</span></span><br><span class="line"><span class="comment">Studying 数学</span></span><br><span class="line"><span class="comment">Finished</span></span><br></pre></td></tr></table></figure>
<h3 id="相关类">相关类</h3>
<table>
<thead>
<tr class="header">
<th>类名</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Class类</td>
<td>代表类的实体，在运行的Java应用程序中表示类和接口</td>
</tr>
<tr class="even">
<td>Field类</td>
<td>代表类的成员变量（成员变量也称为类的属性）</td>
</tr>
<tr class="odd">
<td>Method类</td>
<td>代表类的方法</td>
</tr>
<tr class="even">
<td>Constructor类</td>
<td>代表类的构造方法</td>
</tr>
</tbody>
</table>
<h4 id="class">class</h4>
<p>代表类的实体，在运行的Java应用程序中表示类和接口</p>
<ul>
<li><strong>获得类相关的方法</strong></li>
</ul>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>asSubclass(Class<U> clazz)</td>
<td>把传递的类的对象转换成代表其子类的对象</td>
</tr>
<tr class="even">
<td>Cast</td>
<td>把对象转换成代表类或是接口的对象</td>
</tr>
<tr class="odd">
<td>getClassLoader()</td>
<td>获得类的加载器</td>
</tr>
<tr class="even">
<td>getClasses()</td>
<td>返回一个数组，数组中包含该类中所有公共类和接口类的对象</td>
</tr>
<tr class="odd">
<td>getDeclaredClasses()</td>
<td>返回一个数组，数组中包含该类中所有类和接口类的对象</td>
</tr>
<tr class="even">
<td>forName(String className)</td>
<td>根据类名返回类的对象</td>
</tr>
<tr class="odd">
<td>getName()</td>
<td>获得类的完整路径名字</td>
</tr>
<tr class="even">
<td>newInstance()</td>
<td>创建类的实例</td>
</tr>
<tr class="odd">
<td>getPackage()</td>
<td>获得类的包</td>
</tr>
<tr class="even">
<td>getSimpleName()</td>
<td>获得类的名字</td>
</tr>
<tr class="odd">
<td>getSuperclass()</td>
<td>获得当前类继承的父类的名字</td>
</tr>
<tr class="even">
<td>getInterfaces()</td>
<td>获得当前类实现的类或是接口</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>获得类中属性相关的方法</strong></li>
</ul>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>getField(String name)</td>
<td>获得某个公有的属性对象</td>
</tr>
<tr class="even">
<td>getFields()</td>
<td>获得所有公有的属性对象</td>
</tr>
<tr class="odd">
<td>getDeclaredField(String name)</td>
<td>获得某个属性对象</td>
</tr>
<tr class="even">
<td>getDeclaredFields()</td>
<td>获得所有属性对象</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>获得类中注解相关的方法</strong></li>
</ul>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>getAnnotation(Class<A> annotationClass)</td>
<td>返回该类中与参数类型匹配的公有注解对象</td>
</tr>
<tr class="even">
<td>getAnnotations()</td>
<td>返回该类所有的公有注解对象</td>
</tr>
<tr class="odd">
<td>getDeclaredAnnotation(Class<A> annotationClass)</td>
<td>返回该类中与参数类型匹配的所有注解对象</td>
</tr>
<tr class="even">
<td>getDeclaredAnnotations()</td>
<td>返回该类所有的注解对象</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>获得类中构造器相关的方法</strong></li>
</ul>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>getConstructor(Class...&lt;?&gt; parameterTypes)</td>
<td>获得该类中与参数类型匹配的公有构造方法</td>
</tr>
<tr class="even">
<td>getConstructors()</td>
<td>获得该类的所有公有构造方法</td>
</tr>
<tr class="odd">
<td>getDeclaredConstructor(Class...&lt;?&gt; parameterTypes)</td>
<td>获得该类中与参数类型匹配的构造方法</td>
</tr>
<tr class="even">
<td>getDeclaredConstructors()</td>
<td>获得该类所有构造方法</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>获得类中方法相关的方法</strong></li>
</ul>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>getMethod(String name, Class...&lt;?&gt; parameterTypes)</td>
<td>获得该类某个公有的方法</td>
</tr>
<tr class="even">
<td>getMethods()</td>
<td>获得该类所有公有的方法</td>
</tr>
<tr class="odd">
<td>getDeclaredMethod(String name, Class...&lt;?&gt; parameterTypes)</td>
<td>获得该类某个方法</td>
</tr>
<tr class="even">
<td>getDeclaredMethods()</td>
<td>获得该类所有方法</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>类中其他重要的方法</strong></li>
</ul>
<table>
<tbody>
<tr class="odd">
<td></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第01章 准备工作</title>
    <url>/2019/04/09/%E7%AC%AC01%E7%AB%A0-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="第1章-准备工作">第1章 准备工作</h1>
<h2 id="本书的内容">1.1 本书的内容</h2>
<p>本书讲的是利用Python进行数据控制、处理、整理、分析等方面的具体细节和基本要点。我的目标是介绍Python编程和用于数据处理的库和工具环境，掌握这些，可以让你成为一个数据分析专家。虽然本书的标题是“数据分析”，重点却是Python编程、库，以及用于数据分析的工具。这就是数据分析要用到的Python编程。</p>
<span id="more"></span>
<h3 id="什么样的数据">什么样的数据？</h3>
<p>当书中出现“数据”时，究竟指的是什么呢？主要指的是结构化数据（structured data），这个故意含糊其辞的术语代指了所有通用格式的数据，例如：</p>
<ul>
<li>表格型数据，其中各列可能是不同的类型（字符串、数值、日期等）。比如保存在关系型数据库中或以制表符/逗号为分隔符的文本文件中的那些数据。</li>
<li>多维数组（矩阵）。</li>
<li>通过关键列（对于SQL用户而言，就是主键和外键）相互联系的多个表。</li>
<li>间隔平均或不平均的时间序列。</li>
</ul>
<p>这绝不是一个完整的列表。大部分数据集都能被转化为更加适合分析和建模的结构化形式，虽然有时这并不是很明显。如果不行的话，也可以将数据集的特征提取为某种结构化形式。例如，一组新闻文章可以被处理为一张词频表，而这张词频表就可以用于情感分析。</p>
<p>大部分电子表格软件（比如Microsoft Excel，它可能是世界上使用最广泛的数据分析工具了）的用户不会对此类数据感到陌生。</p>
<h2 id="为什么要使用python进行数据分析">1.2 为什么要使用Python进行数据分析</h2>
<p>许许多多的人（包括我自己）都很容易爱上Python这门语言。自从1991年诞生以来，Python现在已经成为最受欢迎的动态编程语言之一，其他还有Perl、Ruby等。由于拥有大量的Web框架（比如Rails（Ruby）和Django（Python）），自从2005年，使用Python和Ruby进行网站建设工作非常流行。这些语言常被称作脚本（scripting）语言，因为它们可以用于编写简短而粗糙的小程序（也就是脚本）。我个人并不喜欢“脚本语言”这个术语，因为它好像在说这些语言无法用于构建严谨的软件。在众多解释型语言中，由于各种历史和文化的原因，Python发展出了一个巨大而活跃的科学计算（scientific computing）社区。在过去的10年，Python从一个边缘或“自担风险”的科学计算语言，成为了数据科学、机器学习、学界和工业界软件开发最重要的语言之一。</p>
<p>在数据分析、交互式计算以及数据可视化方面，Python将不可避免地与其他开源和商业的领域特定编程语言/工具进行对比，如R、MATLAB、SAS、Stata等。近年来，由于Python的库（例如pandas和scikit-learn）不断改良，使其成为数据分析任务的一个优选方案。结合其在通用编程方面的强大实力，我们完全可以只使用Python这一种语言构建以数据为中心的应用。</p>
<h3 id="python作为胶水语言">Python作为胶水语言</h3>
<p>Python成为成功的科学计算工具的部分原因是，它能够轻松地集成C、C++以及Fortran代码。大部分现代计算环境都利用了一些Fortran和C库来实现线性代数、优选、积分、快速傅里叶变换以及其他诸如此类的算法。许多企业和国家实验室也利用Python来“粘合”那些已经用了多年的遗留软件系统。</p>
<p>大多数软件都是由两部分代码组成的：少量需要占用大部分执行时间的代码，以及大量不经常执行的“胶水代码”。大部分情况下，胶水代码的执行时间是微不足道的。开发人员的精力几乎都是花在优化计算瓶颈上面，有时更是直接转用更低级的语言（比如C）。</p>
<h3 id="解决两种语言问题">解决“两种语言”问题</h3>
<p>很多组织通常都会用一种类似于领域特定的计算语言（如SAS和R）对新想法做研究、原型构建和测试，然后再将这些想法移植到某个更大的生产系统中去（可能是用Java、C#或C++编写的）。人们逐渐意识到，Python不仅适用于研究和原型构建，同时也适用于构建生产系统。为什么一种语言就够了，却要使用两个语言的开发环境呢？我相信越来越多的企业也会这样看，因为研究人员和工程技术人员使用同一种编程工具将会给企业带来非常显著的组织效益。</p>
<h3 id="为什么不选python">为什么不选Python</h3>
<p>虽然Python非常适合构建分析应用以及通用系统，但它对不少应用场景适用性较差。</p>
<p>由于Python是一种解释型编程语言，因此大部分Python代码都要比用编译型语言（比如Java和C++）编写的代码运行慢得多。由于程序员的时间通常都比CPU时间值钱，因此许多人也愿意对此做一些取舍。但是，在那些延迟要求非常小或高资源利用率的应用中（例如高频交易系统），耗费时间使用诸如C++这样更低级、更低生产率的语言进行编程也是值得的。</p>
<p>对于高并发、多线程的应用程序而言（尤其是拥有许多计算密集型线程的应用程序），Python并不是一种理想的编程语言。这是因为Python有一个叫做全局解释器锁（Global Interpreter Lock，GIL）的组件，这是一种防止解释器同时执行多条Python字节码指令的机制。有关“为什么会存在GIL”的技术性原因超出了本书的范围。虽然很多大数据处理应用程序为了能在较短的时间内完成数据集的处理工作都需要运行在计算机集群上，但是仍然有一些情况需要用单进程多线程系统来解决。</p>
<p>这并不是说Python不能执行真正的多线程并行代码。例如，Python的C插件使用原生的C或C++的多线程，可以并行运行而不被GIL影响，只要它们不频繁地与Python对象交互。</p>
<h2 id="重要的python库">1.3 重要的Python库</h2>
<p>考虑到那些还不太了解Python科学计算生态系统和库的读者，下面我先对各个库做一个简单的介绍。</p>
<p>NumPy NumPy（Numerical Python的简称）是Python科学计算的基础包。本书大部分内容都基于NumPy以及构建于其上的库。它提供了以下功能（不限于此）：</p>
<ul>
<li><p>快速高效的多维数组对象ndarray。</p></li>
<li><p>用于对数组执行元素级计算以及直接对数组执行数学运算的函数。</p></li>
<li><p>用于读写硬盘上基于数组的数据集的工具。</p></li>
<li><p>线性代数运算、傅里叶变换，以及随机数生成。</p>
<p>-成熟的C API， 用于Python插件和原生C、C++、Fortran代码访问NumPy的数据结构和计算工具。</p></li>
</ul>
<p>除了为Python提供快速的数组处理能力，NumPy在数据分析方面还有另外一个主要作用，即作为在算法和库之间传递数据的容器。对于数值型数据，NumPy数组在存储和处理数据时要比内置的Python数据结构高效得多。此外，由低级语言（比如C和Fortran）编写的库可以直接操作NumPy数组中的数据，无需进行任何数据复制工作。因此，许多Python的数值计算工具要么使用NumPy数组作为主要的数据结构，要么可以与NumPy进行无缝交互操作。</p>
<h3 id="pandas">pandas</h3>
<p>pandas提供了快速便捷处理结构化数据的大量数据结构和函数。自从2010年出现以来，它助使Python成为强大而高效的数据分析环境。本书用得最多的pandas对象是DataFrame，它是一个面向列（column-oriented）的二维表结构，另一个是Series，一个一维的标签化数组对象。</p>
<p>pandas兼具NumPy高性能的数组计算功能以及电子表格和关系型数据库（如SQL）灵活的数据处理功能。它提供了复杂精细的索引功能，能更加便捷地完成重塑、切片和切块、聚合以及选取数据子集等操作。因为数据操作、准备、清洗是数据分析最重要的技能，pandas是本书的重点。</p>
<p>作为背景，我是在2008年初开始开发pandas的，那时我任职于AQR Capital Management，一家量化投资管理公司，我有许多工作需求都不能用任何单一的工具解决：</p>
<ul>
<li>有标签轴的数据结构，支持自动或清晰的数据对齐。这可以防止由于数据不对齐，或处理来源不同的索引不同的数据，所造成的错误。</li>
<li>集成时间序列功能。</li>
<li>相同的数据结构用于处理时间序列数据和非时间序列数据。</li>
<li>保存元数据的算术运算和压缩。</li>
<li>灵活处理缺失数据。</li>
<li>合并和其它流行数据库（例如基于SQL的数据库）的关系操作。</li>
</ul>
<p>我想只用一种工具就实现所有功能，并使用通用软件开发语言。Python是一个不错的候选语言，但是此时没有集成的数据结构和工具来实现。我一开始就是想把pandas设计为一款适用于金融和商业分析的工具，pandas专注于深度时间序列功能和工具，适用于时间索引化的数据。</p>
<p>对于使用R语言进行统计计算的用户，肯定不会对DataFrame这个名字感到陌生，因为它源自于R的data.frame对象。但与Python不同，data frames是构建于R和它的标准库。因此，pandas的许多功能不属于R或它的扩展包。</p>
<p>pandas这个名字源于panel data（面板数据，这是多维结构化数据集在计量经济学中的术语）以及Python data analysis（Python数据分析）。</p>
<h3 id="matplotlib">matplotlib</h3>
<p>matplotlib是最流行的用于绘制图表和其它二维数据可视化的Python库。它最初由John D.Hunter（JDH）创建，目前由一个庞大的开发团队维护。它非常适合创建出版物上用的图表。虽然还有其它的Python可视化库，matplotlib却是使用最广泛的，并且它和其它生态工具配合也非常完美。我认为，可以使用它作为默认的可视化工具。</p>
<h3 id="ipython和jupyter">IPython和Jupyter</h3>
<p>IPython项目起初是Fernando Pérez在2001年的一个用以加强和Python交互的子项目。在随后的16年中，它成为了Python数据栈最重要的工具之一。虽然IPython本身没有提供计算和数据分析的工具，它却可以大大提高交互式计算和软件开发的生产率。IPython鼓励“执行-探索”的工作流，区别于其它编程软件的“编辑-编译-运行”的工作流。它还可以方便地访问系统的shell和文件系统。因为大部分的数据分析代码包括探索、试错和重复，IPython可以使工作更快。</p>
<p>2014年，Fernando和IPython团队宣布了Jupyter项目，一个更宽泛的多语言交互计算工具的计划。IPython web notebook变成了Jupyter notebook，现在支持40种编程语言。IPython现在可以作为Jupyter使用Python的内核（一种编程语言模式）。</p>
<p>IPython变成了Jupyter庞大开源项目（一个交互和探索式计算的高效环境）中的一个组件。它最老也是最简单的模式，现在是一个用于编写、测试、调试Python代码的强化shell。你还可以使用通过Jupyter Notebook，一个支持多种语言的交互式网络代码“笔记本”，来使用IPython。IPython shell 和Jupyter notebooks特别适合进行数据探索和可视化。</p>
<p>Jupyter notebooks还可以编写Markdown和HTML内容，它提供了一种创建代码和文本的富文本方法。其它编程语言也在Jupyter中植入了内核，好让在Jupyter中可以使用Python以外的语言。</p>
<p>对我个人而言，我的大部分Python工作都要用到IPython，包括运行、调试和测试代码。</p>
<p>在本书的GitHub页面，你可以找到包含各章节所有代码实例的Jupyter notebooks。</p>
<h3 id="scipy">SciPy</h3>
<p>SciPy是一组专门解决科学计算中各种标准问题域的包的集合，主要包括下面这些包：</p>
<ul>
<li>scipy.integrate：数值积分例程和微分方程求解器。</li>
<li>scipy.linalg：扩展了由numpy.linalg提供的线性代数例程和矩阵分解功能。</li>
<li>scipy.optimize：函数优化器（最小化器）以及根查找算法。</li>
<li>scipy.signal：信号处理工具。</li>
<li>scipy.sparse：稀疏矩阵和稀疏线性系统求解器。</li>
<li>scipy.special：SPECFUN（这是一个实现了许多常用数学函数（如伽玛函数）的Fortran库）的包装器。</li>
<li>scipy.stats：标准连续和离散概率分布（如密度函数、采样器、连续分布函数等）、各种统计检验方法，以及更好的描述统计法。</li>
</ul>
<p>NumPy和SciPy结合使用，便形成了一个相当完备和成熟的计算平台，可以处理多种传统的科学计算问题。</p>
<h3 id="scikit-learn">scikit-learn</h3>
<p>2010年诞生以来，scikit-learn成为了Python的通用机器学习工具包。仅仅七年，就汇聚了全世界超过1500名贡献者。它的子模块包括：</p>
<ul>
<li>分类：SVM、近邻、随机森林、逻辑回归等等。</li>
<li>回归：Lasso、岭回归等等。</li>
<li>聚类：k-均值、谱聚类等等。</li>
<li>降维：PCA、特征选择、矩阵分解等等。</li>
<li>选型：网格搜索、交叉验证、度量。</li>
<li>预处理：特征提取、标准化。</li>
</ul>
<p>与pandas、statsmodels和IPython一起，scikit-learn对于Python成为高效数据科学编程语言起到了关键作用。虽然本书不会详细讲解scikit-learn，我会简要介绍它的一些模型，以及用其它工具如何使用这些模型。</p>
<h3 id="statsmodels">statsmodels</h3>
<p>statsmodels是一个统计分析包，起源于斯坦福大学统计学教授Jonathan Taylor，他设计了多种流行于R语言的回归分析模型。Skipper Seabold和Josef Perktold在2010年正式创建了statsmodels项目，随后汇聚了大量的使用者和贡献者。受到R的公式系统的启发，Nathaniel Smith发展出了Patsy项目，它提供了statsmodels的公式或模型的规范框架。</p>
<p>与scikit-learn比较，statsmodels包含经典统计学和经济计量学的算法。包括如下子模块：</p>
<ul>
<li>回归模型：线性回归，广义线性模型，健壮线性模型，线性混合效应模型等等。</li>
<li>方差分析（ANOVA）。</li>
<li>时间序列分析：AR，ARMA，ARIMA，VAR和其它模型。</li>
<li>非参数方法： 核密度估计，核回归。</li>
<li>统计模型结果可视化。</li>
</ul>
<p>statsmodels更关注与统计推断，提供不确定估计和参数p-值。相反的，scikit-learn注重预测。</p>
<p>同scikit-learn一样，我也只是简要介绍statsmodels，以及如何用NumPy和pandas使用它。</p>
<h2 id="安装和设置">1.4 安装和设置</h2>
<p>由于人们用Python所做的事情不同，所以没有一个普适的Python及其插件包的安装方案。由于许多读者的Python科学计算环境都不能完全满足本书的需要，所以接下来我将详细介绍各个操作系统上的安装方法。我推荐免费的Anaconda安装包。写作本书时，Anaconda提供Python 2.7和3.6两个版本，以后可能发生变化。本书使用的是Python 3.6，因此推荐选择Python 3.6或更高版本。</p>
<h3 id="windows">Windows</h3>
<p>要在Windows上运行，先下载<a href="https://www.anaconda.com/download/">Anaconda安装包</a>。推荐跟随Anaconda下载页面的Windows安装指导，安装指导在写作本书和读者看到此文的的这段时间内可能发生变化。</p>
<p>现在，来确认设置是否正确。打开命令行窗口（<code>cmd.exe</code>），输入<code>python</code>以打开Python解释器。可以看到类似下面的Anaconda版本的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\wesm&gt;python</span><br><span class="line">Python 3.5.2 |Anaconda 4.1.1 (64-bit)| (default, Jul  5 2016, 11:41:13)</span><br><span class="line">[MSC v.1900 64 bit (AMD64)] on win32</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>要退出shell，按Ctrl-D（Linux或macOS上），Ctrl-Z（Windows上），或输入命令<code>exit()</code>，再按Enter。</p>
<h3 id="apple-os-x-macos">Apple (OS X, macOS)</h3>
<p>下载OS X Anaconda安装包，它的名字类似Anaconda3-4.1.0-MacOSX-x86_64.pkg。双击.pkg文件，运行安装包。安装包运行时，会自动将Anaconda执行路径添加到<code>.bash_profile</code>文件，它位于<code>/Users/$USER/.bash_profile</code>。</p>
<p>为了确认成功，在系统shell打开IPython： $ ipython</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">要退出shell，按Ctrl-D，或输入命令`exit()`，再按Enter。</span><br><span class="line"></span><br><span class="line">### GNU/Linux</span><br><span class="line"></span><br><span class="line">Linux版本很多，这里给出Debian、Ubantu、CentOS和Fedora的安装方法。安装包是一个脚本文件，必须在shell中运行。取决于系统是32位还是64位，要么选择x86 \(32位\)或x86\_64 \(64位\)安装包。随后你会得到一个文件，名字类似于`Anaconda3-4.1.0-Linux-x86_64.sh`。用bash进行安装：</span><br><span class="line"></span><br><span class="line">​```text</span><br><span class="line">$ bash Anaconda3-4.1.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：某些Linux版本在包管理器中有满足需求的Python包，只需用类似apt的工具安装就行。这里讲的用Anaconda安装，适用于不同的Linux安装包，也很容易将包升级到最新版本。</p>
</blockquote>
<p>接受许可之后，会向你询问在哪里放置Anaconda的文件。我推荐将文件安装到默认的home目录，例如<code>/home/$USER/anaconda</code>。</p>
<p>Anaconda安装包可能会询问你是否将<code>bin/</code>目录添加到<code>$PATH</code>变量。如果在安装之后有任何问题，你可以修改文件<code>.bashrc</code>（或<code>.zshrc</code>，如果使用的是zsh shell）为类似以下的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/home/$USER/anaconda/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>做完之后，你可以开启一个新窗口，或再次用<code>~/.bashrc</code>执行<code>.bashrc</code>。</p>
<h3 id="安装或升级python包">安装或升级Python包</h3>
<p>在你阅读本书的时候，你可能想安装另外的不在Anaconda中的Python包。通常，可以用以下命令安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install package_name</span><br></pre></td></tr></table></figure>
<p>如果这个命令不行，也可以用pip包管理工具：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install package_name</span><br></pre></td></tr></table></figure>
<p>你可以用<code>conda update</code>命令升级包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda update package_name</span><br></pre></td></tr></table></figure>
<p>pip可以用<code>--upgrade</code>升级：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install --upgrade package_name</span><br></pre></td></tr></table></figure>
<p>本书中，你有许多机会尝试这些命令。</p>
<blockquote>
<p>注意：当你使用conda和pip二者安装包时，千万不要用pip升级conda的包，这样会导致环境发生问题。当使用Anaconda或Miniconda时，最好首先使用conda进行升级。</p>
</blockquote>
<p>Python 2 和 Python 3</p>
<p>第一版的Python 3.x出现于2008年。它有一系列的变化，与之前的Python 2.x代码有不兼容的地方。因为从1991年Python出现算起，已经过了17年，Python 3 的出现被视为吸取一些列教训的更优结果。</p>
<p>2012年，因为许多包还没有完全支持Python 3，许多科学和数据分析社区还是在使用Python 2.x。因此，本书第一版使用的是Python 2.7。现在，用户可以在Python 2.x和Python 3.x间自由选择，二者都有良好的支持。</p>
<p>但是，Python 2.x在2020年就会到期（包括重要的安全补丁），因此再用Python 2.7就不是好的选择了。因此，本书使用了Python 3.6，这一广泛使用、支持良好的稳定版本。我们已经称Python 2.x为“遗留版本”，简称Python 3.x为“Python”。我建议你也是如此。</p>
<p>本书基于Python 3.6。你的Python版本也许高于3.6，但是示例代码应该是向前兼容的。一些示例代码可能在Python 2.7上有所不同，或完全不兼容。</p>
<h3 id="集成开发环境ides和文本编辑器">集成开发环境（IDEs）和文本编辑器</h3>
<p>当被问到我的标准开发环境，我几乎总是回答“IPython加文本编辑器”。我通常在编程时，反复在IPython或Jupyter notebooks中测试和调试每条代码。也可以交互式操作数据，和可视化验证数据操作中某一特殊集合。在shell中使用pandas和NumPy也很容易。</p>
<p>但是，当创建软件时，一些用户可能更想使用特点更为丰富的IDE，而不仅仅是原始的Emacs或Vim的文本编辑器。以下是一些IDE：</p>
<ul>
<li>PyDev（免费），基于Eclipse平台的IDE；</li>
<li>JetBrains的PyCharm（商业用户需要订阅，开源开发者免费）；</li>
<li>Visual Studio（Windows用户）的Python Tools；</li>
<li>Spyder（免费），Anaconda附带的IDE；</li>
<li>Komodo IDE（商业）。</li>
</ul>
<p>因为Python的流行，大多数文本编辑器，比如Atom和Sublime Text 3，对Python的支持也非常好。</p>
<h2 id="社区和会议">1.5 社区和会议</h2>
<p>除了在网上搜索，各式各样的科学和数据相关的Python邮件列表是非常有帮助的，很容易获得回答。包括：</p>
<ul>
<li>pydata：一个Google群组列表，用以回答Python数据分析和pandas的问题；</li>
<li>pystatsmodels： statsmodels或pandas相关的问题；</li>
<li>scikit-learn和Python机器学习邮件列表，scikit-learn@python.org；</li>
<li>numpy-discussion：和NumPy相关的问题；</li>
<li>scipy-user：SciPy和科学计算的问题；</li>
</ul>
<p>因为这些邮件列表的URLs可以很容易搜索到，但因为可能发生变化，所以没有给出。</p>
<p>每年，世界各地会举办许多Python开发者大会。如果你想结识其他有相同兴趣的人，如果可能的话，我建议你去参加一个。许多会议会对无力支付入场费和差旅费的人提供财力帮助。下面是一些会议：</p>
<ul>
<li>PyCon和EuroPython：北美和欧洲的两大Python会议；</li>
<li>SciPy和EuroSciPy：北美和欧洲两大面向科学计算的会议；</li>
<li>PyData：世界范围内，一些列的地区性会议，专注数据科学和数据分析；</li>
<li>国际和地区的PyCon会议（<a href="http://pycon.org有完整列表）">http://pycon.org有完整列表）</a> 。</li>
</ul>
<h2 id="本书导航">1.6 本书导航</h2>
<p>如果之前从未使用过Python，那你可能需要先看看本书的第2章和第3章，我简要介绍了Python的特点，IPython和Jupyter notebooks。这些知识是为本书后面的内容做铺垫。如果你已经掌握Python，可以选择跳过。</p>
<p>接下来，简单地介绍了NumPy的关键特性，附录A中是更高级的NumPy功能。然后，我介绍了pandas，本书剩余的内容全部是使用pandas、NumPy和matplotlib处理数据分析的问题。我已经尽量让全书的结构循序渐进，但偶尔会有章节之间的交叉，有时用到的概念还没有介绍过。</p>
<p>尽管读者各自的工作任务不同，大体可以分为几类：</p>
<ul>
<li><p>与外部世界交互</p>
<p>阅读编写多种文件格式和数据存储；</p></li>
<li><p>数据准备</p>
<p>清洗、修改、结合、标准化、重塑、切片、切割、转换数据，以进行分析；</p></li>
<li><p>转换数据</p>
<p>对旧的数据集进行数学和统计操作，生成新的数据集（例如，通过各组变量聚类成大的表）；</p></li>
<li><p>建模和计算</p>
<p>将数据绑定统计模型、机器学习算法、或其他计算工具；</p></li>
<li><p>展示</p>
<p>创建交互式和静态的图表可视化和文本总结。</p></li>
</ul>
<h3 id="代码示例">代码示例</h3>
<p>本书大部分代码示例的输入形式和输出结果都会按照其在IPython shell或Jupyter notebooks中执行时的样子进行排版：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [5]: CODE EXAMPLE</span><br><span class="line">Out[5]: OUTPUT</span><br></pre></td></tr></table></figure>
<p>但你看到类似的示例代码，就是让你在<code>in</code>的部分输入代码，按Enter键执行（Jupyter中是按Shift-Enter）。然后就可以在<code>out</code>看到输出。</p>
<h3 id="示例数据">示例数据</h3>
<p>各章的示例数据都存放在GitHub上：<a href="http://github.com/pydata/pydata-book。">http://github.com/pydata/pydata-book。</a> 下载这些数据的方法有二：使用git版本控制命令行程序；直接从网站上下载该GitHub库的zip文件。如果遇到了问题，可以到我的个人主页，<a href="http://wesmckinney.com/，">http://wesmckinney.com/，</a> 获取最新的指导。</p>
<p>为了让所有示例都能重现，我已经尽我所能使其包含所有必需的东西，但仍然可能会有一些错误或遗漏。如果出现这种情况的话，请给我发邮件：wesmckinn@gmail.com。报告本书错误的最好方法是O’Reilly的errata页面，<a href="http://www.bit.ly/pyDataAnalysis_errata。">http://www.bit.ly/pyDataAnalysis_errata。</a></p>
<h3 id="引入惯例">引入惯例</h3>
<p>Python社区已经广泛采取了一些常用模块的命名惯例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> statsmodels <span class="keyword">as</span> sm</span><br></pre></td></tr></table></figure>
<p>也就是说，当你看到np.arange时，就应该想到它引用的是NumPy中的arange函数。这样做的原因是：在Python软件开发过程中，不建议直接引入类似NumPy这种大型库的全部内容（from numpy import *）。</p>
<h3 id="行话">行话</h3>
<p>由于你可能不太熟悉书中使用的一些有关编程和数据科学方面的常用术语，所以我在这里先给出其简单定义：</p>
<p>数据规整（Munge/Munging/Wrangling） 指的是将非结构化和（或）散乱数据处理为结构化或整洁形式的整个过程。这几个词已经悄悄成为当今数据黑客们的行话了。Munge这个词跟Lunge押韵。</p>
<p>伪码（Pseudocode） 算法或过程的“代码式”描述，而这些代码本身并不是实际有效的源代码。</p>
<p>语法糖（Syntactic sugar） 这是一种编程语法，它并不会带来新的特性，但却能使代码更易读、更易写。</p>
]]></content>
      <categories>
        <category>Python 数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>第02章 Python语法基础</title>
    <url>/2019/04/09/%E7%AC%AC02%E7%AB%A0-Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="第2章-python语法基础ipython和jupyter-notebooks">第2章 Python语法基础，IPython和Jupyter Notebooks</h1>
<p>当我在2011年和2012年写作本书的第一版时，可用的学习Python数据分析的资源很少。这部分上是一个鸡和蛋的问题：我们现在使用的库，比如pandas、scikit-learn和statsmodels，那时相对来说并不成熟。2017年，数据科学、数据分析和机器学习的资源已经很多，原来通用的科学计算拓展到了计算机科学家、物理学家和其它研究领域的工作人员。学习Python和成为软件工程师的优秀书籍也有了。</p>
<span id="more"></span>
<p>因为这本书是专注于Python数据处理的，对于一些Python的数据结构和库的特性难免不足。因此，本章和第3章的内容只够你能学习本书后面的内容。</p>
<p>在我来看，没有必要为了数据分析而去精通Python。我鼓励你使用IPython shell和Jupyter试验示例代码，并学习不同类型、函数和方法的文档。虽然我已尽力让本书内容循序渐进，但读者偶尔仍会碰到没有之前介绍过的内容。</p>
<p>本书大部分内容关注的是基于表格的分析和处理大规模数据集的数据准备工具。为了使用这些工具，必须首先将混乱的数据规整为整洁的表格（或结构化）形式。幸好，Python是一个理想的语言，可以快速整理数据。Python使用得越熟练，越容易准备新数据集以进行分析。</p>
<p>最好在IPython和Jupyter中亲自尝试本书中使用的工具。当你学会了如何启动Ipython和Jupyter，我建议你跟随示例代码进行练习。与任何键盘驱动的操作环境一样，记住常见的命令也是学习曲线的一部分。</p>
<blockquote>
<p>笔记：本章没有介绍Python的某些概念，如类和面向对象编程，你可能会发现它们在Python数据分析中很有用。 为了加强Python知识，我建议你学习官方Python教程，<a href="https://docs.python.org/3/，或是通用的Python教程书籍，比如：">https://docs.python.org/3/，或是通用的Python教程书籍，比如：</a></p>
<ul>
<li>Python Cookbook，第3版，David Beazley和Brian K. Jones著（O’Reilly）</li>
<li>流畅的Python，Luciano Ramalho著 (O’Reilly)</li>
<li>高效的Python，Brett Slatkin著 (Pearson)</li>
</ul>
</blockquote>
<h2 id="python解释器">2.1 Python解释器</h2>
<p>Python是解释性语言。Python解释器同一时间只能运行一个程序的一条语句。标准的交互Python解释器可以在命令行中通过键入<code>python</code>命令打开：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python</span><br><span class="line">Python 3.6.0 | packaged by conda-forge | (default, Jan 13 2017, 23:17:12)</span><br><span class="line">[GCC 4.8.2 20140120 (Red Hat 4.8.2-15)] on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; a = 5</span><br><span class="line">&gt;&gt;&gt; print(a)</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p><code>&gt;&gt;&gt;</code>提示输入代码。要退出Python解释器返回终端，可以输入<code>exit()</code>或按Ctrl-D。</p>
<p>运行Python程序只需调用Python的同时，使用一个<code>.py</code>文件作为它的第一个参数。假设创建了一个<code>hello_world.py</code>文件，它的内容是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello world&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>你可以用下面的命令运行它（<code>hello_world.py</code>文件必须位于终端的工作目录）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python hello_world.py</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>
<p>一些Python程序员总是这样执行Python代码的，从事数据分析和科学计算的人却会使用IPython，一个强化的Python解释器，或Jupyter notebooks，一个网页代码笔记本，它原先是IPython的一个子项目。在本章中，我介绍了如何使用IPython和Jupyter，在附录A中有更深入的介绍。当你使用<code>%run</code>命令，IPython会同样执行指定文件中的代码，结束之后，还可以与结果交互：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ipython</span><br><span class="line">Python 3.6.0 | packaged by conda-forge | (default, Jan 13 2017, 23:17:12)</span><br><span class="line">Type &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line"></span><br><span class="line">IPython 5.1.0 -- An enhanced Interactive Python.</span><br><span class="line">?         -&gt; Introduction and overview of IPython&#x27;s features.</span><br><span class="line">%quickref -&gt; Quick reference.</span><br><span class="line">help      -&gt; Python&#x27;s own help system.</span><br><span class="line">object?   -&gt; Details about &#x27;object&#x27;, use &#x27;object??&#x27; for extra details.</span><br><span class="line"></span><br><span class="line">In [1]: %run hello_world.py</span><br><span class="line">Hello world</span><br><span class="line"></span><br><span class="line">In [2]:</span><br></pre></td></tr></table></figure>
<p>IPython默认采用序号的格式<code>In [2]:</code>，与标准的<code>&gt;&gt;&gt;</code>提示符不同。</p>
<h2 id="ipython基础">2.2 IPython基础</h2>
<p>在本节中，我们会教你打开运行IPython shell和jupyter notebook，并介绍一些基本概念。</p>
<h3 id="运行ipython-shell">运行IPython Shell</h3>
<p>你可以用<code>ipython</code>在命令行打开IPython Shell，就像打开普通的Python解释器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ipython</span><br><span class="line">Python 3.6.0 | packaged by conda-forge | (default, Jan 13 2017, 23:17:12)</span><br><span class="line">Type &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line"></span><br><span class="line">IPython 5.1.0 -- An enhanced Interactive Python.</span><br><span class="line">?         -&gt; Introduction and overview of IPython&#x27;s features.</span><br><span class="line">%quickref -&gt; Quick reference.</span><br><span class="line">help      -&gt; Python&#x27;s own help system.</span><br><span class="line">object?   -&gt; Details about &#x27;object&#x27;, use &#x27;object??&#x27; for extra details.</span><br><span class="line"></span><br><span class="line">In [1]: a = 5</span><br><span class="line">In [2]: a</span><br><span class="line">Out[2]: 5</span><br></pre></td></tr></table></figure>
<p>你可以通过输入代码并按Return（或Enter），运行任意Python语句。当你只输入一个变量，它会显示代表的对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">5</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: data = &#123;i : np.random.randn() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>)&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: data</span><br><span class="line">Out[<span class="number">7</span>]: </span><br><span class="line">&#123;<span class="number">0</span>: -<span class="number">0.20470765948471295</span>,</span><br><span class="line"> <span class="number">1</span>: <span class="number">0.47894333805754824</span>,</span><br><span class="line"> <span class="number">2</span>: -<span class="number">0.5194387150567381</span>,</span><br><span class="line"> <span class="number">3</span>: -<span class="number">0.55573030434749</span>,</span><br><span class="line"> <span class="number">4</span>: <span class="number">1.9657805725027142</span>,</span><br><span class="line"> <span class="number">5</span>: <span class="number">1.3934058329729904</span>,</span><br><span class="line"><span class="number">6</span>: <span class="number">0.09290787674371767</span>&#125;</span><br></pre></td></tr></table></figure>
<p>前两行是Python代码语句；第二条语句创建一个名为<code>data</code>的变量，它引用一个新创建的Python字典。最后一行打印<code>data</code>的值。</p>
<p>许多Python对象被格式化为更易读的形式，或称作<code>pretty-printed</code>，它与普通的<code>print</code>不同。如果在标准Python解释器中打印上述<code>data</code>变量，则可读性要降低：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from numpy.random import randn</span><br><span class="line">&gt;&gt;&gt; data = &#123;i : randn() for i in range(7)&#125;</span><br><span class="line">&gt;&gt;&gt; print(data)</span><br><span class="line">&#123;0: -1.5948255432744511, 1: 0.10569006472787983, 2: 1.972367135977295,</span><br><span class="line">3: 0.15455217573074576, 4: -0.24058577449429575, 5: -1.2904897053651216,</span><br><span class="line">6: 0.3308507317325902&#125;</span><br></pre></td></tr></table></figure>
<p>IPython还支持执行任意代码块（通过一个华丽的复制-粘贴方法）和整段Python脚本的功能。你也可以使用Jupyter notebook运行大代码块，接下来就会看到。</p>
<h3 id="运行jupyter-notebook">运行Jupyter Notebook</h3>
<p>notebook是Jupyter项目的重要组件之一，它是一个代码、文本（有标记或无标记）、数据可视化或其它输出的交互式文档。Jupyter Notebook需要与内核互动，内核是Jupyter与其它编程语言的交互编程协议。Python的Jupyter内核是使用IPython。要启动Jupyter，在命令行中输入<code>jupyter notebook</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ jupyter notebook</span><br><span class="line">[I 15:20:52.739 NotebookApp] Serving notebooks from local directory:</span><br><span class="line">/home/wesm/code/pydata-book</span><br><span class="line">[I 15:20:52.739 NotebookApp] 0 active kernels</span><br><span class="line">[I 15:20:52.739 NotebookApp] The Jupyter Notebook is running at:</span><br><span class="line">http://localhost:8888/</span><br><span class="line">[I 15:20:52.740 NotebookApp] Use Control-C to stop this server and shut down</span><br><span class="line">all kernels (twice to skip confirmation).</span><br><span class="line">Created new window in existing browser session.</span><br></pre></td></tr></table></figure>
<p>在多数平台上，Jupyter会自动打开默认的浏览器（除非指定了<code>--no-browser</code>）。或者，可以在启动notebook之后，手动打开网页<code>http://localhost:8888/</code>。图2-1展示了Google Chrome中的notebook。</p>
<blockquote>
<p>笔记：许多人使用Jupyter作为本地的计算环境，但它也可以部署到服务器上远程访问。这里不做介绍，如果需要的话，鼓励读者自行到网上学习。</p>
</blockquote>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-c76c4f40777d3ef1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2-1 Jupyter notebook启动页面" /><figcaption aria-hidden="true">图2-1 Jupyter notebook启动页面</figcaption>
</figure>
<p>要新建一个notebook，点击按钮New，选择“Python3”或“conda[默认项]”。如果是第一次，点击空格，输入一行Python代码。然后按Shift-Enter执行。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-86a6813291ead445.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2-2 Jupyter新notebook页面" /><figcaption aria-hidden="true">图2-2 Jupyter新notebook页面</figcaption>
</figure>
<p>当保存notebook时（File目录下的Save and Checkpoint），会创建一个后缀名为<code>.ipynb</code>的文件。这是一个自包含文件格式，包含当前笔记本中的所有内容（包括所有已评估的代码输出）。可以被其它Jupyter用户加载和编辑。要加载存在的notebook，把它放到启动notebook进程的相同目录内。你可以用本书的示例代码练习，见图2-3。</p>
<p>虽然Jupyter notebook和IPython shell使用起来不同，本章中几乎所有的命令和工具都可以通用。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-bc9a0b4c30363747.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2-3 Jupyter查看一个存在的notebook的页面" /><figcaption aria-hidden="true">图2-3 Jupyter查看一个存在的notebook的页面</figcaption>
</figure>
<h3 id="tab补全">Tab补全</h3>
<p>从外观上，IPython shell和标准的Python解释器只是看起来不同。IPython shell的进步之一是具备其它IDE和交互计算分析环境都有的tab补全功能。在shell中输入表达式，按下Tab，会搜索已输入变量（对象、函数等等）的命名空间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [1]: an_apple = 27</span><br><span class="line"></span><br><span class="line">In [2]: an_example = 42</span><br><span class="line"></span><br><span class="line">In [3]: an&lt;Tab&gt;</span><br><span class="line">an_apple    and         an_example  any</span><br></pre></td></tr></table></figure>
<p>在这个例子中，IPython呈现出了之前两个定义的变量和Python的关键字和内建的函数<code>any</code>。当然，你也可以补全任何对象的方法和属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [3]: b = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">In [4]: b.&lt;Tab&gt;</span><br><span class="line">b.append  b.count   b.insert  b.reverse</span><br><span class="line">b.clear   b.extend  b.pop     b.sort</span><br><span class="line">b.copy    b.index   b.remove</span><br></pre></td></tr></table></figure>
<p>同样也适用于模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [1]: import datetime</span><br><span class="line"></span><br><span class="line">In [2]: datetime.&lt;Tab&gt;</span><br><span class="line">datetime.date          datetime.MAXYEAR       datetime.timedelta</span><br><span class="line">datetime.datetime      datetime.MINYEAR       datetime.timezone</span><br><span class="line">datetime.datetime_CAPI datetime.time          datetime.tzinfo</span><br></pre></td></tr></table></figure>
<p>在Jupyter notebook和新版的IPython（5.0及以上），自动补全功能是下拉框的形式。</p>
<blockquote>
<p>笔记：注意，默认情况下，IPython会隐藏下划线开头的方法和属性，比如魔术方法和内部的“私有”方法和属性，以避免混乱的显示（和让新手迷惑！）这些也可以tab补全，但是你必须首先键入一个下划线才能看到它们。如果你喜欢总是在tab补全中看到这样的方法，你可以IPython配置中进行设置。可以在IPython文档中查找方法。</p>
</blockquote>
<p>除了补全命名、对象和模块属性，Tab还可以补全其它的。当输入看似文件路径时（即使是Python字符串），按下Tab也可以补全电脑上对应的文件信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [7]: datasets/movielens/&lt;Tab&gt;</span><br><span class="line">datasets/movielens/movies.dat    datasets/movielens/README</span><br><span class="line">datasets/movielens/ratings.dat   datasets/movielens/users.dat</span><br><span class="line"></span><br><span class="line">In [7]: path = &#x27;datasets/movielens/&lt;Tab&gt;</span><br><span class="line">datasets/movielens/movies.dat    datasets/movielens/README</span><br><span class="line">datasets/movielens/ratings.dat   datasets/movielens/users.dat</span><br></pre></td></tr></table></figure>
<p>结合<code>%run</code>，tab补全可以节省许多键盘操作。</p>
<p>另外，tab补全可以补全函数的关键词参数（包括等于号=）。见图2-4。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-8188b0386238c16a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2-4 Jupyter notebook中自动补全函数关键词" /><figcaption aria-hidden="true">图2-4 Jupyter notebook中自动补全函数关键词</figcaption>
</figure>
<p>后面会仔细地学习函数。</p>
<h3 id="自省">自省</h3>
<p>在变量前后使用问号？，可以显示对象的信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">8</span>]: b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: b?</span><br><span class="line"><span class="type">Type</span>:       <span class="built_in">list</span></span><br><span class="line">String Form:[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">Length:     <span class="number">3</span></span><br><span class="line">Docstring:</span><br><span class="line"><span class="built_in">list</span>() -&gt; new empty <span class="built_in">list</span></span><br><span class="line"><span class="built_in">list</span>(iterable) -&gt; new <span class="built_in">list</span> initialized <span class="keyword">from</span> iterable<span class="string">&#x27;s items</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">In [10]: print?</span></span><br><span class="line"><span class="string">Docstring:</span></span><br><span class="line"><span class="string">print(value, ..., sep=&#x27;</span> <span class="string">&#x27;, end=&#x27;</span>\n<span class="string">&#x27;, file=sys.stdout, flush=False)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Prints the values to a stream, or to sys.stdout by default.</span></span><br><span class="line"><span class="string">Optional keyword arguments:</span></span><br><span class="line"><span class="string">file:  a file-like object (stream); defaults to the current sys.stdout.</span></span><br><span class="line"><span class="string">sep:   string inserted between values, default a space.</span></span><br><span class="line"><span class="string">end:   string appended after the last value, default a newline.</span></span><br><span class="line"><span class="string">flush: whether to forcibly flush the stream.</span></span><br><span class="line"><span class="string">Type:      builtin_function_or_method</span></span><br></pre></td></tr></table></figure>
<p>这可以作为对象的自省。如果对象是一个函数或实例方法，定义过的文档字符串，也会显示出信息。假设我们写了一个如下的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_numbers</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Add two numbers together</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    the_sum : type of arguments</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>
<p>然后使用?符号，就可以显示如下的文档字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: add_numbers?</span><br><span class="line">Signature: add_numbers(a, b)</span><br><span class="line">Docstring:</span><br><span class="line">Add two numbers together</span><br><span class="line"></span><br><span class="line">Returns</span><br><span class="line">-------</span><br><span class="line">the_sum : <span class="built_in">type</span> of arguments</span><br><span class="line">File:      &lt;ipython-<span class="built_in">input</span>-<span class="number">9</span>-6a548a216e27&gt;</span><br><span class="line"><span class="type">Type</span>:      function</span><br></pre></td></tr></table></figure>
<p>使用??会显示函数的源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: add_numbers??</span><br><span class="line">Signature: add_numbers(a, b)</span><br><span class="line">Source:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_numbers</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Add two numbers together</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    the_sum : type of arguments</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">File:      &lt;ipython-<span class="built_in">input</span>-<span class="number">9</span>-6a548a216e27&gt;</span><br><span class="line"><span class="type">Type</span>:      function</span><br></pre></td></tr></table></figure>
<p>?还有一个用途，就是像Unix或Windows命令行一样搜索IPython的命名空间。字符与通配符结合可以匹配所有的名字。例如，我们可以获得所有包含load的顶级NumPy命名空间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: np.*load*?</span><br><span class="line">np.__loader__</span><br><span class="line">np.load</span><br><span class="line">np.loads</span><br><span class="line">np.loadtxt</span><br><span class="line">np.pkgload</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="run命令">%run命令</h3>
<p>你可以用<code>%run</code>命令运行所有的Python程序。假设有一个文件<code>ipython_script_test.py</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x, y, z</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (x + y) / z</span><br><span class="line"></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">6</span></span><br><span class="line">c = <span class="number">7.5</span></span><br><span class="line"></span><br><span class="line">result = f(a, b, c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以如下运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">14</span>]: %run ipython_script_test.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段脚本运行在空的命名空间（没有import和其它定义的变量），因此结果和普通的运行方式<code>python script.py</code>相同。文件中所有定义的变量（import、函数和全局变量，除非抛出异常），都可以在IPython shell中随后访问：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: c</span><br><span class="line">Out [<span class="number">15</span>]: <span class="number">7.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: result</span><br><span class="line">Out[<span class="number">16</span>]: <span class="number">1.4666666666666666</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果一个Python脚本需要命令行参数（在<code>sys.argv</code>中查找），可以在文件路径之后传递，就像在命令行上运行一样。</p>
<blockquote>
<p>笔记：如果想让一个脚本访问IPython已经定义过的变量，可以使用<code>%run -i</code>。</p>
</blockquote>
<p>在Jupyter notebook中，你也可以使用<code>%load</code>，它将脚本导入到一个代码格中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; %load ipython_script_test.py</span><br><span class="line"></span><br><span class="line">    def f(x, y, z):</span><br><span class="line">        return (x + y) / z</span><br><span class="line">    a = 5</span><br><span class="line">    b = 6</span><br><span class="line">    c = 7.5</span><br><span class="line"></span><br><span class="line">    result = f(a, b, c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="中断运行的代码">中断运行的代码</h3>
<p>代码运行时按Ctrl-C，无论是%run或长时间运行命令，都会导致<code>KeyboardInterrupt</code>。这会导致几乎所有Python程序立即停止，除非一些特殊情况。</p>
<blockquote>
<p>警告：当Python代码调用了一些编译的扩展模块，按Ctrl-C不一定将执行的程序立即停止。在这种情况下，你必须等待，直到控制返回Python解释器，或者在更糟糕的情况下强制终止Python进程。</p>
</blockquote>
<h3 id="从剪贴板执行程序">从剪贴板执行程序</h3>
<p>如果使用Jupyter notebook，你可以将代码复制粘贴到任意代码格执行。在IPython shell中也可以从剪贴板执行。假设在其它应用中复制了如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">5</span></span><br><span class="line">y = <span class="number">7</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">5</span>:</span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    y = <span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最简单的方法是使用<code>%paste</code>和<code>%cpaste</code>函数。<code>%paste</code>可以直接运行剪贴板中的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: %paste</span><br><span class="line">x = <span class="number">5</span></span><br><span class="line">y = <span class="number">7</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">5</span>:</span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    y = <span class="number">8</span></span><br><span class="line"><span class="comment">## -- End pasted text --</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>%cpaste</code>功能类似，但会给出一条提示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: %cpaste</span><br><span class="line">Pasting code; enter <span class="string">&#x27;--&#x27;</span> alone on the line to stop <span class="keyword">or</span> use Ctrl-D.</span><br><span class="line">:x = <span class="number">5</span></span><br><span class="line">:y = <span class="number">7</span></span><br><span class="line">:<span class="keyword">if</span> x &gt; <span class="number">5</span>:</span><br><span class="line">:    x += <span class="number">1</span></span><br><span class="line">:</span><br><span class="line">:    y = <span class="number">8</span></span><br><span class="line">:--</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用<code>%cpaste</code>，你可以粘贴任意多的代码再运行。你可能想在运行前，先看看代码。如果粘贴了错误的代码，可以用Ctrl-C中断。</p>
<h3 id="键盘快捷键">键盘快捷键</h3>
<p>IPython有许多键盘快捷键进行导航提示（类似Emacs文本编辑器或UNIX bash Shell）和交互shell的历史命令。表2-1总结了常见的快捷键。图2-5展示了一部分，如移动光标。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-9ed3866ea25c11f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2-5 IPython shell中一些快捷键的说明" /><figcaption aria-hidden="true">图2-5 IPython shell中一些快捷键的说明</figcaption>
</figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-e179f5ea00e50691.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表2-1 IPython的标准快捷键" /><figcaption aria-hidden="true">表2-1 IPython的标准快捷键</figcaption>
</figure>
<p>Jupyter notebooks有另外一套庞大的快捷键。因为它的快捷键比IPython的变化快，建议你参阅Jupyter notebook的帮助文档。</p>
<h3 id="魔术命令">魔术命令</h3>
<p>IPython中特殊的命令（Python中没有）被称作“魔术”命令。这些命令可以使普通任务更便捷，更容易控制IPython系统。魔术命令是在指令前添加百分号%前缀。例如，可以用<code>%timeit</code>（这个命令后面会详谈）测量任何Python语句，例如矩阵乘法，的执行时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: a = np.random.randn(<span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: %timeit np.dot(a, a)</span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">3</span>: <span class="number">20.9</span> µs per loop</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>魔术命令可以被看做IPython中运行的命令行。许多魔术命令有“命令行”选项，可以通过？查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [21]: %debug?</span><br><span class="line">Docstring:</span><br><span class="line">::</span><br><span class="line"></span><br><span class="line">  %debug [--breakpoint FILE:LINE] [statement [statement ...]]</span><br><span class="line"></span><br><span class="line">Activate the interactive debugger.</span><br><span class="line"></span><br><span class="line">This magic command support two ways of activating debugger.</span><br><span class="line">One is to activate debugger before executing code.  This way, you</span><br><span class="line">can set a break point, to step through the code from the point.</span><br><span class="line">You can use this mode by giving statements to execute and optionally</span><br><span class="line">a breakpoint.</span><br><span class="line"></span><br><span class="line">The other one is to activate debugger in post-mortem mode.  You can</span><br><span class="line">activate this mode simply running %debug without any argument.</span><br><span class="line">If an exception has just occurred, this lets you inspect its stack</span><br><span class="line">frames interactively.  Note that this will always work only on the last</span><br><span class="line">traceback that occurred, so you must call this quickly after an</span><br><span class="line">exception that you wish to inspect has fired, because if another one</span><br><span class="line">occurs, it clobbers the previous one.</span><br><span class="line"></span><br><span class="line">If you want IPython to automatically do this on every exception, see</span><br><span class="line">the %pdb magic for more details.</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  statement             Code to run in debugger. You can omit this in cell</span><br><span class="line">                        magic mode.</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  --breakpoint &lt;FILE:LINE&gt;, -b &lt;FILE:LINE&gt;</span><br><span class="line">                        Set break point at LINE in FILE.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>魔术函数默认可以不用百分号，只要没有变量和函数名相同。这个特点被称为“自动魔术”，可以用<code>%automagic</code>打开或关闭。</p>
<p>一些魔术函数与Python函数很像，它的结果可以赋值给一个变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [22]: %pwd</span><br><span class="line">Out[22]: &#x27;/home/wesm/code/pydata-book</span><br><span class="line"></span><br><span class="line">In [23]: foo = %pwd</span><br><span class="line"></span><br><span class="line">In [24]: foo</span><br><span class="line">Out[24]: &#x27;/home/wesm/code/pydata-book&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>IPython的文档可以在shell中打开，我建议你用<code>%quickref</code>或<code>%magic</code>学习下所有特殊命令。表2-2列出了一些可以提高生产率的交互计算和Python开发的IPython指令。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-c72b11add9b8ccf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表2-2 一些常用的IPython魔术命令" /><figcaption aria-hidden="true">表2-2 一些常用的IPython魔术命令</figcaption>
</figure>
<h3 id="集成matplotlib">集成Matplotlib</h3>
<p>IPython在分析计算领域能够流行的原因之一是它非常好的集成了数据可视化和其它用户界面库，比如matplotlib。不用担心以前没用过matplotlib，本书后面会详细介绍。<code>%matplotlib</code>魔术函数配置了IPython shell和Jupyter notebook中的matplotlib。这点很重要，其它创建的图不会出现（notebook）或获取session的控制，直到结束（shell）。</p>
<p>在IPython shell中，运行<code>%matplotlib</code>可以进行设置，可以创建多个绘图窗口，而不会干扰控制台session：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [26]: %matplotlib</span><br><span class="line">Using matplotlib backend: Qt4Agg</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在JUpyter中，命令有所不同（图2-6）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [26]: %matplotlib inline</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-3ab3738a92a15486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2-6 Jupyter行内matplotlib作图" /><figcaption aria-hidden="true">图2-6 Jupyter行内matplotlib作图</figcaption>
</figure>
<h2 id="python语法基础">2.3 Python语法基础</h2>
<p>在本节中，我将概述基本的Python概念和语言机制。在下一章，我将详细介绍Python的数据结构、函数和其它内建工具。</p>
<h3 id="语言的语义">语言的语义</h3>
<p>Python的语言设计强调的是可读性、简洁和清晰。有些人称Python为“可执行的伪代码”。</p>
<h3 id="使用缩进而不是括号">使用缩进，而不是括号</h3>
<p>Python使用空白字符（tab和空格）来组织代码，而不是像其它语言，比如R、C++、JAVA和Perl那样使用括号。看一个排序算法的<code>for</code>循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> array:</span><br><span class="line">    <span class="keyword">if</span> x &lt; pivot:</span><br><span class="line">        less.append(x)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        greater.append(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>冒号标志着缩进代码块的开始，冒号之后的所有代码的缩进量必须相同，直到代码块结束。不管是否喜欢这种形式，使用空白符是Python程序员开发的一部分，在我看来，这可以让python的代码可读性大大优于其它语言。虽然期初看起来很奇怪，经过一段时间，你就能适应了。</p>
<blockquote>
<p>笔记：我强烈建议你使用四个空格作为默认的缩进，可以使用tab代替四个空格。许多文本编辑器的设置是使用制表位替代空格。某些人使用tabs或不同数目的空格数，常见的是使用两个空格。大多数情况下，四个空格是大多数人采用的方法，因此建议你也这样做。</p>
</blockquote>
<p>你应该已经看到，Python的语句不需要用分号结尾。但是，分号却可以用来给同在一行的语句切分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span>; b = <span class="number">6</span>; c = <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python不建议将多条语句放到一行，这会降低代码的可读性。</p>
<h3 id="万物皆对象">万物皆对象</h3>
<p>Python语言的一个重要特性就是它的对象模型的一致性。每个数字、字符串、数据结构、函数、类、模块等等，都是在Python解释器的自有“盒子”内，它被认为是Python对象。每个对象都有类型（例如，字符串或函数）和内部数据。在实际中，这可以让语言非常灵活，因为函数也可以被当做对象使用。</p>
<h3 id="注释">注释</h3>
<p>任何前面带有井号#的文本都会被Python解释器忽略。这通常被用来添加注释。有时，你会想排除一段代码，但并不删除。简便的方法就是将其注释掉：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file_handle:</span><br><span class="line">    <span class="comment"># keep the empty lines for now</span></span><br><span class="line">    <span class="comment"># if len(line) == 0:</span></span><br><span class="line">    <span class="comment">#   continue</span></span><br><span class="line">    results.append(line.replace(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以在执行过的代码后面添加注释。一些人习惯在代码之前添加注释，前者这种方法有时也是有用的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Reached this line&quot;</span>)  <span class="comment"># Simple status report</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="函数和对象方法调用">函数和对象方法调用</h3>
<p>你可以用圆括号调用函数，传递零个或几个参数，或者将返回值给一个变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = f(x, y, z)</span><br><span class="line">g()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>几乎Python中的每个对象都有附加的函数，称作方法，可以用来访问对象的内容。可以用下面的语句调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj.some_method(x, y, z)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数可以使用位置和关键词参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = f(a, b, c, d=<span class="number">5</span>, e=<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>后面会有更多介绍。</p>
<h3 id="变量和参数传递">变量和参数传递</h3>
<p>当在Python中创建变量（或名字），你就在等号右边创建了一个对这个变量的引用。考虑一个整数列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">8</span>]: a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设将a赋值给一个新变量b：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: b = a</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在有些方法中，这个赋值会将数据[1, 2, 3]也复制。在Python中，a和b实际上是同一个对象，即原有列表[1, 2, 3]（见图2-7）。你可以在a中添加一个元素，然后检查b：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: a.append(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: b</span><br><span class="line">Out[<span class="number">11</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-3e3a8c6b9c5040fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2-7 对同一对象的双重引用" /><figcaption aria-hidden="true">图2-7 对同一对象的双重引用</figcaption>
</figure>
<p>理解Python的引用的含义，数据是何时、如何、为何复制的，是非常重要的。尤其是当你用Python处理大的数据集时。</p>
<blockquote>
<p>笔记：赋值也被称作绑定，我们是把一个名字绑定给一个对象。变量名有时可能被称为绑定变量。</p>
</blockquote>
<p>当你将对象作为参数传递给函数时，新的局域变量创建了对原始对象的引用，而不是复制。如果在函数里绑定一个新对象到一个变量，这个变动不会反映到上一层。因此可以改变可变参数的内容。假设有以下函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append_element</span>(<span class="params">some_list, element</span>):</span></span><br><span class="line">    some_list.append(element)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">27</span>]: data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: append_element(data, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: data</span><br><span class="line">Out[<span class="number">29</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="动态引用强类型">动态引用，强类型</h3>
<p>与许多编译语言（如JAVA和C++）对比，Python中的对象引用不包含附属的类型。下面的代码是没有问题的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: a = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: <span class="built_in">type</span>(a)</span><br><span class="line">Out[<span class="number">13</span>]: <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: a = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: <span class="built_in">type</span>(a)</span><br><span class="line">Out[<span class="number">15</span>]: <span class="built_in">str</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>变量是在特殊命名空间中的对象的名字，类型信息保存在对象自身中。一些人可能会说Python不是“类型化语言”。这是不正确的，看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [16]: &#x27;5&#x27; + 5</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-16-f9dbf5f0b234&gt; in &lt;module&gt;()</span><br><span class="line">----&gt; 1 &#x27;5&#x27; + 5</span><br><span class="line">TypeError: must be str, not int</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在某些语言中，例如Visual Basic，字符串‘5’可能被默许转换（或投射）为整数，因此会产生10。但在其它语言中，例如JavaScript，整数5会被投射成字符串，结果是联结字符串‘55’。在这个方面，Python被认为是强类型化语言，意味着每个对象都有明确的类型（或类），默许转换只会发生在特定的情况下，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [17]: a = 4.5</span><br><span class="line"></span><br><span class="line">In [18]: b = 2</span><br><span class="line"></span><br><span class="line"># String formatting, to be visited later</span><br><span class="line">In [19]: print(&#x27;a is &#123;0&#125;, b is &#123;1&#125;&#x27;.format(type(a), type(b)))</span><br><span class="line">a is &lt;class &#x27;float&#x27;&gt;, b is &lt;class &#x27;int&#x27;&gt;</span><br><span class="line"></span><br><span class="line">In [20]: a / b</span><br><span class="line">Out[20]: 2.25</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>知道对象的类型很重要，最好能让函数可以处理多种类型的输入。你可以用<code>isinstance</code>函数检查对象是某个类型的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [21]: a = 5</span><br><span class="line"></span><br><span class="line">In [22]: isinstance(a, int)</span><br><span class="line">Out[22]: True</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>isinstance</code>可以用类型元组，检查对象的类型是否在元组中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [23]: a = 5; b = 4.5</span><br><span class="line"></span><br><span class="line">In [24]: isinstance(a, (int, float))</span><br><span class="line">Out[24]: True</span><br><span class="line"></span><br><span class="line">In [25]: isinstance(b, (int, float))</span><br><span class="line">Out[25]: True</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="属性和方法">属性和方法</h3>
<p>Python的对象通常都有属性（其它存储在对象内部的Python对象）和方法（对象的附属函数可以访问对象的内部数据）。可以用<code>obj.attribute_name</code>访问属性和方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [1]: a = &#x27;foo&#x27;</span><br><span class="line"></span><br><span class="line">In [2]: a.&lt;Press Tab&gt;</span><br><span class="line">a.capitalize  a.format      a.isupper     a.rindex      a.strip</span><br><span class="line">a.center      a.index       a.join        a.rjust       a.swapcase</span><br><span class="line">a.count       a.isalnum     a.ljust       a.rpartition  a.title</span><br><span class="line">a.decode      a.isalpha     a.lower       a.rsplit      a.translate</span><br><span class="line">a.encode      a.isdigit     a.lstrip      a.rstrip      a.upper</span><br><span class="line">a.endswith    a.islower     a.partition   a.split       a.zfill</span><br><span class="line">a.expandtabs  a.isspace     a.replace     a.splitlines</span><br><span class="line">a.find        a.istitle     a.rfind       a.startswith</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以用<code>getattr</code>函数，通过名字访问属性和方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [27]: getattr(a, &#x27;split&#x27;)</span><br><span class="line">Out[27]: &lt;function str.split&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在其它语言中，访问对象的名字通常称作“反射”。本书不会大量使用<code>getattr</code>函数和相关的<code>hasattr</code>和<code>setattr</code>函数，使用这些函数可以高效编写原生的、可重复使用的代码。</p>
<h3 id="鸭子类型">鸭子类型</h3>
<p>经常地，你可能不关心对象的类型，只关心对象是否有某些方法或用途。这通常被称为“鸭子类型”，来自“走起来像鸭子、叫起来像鸭子，那么它就是鸭子”的说法。例如，你可以通过验证一个对象是否遵循迭代协议，判断它是可迭代的。对于许多对象，这意味着它有一个<code>__iter__</code>魔术方法，其它更好的判断方法是使用<code>iter</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isiterable</span>(<span class="params">obj</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">iter</span>(obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> TypeError: <span class="comment"># not iterable</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个函数会返回字符串以及大多数Python集合类型为<code>True</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [29]: isiterable(&#x27;a string&#x27;)</span><br><span class="line">Out[29]: True</span><br><span class="line"></span><br><span class="line">In [30]: isiterable([1, 2, 3])</span><br><span class="line">Out[30]: True</span><br><span class="line"></span><br><span class="line">In [31]: isiterable(5)</span><br><span class="line">Out[31]: False</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我总是用这个功能编写可以接受多种输入类型的函数。常见的例子是编写一个函数可以接受任意类型的序列（list、tuple、ndarray）或是迭代器。你可先检验对象是否是列表（或是NUmPy数组），如果不是的话，将其转变成列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x, <span class="built_in">list</span>) <span class="keyword">and</span> isiterable(x):</span><br><span class="line">    x = <span class="built_in">list</span>(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="引入">引入</h3>
<p>在Python中，模块就是一个有<code>.py</code>扩展名、包含Python代码的文件。假设有以下模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># some_module.py</span></span><br><span class="line">PI = <span class="number">3.14159</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果想从同目录下的另一个文件访问<code>some_module.py</code>中定义的变量和函数，可以：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> some_module</span><br><span class="line">result = some_module.f(<span class="number">5</span>)</span><br><span class="line">pi = some_module.PI</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> some_module <span class="keyword">import</span> f, g, PI</span><br><span class="line">result = g(<span class="number">5</span>, PI)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用<code>as</code>关键词，你可以给引入起不同的变量名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> some_module <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">from</span> some_module <span class="keyword">import</span> PI <span class="keyword">as</span> pi, g <span class="keyword">as</span> gf</span><br><span class="line"></span><br><span class="line">r1 = sm.f(pi)</span><br><span class="line">r2 = gf(<span class="number">6</span>, pi)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二元运算符和比较运算符">二元运算符和比较运算符</h3>
<p>大多数二元数学运算和比较都不难想到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">32</span>]: <span class="number">5</span> - <span class="number">7</span></span><br><span class="line">Out[<span class="number">32</span>]: -<span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: <span class="number">12</span> + <span class="number">21.5</span></span><br><span class="line">Out[<span class="number">33</span>]: <span class="number">33.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: <span class="number">5</span> &lt;= <span class="number">2</span></span><br><span class="line">Out[<span class="number">34</span>]: <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表2-3列出了所有的二元运算符。</p>
<p>要判断两个引用是否指向同一个对象，可以使用<code>is</code>方法。<code>is not</code>可以判断两个对象是不同的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">35</span>]: a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: b = a</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: c = <span class="built_in">list</span>(a)</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: a <span class="keyword">is</span> b</span><br><span class="line">Out[<span class="number">38</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: a <span class="keyword">is</span> <span class="keyword">not</span> c</span><br><span class="line">Out[<span class="number">39</span>]: <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为<code>list</code>总是创建一个新的Python列表（即复制），我们可以断定c是不同于a的。使用<code>is</code>比较与<code>==</code>运算符不同，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">40</span>]: a == c</span><br><span class="line">Out[<span class="number">40</span>]: <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>is</code>和<code>is not</code>常用来判断一个变量是否为<code>None</code>，因为只有一个<code>None</code>的实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: a = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: a <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">Out[<span class="number">42</span>]: <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-9fb5f25b33166acf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表2-3 二元运算符" /><figcaption aria-hidden="true">表2-3 二元运算符</figcaption>
</figure>
<h3 id="可变与不可变对象">可变与不可变对象</h3>
<p>Python中的大多数对象，比如列表、字典、NumPy数组，和用户定义的类型（类），都是可变的。意味着这些对象或包含的值可以被修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">43</span>]: a_list = [<span class="string">&#x27;foo&#x27;</span>, <span class="number">2</span>, [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: a_list[<span class="number">2</span>] = (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: a_list</span><br><span class="line">Out[<span class="number">45</span>]: [<span class="string">&#x27;foo&#x27;</span>, <span class="number">2</span>, (<span class="number">3</span>, <span class="number">4</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其它的，例如字符串和元组，是不可变的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">46</span>]: a_tuple = (<span class="number">3</span>, <span class="number">5</span>, (<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: a_tuple[<span class="number">1</span>] = <span class="string">&#x27;four&#x27;</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">47</span>-b7966a9ae0f1&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> a_tuple[<span class="number">1</span>] = <span class="string">&#x27;four&#x27;</span></span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>记住，可以修改一个对象并不意味就要修改它。这被称为副作用。例如，当写一个函数，任何副作用都要在文档或注释中写明。如果可能的话，我推荐避免副作用，采用不可变的方式，即使要用到可变对象。</p>
<h3 id="标量类型">标量类型</h3>
<p>Python的标准库中有一些内建的类型，用于处理数值数据、字符串、布尔值，和日期时间。这些单值类型被称为标量类型，本书中称其为标量。表2-4列出了主要的标量。日期和时间处理会另外讨论，因为它们是标准库的<code>datetime</code>模块提供的。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-27a30ac3e7d262a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表2-4 Python的标量" /><figcaption aria-hidden="true">表2-4 Python的标量</figcaption>
</figure>
<h3 id="数值类型">数值类型</h3>
<p>Python的主要数值类型是<code>int</code>和<code>float</code>。<code>int</code>可以存储任意大的数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">48</span>]: ival = <span class="number">17239871</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: ival ** <span class="number">6</span></span><br><span class="line">Out[<span class="number">49</span>]: <span class="number">26254519291092456596965462913230729701102721</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>浮点数使用Python的<code>float</code>类型。每个数都是双精度（64位）的值。也可以用科学计数法表示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">50</span>]: fval = <span class="number">7.243</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: fval2 = <span class="number">6.78e-5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不能得到整数的除法会得到浮点数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">52</span>]: <span class="number">3</span> / <span class="number">2</span></span><br><span class="line">Out[<span class="number">52</span>]: <span class="number">1.5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要获得C-风格的整除（去掉小数部分），可以使用底除运算符//：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">53</span>]: <span class="number">3</span> // <span class="number">2</span></span><br><span class="line">Out[<span class="number">53</span>]: <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="字符串">字符串</h3>
<p>许多人是因为Python强大而灵活的字符串处理而使用Python的。你可以用单引号或双引号来写字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;one way of writing a string&#x27;</span></span><br><span class="line">b = <span class="string">&quot;another way&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于有换行符的字符串，可以使用三引号，'''或"""都行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">This is a longer string that</span></span><br><span class="line"><span class="string">spans multiple lines</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>字符串<code>c</code>实际包含四行文本，"""后面和lines后面的换行符。可以用<code>count</code>方法计算<code>c</code>中的新的行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">55</span>]: c.count(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">Out[<span class="number">55</span>]: <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python的字符串是不可变的，不能修改字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: a = <span class="string">&#x27;this is a string&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: a[<span class="number">10</span>] = <span class="string">&#x27;f&#x27;</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">57</span>-5ca625d1e504&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> a[<span class="number">10</span>] = <span class="string">&#x27;f&#x27;</span></span><br><span class="line">TypeError: <span class="string">&#x27;str&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: b = a.replace(<span class="string">&#x27;string&#x27;</span>, <span class="string">&#x27;longer string&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: b</span><br><span class="line">Out[<span class="number">59</span>]: <span class="string">&#x27;this is a longer string&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>经过以上的操作，变量<code>a</code>并没有被修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">60</span>]: a</span><br><span class="line">Out[<span class="number">60</span>]: <span class="string">&#x27;this is a string&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>许多Python对象使用<code>str</code>函数可以被转化为字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">61</span>]: a = <span class="number">5.6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: s = <span class="built_in">str</span>(a)</span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: <span class="built_in">print</span>(s)</span><br><span class="line"><span class="number">5.6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>字符串是一个序列的Unicode字符，因此可以像其它序列，比如列表和元组（下一章会详细介绍两者）一样处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">64</span>]: s = <span class="string">&#x27;python&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: <span class="built_in">list</span>(s)</span><br><span class="line">Out[<span class="number">65</span>]: [<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: s[:<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">66</span>]: <span class="string">&#x27;pyt&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>语法<code>s[:3]</code>被称作切片，适用于许多Python序列。后面会更详细的介绍，本书中用到很多切片。</p>
<p>反斜杠是转义字符，意思是它备用来表示特殊字符，比如换行符。要写一个包含反斜杠的字符串，需要进行转义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">67</span>]: s = <span class="string">&#x27;12\\34&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: <span class="built_in">print</span>(s)</span><br><span class="line"><span class="number">12</span>\<span class="number">34</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果字符串中包含许多反斜杠，但没有特殊字符，这样做就很麻烦。幸好，可以在字符串前面加一个r，表明字符就是它自身：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">69</span>]: s = <span class="string">r&#x27;this\has\no\special\characters&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: s</span><br><span class="line">Out[<span class="number">70</span>]: <span class="string">&#x27;this\\has\\no\\special\\characters&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>r表示raw。</p>
<p>将两个字符串合并，会产生一个新的字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">71</span>]: a = <span class="string">&#x27;this is the first half &#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: b = <span class="string">&#x27;and this is the second half&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">73</span>]: a + b</span><br><span class="line">Out[<span class="number">73</span>]: <span class="string">&#x27;this is the first half and this is the second half&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>字符串的模板化或格式化，是另一个重要的主题。Python 3拓展了此类的方法，这里只介绍一些。字符串对象有<code>format</code>方法，可以替换格式化的参数为字符串，产生一个新的字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: template = <span class="string">&#x27;&#123;0:.2f&#125; &#123;1:s&#125; are worth US$&#123;2:d&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个字符串中，</p>
<ul>
<li><code>&#123;0:.2f&#125;</code>表示格式化第一个参数为带有两位小数的浮点数。</li>
<li><code>&#123;1:s&#125;</code>表示格式化第二个参数为字符串。</li>
<li><code>&#123;2:d&#125;</code>表示格式化第三个参数为一个整数。</li>
</ul>
<p>要替换参数为这些格式化的参数，我们传递<code>format</code>方法一个序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">75</span>]: template.<span class="built_in">format</span>(<span class="number">4.5560</span>, <span class="string">&#x27;Argentine Pesos&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">Out[<span class="number">75</span>]: <span class="string">&#x27;4.56 Argentine Pesos are worth US$1&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>字符串格式化是一个很深的主题，有多种方法和大量的选项，可以控制字符串中的值是如何格式化的。推荐参阅Python官方文档。</p>
<p>这里概括介绍字符串处理，第8章的数据分析会详细介绍。</p>
<h3 id="字节和unicode">字节和Unicode</h3>
<p>在Python 3及以上版本中，Unicode是一级的字符串类型，这样可以更一致的处理ASCII和Non-ASCII文本。在老的Python版本中，字符串都是字节，不使用Unicode编码。假如知道字符编码，可以将其转化为Unicode。看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: val = <span class="string">&quot;español&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: val</span><br><span class="line">Out[<span class="number">77</span>]: <span class="string">&#x27;español&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以用<code>encode</code>将这个Unicode字符串编码为UTF-8：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">78</span>]: val_utf8 = val.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: val_utf8</span><br><span class="line">Out[<span class="number">79</span>]: <span class="string">b&#x27;espa\xc3\xb1ol&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: <span class="built_in">type</span>(val_utf8)</span><br><span class="line">Out[<span class="number">80</span>]: <span class="built_in">bytes</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你知道一个字节对象的Unicode编码，用<code>decode</code>方法可以解码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">81</span>]: val_utf8.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">Out[<span class="number">81</span>]: <span class="string">&#x27;español&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然UTF-8编码已经变成主流，但因为历史的原因，你仍然可能碰到其它编码的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">82</span>]: val.encode(<span class="string">&#x27;latin1&#x27;</span>)</span><br><span class="line">Out[<span class="number">82</span>]: <span class="string">b&#x27;espa\xf1ol&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: val.encode(<span class="string">&#x27;utf-16&#x27;</span>)</span><br><span class="line">Out[<span class="number">83</span>]: <span class="string">b&#x27;\xff\xfee\x00s\x00p\x00a\x00\xf1\x00o\x00l\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: val.encode(<span class="string">&#x27;utf-16le&#x27;</span>)</span><br><span class="line">Out[<span class="number">84</span>]: <span class="string">b&#x27;e\x00s\x00p\x00a\x00\xf1\x00o\x00l\x00&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>工作中碰到的文件很多都是字节对象，盲目地将所有数据编码为Unicode是不可取的。</p>
<p>虽然用的不多，你可以在字节文本的前面加上一个b：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">85</span>]: bytes_val = <span class="string">b&#x27;this is bytes&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: bytes_val</span><br><span class="line">Out[<span class="number">86</span>]: <span class="string">b&#x27;this is bytes&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: decoded = bytes_val.decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: decoded  <span class="comment"># this is str (Unicode) now</span></span><br><span class="line">Out[<span class="number">88</span>]: <span class="string">&#x27;this is bytes&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="布尔值">布尔值</h3>
<p>Python中的布尔值有两个，True和False。比较和其它条件表达式可以用True和False判断。布尔值可以与and和or结合使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">89</span>]: <span class="literal">True</span> <span class="keyword">and</span> <span class="literal">True</span></span><br><span class="line">Out[<span class="number">89</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: <span class="literal">False</span> <span class="keyword">or</span> <span class="literal">True</span></span><br><span class="line">Out[<span class="number">90</span>]: <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="类型转换">类型转换</h3>
<p>str、bool、int和float也是函数，可以用来转换类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">91</span>]: s = <span class="string">&#x27;3.14159&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: fval = <span class="built_in">float</span>(s)</span><br><span class="line"></span><br><span class="line">In [<span class="number">93</span>]: <span class="built_in">type</span>(fval)</span><br><span class="line">Out[<span class="number">93</span>]: <span class="built_in">float</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: <span class="built_in">int</span>(fval)</span><br><span class="line">Out[<span class="number">94</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">95</span>]: <span class="built_in">bool</span>(fval)</span><br><span class="line">Out[<span class="number">95</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">96</span>]: <span class="built_in">bool</span>(<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">96</span>]: <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="none">None</h3>
<p>None是Python的空值类型。如果一个函数没有明确的返回值，就会默认返回None：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">97</span>]: a = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: a <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">Out[<span class="number">98</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: b = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: b <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">Out[<span class="number">100</span>]: <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>None也常常作为函数的默认参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_and_maybe_multiply</span>(<span class="params">a, b, c=<span class="literal">None</span></span>):</span></span><br><span class="line">    result = a + b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        result = result * c</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外，None不仅是一个保留字，还是唯一的NoneType的实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">101</span>]: <span class="built_in">type</span>(<span class="literal">None</span>)</span><br><span class="line">Out[<span class="number">101</span>]: NoneType</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="日期和时间">日期和时间</h3>
<p>Python内建的<code>datetime</code>模块提供了<code>datetime</code>、<code>date</code>和<code>time</code>类型。<code>datetime</code>类型结合了<code>date</code>和<code>time</code>，是最常使用的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">102</span>]: <span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, date, time</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: dt = datetime(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: dt.day</span><br><span class="line">Out[<span class="number">104</span>]: <span class="number">29</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: dt.minute</span><br><span class="line">Out[<span class="number">105</span>]: <span class="number">30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据<code>datetime</code>实例，你可以用<code>date</code>和<code>time</code>提取出各自的对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">106</span>]: dt.date()</span><br><span class="line">Out[<span class="number">106</span>]: datetime.date(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: dt.time()</span><br><span class="line">Out[<span class="number">107</span>]: datetime.time(<span class="number">20</span>, <span class="number">30</span>, <span class="number">21</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>strftime</code>方法可以将datetime格式化为字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">108</span>]: dt.strftime(<span class="string">&#x27;%m/%d/%Y %H:%M&#x27;</span>)</span><br><span class="line">Out[<span class="number">108</span>]: <span class="string">&#x27;10/29/2011 20:30&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>strptime</code>可以将字符串转换成<code>datetime</code>对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">109</span>]: datetime.strptime(<span class="string">&#x27;20091031&#x27;</span>, <span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line">Out[<span class="number">109</span>]: datetime.datetime(<span class="number">2009</span>, <span class="number">10</span>, <span class="number">31</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表2-5列出了所有的格式化命令。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-100f9a20c1536553.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表2-5 Datetime格式化指令（与ISO C89兼容）" /><figcaption aria-hidden="true">表2-5 Datetime格式化指令（与ISO C89兼容）</figcaption>
</figure>
<p>当你聚类或对时间序列进行分组，替换datetimes的time字段有时会很有用。例如，用0替换分和秒：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">110</span>]: dt.replace(minute=<span class="number">0</span>, second=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">110</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为<code>datetime.datetime</code>是不可变类型，上面的方法会产生新的对象。</p>
<p>两个datetime对象的差会产生一个<code>datetime.timedelta</code>类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">111</span>]: dt2 = datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">22</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">112</span>]: delta = dt2 - dt</span><br><span class="line"></span><br><span class="line">In [<span class="number">113</span>]: delta</span><br><span class="line">Out[<span class="number">113</span>]: datetime.timedelta(<span class="number">17</span>, <span class="number">7179</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: <span class="built_in">type</span>(delta)</span><br><span class="line">Out[<span class="number">114</span>]: datetime.timedelta</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果<code>timedelta(17, 7179)</code>指明了<code>timedelta</code>将17天、7179秒的编码方式。</p>
<p>将<code>timedelta</code>添加到<code>datetime</code>，会产生一个新的偏移<code>datetime</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">115</span>]: dt</span><br><span class="line">Out[<span class="number">115</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: dt + delta</span><br><span class="line">Out[<span class="number">116</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">22</span>, <span class="number">30</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="控制流">控制流</h3>
<p>Python有若干内建的关键字进行条件逻辑、循环和其它控制流操作。</p>
<h3 id="ifelif和else">if、elif和else</h3>
<p>if是最广为人知的控制流语句。它检查一个条件，如果为True，就执行后面的语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;It&#x27;</span>s negative<span class="string">&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p><code>if</code>后面可以跟一个或多个<code>elif</code>，所有条件都是False时，还可以添加一个<code>else</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;It&#x27;</span>s negative<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">elif x == 0:</span></span><br><span class="line"><span class="string">    print(&#x27;</span>Equal to zero<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">elif 0 &lt; x &lt; 5:</span></span><br><span class="line"><span class="string">    print(&#x27;</span>Positive but smaller than <span class="number">5</span><span class="string">&#x27;)</span></span><br><span class="line"><span class="string">else:</span></span><br><span class="line"><span class="string">    print(&#x27;</span>Positive <span class="keyword">and</span> larger than <span class="keyword">or</span> equal to <span class="number">5</span><span class="string">&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>如果某个条件为True，后面的<code>elif</code>就不会被执行。当使用and和or时，复合条件语句是从左到右执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">117</span>]: a = <span class="number">5</span>; b = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: c = <span class="number">8</span>; d = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: <span class="keyword">if</span> a &lt; b <span class="keyword">or</span> c &gt; d:</span><br><span class="line">   .....:     <span class="built_in">print</span>(<span class="string">&#x27;Made it&#x27;</span>)</span><br><span class="line">Made it</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>c &gt; d</code>不会被执行，因为第一个比较是True：</p>
<p>也可以把比较式串在一起：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">120</span>]: <span class="number">4</span> &gt; <span class="number">3</span> &gt; <span class="number">2</span> &gt; <span class="number">1</span></span><br><span class="line">Out[<span class="number">120</span>]: <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="for循环">for循环</h3>
<p>for循环是在一个集合（列表或元组）中进行迭代，或者就是一个迭代器。for循环的标准语法是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> collection:</span><br><span class="line">    <span class="comment"># do something with value</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可以用continue使for循环提前，跳过剩下的部分。看下面这个例子，将一个列表中的整数相加，跳过None：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sequence = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">None</span>, <span class="number">4</span>, <span class="literal">None</span>, <span class="number">5</span>]</span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> sequence:</span><br><span class="line">    <span class="keyword">if</span> value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    total += value</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以用<code>break</code>跳出for循环。下面的代码将各元素相加，直到遇到5：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sequence = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">total_until_5 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> sequence:</span><br><span class="line">    <span class="keyword">if</span> value == <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    total_until_5 += value</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>break只中断for循环的最内层，其余的for循环仍会运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">121</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">   .....:     <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">   .....:         <span class="keyword">if</span> j &gt; i:</span><br><span class="line">   .....:             <span class="keyword">break</span></span><br><span class="line">   .....:         <span class="built_in">print</span>((i, j))</span><br><span class="line">   .....:</span><br><span class="line">(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果集合或迭代器中的元素序列（元组或列表），可以用for循环将其方便地拆分成变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> a, b, c <span class="keyword">in</span> iterator:</span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="while循环">While循环</h3>
<p>while循环指定了条件和代码，当条件为False或用break退出循环，代码才会退出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">256</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">if</span> total &gt; <span class="number">500</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    total += x</span><br><span class="line">    x = x // <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="pass">pass</h3>
<p>pass是Python中的非操作语句。代码块不需要任何动作时可以使用（作为未执行代码的占位符）；因为Python需要使用空白字符划定代码块，所以需要pass：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;negative!&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> put something smart here</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;positive!&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="range">range</h3>
<p>range函数返回一个迭代器，它产生一个均匀分布的整数序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">122</span>]: <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">122</span>]: <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">Out[<span class="number">123</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>range的三个参数是（起点，终点，步进）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">124</span>]: <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">20</span>, <span class="number">2</span>))</span><br><span class="line">Out[<span class="number">124</span>]: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>, <span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line">Out[<span class="number">125</span>]: [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，range产生的整数不包括终点。range的常见用法是用序号迭代序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(seq)):</span><br><span class="line">    val = seq[i]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以使用list来存储range在其他数据结构中生成的所有整数，默认的迭代器形式通常是你想要的。下面的代码对0到99999中3或5的倍数求和：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">    <span class="comment"># % is the modulo operator</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span> <span class="keyword">or</span> i % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">sum</span> += i</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然range可以产生任意大的数，但任意时刻耗用的内存却很小。</p>
<h3 id="三元表达式">三元表达式</h3>
<p>Python中的三元表达式可以将if-else语句放到一行里。语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = true-expr <span class="keyword">if</span> condition <span class="keyword">else</span> false-expr</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>true-expr</code>或<code>false-expr</code>可以是任何Python代码。它和下面的代码效果相同：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition:</span><br><span class="line">    value = true-expr</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    value = false-expr</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面是一个更具体的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">126</span>]: x = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">127</span>]: <span class="string">&#x27;Non-negative&#x27;</span> <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;Negative&#x27;</span></span><br><span class="line">Out[<span class="number">127</span>]: <span class="string">&#x27;Non-negative&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>和if-else一样，只有一个表达式会被执行。因此，三元表达式中的if和else可以包含大量的计算，但只有True的分支会被执行。因此，三元表达式中的if和else可以包含大量的计算，但只有True的分支会被执行。</p>
<p>虽然使用三元表达式可以压缩代码，但会降低代码可读性。</p>
]]></content>
      <categories>
        <category>Python 数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>第03章 数据结构和序列</title>
    <url>/2019/04/09/%E7%AC%AC03%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>本章讨论Python的内置功能，这些功能本书会用到很多。虽然扩展库，比如pandas和Numpy，使处理大数据集很方便，但它们是和Python的内置数据处理工具一同使用的。</p>
<span id="more"></span>
<p>我们会从Python最基础的数据结构开始：元组、列表、字典和集合。然后会讨论创建你自己的、可重复使用的Python函数。最后，会学习Python的文件对象，以及如何与本地硬盘交互。</p>
<h1 id="数据结构和序列">3.1 数据结构和序列</h1>
<p>Python的数据结构简单而强大。通晓它们才能成为熟练的Python程序员。</p>
<h2 id="元组">元组</h2>
<p>元组是一个固定长度，不可改变的Python序列对象。创建元组的最简单方式，是用逗号分隔一列值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: tup = <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: tup</span><br><span class="line">Out[<span class="number">2</span>]: (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>当用复杂的表达式定义元组，最好将值放到圆括号内，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">3</span>]: nested_tup = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: nested_tup</span><br><span class="line">Out[<span class="number">4</span>]: ((<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>))</span><br></pre></td></tr></table></figure>
<p>用<code>tuple</code>可以将任意序列或迭代器转换成元组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">5</span>]: <span class="built_in">tuple</span>([<span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line">Out[<span class="number">5</span>]: (<span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: tup = <span class="built_in">tuple</span>(<span class="string">&#x27;string&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: tup</span><br><span class="line">Out[<span class="number">7</span>]: (<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;g&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>可以用方括号访问元组中的元素。和C、C++、JAVA等语言一样，序列是从0开始的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">8</span>]: tup[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">8</span>]: <span class="string">&#x27;s&#x27;</span></span><br></pre></td></tr></table></figure>
<p>元组中存储的对象可能是可变对象。一旦创建了元组，元组中的对象就不能修改了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: tup = <span class="built_in">tuple</span>([<span class="string">&#x27;foo&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="literal">True</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: tup[<span class="number">2</span>] = <span class="literal">False</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">10</span>-c7308343b841&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> tup[<span class="number">2</span>] = <span class="literal">False</span></span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure>
<p>如果元组中的某个对象是可变的，比如列表，可以在原位进行修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: tup[<span class="number">1</span>].append(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: tup</span><br><span class="line">Out[<span class="number">12</span>]: (<span class="string">&#x27;foo&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>可以用加号运算符将元组串联起来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: (<span class="number">4</span>, <span class="literal">None</span>, <span class="string">&#x27;foo&#x27;</span>) + (<span class="number">6</span>, <span class="number">0</span>) + (<span class="string">&#x27;bar&#x27;</span>,)</span><br><span class="line">Out[<span class="number">13</span>]: (<span class="number">4</span>, <span class="literal">None</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="string">&#x27;bar&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>元组乘以一个整数，像列表一样，会将几个元组的复制串联起来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">14</span>]: (<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>) * <span class="number">4</span></span><br><span class="line">Out[<span class="number">14</span>]: (<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>对象本身并没有被复制，只是引用了它。</p>
<h2 id="拆分元组">拆分元组</h2>
<p>如果你想将元组赋值给类似元组的变量，Python会试图拆分等号右边的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: tup = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: a, b, c = tup</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: b</span><br><span class="line">Out[<span class="number">17</span>]: <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>即使含有元组的元组也会被拆分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: tup = <span class="number">4</span>, <span class="number">5</span>, (<span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: a, b, (c, d) = tup</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: d</span><br><span class="line">Out[<span class="number">20</span>]: <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>使用这个功能，你可以很容易地替换变量的名字，其它语言可能是这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tmp = a</span><br><span class="line">a = b</span><br><span class="line">b = tmp</span><br></pre></td></tr></table></figure>
<p>但是在Python中，替换可以这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: a, b = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: a</span><br><span class="line">Out[<span class="number">22</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: b</span><br><span class="line">Out[<span class="number">23</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: b, a = a, b</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: a</span><br><span class="line">Out[<span class="number">25</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: b</span><br><span class="line">Out[<span class="number">26</span>]: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>变量拆分常用来迭代元组或列表序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">27</span>]: seq = [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: <span class="keyword">for</span> a, b, c <span class="keyword">in</span> seq:</span><br><span class="line">   ....:     <span class="built_in">print</span>(<span class="string">&#x27;a=&#123;0&#125;, b=&#123;1&#125;, c=&#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(a, b, c))</span><br><span class="line">a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span></span><br><span class="line">a=<span class="number">4</span>, b=<span class="number">5</span>, c=<span class="number">6</span></span><br><span class="line">a=<span class="number">7</span>, b=<span class="number">8</span>, c=<span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>另一个常见用法是从函数返回多个值。后面会详解。</p>
<p>Python最近新增了更多高级的元组拆分功能，允许从元组的开头“摘取”几个元素。它使用了特殊的语法<code>*rest</code>，这也用在函数签名中以抓取任意长度列表的位置参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">29</span>]: values = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: a, b, *rest = values</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: a, b</span><br><span class="line">Out[<span class="number">31</span>]: (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: rest</span><br><span class="line">Out[<span class="number">32</span>]: [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p><code>rest</code>的部分是想要舍弃的部分，rest的名字不重要。作为惯用写法，许多Python程序员会将不需要的变量使用下划线：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">33</span>]: a, b, *_ = values</span><br></pre></td></tr></table></figure>
<h2 id="tuple方法">tuple方法</h2>
<p>因为元组的大小和内容不能修改，它的实例方法都很轻量。其中一个很有用的就是<code>count</code>（也适用于列表），它可以统计某个值得出现频率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">34</span>]: a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: a.count(<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">35</span>]: <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="列表">列表</h2>
<p>与元组对比，列表的长度可变、内容可以被修改。你可以用方括号定义，或用<code>list</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">36</span>]: a_list = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="literal">None</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: tup = (<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: b_list = <span class="built_in">list</span>(tup)</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: b_list</span><br><span class="line">Out[<span class="number">39</span>]: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: b_list[<span class="number">1</span>] = <span class="string">&#x27;peekaboo&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: b_list</span><br><span class="line">Out[<span class="number">41</span>]: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;peekaboo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>列表和元组的语义接近，在许多函数中可以交叉使用。</p>
<p><code>list</code>函数常用来在数据处理中实体化迭代器或生成器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">42</span>]: gen = <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: gen</span><br><span class="line">Out[<span class="number">43</span>]: <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: <span class="built_in">list</span>(gen)</span><br><span class="line">Out[<span class="number">44</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="添加和删除元素">添加和删除元素</h2>
<p>可以用<code>append</code>在列表末尾添加元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">45</span>]: b_list.append(<span class="string">&#x27;dwarf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: b_list</span><br><span class="line">Out[<span class="number">46</span>]: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;peekaboo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;dwarf&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>insert</code>可以在特定的位置插入元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">47</span>]: b_list.insert(<span class="number">1</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: b_list</span><br><span class="line">Out[<span class="number">48</span>]: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;peekaboo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;dwarf&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>插入的序号必须在0和列表长度之间。</p>
<blockquote>
<p>警告：与<code>append</code>相比，<code>insert</code>耗费的计算量大，因为对后续元素的引用必须在内部迁移，以便为新元素提供空间。如果要在序列的头部和尾部插入元素，你可能需要使用<code>collections.deque</code>，一个双尾部队列。</p>
</blockquote>
<p>insert的逆运算是pop，它移除并返回指定位置的元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">49</span>]: b_list.pop(<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">49</span>]: <span class="string">&#x27;peekaboo&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: b_list</span><br><span class="line">Out[<span class="number">50</span>]: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;dwarf&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以用<code>remove</code>去除某个值，<code>remove</code>会先寻找第一个值并除去：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">51</span>]: b_list.append(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: b_list</span><br><span class="line">Out[<span class="number">52</span>]: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;dwarf&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: b_list.remove(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: b_list</span><br><span class="line">Out[<span class="number">54</span>]: [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;dwarf&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果不考虑性能，使用<code>append</code>和<code>remove</code>，可以把Python的列表当做完美的“多重集”数据结构。</p>
<p>用<code>in</code>可以检查列表是否包含某个值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">55</span>]: <span class="string">&#x27;dwarf&#x27;</span> <span class="keyword">in</span> b_list</span><br><span class="line">Out[<span class="number">55</span>]: <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>否定<code>in</code>可以再加一个not：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: <span class="string">&#x27;dwarf&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> b_list</span><br><span class="line">Out[<span class="number">56</span>]: <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在列表中检查是否存在某个值远比字典和集合速度慢，因为Python是线性搜索列表中的值，但在字典和集合中，在同样的时间内还可以检查其它项（基于哈希表）。</p>
<h2 id="串联和组合列表">串联和组合列表</h2>
<p>与元组类似，可以用加号将两个列表串联起来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">57</span>]: [<span class="number">4</span>, <span class="literal">None</span>, <span class="string">&#x27;foo&#x27;</span>] + [<span class="number">7</span>, <span class="number">8</span>, (<span class="number">2</span>, <span class="number">3</span>)]</span><br><span class="line">Out[<span class="number">57</span>]: [<span class="number">4</span>, <span class="literal">None</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="number">7</span>, <span class="number">8</span>, (<span class="number">2</span>, <span class="number">3</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果已经定义了一个列表，用<code>extend</code>方法可以追加多个元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">58</span>]: x = [<span class="number">4</span>, <span class="literal">None</span>, <span class="string">&#x27;foo&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: x.extend([<span class="number">7</span>, <span class="number">8</span>, (<span class="number">2</span>, <span class="number">3</span>)])</span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: x</span><br><span class="line">Out[<span class="number">60</span>]: [<span class="number">4</span>, <span class="literal">None</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="number">7</span>, <span class="number">8</span>, (<span class="number">2</span>, <span class="number">3</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过加法将列表串联的计算量较大，因为要新建一个列表，并且要复制对象。用<code>extend</code>追加元素，尤其是到一个大列表中，更为可取。因此：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">everything = []</span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> list_of_lists:</span><br><span class="line">    everything.extend(chunk)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要比串联方法快：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">everything = []</span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> list_of_lists:</span><br><span class="line">    everything = everything + chunk</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="排序">排序</h2>
<p>你可以用<code>sort</code>函数将一个列表原地排序（不创建新的对象）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">61</span>]: a = [<span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: a.sort()</span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: a</span><br><span class="line">Out[<span class="number">63</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>sort</code>有一些选项，有时会很好用。其中之一是二级排序key，可以用这个key进行排序。例如，我们可以按长度对字符串进行排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">64</span>]: b = [<span class="string">&#x27;saw&#x27;</span>, <span class="string">&#x27;small&#x27;</span>, <span class="string">&#x27;He&#x27;</span>, <span class="string">&#x27;foxes&#x27;</span>, <span class="string">&#x27;six&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: b.sort(key=<span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: b</span><br><span class="line">Out[<span class="number">66</span>]: [<span class="string">&#x27;He&#x27;</span>, <span class="string">&#x27;saw&#x27;</span>, <span class="string">&#x27;six&#x27;</span>, <span class="string">&#x27;small&#x27;</span>, <span class="string">&#x27;foxes&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>稍后，我们会学习<code>sorted</code>函数，它可以产生一个排好序的序列副本。</p>
<h2 id="二分搜索和维护已排序的列表">二分搜索和维护已排序的列表</h2>
<p><code>bisect</code>模块支持二分查找，和向已排序的列表插入值。<code>bisect.bisect</code>可以找到插入值后仍保证排序的位置，<code>bisect.insort</code>是向这个位置插入值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">67</span>]: <span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: bisect.bisect(c, <span class="number">2</span>)</span><br><span class="line">Out[<span class="number">69</span>]: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: bisect.bisect(c, <span class="number">5</span>)</span><br><span class="line">Out[<span class="number">70</span>]: <span class="number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: bisect.insort(c, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: c</span><br><span class="line">Out[<span class="number">72</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>bisect</code>模块不会检查列表是否已排好序，进行检查的话会耗费大量计算。因此，对未排序的列表使用<code>bisect</code>不会产生错误，但结果不一定正确。</p>
</blockquote>
<h2 id="切片">切片</h2>
<p>用切边可以选取大多数序列类型的一部分，切片的基本形式是在方括号中使用<code>start:stop</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">73</span>]: seq = [<span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">74</span>]: seq[<span class="number">1</span>:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">74</span>]: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>切片也可以被序列赋值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">75</span>]: seq[<span class="number">3</span>:<span class="number">4</span>] = [<span class="number">6</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: seq</span><br><span class="line">Out[<span class="number">76</span>]: [<span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>切片的起始元素是包括的，不包含结束元素。因此，结果中包含的元素个数是<code>stop - start</code>。</p>
<p><code>start</code>或<code>stop</code>都可以被省略，省略之后，分别默认序列的开头和结尾：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">77</span>]: seq[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">77</span>]: [<span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: seq[<span class="number">3</span>:]</span><br><span class="line">Out[<span class="number">78</span>]: [<span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>负数表明从后向前切片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">79</span>]: seq[-<span class="number">4</span>:]</span><br><span class="line">Out[<span class="number">79</span>]: [<span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: seq[-<span class="number">6</span>:-<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">80</span>]: [<span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要一段时间来熟悉使用切片，尤其是当你之前学的是R或MATLAB。图3-1展示了正整数和负整数的切片。在图中，指数标示在边缘以表明切片是在哪里开始哪里结束的。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-522e2b688b755ff3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3-1 Python切片演示" /><figcaption aria-hidden="true">图3-1 Python切片演示</figcaption>
</figure>
<p>在第二个冒号后面使用<code>step</code>，可以隔一个取一个元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">81</span>]: seq[::<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">81</span>]: [<span class="number">7</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一个聪明的方法是使用<code>-1</code>，它可以将列表或元组颠倒过来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">82</span>]: seq[::-<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">82</span>]: [<span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="序列函数">序列函数</h2>
<p>Python有一些有用的序列函数。</p>
<h2 id="enumerate函数">enumerate函数</h2>
<p>迭代一个序列时，你可能想跟踪当前项的序号。手动的方法可能是下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> collection:</span><br><span class="line">   <span class="comment"># do something with value</span></span><br><span class="line">   i += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为这么做很常见，Python内建了一个<code>enumerate</code>函数，可以返回<code>(i, value)</code>元组序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(collection):</span><br><span class="line">   <span class="comment"># do something with value</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当你索引数据时，使用<code>enumerate</code>的一个好方法是计算序列（唯一的）<code>dict</code>映射到位置的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">83</span>]: some_list = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: mapping = &#123;&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">85</span>]: <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(some_list):</span><br><span class="line">   ....:     mapping[v] = i</span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: mapping</span><br><span class="line">Out[<span class="number">86</span>]: &#123;<span class="string">&#x27;bar&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;baz&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;foo&#x27;</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="sorted函数">sorted函数</h2>
<p><code>sorted</code>函数可以从任意序列的元素返回一个新的排好序的列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">87</span>]: <span class="built_in">sorted</span>([<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">Out[<span class="number">87</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: <span class="built_in">sorted</span>(<span class="string">&#x27;horse race&#x27;</span>)</span><br><span class="line">Out[<span class="number">88</span>]: [<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>sorted</code>函数可以接受和<code>sort</code>相同的参数。</p>
<h2 id="zip函数">zip函数</h2>
<p><code>zip</code>可以将多个列表、元组或其它序列成对组合成一个元组列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">89</span>]: seq1 = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: seq2 = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">91</span>]: zipped = <span class="built_in">zip</span>(seq1, seq2)</span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: <span class="built_in">list</span>(zipped)</span><br><span class="line">Out[<span class="number">92</span>]: [(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;one&#x27;</span>), (<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;two&#x27;</span>), (<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;three&#x27;</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>zip</code>可以处理任意多的序列，元素的个数取决于最短的序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">93</span>]: seq3 = [<span class="literal">False</span>, <span class="literal">True</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: <span class="built_in">list</span>(<span class="built_in">zip</span>(seq1, seq2, seq3))</span><br><span class="line">Out[<span class="number">94</span>]: [(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="literal">False</span>), (<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="literal">True</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>zip</code>的常见用法之一是同时迭代多个序列，可能结合<code>enumerate</code>使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">95</span>]: <span class="keyword">for</span> i, (a, b) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(seq1, seq2)):</span><br><span class="line">   ....:     <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;: &#123;1&#125;, &#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(i, a, b))</span><br><span class="line">   ....:</span><br><span class="line"><span class="number">0</span>: foo, one</span><br><span class="line"><span class="number">1</span>: bar, two</span><br><span class="line"><span class="number">2</span>: baz, three</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>给出一个“被压缩的”序列，<code>zip</code>可以被用来解压序列。也可以当作把行的列表转换为列的列表。这个方法看起来有点神奇：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">96</span>]: pitchers = [(<span class="string">&#x27;Nolan&#x27;</span>, <span class="string">&#x27;Ryan&#x27;</span>), (<span class="string">&#x27;Roger&#x27;</span>, <span class="string">&#x27;Clemens&#x27;</span>),</span><br><span class="line">   ....:             (<span class="string">&#x27;Schilling&#x27;</span>, <span class="string">&#x27;Curt&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: first_names, last_names = <span class="built_in">zip</span>(*pitchers)</span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: first_names</span><br><span class="line">Out[<span class="number">98</span>]: (<span class="string">&#x27;Nolan&#x27;</span>, <span class="string">&#x27;Roger&#x27;</span>, <span class="string">&#x27;Schilling&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: last_names</span><br><span class="line">Out[<span class="number">99</span>]: (<span class="string">&#x27;Ryan&#x27;</span>, <span class="string">&#x27;Clemens&#x27;</span>, <span class="string">&#x27;Curt&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="reversed函数">reversed函数</h2>
<p><code>reversed</code>可以从后向前迭代一个序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">100</span>]: <span class="built_in">list</span>(<span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line">Out[<span class="number">100</span>]: [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要记住<code>reversed</code>是一个生成器（后面详细介绍），只有实体化（即列表或for循环）之后才能创建翻转的序列。</p>
<h2 id="字典">字典</h2>
<p>字典可能是Python最为重要的数据结构。它更为常见的名字是哈希映射或关联数组。它是键值对的大小可变集合，键和值都是Python对象。创建字典的方法之一是使用尖括号，用冒号分隔键和值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">101</span>]: empty_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">102</span>]: d1 = &#123;<span class="string">&#x27;a&#x27;</span> : <span class="string">&#x27;some value&#x27;</span>, <span class="string">&#x27;b&#x27;</span> : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: d1</span><br><span class="line">Out[<span class="number">103</span>]: &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;some value&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可以像访问列表或元组中的元素一样，访问、插入或设定字典中的元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">104</span>]: d1[<span class="number">7</span>] = <span class="string">&#x27;an integer&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: d1</span><br><span class="line">Out[<span class="number">105</span>]: &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;some value&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">7</span>: <span class="string">&#x27;an integer&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: d1[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">106</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可以用检查列表和元组是否包含某个值的方法，检查字典中是否包含某个键：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">107</span>]: <span class="string">&#x27;b&#x27;</span> <span class="keyword">in</span> d1</span><br><span class="line">Out[<span class="number">107</span>]: <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以用<code>del</code>关键字或<code>pop</code>方法（返回值的同时删除键）删除值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">108</span>]: d1[<span class="number">5</span>] = <span class="string">&#x27;some value&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: d1</span><br><span class="line">Out[<span class="number">109</span>]: </span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;some value&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;b&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"> <span class="number">7</span>: <span class="string">&#x27;an integer&#x27;</span>,</span><br><span class="line"> <span class="number">5</span>: <span class="string">&#x27;some value&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">110</span>]: d1[<span class="string">&#x27;dummy&#x27;</span>] = <span class="string">&#x27;another value&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: d1</span><br><span class="line">Out[<span class="number">111</span>]: </span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;some value&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;b&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"> <span class="number">7</span>: <span class="string">&#x27;an integer&#x27;</span>,</span><br><span class="line"> <span class="number">5</span>: <span class="string">&#x27;some value&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;dummy&#x27;</span>: <span class="string">&#x27;another value&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">112</span>]: <span class="keyword">del</span> d1[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">113</span>]: d1</span><br><span class="line">Out[<span class="number">113</span>]: </span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;some value&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;b&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"> <span class="number">7</span>: <span class="string">&#x27;an integer&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;dummy&#x27;</span>: <span class="string">&#x27;another value&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: ret = d1.pop(<span class="string">&#x27;dummy&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">115</span>]: ret</span><br><span class="line">Out[<span class="number">115</span>]: <span class="string">&#x27;another value&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: d1</span><br><span class="line">Out[<span class="number">116</span>]: &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;some value&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">7</span>: <span class="string">&#x27;an integer&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>keys</code>和<code>values</code>是字典的键和值的迭代器方法。虽然键值对没有顺序，这两个方法可以用相同的顺序输出键和值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">117</span>]: <span class="built_in">list</span>(d1.keys())</span><br><span class="line">Out[<span class="number">117</span>]: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: <span class="built_in">list</span>(d1.values())</span><br><span class="line">Out[<span class="number">118</span>]: [<span class="string">&#x27;some value&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="string">&#x27;an integer&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用<code>update</code>方法可以将一个字典与另一个融合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">119</span>]: d1.update(&#123;<span class="string">&#x27;b&#x27;</span> : <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;c&#x27;</span> : <span class="number">12</span>&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: d1</span><br><span class="line">Out[<span class="number">120</span>]: &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;some value&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;an integer&#x27;</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">12</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>update</code>方法是原地改变字典，因此任何传递给<code>update</code>的键的旧的值都会被舍弃。</p>
<h2 id="用序列创建字典">用序列创建字典</h2>
<p>常常，你可能想将两个序列配对组合成字典。下面是一种写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mapping = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">zip</span>(key_list, value_list):</span><br><span class="line">    mapping[key] = value</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为字典本质上是2元元组的集合，dict可以接受2元元组的列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">121</span>]: mapping = <span class="built_in">dict</span>(<span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">5</span>), <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">5</span>))))</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: mapping</span><br><span class="line">Out[<span class="number">122</span>]: &#123;<span class="number">0</span>: <span class="number">4</span>, <span class="number">1</span>: <span class="number">3</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">1</span>, <span class="number">4</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>后面会谈到<code>dict comprehensions</code>，另一种构建字典的优雅方式。</p>
<h2 id="默认值">默认值</h2>
<p>下面的逻辑很常见：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> key <span class="keyword">in</span> some_dict:</span><br><span class="line">    value = some_dict[key]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    value = default_value</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此，dict的方法get和pop可以取默认值进行返回，上面的if-else语句可以简写成下面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = some_dict.get(key, default_value)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>get默认会返回None，如果不存在键，pop会抛出一个例外。关于设定值，常见的情况是在字典的值是属于其它集合，如列表。例如，你可以通过首字母，将一个列表中的单词分类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">123</span>]: words = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;bat&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;atom&#x27;</span>, <span class="string">&#x27;book&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: by_letter = &#123;&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">   .....:     letter = word[<span class="number">0</span>]</span><br><span class="line">   .....:     <span class="keyword">if</span> letter <span class="keyword">not</span> <span class="keyword">in</span> by_letter:</span><br><span class="line">   .....:         by_letter[letter] = [word]</span><br><span class="line">   .....:     <span class="keyword">else</span>:</span><br><span class="line">   .....:         by_letter[letter].append(word)</span><br><span class="line">   .....:</span><br><span class="line"></span><br><span class="line">In [<span class="number">126</span>]: by_letter</span><br><span class="line">Out[<span class="number">126</span>]: &#123;<span class="string">&#x27;a&#x27;</span>: [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;atom&#x27;</span>], <span class="string">&#x27;b&#x27;</span>: [<span class="string">&#x27;bat&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;book&#x27;</span>]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>setdefault</code>方法就正是干这个的。前面的for循环可以改写为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    letter = word[<span class="number">0</span>]</span><br><span class="line">    by_letter.setdefault(letter, []).append(word)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>collections</code>模块有一个很有用的类，<code>defaultdict</code>，它可以进一步简化上面。传递类型或函数以生成每个位置的默认值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">by_letter = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    by_letter[word[<span class="number">0</span>]].append(word)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="有效的键类型">有效的键类型</h2>
<p>字典的值可以是任意Python对象，而键通常是不可变的标量类型（整数、浮点型、字符串）或元组（元组中的对象必须是不可变的）。这被称为“可哈希性”。可以用<code>hash</code>函数检测一个对象是否是可哈希的（可被用作字典的键）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">127</span>]: <span class="built_in">hash</span>(<span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">Out[<span class="number">127</span>]: <span class="number">5023931463650008331</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">128</span>]: <span class="built_in">hash</span>((<span class="number">1</span>, <span class="number">2</span>, (<span class="number">2</span>, <span class="number">3</span>)))</span><br><span class="line">Out[<span class="number">128</span>]: <span class="number">1097636502276347782</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: <span class="built_in">hash</span>((<span class="number">1</span>, <span class="number">2</span>, [<span class="number">2</span>, <span class="number">3</span>])) <span class="comment"># fails because lists are mutable</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">129</span>-800cd14ba8be&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> <span class="built_in">hash</span>((<span class="number">1</span>, <span class="number">2</span>, [<span class="number">2</span>, <span class="number">3</span>])) <span class="comment"># fails because lists are mutable</span></span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要用列表当做键，一种方法是将列表转化为元组，只要内部元素可以被哈希，它也就可以被哈希：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">130</span>]: d = &#123;&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">131</span>]: d[<span class="built_in">tuple</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">132</span>]: d</span><br><span class="line">Out[<span class="number">132</span>]: &#123;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>): <span class="number">5</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="集合">集合</h2>
<p>集合是无序的不可重复的元素的集合。你可以把它当做字典，但是只有键没有值。可以用两种方式创建集合：通过set函数或使用尖括号set语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">133</span>]: <span class="built_in">set</span>([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line">Out[<span class="number">133</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">134</span>]: &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>&#125;</span><br><span class="line">Out[<span class="number">134</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>集合支持合并、交集、差分和对称差等数学集合运算。考虑两个示例集合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">135</span>]: a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: b = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>合并是取两个集合中不重复的元素。可以用<code>union</code>方法，或者<code>|</code>运算符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">137</span>]: a.union(b)</span><br><span class="line">Out[<span class="number">137</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">138</span>]: a | b</span><br><span class="line">Out[<span class="number">138</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>交集的元素包含在两个集合中。可以用<code>intersection</code>或<code>&amp;</code>运算符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">139</span>]: a.intersection(b)</span><br><span class="line">Out[<span class="number">139</span>]: &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">140</span>]: a &amp; b</span><br><span class="line">Out[<span class="number">140</span>]: &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表3-1列出了常用的集合方法。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-980efe5d98ecc4d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表3-1 Python的集合操作" /><figcaption aria-hidden="true">表3-1 Python的集合操作</figcaption>
</figure>
<p>所有逻辑集合操作都有另外的原地实现方法，可以直接用结果替代集合的内容。对于大的集合，这么做效率更高：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">141</span>]: c = a.copy()</span><br><span class="line"></span><br><span class="line">In [<span class="number">142</span>]: c |= b</span><br><span class="line"></span><br><span class="line">In [<span class="number">143</span>]: c</span><br><span class="line">Out[<span class="number">143</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">144</span>]: d = a.copy()</span><br><span class="line"></span><br><span class="line">In [<span class="number">145</span>]: d &amp;= b</span><br><span class="line"></span><br><span class="line">In [<span class="number">146</span>]: d</span><br><span class="line">Out[<span class="number">146</span>]: &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与字典类似，集合元素通常都是不可变的。要获得类似列表的元素，必须转换成元组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">147</span>]: my_data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">148</span>]: my_set = &#123;<span class="built_in">tuple</span>(my_data)&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">149</span>]: my_set</span><br><span class="line">Out[<span class="number">149</span>]: &#123;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你还可以检测一个集合是否是另一个集合的子集或父集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">150</span>]: a_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">151</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;.issubset(a_set)</span><br><span class="line">Out[<span class="number">151</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">152</span>]: a_set.issuperset(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line">Out[<span class="number">152</span>]: <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>集合的内容相同时，集合才对等：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">153</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; == &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line">Out[<span class="number">153</span>]: <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="列表集合和字典推导式">列表、集合和字典推导式</h2>
<p>列表推导式是Python最受喜爱的特性之一。它允许用户方便的从一个集合过滤元素，形成列表，在传递参数的过程中还可以修改元素。形式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[expr <span class="keyword">for</span> val <span class="keyword">in</span> collection <span class="keyword">if</span> condition]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它等同于下面的for循环;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> collection:</span><br><span class="line">    <span class="keyword">if</span> condition:</span><br><span class="line">        result.append(expr)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>filter条件可以被忽略，只留下表达式就行。例如，给定一个字符串列表，我们可以过滤出长度在2及以下的字符串，并将其转换成大写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">154</span>]: strings = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;as&#x27;</span>, <span class="string">&#x27;bat&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;dove&#x27;</span>, <span class="string">&#x27;python&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">155</span>]: [x.upper() <span class="keyword">for</span> x <span class="keyword">in</span> strings <span class="keyword">if</span> <span class="built_in">len</span>(x) &gt; <span class="number">2</span>]</span><br><span class="line">Out[<span class="number">155</span>]: [<span class="string">&#x27;BAT&#x27;</span>, <span class="string">&#x27;CAR&#x27;</span>, <span class="string">&#x27;DOVE&#x27;</span>, <span class="string">&#x27;PYTHON&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用相似的方法，还可以推导集合和字典。字典的推导式如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict_comp = &#123;key-expr : value-expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>集合的推导式与列表很像，只不过用的是尖括号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set_comp = &#123;expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与列表推导式类似，集合与字典的推导也很方便，而且使代码的读写都很容易。来看前面的字符串列表。假如我们只想要字符串的长度，用集合推导式的方法非常方便：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">156</span>]: unique_lengths = &#123;<span class="built_in">len</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> strings&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">157</span>]: unique_lengths</span><br><span class="line">Out[<span class="number">157</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>map</code>函数可以进一步简化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">158</span>]: <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="built_in">len</span>, strings))</span><br><span class="line">Out[<span class="number">158</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>作为一个字典推导式的例子，我们可以创建一个字符串的查找映射表以确定它在列表中的位置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">159</span>]: loc_mapping = &#123;val : index <span class="keyword">for</span> index, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(strings)&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">160</span>]: loc_mapping</span><br><span class="line">Out[<span class="number">160</span>]: &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;as&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;bat&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;car&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;dove&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;python&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="嵌套列表推导式">嵌套列表推导式</h2>
<p>假设我们有一个包含列表的列表，包含了一些英文名和西班牙名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">161</span>]: all_data = [[<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Emily&#x27;</span>, <span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Mary&#x27;</span>, <span class="string">&#x27;Steven&#x27;</span>],</span><br><span class="line">   .....:             [<span class="string">&#x27;Maria&#x27;</span>, <span class="string">&#x27;Juan&#x27;</span>, <span class="string">&#x27;Javier&#x27;</span>, <span class="string">&#x27;Natalia&#x27;</span>, <span class="string">&#x27;Pilar&#x27;</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可能是从一些文件得到的这些名字，然后想按照语言进行分类。现在假设我们想用一个列表包含所有的名字，这些名字中包含两个或更多的e。可以用for循环来做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names_of_interest = []</span><br><span class="line"><span class="keyword">for</span> names <span class="keyword">in</span> all_data:</span><br><span class="line">    enough_es = [name <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> name.count(<span class="string">&#x27;e&#x27;</span>) &gt;= <span class="number">2</span>]</span><br><span class="line">    names_of_interest.extend(enough_es)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以用嵌套列表推导式的方法，将这些写在一起，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">162</span>]: result = [name <span class="keyword">for</span> names <span class="keyword">in</span> all_data <span class="keyword">for</span> name <span class="keyword">in</span> names</span><br><span class="line">   .....:           <span class="keyword">if</span> name.count(<span class="string">&#x27;e&#x27;</span>) &gt;= <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">163</span>]: result</span><br><span class="line">Out[<span class="number">163</span>]: [<span class="string">&#x27;Steven&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>嵌套列表推导式看起来有些复杂。列表推导式的for部分是根据嵌套的顺序，过滤条件还是放在最后。下面是另一个例子，我们将一个整数元组的列表扁平化成了一个整数列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">164</span>]: some_tuples = [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">165</span>]: flattened = [x <span class="keyword">for</span> tup <span class="keyword">in</span> some_tuples <span class="keyword">for</span> x <span class="keyword">in</span> tup]</span><br><span class="line"></span><br><span class="line">In [<span class="number">166</span>]: flattened</span><br><span class="line">Out[<span class="number">166</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>记住，for表达式的顺序是与嵌套for循环的顺序一样（而不是列表推导式的顺序）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flattened = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tup <span class="keyword">in</span> some_tuples:</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> tup:</span><br><span class="line">        flattened.append(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可以有任意多级别的嵌套，但是如果你有两三个以上的嵌套，你就应该考虑下代码可读性的问题了。分辨列表推导式的列表推导式中的语法也是很重要的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">167</span>]: [[x <span class="keyword">for</span> x <span class="keyword">in</span> tup] <span class="keyword">for</span> tup <span class="keyword">in</span> some_tuples]</span><br><span class="line">Out[<span class="number">167</span>]: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码产生了一个列表的列表，而不是扁平化的只包含元素的列表。</p>
<h1 id="函数">3.2 函数</h1>
<p>函数是Python中最主要也是最重要的代码组织和复用手段。作为最重要的原则，如果你要重复使用相同或非常类似的代码，就需要写一个函数。通过给函数起一个名字，还可以提高代码的可读性。</p>
<p>函数使用<code>def</code>关键字声明，用<code>return</code>关键字返回值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_function</span>(<span class="params">x, y, z=<span class="number">1.5</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> z &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> z * (x + y)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> z / (x + y)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同时拥有多条return语句也是可以的。如果到达函数末尾时没有遇到任何一条return语句，则返回None。</p>
<p>函数可以有一些位置参数（positional）和一些关键字参数（keyword）。关键字参数通常用于指定默认值或可选参数。在上面的函数中，x和y是位置参数，而z则是关键字参数。也就是说，该函数可以下面这两种方式进行调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_function(<span class="number">5</span>, <span class="number">6</span>, z=<span class="number">0.7</span>)</span><br><span class="line">my_function(<span class="number">3.14</span>, <span class="number">7</span>, <span class="number">3.5</span>)</span><br><span class="line">my_function(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数参数的主要限制在于：关键字参数必须位于位置参数（如果有的话）之后。你可以任何顺序指定关键字参数。也就是说，你不用死记硬背函数参数的顺序，只要记得它们的名字就可以了。</p>
<blockquote>
<p>笔记：也可以用关键字传递位置参数。前面的例子，也可以写为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_function(x=<span class="number">5</span>, y=<span class="number">6</span>, z=<span class="number">7</span>)</span><br><span class="line">my_function(y=<span class="number">6</span>, x=<span class="number">5</span>, z=<span class="number">7</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种写法可以提高可读性。</p>
</blockquote>
<h2 id="命名空间作用域和局部函数">命名空间、作用域，和局部函数</h2>
<p>函数可以访问两种不同作用域中的变量：全局（global）和局部（local）。Python有一种更科学的用于描述变量作用域的名称，即命名空间（namespace）。任何在函数中赋值的变量默认都是被分配到局部命名空间（local namespace）中的。局部命名空间是在函数被调用时创建的，函数参数会立即填入该命名空间。在函数执行完毕之后，局部命名空间就会被销毁（会有一些例外的情况，具体请参见后面介绍闭包的那一节）。看看下面这个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    a = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        a.append(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调用func()之后，首先会创建出空列表a，然后添加5个元素，最后a会在该函数退出的时候被销毁。假如我们像下面这样定义a：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        a.append(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然可以在函数中对全局变量进行赋值操作，但是那些变量必须用global关键字声明成全局的才行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">168</span>]: a = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">169</span>]: <span class="function"><span class="keyword">def</span> <span class="title">bind_a_variable</span>():</span></span><br><span class="line">   .....:     <span class="keyword">global</span> a</span><br><span class="line">   .....:     a = []</span><br><span class="line">   .....: bind_a_variable()</span><br><span class="line">   .....:</span><br><span class="line"></span><br><span class="line">In [<span class="number">170</span>]: <span class="built_in">print</span>(a)</span><br><span class="line">[]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：我常常建议人们不要频繁使用global关键字。因为全局变量一般是用于存放系统的某些状态的。如果你发现自己用了很多，那可能就说明得要来点儿面向对象编程了（即使用类）。</p>
</blockquote>
<h2 id="返回多个值">返回多个值</h2>
<p>在我第一次用Python编程时（之前已经习惯了Java和C++），最喜欢的一个功能是：函数可以返回多个值。下面是一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    b = <span class="number">6</span></span><br><span class="line">    c = <span class="number">7</span></span><br><span class="line">    <span class="keyword">return</span> a, b, c</span><br><span class="line"></span><br><span class="line">a, b, c = f()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在数据分析和其他科学计算应用中，你会发现自己常常这么干。该函数其实只返回了一个对象，也就是一个元组，最后该元组会被拆包到各个结果变量中。在上面的例子中，我们还可以这样写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">return_value = f()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的return_value将会是一个含有3个返回值的三元元组。此外，还有一种非常具有吸引力的多值返回方式——返回字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    b = <span class="number">6</span></span><br><span class="line">    c = <span class="number">7</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;a&#x27;</span> : a, <span class="string">&#x27;b&#x27;</span> : b, <span class="string">&#x27;c&#x27;</span> : c&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>取决于工作内容，第二种方法可能很有用。</p>
<h2 id="函数也是对象">函数也是对象</h2>
<p>由于Python函数都是对象，因此，在其他语言中较难表达的一些设计思想在Python中就要简单很多了。假设我们有下面这样一个字符串数组，希望对其进行一些数据清理工作并执行一堆转换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">171</span>]: states = [<span class="string">&#x27;   Alabama &#x27;</span>, <span class="string">&#x27;Georgia!&#x27;</span>, <span class="string">&#x27;Georgia&#x27;</span>, <span class="string">&#x27;georgia&#x27;</span>, <span class="string">&#x27;FlOrIda&#x27;</span>,</span><br><span class="line">   .....:           <span class="string">&#x27;south   carolina##&#x27;</span>, <span class="string">&#x27;West virginia?&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不管是谁，只要处理过由用户提交的调查数据，就能明白这种乱七八糟的数据是怎么一回事。为了得到一组能用于分析工作的格式统一的字符串，需要做很多事情：去除空白符、删除各种标点符号、正确的大写格式等。做法之一是使用内建的字符串方法和正则表达式<code>re</code>模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_strings</span>(<span class="params">strings</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> strings:</span><br><span class="line">        value = value.strip()</span><br><span class="line">        value = re.sub(<span class="string">&#x27;[!#?]&#x27;</span>, <span class="string">&#x27;&#x27;</span>, value)</span><br><span class="line">        value = value.title()</span><br><span class="line">        result.append(value)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">173</span>]: clean_strings(states)</span><br><span class="line">Out[<span class="number">173</span>]: </span><br><span class="line">[<span class="string">&#x27;Alabama&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Georgia&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Georgia&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Georgia&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Florida&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;South   Carolina&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;West Virginia&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实还有另外一种不错的办法：将需要在一组给定字符串上执行的所有运算做成一个列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_punctuation</span>(<span class="params">value</span>):</span></span><br><span class="line">    <span class="keyword">return</span> re.sub(<span class="string">&#x27;[!#?]&#x27;</span>, <span class="string">&#x27;&#x27;</span>, value)</span><br><span class="line"></span><br><span class="line">clean_ops = [<span class="built_in">str</span>.strip, remove_punctuation, <span class="built_in">str</span>.title]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_strings</span>(<span class="params">strings, ops</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> strings:</span><br><span class="line">        <span class="keyword">for</span> function <span class="keyword">in</span> ops:</span><br><span class="line">            value = function(value)</span><br><span class="line">        result.append(value)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们就有了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">175</span>]: clean_strings(states, clean_ops)</span><br><span class="line">Out[<span class="number">175</span>]: </span><br><span class="line">[<span class="string">&#x27;Alabama&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Georgia&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Georgia&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Georgia&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Florida&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;South   Carolina&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;West Virginia&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种多函数模式使你能在很高的层次上轻松修改字符串的转换方式。此时的clean_strings也更具可复用性！</p>
<p>还可以将函数用作其他函数的参数，比如内置的map函数，它用于在一组数据上应用一个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">176</span>]: <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">map</span>(remove_punctuation, states):</span><br><span class="line">   .....:     <span class="built_in">print</span>(x)</span><br><span class="line">Alabama </span><br><span class="line">Georgia</span><br><span class="line">Georgia</span><br><span class="line">georgia</span><br><span class="line">FlOrIda</span><br><span class="line">south   carolina</span><br><span class="line">West virginia</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="匿名lambda函数">匿名（lambda）函数</h2>
<p>Python支持一种被称为匿名的、或lambda函数。它仅由单条语句组成，该语句的结果就是返回值。它是通过lambda关键字定义的，这个关键字没有别的含义，仅仅是说“我们正在声明的是一个匿名函数”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">short_function</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">equiv_anon = <span class="keyword">lambda</span> x: x * <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>本书其余部分一般将其称为lambda函数。它们在数据分析工作中非常方便，因为你会发现很多数据转换函数都以函数作为参数的。直接传入lambda函数比编写完整函数声明要少输入很多字（也更清晰），甚至比将lambda函数赋值给一个变量还要少输入很多字。看看下面这个简单得有些傻的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_to_list</span>(<span class="params">some_list, f</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [f(x) <span class="keyword">for</span> x <span class="keyword">in</span> some_list]</span><br><span class="line"></span><br><span class="line">ints = [<span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">apply_to_list(ints, <span class="keyword">lambda</span> x: x * <span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然你可以直接编写[x *2for x in ints]，但是这里我们可以非常轻松地传入一个自定义运算给apply_to_list函数。</p>
<p>再来看另外一个例子。假设有一组字符串，你想要根据各字符串不同字母的数量对其进行排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">177</span>]: strings = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;card&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;aaaa&#x27;</span>, <span class="string">&#x27;abab&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，我们可以传入一个lambda函数到列表的sort方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">178</span>]: strings.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">len</span>(<span class="built_in">set</span>(<span class="built_in">list</span>(x))))</span><br><span class="line"></span><br><span class="line">In [<span class="number">179</span>]: strings</span><br><span class="line">Out[<span class="number">179</span>]: [<span class="string">&#x27;aaaa&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;abab&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;card&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：lambda函数之所以会被称为匿名函数，与def声明的函数不同，原因之一就是这种函数对象本身是没有提供名称__name__属性。</p>
</blockquote>
<h2 id="柯里化部分参数应用">柯里化：部分参数应用</h2>
<p>柯里化（currying）是一个有趣的计算机科学术语，它指的是通过“部分参数应用”（partial argument application）从现有函数派生出新函数的技术。例如，假设我们有一个执行两数相加的简单函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_numbers</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过这个函数，我们可以派生出一个新的只有一个参数的函数——add_five，它用于对其参数加5：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add_five = <span class="keyword">lambda</span> y: add_numbers(<span class="number">5</span>, y)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>add_numbers的第二个参数称为“柯里化的”（curried）。这里没什么特别花哨的东西，因为我们其实就只是定义了一个可以调用现有函数的新函数而已。内置的functools模块可以用partial函数将此过程简化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line">add_five = partial(add_numbers, <span class="number">5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="生成器">生成器</h2>
<p>能以一种一致的方式对序列进行迭代（比如列表中的对象或文件中的行）是Python的一个重要特点。这是通过一种叫做迭代器协议（iterator protocol，它是一种使对象可迭代的通用方式）的方式实现的，一个原生的使对象可迭代的方法。比如说，对字典进行迭代可以得到其所有的键：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">180</span>]: some_dict = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">181</span>]: <span class="keyword">for</span> key <span class="keyword">in</span> some_dict:</span><br><span class="line">   .....:     <span class="built_in">print</span>(key)</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当你编写for key in some_dict时，Python解释器首先会尝试从some_dict创建一个迭代器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">182</span>]: dict_iterator = <span class="built_in">iter</span>(some_dict)</span><br><span class="line"></span><br><span class="line">In [<span class="number">183</span>]: dict_iterator</span><br><span class="line">Out[<span class="number">183</span>]: &lt;dict_keyiterator at <span class="number">0x7fbbd5a9f908</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>迭代器是一种特殊对象，它可以在诸如for循环之类的上下文中向Python解释器输送对象。大部分能接受列表之类的对象的方法也都可以接受任何可迭代对象。比如min、max、sum等内置方法以及list、tuple等类型构造器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">184</span>]: <span class="built_in">list</span>(dict_iterator)</span><br><span class="line">Out[<span class="number">184</span>]: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>生成器（generator）是构造新的可迭代对象的一种简单方式。一般的函数执行之后只会返回单个值，而生成器则是以延迟的方式返回一个值序列，即每返回一个值之后暂停，直到下一个值被请求时再继续。要创建一个生成器，只需将函数中的return替换为yeild即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squares</span>(<span class="params">n=<span class="number">10</span></span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Generating squares from 1 to &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(n ** <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">yield</span> i ** <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调用该生成器时，没有任何代码会被立即执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">186</span>]: gen = squares()</span><br><span class="line"></span><br><span class="line">In [<span class="number">187</span>]: gen</span><br><span class="line">Out[<span class="number">187</span>]: &lt;generator <span class="built_in">object</span> squares at <span class="number">0x7fbbd5ab4570</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>直到你从该生成器中请求元素时，它才会开始执行其代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">188</span>]: <span class="keyword">for</span> x <span class="keyword">in</span> gen:</span><br><span class="line">   .....:     <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">Generating squares <span class="keyword">from</span> <span class="number">1</span> to <span class="number">100</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">16</span> <span class="number">25</span> <span class="number">36</span> <span class="number">49</span> <span class="number">64</span> <span class="number">81</span> <span class="number">100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="生成器表达式">生成器表达式</h2>
<p>另一种更简洁的构造生成器的方法是使用生成器表达式（generator expression）。这是一种类似于列表、字典、集合推导式的生成器。其创建方式为，把列表推导式两端的方括号改成圆括号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">189</span>]: gen = (x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">190</span>]: gen</span><br><span class="line">Out[<span class="number">190</span>]: &lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x7fbbd5ab29e8</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它跟下面这个冗长得多的生成器是完全等价的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_make_gen</span>():</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">yield</span> x ** <span class="number">2</span></span><br><span class="line">gen = _make_gen()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>生成器表达式也可以取代列表推导式，作为函数参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">191</span>]: <span class="built_in">sum</span>(x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>))</span><br><span class="line">Out[<span class="number">191</span>]: <span class="number">328350</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">192</span>]: <span class="built_in">dict</span>((i, i **<span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line">Out[<span class="number">192</span>]: &#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="number">3</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="itertools模块">itertools模块</h2>
<p>标准库itertools模块中有一组用于许多常见数据算法的生成器。例如，groupby可以接受任何序列和一个函数。它根据函数的返回值对序列中的连续元素进行分组。下面是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">193</span>]: <span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">In [<span class="number">194</span>]: first_letter = <span class="keyword">lambda</span> x: x[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">195</span>]: names = [<span class="string">&#x27;Alan&#x27;</span>, <span class="string">&#x27;Adam&#x27;</span>, <span class="string">&#x27;Wes&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Albert&#x27;</span>, <span class="string">&#x27;Steven&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">196</span>]: <span class="keyword">for</span> letter, names <span class="keyword">in</span> itertools.groupby(names, first_letter):</span><br><span class="line">   .....:     <span class="built_in">print</span>(letter, <span class="built_in">list</span>(names)) <span class="comment"># names is a generator</span></span><br><span class="line">A [<span class="string">&#x27;Alan&#x27;</span>, <span class="string">&#x27;Adam&#x27;</span>]</span><br><span class="line">W [<span class="string">&#x27;Wes&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>]</span><br><span class="line">A [<span class="string">&#x27;Albert&#x27;</span>]</span><br><span class="line">S [<span class="string">&#x27;Steven&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表3-2中列出了一些我经常用到的itertools函数。建议参阅Python官方文档，进一步学习。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-111823d8767a104d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表3-2 一些有用的itertools函数" /><figcaption aria-hidden="true">表3-2 一些有用的itertools函数</figcaption>
</figure>
<h2 id="错误和异常处理">错误和异常处理</h2>
<p>优雅地处理Python的错误和异常是构建健壮程序的重要部分。在数据分析中，许多函数函数只用于部分输入。例如，Python的float函数可以将字符串转换成浮点数，但输入有误时，有<code>ValueError</code>错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">197</span>]: <span class="built_in">float</span>(<span class="string">&#x27;1.2345&#x27;</span>)</span><br><span class="line">Out[<span class="number">197</span>]: <span class="number">1.2345</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">198</span>]: <span class="built_in">float</span>(<span class="string">&#x27;something&#x27;</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">198</span>-<span class="number">439904410854</span>&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> <span class="built_in">float</span>(<span class="string">&#x27;something&#x27;</span>)</span><br><span class="line">ValueError: could <span class="keyword">not</span> convert string to <span class="built_in">float</span>: <span class="string">&#x27;something&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假如想优雅地处理float的错误，让它返回输入值。我们可以写一个函数，在try/except中调用float：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attempt_float</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">float</span>(x)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当float(x)抛出异常时，才会执行except的部分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">200</span>]: attempt_float(<span class="string">&#x27;1.2345&#x27;</span>)</span><br><span class="line">Out[<span class="number">200</span>]: <span class="number">1.2345</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">201</span>]: attempt_float(<span class="string">&#x27;something&#x27;</span>)</span><br><span class="line">Out[<span class="number">201</span>]: <span class="string">&#x27;something&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可能注意到float抛出的异常不仅是ValueError：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">202</span>]: <span class="built_in">float</span>((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">202</span>-842079ebb635&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> <span class="built_in">float</span>((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">TypeError: <span class="built_in">float</span>() argument must be a string <span class="keyword">or</span> a number, <span class="keyword">not</span> <span class="string">&#x27;tuple&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可能只想处理ValueError，TypeError错误（输入不是字符串或数值）可能是合理的bug。可以写一个异常类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attempt_float</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">float</span>(x)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">204</span>]: attempt_float((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">204</span>-9bdfd730cead&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> attempt_float((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">203</span>-3e06b8379b6b&gt; <span class="keyword">in</span> attempt_float(x)</span><br><span class="line">      <span class="number">1</span> <span class="function"><span class="keyword">def</span> <span class="title">attempt_float</span>(<span class="params">x</span>):</span></span><br><span class="line">      <span class="number">2</span>     <span class="keyword">try</span>:</span><br><span class="line">----&gt; <span class="number">3</span>         <span class="keyword">return</span> <span class="built_in">float</span>(x)</span><br><span class="line">      <span class="number">4</span>     <span class="keyword">except</span> ValueError:</span><br><span class="line">      <span class="number">5</span>         <span class="keyword">return</span> x</span><br><span class="line">TypeError: <span class="built_in">float</span>() argument must be a string <span class="keyword">or</span> a number, <span class="keyword">not</span> <span class="string">&#x27;tuple&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以用元组包含多个异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attempt_float</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">float</span>(x)</span><br><span class="line">    <span class="keyword">except</span> (TypeError, ValueError):</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>某些情况下，你可能不想抑制异常，你想无论try部分的代码是否成功，都执行一段代码。可以使用finally：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(path, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    write_to_file(f)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，文件处理f总会被关闭。相似的，你可以用else让只在try部分成功的情况下，才执行代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(path, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    write_to_file(f)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Succeeded&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ipython的异常">IPython的异常</h2>
<p>如果是在%run一个脚本或一条语句时抛出异常，IPython默认会打印完整的调用栈（traceback），在栈的每个点都会有几行上下文：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: %run examples/ipython_bug.py</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AssertionError                            Traceback (most recent call last)</span><br><span class="line">/home/wesm/code/pydata-book/examples/ipython_bug.py <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">     <span class="number">13</span>     throws_an_exception()</span><br><span class="line">     <span class="number">14</span></span><br><span class="line">---&gt; <span class="number">15</span> calling_things()</span><br><span class="line"></span><br><span class="line">/home/wesm/code/pydata-book/examples/ipython_bug.py <span class="keyword">in</span> calling_things()</span><br><span class="line">     <span class="number">11</span> <span class="function"><span class="keyword">def</span> <span class="title">calling_things</span>():</span></span><br><span class="line">     <span class="number">12</span>     works_fine()</span><br><span class="line">---&gt; <span class="number">13</span>     throws_an_exception()</span><br><span class="line">     <span class="number">14</span></span><br><span class="line">     <span class="number">15</span> calling_things()</span><br><span class="line"></span><br><span class="line">/home/wesm/code/pydata-book/examples/ipython_bug.py <span class="keyword">in</span> throws_an_exception()</span><br><span class="line">      <span class="number">7</span>     a = <span class="number">5</span></span><br><span class="line">      <span class="number">8</span>     b = <span class="number">6</span></span><br><span class="line">----&gt; <span class="number">9</span>     <span class="keyword">assert</span>(a + b == <span class="number">10</span>)</span><br><span class="line">     <span class="number">10</span></span><br><span class="line">     <span class="number">11</span> <span class="function"><span class="keyword">def</span> <span class="title">calling_things</span>():</span></span><br><span class="line"></span><br><span class="line">AssertionError:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自身就带有文本是相对于Python标准解释器的极大优点。你可以用魔术命令<code>%xmode</code>，从Plain（与Python标准解释器相同）到Verbose（带有函数的参数值）控制文本显示的数量。后面可以看到，发生错误之后，（用%debug或%pdb magics）可以进入stack进行事后调试。</p>
<h1 id="文件和操作系统">3.3 文件和操作系统</h1>
<p>本书的代码示例大多使用诸如pandas.read_csv之类的高级工具将磁盘上的数据文件读入Python数据结构。但我们还是需要了解一些有关Python文件处理方面的基础知识。好在它本来就很简单，这也是Python在文本和文件处理方面的如此流行的原因之一。</p>
<p>为了打开一个文件以便读写，可以使用内置的open函数以及一个相对或绝对的文件路径：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">207</span>]: path = <span class="string">&#x27;examples/segismundo.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">208</span>]: f = <span class="built_in">open</span>(path)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认情况下，文件是以只读模式（'r'）打开的。然后，我们就可以像处理列表那样来处理这个文件句柄f了，比如对行进行迭代：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从文件中取出的行都带有完整的行结束符（EOL），因此你常常会看到下面这样的代码（得到一组没有EOL的行）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">209</span>]: lines = [x.rstrip() <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">open</span>(path)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">210</span>]: lines</span><br><span class="line">Out[<span class="number">210</span>]: </span><br><span class="line">[<span class="string">&#x27;Sueña el rico en su riqueza,&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;que más cuidados le ofrece;&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;sueña el pobre que padece&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;su miseria y su pobreza;&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;sueña el que a medrar empieza,&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;sueña el que afana y pretende,&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;sueña el que agravia y ofende,&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;y en el mundo, en conclusión,&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;todos sueñan lo que son,&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;aunque ninguno lo entiende.&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果使用open创建文件对象，一定要用close关闭它。关闭文件可以返回操作系统资源：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">211</span>]: f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用with语句可以可以更容易地清理打开的文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">212</span>]: <span class="keyword">with</span> <span class="built_in">open</span>(path) <span class="keyword">as</span> f:</span><br><span class="line">   .....:     lines = [x.rstrip() <span class="keyword">for</span> x <span class="keyword">in</span> f]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样可以在退出代码块时，自动关闭文件。</p>
<p>如果输入f =open(path,'w')，就会有一个新文件被创建在examples/segismundo.txt，并覆盖掉该位置原来的任何数据。另外有一个x文件模式，它可以创建可写的文件，但是如果文件路径存在，就无法创建。表3-3列出了所有的读/写模式。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-28274484129f0ea7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表3-3 Python的文件模式" /><figcaption aria-hidden="true">表3-3 Python的文件模式</figcaption>
</figure>
<p>对于可读文件，一些常用的方法是read、seek和tell。read会从文件返回字符。字符的内容是由文件的编码决定的（如UTF-8），如果是二进制模式打开的就是原始字节：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">213</span>]: f = <span class="built_in">open</span>(path)</span><br><span class="line"></span><br><span class="line">In [<span class="number">214</span>]: f.read(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">214</span>]: <span class="string">&#x27;Sueña el r&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">215</span>]: f2 = <span class="built_in">open</span>(path, <span class="string">&#x27;rb&#x27;</span>)  <span class="comment"># Binary mode</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">216</span>]: f2.read(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">216</span>]: <span class="string">b&#x27;Sue\xc3\xb1a el &#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>read模式会将文件句柄的位置提前，提前的数量是读取的字节数。tell可以给出当前的位置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">217</span>]: f.tell()</span><br><span class="line">Out[<span class="number">217</span>]: <span class="number">11</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">218</span>]: f2.tell()</span><br><span class="line">Out[<span class="number">218</span>]: <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>尽管我们从文件读取了10个字符，位置却是11，这是因为用默认的编码用了这么多字节才解码了这10个字符。你可以用sys模块检查默认的编码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">219</span>]: <span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">In [<span class="number">220</span>]: sys.getdefaultencoding()</span><br><span class="line">Out[<span class="number">220</span>]: <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>seek将文件位置更改为文件中的指定字节：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">221</span>]: f.seek(<span class="number">3</span>)</span><br><span class="line">Out[<span class="number">221</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">222</span>]: f.read(<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">222</span>]: <span class="string">&#x27;ñ&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后，关闭文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">223</span>]: f.close()</span><br><span class="line"></span><br><span class="line">In [<span class="number">224</span>]: f2.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>向文件写入，可以使用文件的write或writelines方法。例如，我们可以创建一个无空行版的prof_mod.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">225</span>]: <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;tmp.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> handle:</span><br><span class="line">   .....:     handle.writelines(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">open</span>(path) <span class="keyword">if</span> <span class="built_in">len</span>(x) &gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">226</span>]: <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;tmp.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">   .....:     lines = f.readlines()</span><br><span class="line"></span><br><span class="line">In [<span class="number">227</span>]: lines</span><br><span class="line">Out[<span class="number">227</span>]: </span><br><span class="line">[<span class="string">&#x27;Sueña el rico en su riqueza,\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;que más cuidados le ofrece;\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;sueña el pobre que padece\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;su miseria y su pobreza;\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;sueña el que a medrar empieza,\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;sueña el que afana y pretende,\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;sueña el que agravia y ofende,\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;y en el mundo, en conclusión,\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;todos sueñan lo que son,\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;aunque ninguno lo entiende.\n&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表3-4列出了一些最常用的文件方法。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-d25bd6e730afeb39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表3-4 Python重要的文件方法或属性" /><figcaption aria-hidden="true">表3-4 Python重要的文件方法或属性</figcaption>
</figure>
<h2 id="文件的字节和unicode">文件的字节和Unicode</h2>
<p>Python文件的默认操作是“文本模式”，也就是说，你需要处理Python的字符串（即Unicode）。它与“二进制模式”相对，文件模式加一个b。我们来看上一节的文件（UTF-8编码、包含非ASCII字符）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">230</span>]: <span class="keyword">with</span> <span class="built_in">open</span>(path) <span class="keyword">as</span> f:</span><br><span class="line">   .....:     chars = f.read(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">231</span>]: chars</span><br><span class="line">Out[<span class="number">231</span>]: <span class="string">&#x27;Sueña el r&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>UTF-8是长度可变的Unicode编码，所以当我从文件请求一定数量的字符时，Python会从文件读取足够多（可能少至10或多至40字节）的字节进行解码。如果以“rb”模式打开文件，则读取确切的请求字节数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">232</span>]: <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">   .....:     data = f.read(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">233</span>]: data</span><br><span class="line">Out[<span class="number">233</span>]: <span class="string">b&#x27;Sue\xc3\xb1a el &#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>取决于文本的编码，你可以将字节解码为str对象，但只有当每个编码的Unicode字符都完全成形时才能这么做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">234</span>]: data.decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">Out[<span class="number">234</span>]: <span class="string">&#x27;Sueña el &#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">235</span>]: data[:<span class="number">4</span>].decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">UnicodeDecodeError                        Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">235</span>-300e0af10bb7&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> data[:<span class="number">4</span>].decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">UnicodeDecodeError: <span class="string">&#x27;utf-8&#x27;</span> codec can<span class="string">&#x27;t decode byte 0xc3 in position 3: unexpecte</span></span><br><span class="line"><span class="string">d end of data</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>文本模式结合了open的编码选项，提供了一种更方便的方法将Unicode转换为另一种编码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">236</span>]: sink_path = <span class="string">&#x27;sink.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">237</span>]: <span class="keyword">with</span> <span class="built_in">open</span>(path) <span class="keyword">as</span> source:</span><br><span class="line">   .....:     <span class="keyword">with</span> <span class="built_in">open</span>(sink_path, <span class="string">&#x27;xt&#x27;</span>, encoding=<span class="string">&#x27;iso-8859-1&#x27;</span>) <span class="keyword">as</span> sink:</span><br><span class="line">   .....:         sink.write(source.read())</span><br><span class="line"></span><br><span class="line">In [<span class="number">238</span>]: <span class="keyword">with</span> <span class="built_in">open</span>(sink_path, encoding=<span class="string">&#x27;iso-8859-1&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">   .....:     <span class="built_in">print</span>(f.read(<span class="number">10</span>))</span><br><span class="line">Sueña el r</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，不要在二进制模式中使用seek。如果文件位置位于定义Unicode字符的字节的中间位置，读取后面会产生错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">240</span>]: f = <span class="built_in">open</span>(path)</span><br><span class="line"></span><br><span class="line">In [<span class="number">241</span>]: f.read(<span class="number">5</span>)</span><br><span class="line">Out[<span class="number">241</span>]: <span class="string">&#x27;Sueña&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">242</span>]: f.seek(<span class="number">4</span>)</span><br><span class="line">Out[<span class="number">242</span>]: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">243</span>]: f.read(<span class="number">1</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">UnicodeDecodeError                        Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">243</span>-7841103e33f5&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> f.read(<span class="number">1</span>)</span><br><span class="line">/miniconda/envs/book-env/lib/python3<span class="number">.6</span>/codecs.py <span class="keyword">in</span> decode(self, <span class="built_in">input</span>, final)</span><br><span class="line">    <span class="number">319</span>         <span class="comment"># decode input (taking the buffer into account)</span></span><br><span class="line">    <span class="number">320</span>         data = self.buffer + <span class="built_in">input</span></span><br><span class="line">--&gt; <span class="number">321</span>         (result, consumed) = self._buffer_decode(data, self.errors, final</span><br><span class="line">)</span><br><span class="line">    <span class="number">322</span>         <span class="comment"># keep undecoded input until the next call</span></span><br><span class="line">    <span class="number">323</span>         self.buffer = data[consumed:]</span><br><span class="line">UnicodeDecodeError: <span class="string">&#x27;utf-8&#x27;</span> codec can<span class="string">&#x27;t decode byte 0xb1 in position 0: invalid s</span></span><br><span class="line"><span class="string">tart byte</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">In [244]: f.close()</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>如果你经常要对非ASCII字符文本进行数据分析，通晓Python的Unicode功能是非常重要的。更多内容，参阅Python官方文档。</p>
<h1 id="结论">3.4 结论</h1>
<p>我们已经学过了Python的基础、环境和语法，接下来学习NumPy和Python的面向数组计算。</p>
]]></content>
      <categories>
        <category>Python 数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>第04章 NumPy基础：数组和矢量计算</title>
    <url>/2019/04/09/%E7%AC%AC04%E7%AB%A0-NumPy%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A2%E9%87%8F%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p>NumPy（Numerical Python的简称）是Python数值计算最重要的基础包。大多数提供科学计算的包都是用NumPy的数组作为构建基础。<span id="more"></span></p>
<p>NumPy的部分功能如下：</p>
<ul>
<li>ndarray，一个具有矢量算术运算和复杂广播能力的快速且节省空间的多维数组。</li>
<li>用于对整组数据进行快速运算的标准数学函数（无需编写循环）。</li>
<li>用于读写磁盘数据的工具以及用于操作内存映射文件的工具。</li>
<li>线性代数、随机数生成以及傅里叶变换功能。</li>
<li>用于集成由C、C++、Fortran等语言编写的代码的A C API。</li>
</ul>
<p>由于NumPy提供了一个简单易用的C API，因此很容易将数据传递给由低级语言编写的外部库，外部库也能以NumPy数组的形式将数据返回给Python。这个功能使Python成为一种包装C/C++/Fortran历史代码库的选择，并使被包装库拥有一个动态的、易用的接口。</p>
<p>NumPy本身并没有提供多么高级的数据分析功能，理解NumPy数组以及面向数组的计算将有助于你更加高效地使用诸如pandas之类的工具。因为NumPy是一个很大的题目，我会在附录A中介绍更多NumPy高级功能，比如广播。</p>
<p>对于大部分数据分析应用而言，我最关注的功能主要集中在：</p>
<ul>
<li>用于数据整理和清理、子集构造和过滤、转换等快速的矢量化数组运算。</li>
<li>常用的数组算法，如排序、唯一化、集合运算等。</li>
<li>高效的描述统计和数据聚合/摘要运算。</li>
<li>用于异构数据集的合并/连接运算的数据对齐和关系型数据运算。</li>
<li>将条件逻辑表述为数组表达式（而不是带有if-elif-else分支的循环）。</li>
<li>数据的分组运算（聚合、转换、函数应用等）。。</li>
</ul>
<p>虽然NumPy提供了通用的数值数据处理的计算基础，但大多数读者可能还是想将pandas作为统计和分析工作的基础，尤其是处理表格数据时。pandas还提供了一些NumPy所没有的领域特定的功能，如时间序列处理等。</p>
<blockquote>
<p>笔记：Python的面向数组计算可以追溯到1995年，Jim Hugunin创建了Numeric库。接下来的10年，许多科学编程社区纷纷开始使用Python的数组编程，但是进入21世纪，库的生态系统变得碎片化了。2005年，Travis Oliphant从Numeric和Numarray项目整了出了NumPy项目，进而所有社区都集合到了这个框架下。</p>
</blockquote>
<p>NumPy之于数值计算特别重要的原因之一，是因为它可以高效处理大数组的数据。这是因为：</p>
<ul>
<li>NumPy是在一个连续的内存块中存储数据，独立于其他Python内置对象。NumPy的C语言编写的算法库可以操作内存，而不必进行类型检查或其它前期工作。比起Python的内置序列，NumPy数组使用的内存更少。</li>
<li>NumPy可以在整个数组上执行复杂的计算，而不需要Python的for循环。</li>
</ul>
<p>要搞明白具体的性能差距，考察一个包含一百万整数的数组，和一个等价的Python列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">7</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: my_arr = np.arange(<span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: my_list = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1000000</span>))</span><br></pre></td></tr></table></figure>
<p>各个序列分别乘以2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: %time <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>): my_arr2 = my_arr * <span class="number">2</span></span><br><span class="line">CPU times: user <span class="number">20</span> ms, sys: <span class="number">50</span> ms, total: <span class="number">70</span> ms</span><br><span class="line">Wall time: <span class="number">72.4</span> ms</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: %time <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>): my_list2 = [x * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> my_list]</span><br><span class="line">CPU times: user <span class="number">760</span> ms, sys: <span class="number">290</span> ms, total: <span class="number">1.05</span> s</span><br><span class="line">Wall time: <span class="number">1.05</span> s</span><br></pre></td></tr></table></figure>
<p>基于NumPy的算法要比纯Python快10到100倍（甚至更快），并且使用的内存更少。</p>
<h1 id="numpy的ndarray一种多维数组对象">4.1 NumPy的ndarray：一种多维数组对象</h1>
<p>NumPy最重要的一个特点就是其N维数组对象（即ndarray），该对象是一个快速而灵活的大数据集容器。你可以利用这种数组对整块数据执行一些数学运算，其语法跟标量元素之间的运算一样。</p>
<p>要明白Python是如何利用与标量值类似的语法进行批次计算，我先引入NumPy，然后生成一个包含随机数据的小数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate some random data</span></span><br><span class="line">In [<span class="number">13</span>]: data = np.random.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: data</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">array([[-<span class="number">0.2047</span>,  <span class="number">0.4789</span>, -<span class="number">0.5194</span>],</span><br><span class="line">       [-<span class="number">0.5557</span>,  <span class="number">1.9658</span>,  <span class="number">1.3934</span>]])</span><br></pre></td></tr></table></figure>
<p>然后进行数学运算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: data * <span class="number">10</span></span><br><span class="line">Out[<span class="number">15</span>]: </span><br><span class="line">array([[ -<span class="number">2.0471</span>,   <span class="number">4.7894</span>,  -<span class="number">5.1944</span>],</span><br><span class="line">       [ -<span class="number">5.5573</span>,  <span class="number">19.6578</span>,  <span class="number">13.9341</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: data + data</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">array([[-<span class="number">0.4094</span>,  <span class="number">0.9579</span>, -<span class="number">1.0389</span>],</span><br><span class="line">       [-<span class="number">1.1115</span>,  <span class="number">3.9316</span>,  <span class="number">2.7868</span>]])</span><br></pre></td></tr></table></figure>
<p>第一个例子中，所有的元素都乘以10。第二个例子中，每个元素都与自身相加。</p>
<blockquote>
<p>笔记：在本章及全书中，我会使用标准的NumPy惯用法<code>import numpy as np</code>。你当然也可以在代码中使用<code>from numpy import *</code>，但不建议这么做。<code>numpy</code>的命名空间很大，包含许多函数，其中一些的名字与Python的内置函数重名（比如min和max）。</p>
</blockquote>
<p>ndarray是一个通用的同构数据多维容器，也就是说，其中的所有元素必须是相同类型的。每个数组都有一个shape（一个表示各维度大小的元组）和一个dtype（一个用于说明数组数据类型的对象）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: data.shape</span><br><span class="line">Out[<span class="number">17</span>]: (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: data.dtype</span><br><span class="line">Out[<span class="number">18</span>]: dtype(<span class="string">&#x27;float64&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>本章将会介绍NumPy数组的基本用法，这对于本书后面各章的理解基本够用。虽然大多数数据分析工作不需要深入理解NumPy，但是精通面向数组的编程和思维方式是成为Python科学计算牛人的一大关键步骤。</p>
<blockquote>
<p>笔记：当你在本书中看到“数组”、“NumPy数组”、"ndarray"时，基本上都指的是同一样东西，即ndarray对象。</p>
</blockquote>
<h2 id="创建ndarray">创建ndarray</h2>
<p>创建数组最简单的办法就是使用array函数。它接受一切序列型的对象（包括其他数组），然后产生一个新的含有传入数据的NumPy数组。以一个列表的转换为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">19</span>]: data1 = [<span class="number">6</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: arr1 = np.array(data1)</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: arr1</span><br><span class="line">Out[<span class="number">21</span>]: array([ <span class="number">6.</span> ,  <span class="number">7.5</span>,  <span class="number">8.</span> ,  <span class="number">0.</span> ,  <span class="number">1.</span> ])</span><br></pre></td></tr></table></figure>
<p>嵌套序列（比如由一组等长列表组成的列表）将会被转换为一个多维数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">22</span>]: data2 = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: arr2 = np.array(data2)</span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: arr2</span><br><span class="line">Out[<span class="number">24</span>]: </span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br></pre></td></tr></table></figure>
<p>因为data2是列表的列表，NumPy数组arr2的两个维度的shape是从data2引入的。可以用属性ndim和shape验证：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: arr2.ndim</span><br><span class="line">Out[<span class="number">25</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: arr2.shape</span><br><span class="line">Out[<span class="number">26</span>]: (<span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>除非特别说明（稍后将会详细介绍），np.array会尝试为新建的这个数组推断出一个较为合适的数据类型。数据类型保存在一个特殊的dtype对象中。比如说，在上面的两个例子中，我们有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">27</span>]: arr1.dtype</span><br><span class="line">Out[<span class="number">27</span>]: dtype(<span class="string">&#x27;float64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: arr2.dtype</span><br><span class="line">Out[<span class="number">28</span>]: dtype(<span class="string">&#x27;int64&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>除np.array之外，还有一些函数也可以新建数组。比如，zeros和ones分别可以创建指定长度或形状的全0或全1数组。empty可以创建一个没有任何具体值的数组。要用这些方法创建多维数组，只需传入一个表示形状的元组即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">29</span>]: np.zeros(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">29</span>]: array([ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: np.zeros((<span class="number">3</span>, <span class="number">6</span>))</span><br><span class="line">Out[<span class="number">30</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: np.empty((<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line">Out[<span class="number">31</span>]: </span><br><span class="line">array([[[ <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>]],</span><br><span class="line">       [[ <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>]]])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：认为np.empty会返回全0数组的想法是不安全的。很多情况下（如前所示），它返回的都是一些未初始化的垃圾值。</p>
</blockquote>
<p>arange是Python内置函数range的数组版：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">32</span>]: np.arange(<span class="number">15</span>)</span><br><span class="line">Out[<span class="number">32</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>])</span><br></pre></td></tr></table></figure>
<p>表4-1列出了一些数组创建函数。由于NumPy关注的是数值计算，因此，如果没有特别指定，数据类型基本都是float64（浮点数）。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-78ab11f67e7077a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表4-1 数组创建函数" /><figcaption aria-hidden="true">表4-1 数组创建函数</figcaption>
</figure>
<h2 id="ndarray的数据类型">ndarray的数据类型</h2>
<p>dtype（数据类型）是一个特殊的对象，它含有ndarray将一块内存解释为特定数据类型所需的信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">33</span>]: arr1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=np.float64)</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: arr2 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=np.int32)</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: arr1.dtype</span><br><span class="line">Out[<span class="number">35</span>]: dtype(<span class="string">&#x27;float64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: arr2.dtype</span><br><span class="line">Out[<span class="number">36</span>]: dtype(<span class="string">&#x27;int32&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>dtype是NumPy灵活交互其它系统的源泉之一。多数情况下，它们直接映射到相应的机器表示，这使得“读写磁盘上的二进制数据流”以及“集成低级语言代码（如C、Fortran）”等工作变得更加简单。数值型dtype的命名方式相同：一个类型名（如float或int），后面跟一个用于表示各元素位长的数字。标准的双精度浮点值（即Python中的float对象）需要占用8字节（即64位）。因此，该类型在NumPy中就记作float64。表4-2列出了NumPy所支持的全部数据类型。</p>
<blockquote>
<p>笔记：记不住这些NumPy的dtype也没关系，新手更是如此。通常只需要知道你所处理的数据的大致类型是浮点数、复数、整数、布尔值、字符串，还是普通的Python对象即可。当你需要控制数据在内存和磁盘中的存储方式时（尤其是对大数据集），那就得了解如何控制存储类型。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-2f2d7406a8bc076c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-5cc31115615737b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>你可以通过ndarray的astype方法明确地将一个数组从一个dtype转换成另一个dtype：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">37</span>]: arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: arr.dtype</span><br><span class="line">Out[<span class="number">38</span>]: dtype(<span class="string">&#x27;int64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: float_arr = arr.astype(np.float64)</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: float_arr.dtype</span><br><span class="line">Out[<span class="number">40</span>]: dtype(<span class="string">&#x27;float64&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在本例中，整数被转换成了浮点数。如果将浮点数转换成整数，则小数部分将会被截取删除：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: arr = np.array([<span class="number">3.7</span>, -<span class="number">1.2</span>, -<span class="number">2.6</span>, <span class="number">0.5</span>, <span class="number">12.9</span>, <span class="number">10.1</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: arr</span><br><span class="line">Out[<span class="number">42</span>]: array([  <span class="number">3.7</span>,  -<span class="number">1.2</span>,  -<span class="number">2.6</span>,   <span class="number">0.5</span>,  <span class="number">12.9</span>,  <span class="number">10.1</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: arr.astype(np.int32)</span><br><span class="line">Out[<span class="number">43</span>]: array([ <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">2</span>,  <span class="number">0</span>, <span class="number">12</span>, <span class="number">10</span>], dtype=int32)</span><br></pre></td></tr></table></figure>
<p>如果某字符串数组表示的全是数字，也可以用astype将其转换为数值形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">44</span>]: numeric_strings = np.array([<span class="string">&#x27;1.25&#x27;</span>, <span class="string">&#x27;-9.6&#x27;</span>, <span class="string">&#x27;42&#x27;</span>], dtype=np.string_)</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: numeric_strings.astype(<span class="built_in">float</span>)</span><br><span class="line">Out[<span class="number">45</span>]: array([  <span class="number">1.25</span>,  -<span class="number">9.6</span> ,  <span class="number">42.</span>  ])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：使用numpy.string_类型时，一定要小心，因为NumPy的字符串数据是大小固定的，发生截取时，不会发出警告。pandas提供了更多非数值数据的便利的处理方法。</p>
</blockquote>
<p>如果转换过程因为某种原因而失败了（比如某个不能被转换为float64的字符串），就会引发一个ValueError。这里，我比较懒，写的是float而不是np.float64；NumPy很聪明，它会将Python类型映射到等价的dtype上。</p>
<p>数组的dtype还有另一个属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">46</span>]: int_array = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: calibers = np.array([<span class="number">.22</span>, <span class="number">.270</span>, <span class="number">.357</span>, <span class="number">.380</span>, <span class="number">.44</span>, <span class="number">.50</span>], dtype=np.float64)</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: int_array.astype(calibers.dtype)</span><br><span class="line">Out[<span class="number">48</span>]: array([ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">8.</span>,  <span class="number">9.</span>])</span><br></pre></td></tr></table></figure>
<p>你还可以用简洁的类型代码来表示dtype：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">49</span>]: empty_uint32 = np.empty(<span class="number">8</span>, dtype=<span class="string">&#x27;u4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: empty_uint32</span><br><span class="line">Out[<span class="number">50</span>]: </span><br><span class="line">array([         <span class="number">0</span>, <span class="number">1075314688</span>,          <span class="number">0</span>, <span class="number">1075707904</span>,          <span class="number">0</span>,</span><br><span class="line">       <span class="number">1075838976</span>,          <span class="number">0</span>, <span class="number">1072693248</span>], dtype=uint32)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：调用astype总会创建一个新的数组（一个数据的备份），即使新的dtype与旧的dtype相同。</p>
</blockquote>
<h2 id="numpy数组的运算">NumPy数组的运算</h2>
<p>数组很重要，因为它使你不用编写循环即可对数据执行批量运算。NumPy用户称其为矢量化（vectorization）。大小相等的数组之间的任何算术运算都会将运算应用到元素级：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">51</span>]: arr = np.array([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: arr</span><br><span class="line">Out[<span class="number">52</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: arr * arr</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">array([[  <span class="number">1.</span>,   <span class="number">4.</span>,   <span class="number">9.</span>],</span><br><span class="line">       [ <span class="number">16.</span>,  <span class="number">25.</span>,  <span class="number">36.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: arr - arr</span><br><span class="line">Out[<span class="number">54</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数组与标量的算术运算会将标量值传播到各个元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">55</span>]: <span class="number">1</span> / arr</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>    ,  <span class="number">0.5</span>   ,  <span class="number">0.3333</span>],</span><br><span class="line">       [ <span class="number">0.25</span>  ,  <span class="number">0.2</span>   ,  <span class="number">0.1667</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">56</span>]: arr ** <span class="number">0.5</span></span><br><span class="line">Out[<span class="number">56</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>    ,  <span class="number">1.4142</span>,  <span class="number">1.7321</span>],</span><br><span class="line">       [ <span class="number">2.</span>    ,  <span class="number">2.2361</span>,  <span class="number">2.4495</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>大小相同的数组之间的比较会生成布尔值数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">57</span>]: arr2 = np.array([[<span class="number">0.</span>, <span class="number">4.</span>, <span class="number">1.</span>], [<span class="number">7.</span>, <span class="number">2.</span>, <span class="number">12.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: arr2</span><br><span class="line">Out[<span class="number">58</span>]: </span><br><span class="line">array([[  <span class="number">0.</span>,   <span class="number">4.</span>,   <span class="number">1.</span>],</span><br><span class="line">       [  <span class="number">7.</span>,   <span class="number">2.</span>,  <span class="number">12.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: arr2 &gt; arr</span><br><span class="line">Out[<span class="number">59</span>]:</span><br><span class="line">array([[<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">       [ <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>]], dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不同大小的数组之间的运算叫做广播（broadcasting），将在附录A中对其进行详细讨论。本书的内容不需要对广播机制有多深的理解。</p>
<h2 id="基本的索引和切片">基本的索引和切片</h2>
<p>NumPy数组的索引是一个内容丰富的主题，因为选取数据子集或单个元素的方式有很多。一维数组很简单。从表面上看，它们跟Python列表的功能差不多：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">60</span>]: arr = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: arr</span><br><span class="line">Out[<span class="number">61</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: arr[<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">62</span>]: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: arr[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line">Out[<span class="number">63</span>]: array([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: arr[<span class="number">5</span>:<span class="number">8</span>] = <span class="number">12</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: arr</span><br><span class="line">Out[<span class="number">65</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>,  <span class="number">8</span>,  <span class="number">9</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如上所示，当你将一个标量值赋值给一个切片时（如arr[5:8]=12），该值会自动传播（也就说后面将会讲到的“广播”）到整个选区。跟列表最重要的区别在于，数组切片是原始数组的视图。这意味着数据不会被复制，视图上的任何修改都会直接反映到源数组上。</p>
<p>作为例子，先创建一个arr的切片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">66</span>]: arr_slice = arr[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: arr_slice</span><br><span class="line">Out[<span class="number">67</span>]: array([<span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，当我修稿arr_slice中的值，变动也会体现在原始数组arr中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">68</span>]: arr_slice[<span class="number">1</span>] = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: arr</span><br><span class="line">Out[<span class="number">69</span>]: array([    <span class="number">0</span>,     <span class="number">1</span>,     <span class="number">2</span>,     <span class="number">3</span>,     <span class="number">4</span>,    <span class="number">12</span>, <span class="number">12345</span>,    <span class="number">12</span>,     <span class="number">8</span>,   </span><br><span class="line">  <span class="number">9</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>切片[ : ]会给数组中的所有值赋值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">70</span>]: arr_slice[:] = <span class="number">64</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: arr</span><br><span class="line">Out[<span class="number">71</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>,  <span class="number">8</span>,  <span class="number">9</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你刚开始接触NumPy，可能会对此感到惊讶（尤其是当你曾经用过其他热衷于复制数组数据的编程语言）。由于NumPy的设计目的是处理大数据，所以你可以想象一下，假如NumPy坚持要将数据复制来复制去的话会产生何等的性能和内存问题。</p>
<blockquote>
<p>注意：如果你想要得到的是ndarray切片的一份副本而非视图，就需要明确地进行复制操作，例如<code>arr[5:8].copy()</code>。</p>
</blockquote>
<p>对于高维度数组，能做的事情更多。在一个二维数组中，各索引位置上的元素不再是标量而是一维数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">72</span>]: arr2d = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">73</span>]: arr2d[<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">73</span>]: array([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此，可以对各个元素进行递归访问，但这样需要做的事情有点多。你可以传入一个以逗号隔开的索引列表来选取单个元素。也就是说，下面两种方式是等价的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: arr2d[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">74</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: arr2d[<span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">Out[<span class="number">75</span>]: <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>图4-1说明了二维数组的索引方式。轴0作为行，轴1作为列。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-0a641536f73f560e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4-1 NumPy数组中的元素索引" /><figcaption aria-hidden="true">图4-1 NumPy数组中的元素索引</figcaption>
</figure>
<p>在多维数组中，如果省略了后面的索引，则返回对象会是一个维度低一点的ndarray（它含有高一级维度上的所有数据）。因此，在2×2×3数组arr3d中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: arr3d = np.array([[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]], [[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: arr3d</span><br><span class="line">Out[<span class="number">77</span>]: </span><br><span class="line">array([[[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>]],</span><br><span class="line">       [[ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>arr3d[0]是一个2×3数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">78</span>]: arr3d[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">78</span>]: </span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>标量值和数组都可以被赋值给arr3d[0]：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">79</span>]: old_values = arr3d[<span class="number">0</span>].copy()</span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: arr3d[<span class="number">0</span>] = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: arr3d</span><br><span class="line">Out[<span class="number">81</span>]: </span><br><span class="line">array([[[<span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>],</span><br><span class="line">        [<span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>]],</span><br><span class="line">       [[ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">82</span>]: arr3d[<span class="number">0</span>] = old_values</span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: arr3d</span><br><span class="line">Out[<span class="number">83</span>]: </span><br><span class="line">array([[[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>]],</span><br><span class="line">       [[ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>相似的，arr3d[1,0]可以访问索引以(1,0)开头的那些值（以一维数组的形式返回）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">84</span>]: arr3d[<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">Out[<span class="number">84</span>]: array([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然是用两步进行索引的，表达式是相同的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">85</span>]: x = arr3d[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: x</span><br><span class="line">Out[<span class="number">86</span>]: </span><br><span class="line">array([[ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: x[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">87</span>]: array([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，在上面所有这些选取数组子集的例子中，返回的数组都是视图。</p>
<h2 id="切片索引">切片索引</h2>
<p>ndarray的切片语法跟Python列表这样的一维对象差不多：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">88</span>]: arr</span><br><span class="line">Out[<span class="number">88</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>,  <span class="number">8</span>,  <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: arr[<span class="number">1</span>:<span class="number">6</span>]</span><br><span class="line">Out[<span class="number">89</span>]: array([ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>, <span class="number">64</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于之前的二维数组arr2d，其切片方式稍显不同：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">90</span>]: arr2d</span><br><span class="line">Out[<span class="number">90</span>]: </span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">91</span>]: arr2d[:<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">91</span>]: </span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看出，它是沿着第0轴（即第一个轴）切片的。也就是说，切片是沿着一个轴向选取元素的。表达式arr2d[:2]可以被认为是“选取arr2d的前两行”。</p>
<p>你可以一次传入多个切片，就像传入多个索引那样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">92</span>]: arr2d[:<span class="number">2</span>, <span class="number">1</span>:]</span><br><span class="line">Out[<span class="number">92</span>]: </span><br><span class="line">array([[<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>像这样进行切片时，只能得到相同维数的数组视图。通过将整数索引和切片混合，可以得到低维度的切片。</p>
<p>例如，我可以选取第二行的前两列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">93</span>]: arr2d[<span class="number">1</span>, :<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">93</span>]: array([<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>相似的，还可以选择第三列的前两行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">94</span>]: arr2d[:<span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">Out[<span class="number">94</span>]: array([<span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>图4-2对此进行了说明。注意，“只有冒号”表示选取整个轴，因此你可以像下面这样只对高维轴进行切片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">95</span>]: arr2d[:, :<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">95</span>]: </span><br><span class="line">array([[<span class="number">1</span>],</span><br><span class="line">       [<span class="number">4</span>],</span><br><span class="line">       [<span class="number">7</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-9da32d2f4629c304.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4-2 二维数组切片" /><figcaption aria-hidden="true">图4-2 二维数组切片</figcaption>
</figure>
<p>自然，对切片表达式的赋值操作也会被扩散到整个选区：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">96</span>]: arr2d[:<span class="number">2</span>, <span class="number">1</span>:] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: arr2d</span><br><span class="line">Out[<span class="number">97</span>]: </span><br><span class="line">array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="布尔型索引">布尔型索引</h2>
<p>来看这样一个例子，假设我们有一个用于存储数据的数组以及一个存储姓名的数组（含有重复项）。在这里，我将使用numpy.random中的randn函数生成一些正态分布的随机数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">98</span>]: names = np.array([<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: data = np.random.randn(<span class="number">7</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: names</span><br><span class="line">Out[<span class="number">100</span>]: </span><br><span class="line">array([<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>],</span><br><span class="line">      dtype=<span class="string">&#x27;&lt;U4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">101</span>]: data</span><br><span class="line">Out[<span class="number">101</span>]: </span><br><span class="line">array([[ <span class="number">0.0929</span>,  <span class="number">0.2817</span>,  <span class="number">0.769</span> ,  <span class="number">1.2464</span>],</span><br><span class="line">       [ <span class="number">1.0072</span>, -<span class="number">1.2962</span>,  <span class="number">0.275</span> ,  <span class="number">0.2289</span>],</span><br><span class="line">       [ <span class="number">1.3529</span>,  <span class="number">0.8864</span>, -<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>, -<span class="number">0.5397</span>,  <span class="number">0.477</span> ],</span><br><span class="line">       [ <span class="number">3.2489</span>, -<span class="number">1.0212</span>, -<span class="number">0.5771</span>,  <span class="number">0.1241</span>],</span><br><span class="line">       [ <span class="number">0.3026</span>,  <span class="number">0.5238</span>,  <span class="number">0.0009</span>,  <span class="number">1.3438</span>],</span><br><span class="line">       [-<span class="number">0.7135</span>, -<span class="number">0.8312</span>, -<span class="number">2.3702</span>, -<span class="number">1.8608</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设每个名字都对应data数组中的一行，而我们想要选出对应于名字"Bob"的所有行。跟算术运算一样，数组的比较运算（如==）也是矢量化的。因此，对names和字符串"Bob"的比较运算将会产生一个布尔型数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">102</span>]: names == <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">Out[<span class="number">102</span>]: array([ <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>], dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个布尔型数组可用于数组索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">103</span>]: data[names == <span class="string">&#x27;Bob&#x27;</span>]</span><br><span class="line">Out[<span class="number">103</span>]: </span><br><span class="line">array([[ <span class="number">0.0929</span>,  <span class="number">0.2817</span>,  <span class="number">0.769</span> ,  <span class="number">1.2464</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>, -<span class="number">0.5397</span>,  <span class="number">0.477</span> ]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>布尔型数组的长度必须跟被索引的轴长度一致。此外，还可以将布尔型数组跟切片、整数（或整数序列，稍后将对此进行详细讲解）混合使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">103</span>]: data[names == <span class="string">&#x27;Bob&#x27;</span>]</span><br><span class="line">Out[<span class="number">103</span>]: </span><br><span class="line">array([[ <span class="number">0.0929</span>,  <span class="number">0.2817</span>,  <span class="number">0.769</span> ,  <span class="number">1.2464</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>, -<span class="number">0.5397</span>,  <span class="number">0.477</span> ]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果布尔型数组的长度不对，布尔型选择就会出错，因此一定要小心。</p>
</blockquote>
<p>下面的例子，我选取了<code>names == 'Bob'</code>的行，并索引了列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">104</span>]: data[names == <span class="string">&#x27;Bob&#x27;</span>, <span class="number">2</span>:]</span><br><span class="line">Out[<span class="number">104</span>]: </span><br><span class="line">array([[ <span class="number">0.769</span> ,  <span class="number">1.2464</span>],</span><br><span class="line">       [-<span class="number">0.5397</span>,  <span class="number">0.477</span> ]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: data[names == <span class="string">&#x27;Bob&#x27;</span>, <span class="number">3</span>]</span><br><span class="line">Out[<span class="number">105</span>]: array([ <span class="number">1.2464</span>,  <span class="number">0.477</span> ])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要选择除"Bob"以外的其他值，既可以使用不等于符号（!=），也可以通过~对条件进行否定：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">106</span>]: names != <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">Out[<span class="number">106</span>]: array([<span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>], dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: data[~(names == <span class="string">&#x27;Bob&#x27;</span>)]</span><br><span class="line">Out[<span class="number">107</span>]:</span><br><span class="line">array([[ <span class="number">1.0072</span>, -<span class="number">1.2962</span>,  <span class="number">0.275</span> ,  <span class="number">0.2289</span>],</span><br><span class="line">       [ <span class="number">1.3529</span>,  <span class="number">0.8864</span>, -<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">3.2489</span>, -<span class="number">1.0212</span>, -<span class="number">0.5771</span>,  <span class="number">0.1241</span>],</span><br><span class="line">       [ <span class="number">0.3026</span>,  <span class="number">0.5238</span>,  <span class="number">0.0009</span>,  <span class="number">1.3438</span>],</span><br><span class="line">       [-<span class="number">0.7135</span>, -<span class="number">0.8312</span>, -<span class="number">2.3702</span>, -<span class="number">1.8608</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>~操作符用来反转条件很好用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">108</span>]: cond = names == <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: data[~cond]</span><br><span class="line">Out[<span class="number">109</span>]: </span><br><span class="line">array([[ <span class="number">1.0072</span>, -<span class="number">1.2962</span>,  <span class="number">0.275</span> ,  <span class="number">0.2289</span>],</span><br><span class="line">       [ <span class="number">1.3529</span>,  <span class="number">0.8864</span>, -<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">3.2489</span>, -<span class="number">1.0212</span>, -<span class="number">0.5771</span>,  <span class="number">0.1241</span>],</span><br><span class="line">       [ <span class="number">0.3026</span>,  <span class="number">0.5238</span>,  <span class="number">0.0009</span>,  <span class="number">1.3438</span>],</span><br><span class="line">       [-<span class="number">0.7135</span>, -<span class="number">0.8312</span>, -<span class="number">2.3702</span>, -<span class="number">1.8608</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>选取这三个名字中的两个需要组合应用多个布尔条件，使用&amp;（和）、|（或）之类的布尔算术运算符即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">110</span>]: mask = (names == <span class="string">&#x27;Bob&#x27;</span>) | (names == <span class="string">&#x27;Will&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: mask</span><br><span class="line">Out[<span class="number">111</span>]: array([ <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>], dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">112</span>]: data[mask]</span><br><span class="line">Out[<span class="number">112</span>]: </span><br><span class="line">array([[ <span class="number">0.0929</span>,  <span class="number">0.2817</span>,  <span class="number">0.769</span> ,  <span class="number">1.2464</span>],</span><br><span class="line">       [ <span class="number">1.3529</span>,  <span class="number">0.8864</span>, -<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>, -<span class="number">0.5397</span>,  <span class="number">0.477</span> ],</span><br><span class="line">       [ <span class="number">3.2489</span>, -<span class="number">1.0212</span>, -<span class="number">0.5771</span>,  <span class="number">0.1241</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过布尔型索引选取数组中的数据，将总是创建数据的副本，即使返回一模一样的数组也是如此。</p>
<blockquote>
<p>注意：Python关键字and和or在布尔型数组中无效。要使用&amp;与|。</p>
</blockquote>
<p>通过布尔型数组设置值是一种经常用到的手段。为了将data中的所有负值都设置为0，我们只需：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">113</span>]: data[data &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: data</span><br><span class="line">Out[<span class="number">114</span>]: </span><br><span class="line">array([[ <span class="number">0.0929</span>,  <span class="number">0.2817</span>,  <span class="number">0.769</span> ,  <span class="number">1.2464</span>],</span><br><span class="line">       [ <span class="number">1.0072</span>,  <span class="number">0.</span>    ,  <span class="number">0.275</span> ,  <span class="number">0.2289</span>],</span><br><span class="line">       [ <span class="number">1.3529</span>,  <span class="number">0.8864</span>,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ],</span><br><span class="line">       [ <span class="number">1.669</span> ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.477</span> ],</span><br><span class="line">       [ <span class="number">3.2489</span>,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.1241</span>],</span><br><span class="line">       [ <span class="number">0.3026</span>,  <span class="number">0.5238</span>,  <span class="number">0.0009</span>,  <span class="number">1.3438</span>],</span><br><span class="line">       [ <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过一维布尔数组设置整行或列的值也很简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">115</span>]: data[names != <span class="string">&#x27;Joe&#x27;</span>] = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: data</span><br><span class="line">Out[<span class="number">116</span>]: </span><br><span class="line">array([[ <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ],</span><br><span class="line">       [ <span class="number">1.0072</span>,  <span class="number">0.</span>    ,  <span class="number">0.275</span> ,  <span class="number">0.2289</span>],</span><br><span class="line">       [ <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ],</span><br><span class="line">       [ <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ],</span><br><span class="line">       [ <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ],</span><br><span class="line">       [ <span class="number">0.3026</span>,  <span class="number">0.5238</span>,  <span class="number">0.0009</span>,  <span class="number">1.3438</span>],</span><br><span class="line">       [ <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>后面会看到，这类二维数据的操作也可以用pandas方便的来做。</p>
<h2 id="花式索引">花式索引</h2>
<p>花式索引（Fancy indexing）是一个NumPy术语，它指的是利用整数数组进行索引。假设我们有一个8×4数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">117</span>]: arr = np.empty((<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">   .....:     arr[i] = i</span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: arr</span><br><span class="line">Out[<span class="number">119</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">2.</span>,  <span class="number">2.</span>,  <span class="number">2.</span>,  <span class="number">2.</span>],</span><br><span class="line">       [ <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>],</span><br><span class="line">       [ <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>],</span><br><span class="line">       [ <span class="number">6.</span>,  <span class="number">6.</span>,  <span class="number">6.</span>,  <span class="number">6.</span>],</span><br><span class="line">       [ <span class="number">7.</span>,  <span class="number">7.</span>,  <span class="number">7.</span>,  <span class="number">7.</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了以特定顺序选取行子集，只需传入一个用于指定顺序的整数列表或ndarray即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">120</span>]: arr[[<span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>]]</span><br><span class="line">Out[<span class="number">120</span>]: </span><br><span class="line">array([[ <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>],</span><br><span class="line">       [ <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">6.</span>,  <span class="number">6.</span>,  <span class="number">6.</span>,  <span class="number">6.</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码确实达到我们的要求了！使用负数索引将会从末尾开始选取行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">121</span>]: arr[[-<span class="number">3</span>, -<span class="number">5</span>, -<span class="number">7</span>]]</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line">array([[ <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>],</span><br><span class="line">       [ <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一次传入多个索引数组会有一点特别。它返回的是一个一维数组，其中的元素对应各个索引元组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">122</span>]: arr = np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: arr</span><br><span class="line">Out[<span class="number">123</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">       [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">       [<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>],</span><br><span class="line">       [<span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: arr[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">Out[<span class="number">124</span>]: array([ <span class="number">4</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">10</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>附录A中会详细介绍reshape方法。</p>
<p>最终选出的是元素(1,0)、(5,3)、(7,1)和(2,2)。无论数组是多少维的，花式索引总是一维的。</p>
<p>这个花式索引的行为可能会跟某些用户的预期不一样（包括我在内），选取矩阵的行列子集应该是矩形区域的形式才对。下面是得到该结果的一个办法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">125</span>]: arr[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>]][:, [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">Out[<span class="number">125</span>]: </span><br><span class="line">array([[ <span class="number">4</span>,  <span class="number">7</span>,  <span class="number">5</span>,  <span class="number">6</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">23</span>, <span class="number">21</span>, <span class="number">22</span>],</span><br><span class="line">       [<span class="number">28</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">       [ <span class="number">8</span>, <span class="number">11</span>,  <span class="number">9</span>, <span class="number">10</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>记住，花式索引跟切片不一样，它总是将数据复制到新数组中。</p>
<h2 id="数组转置和轴对换">数组转置和轴对换</h2>
<p>转置是重塑的一种特殊形式，它返回的是源数据的视图（不会进行任何复制操作）。数组不仅有transpose方法，还有一个特殊的T属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">126</span>]: arr = np.arange(<span class="number">15</span>).reshape((<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">127</span>]: arr</span><br><span class="line">Out[<span class="number">127</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">128</span>]: arr.T</span><br><span class="line">Out[<span class="number">128</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">5</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">1</span>,  <span class="number">6</span>, <span class="number">11</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">7</span>, <span class="number">12</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">8</span>, <span class="number">13</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">9</span>, <span class="number">14</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在进行矩阵计算时，经常需要用到该操作，比如利用np.dot计算矩阵内积：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">129</span>]: arr = np.random.randn(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">130</span>]: arr</span><br><span class="line">Out[<span class="number">130</span>]: </span><br><span class="line">array([[-<span class="number">0.8608</span>,  <span class="number">0.5601</span>, -<span class="number">1.2659</span>],</span><br><span class="line">       [ <span class="number">0.1198</span>, -<span class="number">1.0635</span>,  <span class="number">0.3329</span>],</span><br><span class="line">       [-<span class="number">2.3594</span>, -<span class="number">0.1995</span>, -<span class="number">1.542</span> ],</span><br><span class="line">       [-<span class="number">0.9707</span>, -<span class="number">1.307</span> ,  <span class="number">0.2863</span>],</span><br><span class="line">       [ <span class="number">0.378</span> , -<span class="number">0.7539</span>,  <span class="number">0.3313</span>],</span><br><span class="line">       [ <span class="number">1.3497</span>,  <span class="number">0.0699</span>,  <span class="number">0.2467</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">131</span>]: np.dot(arr.T, arr)</span><br><span class="line">Out[<span class="number">131</span>]:</span><br><span class="line">array([[ <span class="number">9.2291</span>,  <span class="number">0.9394</span>,  <span class="number">4.948</span> ],</span><br><span class="line">       [ <span class="number">0.9394</span>,  <span class="number">3.7662</span>, -<span class="number">1.3622</span>],</span><br><span class="line">       [ <span class="number">4.948</span> , -<span class="number">1.3622</span>,  <span class="number">4.3437</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于高维数组，transpose需要得到一个由轴编号组成的元组才能对这些轴进行转置（比较费脑子）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">132</span>]: arr = np.arange(<span class="number">16</span>).reshape((<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">133</span>]: arr</span><br><span class="line">Out[<span class="number">133</span>]: </span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>]],</span><br><span class="line">       [[ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">134</span>]: arr.transpose((<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line">Out[<span class="number">134</span>]: </span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line">       [[ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，第一个轴被换成了第二个，第二个轴被换成了第一个，最后一个轴不变。</p>
<p>简单的转置可以使用.T，它其实就是进行轴对换而已。ndarray还有一个swapaxes方法，它需要接受一对轴编号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">135</span>]: arr</span><br><span class="line">Out[<span class="number">135</span>]: </span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>]],</span><br><span class="line">       [[ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: arr.swapaxes(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Out[<span class="number">136</span>]: </span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">4</span>],</span><br><span class="line">        [ <span class="number">1</span>,  <span class="number">5</span>],</span><br><span class="line">        [ <span class="number">2</span>,  <span class="number">6</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">7</span>]],</span><br><span class="line">       [[ <span class="number">8</span>, <span class="number">12</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">13</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">14</span>],</span><br><span class="line">        [<span class="number">11</span>, <span class="number">15</span>]]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>swapaxes也是返回源数据的视图（不会进行任何复制操作）。</p>
<h1 id="通用函数快速的元素级数组函数">4.2 通用函数：快速的元素级数组函数</h1>
<p>通用函数（即ufunc）是一种对ndarray中的数据执行元素级运算的函数。你可以将其看做简单函数（接受一个或多个标量值，并产生一个或多个标量值）的矢量化包装器。</p>
<p>许多ufunc都是简单的元素级变体，如sqrt和exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">137</span>]: arr = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">138</span>]: arr</span><br><span class="line">Out[<span class="number">138</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">139</span>]: np.sqrt(arr)</span><br><span class="line">Out[<span class="number">139</span>]: </span><br><span class="line">array([ <span class="number">0.</span>    ,  <span class="number">1.</span>    ,  <span class="number">1.4142</span>,  <span class="number">1.7321</span>,  <span class="number">2.</span>    ,  <span class="number">2.2361</span>,  <span class="number">2.4495</span>,</span><br><span class="line">        <span class="number">2.6458</span>,  <span class="number">2.8284</span>,  <span class="number">3.</span>    ])</span><br><span class="line"></span><br><span class="line">In [<span class="number">140</span>]: np.exp(arr)</span><br><span class="line">Out[<span class="number">140</span>]: </span><br><span class="line">array([    <span class="number">1.</span>    ,     <span class="number">2.7183</span>,     <span class="number">7.3891</span>,    <span class="number">20.0855</span>,    <span class="number">54.5982</span>,</span><br><span class="line">         <span class="number">148.4132</span>,   <span class="number">403.4288</span>,  <span class="number">1096.6332</span>,  <span class="number">2980.958</span> ,  <span class="number">8103.0839</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这些都是一元（unary）ufunc。另外一些（如add或maximum）接受2个数组（因此也叫二元（binary）ufunc），并返回一个结果数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">141</span>]: x = np.random.randn(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">142</span>]: y = np.random.randn(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">143</span>]: x</span><br><span class="line">Out[<span class="number">143</span>]: </span><br><span class="line">array([-<span class="number">0.0119</span>,  <span class="number">1.0048</span>,  <span class="number">1.3272</span>, -<span class="number">0.9193</span>, -<span class="number">1.5491</span>,  <span class="number">0.0222</span>,  <span class="number">0.7584</span>,</span><br><span class="line">       -<span class="number">0.6605</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">144</span>]: y</span><br><span class="line">Out[<span class="number">144</span>]: </span><br><span class="line">array([ <span class="number">0.8626</span>, -<span class="number">0.01</span>  ,  <span class="number">0.05</span>  ,  <span class="number">0.6702</span>,  <span class="number">0.853</span> , -<span class="number">0.9559</span>, -<span class="number">0.0235</span>,</span><br><span class="line">       -<span class="number">2.3042</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">145</span>]: np.maximum(x, y)</span><br><span class="line">Out[<span class="number">145</span>]: </span><br><span class="line">array([ <span class="number">0.8626</span>,  <span class="number">1.0048</span>,  <span class="number">1.3272</span>,  <span class="number">0.6702</span>,  <span class="number">0.853</span> ,  <span class="number">0.0222</span>,  <span class="number">0.7584</span>,   </span><br><span class="line">       -<span class="number">0.6605</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，numpy.maximum计算了x和y中元素级别最大的元素。</p>
<p>虽然并不常见，但有些ufunc的确可以返回多个数组。modf就是一个例子，它是Python内置函数divmod的矢量化版本，它会返回浮点数数组的小数和整数部分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">146</span>]: arr = np.random.randn(<span class="number">7</span>) * <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">147</span>]: arr</span><br><span class="line">Out[<span class="number">147</span>]: array([-<span class="number">3.2623</span>, -<span class="number">6.0915</span>, -<span class="number">6.663</span> ,  <span class="number">5.3731</span>,  <span class="number">3.6182</span>,  <span class="number">3.45</span>  ,  <span class="number">5.0077</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">148</span>]: remainder, whole_part = np.modf(arr)</span><br><span class="line"></span><br><span class="line">In [<span class="number">149</span>]: remainder</span><br><span class="line">Out[<span class="number">149</span>]: array([-<span class="number">0.2623</span>, -<span class="number">0.0915</span>, -<span class="number">0.663</span> ,  <span class="number">0.3731</span>,</span><br><span class="line"><span class="number">0.6182</span>,  <span class="number">0.45</span>  ,  <span class="number">0.0077</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">150</span>]: whole_part</span><br><span class="line">Out[<span class="number">150</span>]: array([-<span class="number">3.</span>, -<span class="number">6.</span>, -<span class="number">6.</span>,  <span class="number">5.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">5.</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Ufuncs可以接受一个out可选参数，这样就能在数组原地进行操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">151</span>]: arr</span><br><span class="line">Out[<span class="number">151</span>]: array([-<span class="number">3.2623</span>, -<span class="number">6.0915</span>, -<span class="number">6.663</span> ,  <span class="number">5.3731</span>,  <span class="number">3.6182</span>,  <span class="number">3.45</span>  ,  <span class="number">5.0077</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">152</span>]: np.sqrt(arr)</span><br><span class="line">Out[<span class="number">152</span>]: array([    nan,     nan,     nan,  <span class="number">2.318</span> ,  <span class="number">1.9022</span>,  <span class="number">1.8574</span>,  <span class="number">2.2378</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">153</span>]: np.sqrt(arr, arr)</span><br><span class="line">Out[<span class="number">153</span>]: array([    nan,     nan,     nan,  <span class="number">2.318</span> ,  <span class="number">1.9022</span>,  <span class="number">1.8574</span>,  <span class="number">2.2378</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">154</span>]: arr</span><br><span class="line">Out[<span class="number">154</span>]: array([    nan,     nan,     nan,  <span class="number">2.318</span> ,  <span class="number">1.9022</span>,  <span class="number">1.8574</span>,  <span class="number">2.2378</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表4-3和表4-4分别列出了一些一元和二元ufunc。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-1d494e73b61c7ced.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-2be79faf68ab6ff8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-4e38d02a66481530.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-eff1e61e5464159f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-236dba83b6a420cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<h1 id="利用数组进行数据处理">4.3 利用数组进行数据处理</h1>
<p>NumPy数组使你可以将许多种数据处理任务表述为简洁的数组表达式（否则需要编写循环）。用数组表达式代替循环的做法，通常被称为矢量化。一般来说，矢量化数组运算要比等价的纯Python方式快上一两个数量级（甚至更多），尤其是各种数值计算。在后面内容中（见附录A）我将介绍广播，这是一种针对矢量化计算的强大手段。</p>
<p>作为简单的例子，假设我们想要在一组值（网格型）上计算函数<code>sqrt(x^2+y^2)</code>。np.meshgrid函数接受两个一维数组，并产生两个二维矩阵（对应于两个数组中所有的(x,y)对）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">155</span>]: points = np.arange(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">0.01</span>) <span class="comment"># 1000 equally spaced points</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">156</span>]: xs, ys = np.meshgrid(points, points)</span><br><span class="line">In [<span class="number">157</span>]: ys</span><br><span class="line">Out[<span class="number">157</span>]: </span><br><span class="line">array([[-<span class="number">5.</span>  , -<span class="number">5.</span>  , -<span class="number">5.</span>  , ..., -<span class="number">5.</span>  , -<span class="number">5.</span>  , -<span class="number">5.</span>  ],</span><br><span class="line">       [-<span class="number">4.99</span>, -<span class="number">4.99</span>, -<span class="number">4.99</span>, ..., -<span class="number">4.99</span>, -<span class="number">4.99</span>, -<span class="number">4.99</span>],</span><br><span class="line">       [-<span class="number">4.98</span>, -<span class="number">4.98</span>, -<span class="number">4.98</span>, ..., -<span class="number">4.98</span>, -<span class="number">4.98</span>, -<span class="number">4.98</span>],</span><br><span class="line">       ..., </span><br><span class="line">       [ <span class="number">4.97</span>,  <span class="number">4.97</span>,  <span class="number">4.97</span>, ...,  <span class="number">4.97</span>,  <span class="number">4.97</span>,  <span class="number">4.97</span>],</span><br><span class="line">       [ <span class="number">4.98</span>,  <span class="number">4.98</span>,  <span class="number">4.98</span>, ...,  <span class="number">4.98</span>,  <span class="number">4.98</span>,  <span class="number">4.98</span>],</span><br><span class="line">       [ <span class="number">4.99</span>,  <span class="number">4.99</span>,  <span class="number">4.99</span>, ...,  <span class="number">4.99</span>,  <span class="number">4.99</span>,  <span class="number">4.99</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，对该函数的求值运算就好办了，把这两个数组当做两个浮点数那样编写表达式即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">158</span>]: z = np.sqrt(xs ** <span class="number">2</span> + ys ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">159</span>]: z</span><br><span class="line">Out[<span class="number">159</span>]: </span><br><span class="line">array([[ <span class="number">7.0711</span>,  <span class="number">7.064</span> ,  <span class="number">7.0569</span>, ...,  <span class="number">7.0499</span>,  <span class="number">7.0569</span>,  <span class="number">7.064</span> ],</span><br><span class="line">       [ <span class="number">7.064</span> ,  <span class="number">7.0569</span>,  <span class="number">7.0499</span>, ...,  <span class="number">7.0428</span>,  <span class="number">7.0499</span>,  <span class="number">7.0569</span>],</span><br><span class="line">       [ <span class="number">7.0569</span>,  <span class="number">7.0499</span>,  <span class="number">7.0428</span>, ...,  <span class="number">7.0357</span>,  <span class="number">7.0428</span>, <span class="number">7.0499</span>],</span><br><span class="line">       ..., </span><br><span class="line">       [ <span class="number">7.0499</span>,  <span class="number">7.0428</span>,  <span class="number">7.0357</span>, ...,  <span class="number">7.0286</span>,  <span class="number">7.0357</span>,  <span class="number">7.0428</span>],</span><br><span class="line">       [ <span class="number">7.0569</span>,  <span class="number">7.0499</span>,  <span class="number">7.0428</span>, ...,  <span class="number">7.0357</span>,  <span class="number">7.0428</span>,  <span class="number">7.0499</span>],</span><br><span class="line">       [ <span class="number">7.064</span> ,  <span class="number">7.0569</span>,  <span class="number">7.0499</span>, ...,  <span class="number">7.0428</span>,  <span class="number">7.0499</span>,  <span class="number">7.0569</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>作为第9章的先导，我用matplotlib创建了这个二维数组的可视化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">160</span>]: <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">In [<span class="number">161</span>]: plt.imshow(z, cmap=plt.cm.gray); plt.colorbar()</span><br><span class="line">Out[<span class="number">161</span>]: &lt;matplotlib.colorbar.Colorbar at <span class="number">0x7f715e3fa630</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">162</span>]: plt.title(<span class="string">&quot;Image plot of $\sqrt&#123;x^2 + y^2&#125;$ for a grid of values&quot;</span>)</span><br><span class="line">Out[<span class="number">162</span>]: &lt;matplotlib.text.Text at <span class="number">0x7f715d2de748</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>见图4-3。这张图是用matplotlib的imshow函数创建的。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-3b22000d4cd38650.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4-3 根据网格对函数求值的结果" /><figcaption aria-hidden="true">图4-3 根据网格对函数求值的结果</figcaption>
</figure>
<h2 id="将条件逻辑表述为数组运算">将条件逻辑表述为数组运算</h2>
<p>numpy.where函数是三元表达式x if condition else y的矢量化版本。假设我们有一个布尔数组和两个值数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">165</span>]: xarr = np.array([<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">1.5</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">166</span>]: yarr = np.array([<span class="number">2.1</span>, <span class="number">2.2</span>, <span class="number">2.3</span>, <span class="number">2.4</span>, <span class="number">2.5</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">167</span>]: cond = np.array([<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设我们想要根据cond中的值选取xarr和yarr的值：当cond中的值为True时，选取xarr的值，否则从yarr中选取。列表推导式的写法应该如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">168</span>]: result = [(x <span class="keyword">if</span> c <span class="keyword">else</span> y)</span><br><span class="line">   .....:           <span class="keyword">for</span> x, y, c <span class="keyword">in</span> <span class="built_in">zip</span>(xarr, yarr, cond)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">169</span>]: result</span><br><span class="line">Out[<span class="number">169</span>]: [<span class="number">1.1000000000000001</span>, <span class="number">2.2000000000000002</span>, <span class="number">1.3</span>, <span class="number">1.3999999999999999</span>, <span class="number">2.5</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这有几个问题。第一，它对大数组的处理速度不是很快（因为所有工作都是由纯Python完成的）。第二，无法用于多维数组。若使用np.where，则可以将该功能写得非常简洁：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">170</span>]: result = np.where(cond, xarr, yarr)</span><br><span class="line"></span><br><span class="line">In [<span class="number">171</span>]: result</span><br><span class="line">Out[<span class="number">171</span>]: array([ <span class="number">1.1</span>,  <span class="number">2.2</span>,  <span class="number">1.3</span>,  <span class="number">1.4</span>,  <span class="number">2.5</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>np.where的第二个和第三个参数不必是数组，它们都可以是标量值。在数据分析工作中，where通常用于根据另一个数组而产生一个新的数组。假设有一个由随机数据组成的矩阵，你希望将所有正值替换为2，将所有负值替换为－2。若利用np.where，则会非常简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">172</span>]: arr = np.random.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">173</span>]: arr</span><br><span class="line">Out[<span class="number">173</span>]: </span><br><span class="line">array([[-<span class="number">0.5031</span>, -<span class="number">0.6223</span>, -<span class="number">0.9212</span>, -<span class="number">0.7262</span>],</span><br><span class="line">       [ <span class="number">0.2229</span>,  <span class="number">0.0513</span>, -<span class="number">1.1577</span>,  <span class="number">0.8167</span>],</span><br><span class="line">       [ <span class="number">0.4336</span>,  <span class="number">1.0107</span>,  <span class="number">1.8249</span>, -<span class="number">0.9975</span>],</span><br><span class="line">       [ <span class="number">0.8506</span>, -<span class="number">0.1316</span>,  <span class="number">0.9124</span>,  <span class="number">0.1882</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">174</span>]: arr &gt; <span class="number">0</span></span><br><span class="line">Out[<span class="number">174</span>]: </span><br><span class="line">array([[<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">       [ <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>],</span><br><span class="line">       [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">       [ <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>]], dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">175</span>]: np.where(arr &gt; <span class="number">0</span>, <span class="number">2</span>, -<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">175</span>]: </span><br><span class="line">array([[-<span class="number">2</span>, -<span class="number">2</span>, -<span class="number">2</span>, -<span class="number">2</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">2</span>, -<span class="number">2</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>, -<span class="number">2</span>],</span><br><span class="line">       [ <span class="number">2</span>, -<span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用np.where，可以将标量和数组结合起来。例如，我可用常数2替换arr中所有正的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">176</span>]: np.where(arr &gt; <span class="number">0</span>, <span class="number">2</span>, arr) <span class="comment"># set only positive values to 2</span></span><br><span class="line">Out[<span class="number">176</span>]: </span><br><span class="line">array([[-<span class="number">0.5031</span>, -<span class="number">0.6223</span>, -<span class="number">0.9212</span>, -<span class="number">0.7262</span>],</span><br><span class="line">       [ <span class="number">2.</span>    ,  <span class="number">2.</span>    , -<span class="number">1.1577</span>,  <span class="number">2.</span>    ],</span><br><span class="line">       [ <span class="number">2.</span>    ,  <span class="number">2.</span>    ,  <span class="number">2.</span>    , -<span class="number">0.9975</span>],</span><br><span class="line">       [ <span class="number">2.</span>    , -<span class="number">0.1316</span>,  <span class="number">2.</span>    ,  <span class="number">2.</span>    ]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传递给where的数组大小可以不相等，甚至可以是标量值。</p>
<h2 id="数学和统计方法">数学和统计方法</h2>
<p>可以通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计计算。sum、mean以及标准差std等聚合计算（aggregation，通常叫做约简（reduction））既可以当做数组的实例方法调用，也可以当做顶级NumPy函数使用。</p>
<p>这里，我生成了一些正态分布随机数据，然后做了聚类统计：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">177</span>]: arr = np.random.randn(<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">178</span>]: arr</span><br><span class="line">Out[<span class="number">178</span>]: </span><br><span class="line">array([[ <span class="number">2.1695</span>, -<span class="number">0.1149</span>,  <span class="number">2.0037</span>,  <span class="number">0.0296</span>],</span><br><span class="line">       [ <span class="number">0.7953</span>,  <span class="number">0.1181</span>, -<span class="number">0.7485</span>,  <span class="number">0.585</span> ],</span><br><span class="line">       [ <span class="number">0.1527</span>, -<span class="number">1.5657</span>, -<span class="number">0.5625</span>, -<span class="number">0.0327</span>],</span><br><span class="line">       [-<span class="number">0.929</span> , -<span class="number">0.4826</span>, -<span class="number">0.0363</span>,  <span class="number">1.0954</span>],</span><br><span class="line">       [ <span class="number">0.9809</span>, -<span class="number">0.5895</span>,  <span class="number">1.5817</span>, -<span class="number">0.5287</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">179</span>]: arr.mean()</span><br><span class="line">Out[<span class="number">179</span>]: <span class="number">0.19607051119998253</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">180</span>]: np.mean(arr)</span><br><span class="line">Out[<span class="number">180</span>]: <span class="number">0.19607051119998253</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">181</span>]: arr.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">181</span>]: <span class="number">3.9214102239996507</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>mean和sum这类的函数可以接受一个axis选项参数，用于计算该轴向上的统计值，最终结果是一个少一维的数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">182</span>]: arr.mean(axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">182</span>]: array([ <span class="number">1.022</span> ,  <span class="number">0.1875</span>, -<span class="number">0.502</span> , -<span class="number">0.0881</span>,  <span class="number">0.3611</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">183</span>]: arr.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">183</span>]: array([ <span class="number">3.1693</span>, -<span class="number">2.6345</span>,  <span class="number">2.2381</span>,  <span class="number">1.1486</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，arr.mean(1)是“计算行的平均值”，arr.sum(0)是“计算每列的和”。</p>
<p>其他如cumsum和cumprod之类的方法则不聚合，而是产生一个由中间结果组成的数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">184</span>]: arr = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">185</span>]: arr.cumsum()</span><br><span class="line">Out[<span class="number">185</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">3</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">28</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在多维数组中，累加函数（如cumsum）返回的是同样大小的数组，但是会根据每个低维的切片沿着标记轴计算部分聚类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">186</span>]: arr = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">187</span>]: arr</span><br><span class="line">Out[<span class="number">187</span>]: </span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">188</span>]: arr.cumsum(axis=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">188</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">189</span>]: arr.cumprod(axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">189</span>]: </span><br><span class="line">array([[  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>],</span><br><span class="line">       [  <span class="number">3</span>,  <span class="number">12</span>,  <span class="number">60</span>],</span><br><span class="line">       [  <span class="number">6</span>,  <span class="number">42</span>, <span class="number">336</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表4-5列出了全部的基本数组统计方法。后续章节中有很多例子都会用到这些方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-a6c6df3ca8e0b98e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-866fcde885b1d357.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<h2 id="用于布尔型数组的方法">用于布尔型数组的方法</h2>
<p>在上面这些方法中，布尔值会被强制转换为1（True）和0（False）。因此，sum经常被用来对布尔型数组中的True值计数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">190</span>]: arr = np.random.randn(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">191</span>]: (arr &gt; <span class="number">0</span>).<span class="built_in">sum</span>() <span class="comment"># Number of positive values</span></span><br><span class="line">Out[<span class="number">191</span>]: <span class="number">42</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外还有两个方法any和all，它们对布尔型数组非常有用。any用于测试数组中是否存在一个或多个True，而all则检查数组中所有值是否都是True：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">192</span>]: bools = np.array([<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">193</span>]: bools.<span class="built_in">any</span>()</span><br><span class="line">Out[<span class="number">193</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">194</span>]: bools.<span class="built_in">all</span>()</span><br><span class="line">Out[<span class="number">194</span>]: <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这两个方法也能用于非布尔型数组，所有非0元素将会被当做True。</p>
<h2 id="排序">排序</h2>
<p>跟Python内置的列表类型一样，NumPy数组也可以通过sort方法就地排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">195</span>]: arr = np.random.randn(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">196</span>]: arr</span><br><span class="line">Out[<span class="number">196</span>]: array([ <span class="number">0.6095</span>, -<span class="number">0.4938</span>,  <span class="number">1.24</span>  , -<span class="number">0.1357</span>,  <span class="number">1.43</span>  , -<span class="number">0.8469</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">197</span>]: arr.sort()</span><br><span class="line"></span><br><span class="line">In [<span class="number">198</span>]: arr</span><br><span class="line">Out[<span class="number">198</span>]: array([-<span class="number">0.8469</span>, -<span class="number">0.4938</span>, -<span class="number">0.1357</span>,  <span class="number">0.6095</span>,  <span class="number">1.24</span>  ,  <span class="number">1.43</span>  ])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>多维数组可以在任何一个轴向上进行排序，只需将轴编号传给sort即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">199</span>]: arr = np.random.randn(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">200</span>]: arr</span><br><span class="line">Out[<span class="number">200</span>]: </span><br><span class="line">array([[ <span class="number">0.6033</span>,  <span class="number">1.2636</span>, -<span class="number">0.2555</span>],</span><br><span class="line">       [-<span class="number">0.4457</span>,  <span class="number">0.4684</span>, -<span class="number">0.9616</span>],</span><br><span class="line">       [-<span class="number">1.8245</span>,  <span class="number">0.6254</span>,  <span class="number">1.0229</span>],</span><br><span class="line">       [ <span class="number">1.1074</span>,  <span class="number">0.0909</span>, -<span class="number">0.3501</span>],</span><br><span class="line">       [ <span class="number">0.218</span> , -<span class="number">0.8948</span>, -<span class="number">1.7415</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">201</span>]: arr.sort(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">202</span>]: arr</span><br><span class="line">Out[<span class="number">202</span>]: </span><br><span class="line">array([[-<span class="number">0.2555</span>,  <span class="number">0.6033</span>,  <span class="number">1.2636</span>],</span><br><span class="line">       [-<span class="number">0.9616</span>, -<span class="number">0.4457</span>,  <span class="number">0.4684</span>],</span><br><span class="line">       [-<span class="number">1.8245</span>,  <span class="number">0.6254</span>,  <span class="number">1.0229</span>],</span><br><span class="line">       [-<span class="number">0.3501</span>,  <span class="number">0.0909</span>,  <span class="number">1.1074</span>],</span><br><span class="line">       [-<span class="number">1.7415</span>, -<span class="number">0.8948</span>,  <span class="number">0.218</span> ]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>顶级方法np.sort返回的是数组的已排序副本，而就地排序则会修改数组本身。计算数组分位数最简单的办法是对其进行排序，然后选取特定位置的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">203</span>]: large_arr = np.random.randn(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">204</span>]: large_arr.sort()</span><br><span class="line"></span><br><span class="line">In [<span class="number">205</span>]: large_arr[<span class="built_in">int</span>(<span class="number">0.05</span> * <span class="built_in">len</span>(large_arr))] <span class="comment"># 5% quantile</span></span><br><span class="line">Out[<span class="number">205</span>]: -<span class="number">1.5311513550102103</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更多关于NumPy排序方法以及诸如间接排序之类的高级技术，请参阅附录A。在pandas中还可以找到一些其他跟排序有关的数据操作（比如根据一列或多列对表格型数据进行排序）。</p>
<h2 id="唯一化以及其它的集合逻辑">唯一化以及其它的集合逻辑</h2>
<p>NumPy提供了一些针对一维ndarray的基本集合运算。最常用的可能要数np.unique了，它用于找出数组中的唯一值并返回已排序的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">206</span>]: names = np.array([<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">207</span>]: np.unique(names)</span><br><span class="line">Out[<span class="number">207</span>]: </span><br><span class="line">array([<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>],</span><br><span class="line">      dtype=<span class="string">&#x27;&lt;U4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">208</span>]: ints = np.array([<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">209</span>]: np.unique(ints)</span><br><span class="line">Out[<span class="number">209</span>]: array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>拿跟np.unique等价的纯Python代码来对比一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">210</span>]: <span class="built_in">sorted</span>(<span class="built_in">set</span>(names))</span><br><span class="line">Out[<span class="number">210</span>]: [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另一个函数np.in1d用于测试一个数组中的值在另一个数组中的成员资格，返回一个布尔型数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">211</span>]: values = np.array([<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">212</span>]: np.in1d(values, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line">Out[<span class="number">212</span>]: array([ <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>], dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>NumPy中的集合函数请参见表4-6。 <img src="http://upload-images.jianshu.io/upload_images/7178691-80e85ae6b9c89ada.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<h1 id="用于数组的文件输入输出">4.4 用于数组的文件输入输出</h1>
<p>NumPy能够读写磁盘上的文本数据或二进制数据。这一小节只讨论NumPy的内置二进制格式，因为更多的用户会使用pandas或其它工具加载文本或表格数据（见第6章）。</p>
<p>np.save和np.load是读写磁盘数组数据的两个主要函数。默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为.npy的文件中的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">213</span>]: arr = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">214</span>]: np.save(<span class="string">&#x27;some_array&#x27;</span>, arr)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果文件路径末尾没有扩展名.npy，则该扩展名会被自动加上。然后就可以通过np.load读取磁盘上的数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">215</span>]: np.load(<span class="string">&#x27;some_array.npy&#x27;</span>)</span><br><span class="line">Out[<span class="number">215</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过np.savez可以将多个数组保存到一个未压缩文件中，将数组以关键字参数的形式传入即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">216</span>]: np.savez(<span class="string">&#x27;array_archive.npz&#x27;</span>, a=arr, b=arr)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>加载.npz文件时，你会得到一个类似字典的对象，该对象会对各个数组进行延迟加载：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">217</span>]: arch = np.load(<span class="string">&#x27;array_archive.npz&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">218</span>]: arch[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">218</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果要将数据压缩，可以使用numpy.savez_compressed：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">219</span>]: np.savez_compressed(<span class="string">&#x27;arrays_compressed.npz&#x27;</span>, a=arr, b=arr)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="线性代数">4.5 线性代数</h1>
<p>线性代数（如矩阵乘法、矩阵分解、行列式以及其他方阵数学等）是任何数组库的重要组成部分。不像某些语言（如MATLAB），通过*对两个二维数组相乘得到的是一个元素级的积，而不是一个矩阵点积。因此，NumPy提供了一个用于矩阵乘法的dot函数（既是一个数组方法也是numpy命名空间中的一个函数）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">223</span>]: x = np.array([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">224</span>]: y = np.array([[<span class="number">6.</span>, <span class="number">23.</span>], [-<span class="number">1</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">225</span>]: x</span><br><span class="line">Out[<span class="number">225</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">226</span>]: y</span><br><span class="line">Out[<span class="number">226</span>]: </span><br><span class="line">array([[  <span class="number">6.</span>,  <span class="number">23.</span>],</span><br><span class="line">       [ -<span class="number">1.</span>,   <span class="number">7.</span>],</span><br><span class="line">       [  <span class="number">8.</span>,   <span class="number">9.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">227</span>]: x.dot(y)</span><br><span class="line">Out[<span class="number">227</span>]: </span><br><span class="line">array([[  <span class="number">28.</span>,   <span class="number">64.</span>],</span><br><span class="line">       [  <span class="number">67.</span>,  <span class="number">181.</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>x.dot(y)等价于np.dot(x, y)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">228</span>]: np.dot(x, y)</span><br><span class="line">Out[<span class="number">228</span>]: </span><br><span class="line">array([[  <span class="number">28.</span>,   <span class="number">64.</span>],</span><br><span class="line">       [  <span class="number">67.</span>,  <span class="number">181.</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一个二维数组跟一个大小合适的一维数组的矩阵点积运算之后将会得到一个一维数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">229</span>]: np.dot(x, np.ones(<span class="number">3</span>))</span><br><span class="line">Out[<span class="number">229</span>]: array([  <span class="number">6.</span>,  <span class="number">15.</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><span class="citation" data-cites="符">@符</span>（类似Python 3.5）也可以用作中缀运算符，进行矩阵乘法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">230</span>]: x @ np.ones(<span class="number">3</span>)</span><br><span class="line">Out[<span class="number">230</span>]: array([  <span class="number">6.</span>,  <span class="number">15.</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>numpy.linalg中有一组标准的矩阵分解运算以及诸如求逆和行列式之类的东西。它们跟MATLAB和R等语言所使用的是相同的行业标准线性代数库，如BLAS、LAPACK、Intel MKL（Math Kernel Library，可能有，取决于你的NumPy版本）等：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">231</span>]: <span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> inv, qr</span><br><span class="line"></span><br><span class="line">In [<span class="number">232</span>]: X = np.random.randn(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">233</span>]: mat = X.T.dot(X)</span><br><span class="line"></span><br><span class="line">In [<span class="number">234</span>]: inv(mat)</span><br><span class="line">Out[<span class="number">234</span>]: </span><br><span class="line">array([[  <span class="number">933.1189</span>,   <span class="number">871.8258</span>, -<span class="number">1417.6902</span>, -<span class="number">1460.4005</span>,  <span class="number">1782.1391</span>],</span><br><span class="line">       [  <span class="number">871.8258</span>,   <span class="number">815.3929</span>, -<span class="number">1325.9965</span>, -<span class="number">1365.9242</span>,  <span class="number">1666.9347</span>],</span><br><span class="line">       [-<span class="number">1417.6902</span>, -<span class="number">1325.9965</span>,  <span class="number">2158.4424</span>,  <span class="number">2222.0191</span>, -<span class="number">2711.6822</span>],</span><br><span class="line">       [-<span class="number">1460.4005</span>, -<span class="number">1365.9242</span>,  <span class="number">2222.0191</span>,  <span class="number">2289.0575</span>, -<span class="number">2793.422</span> ],</span><br><span class="line">       [ <span class="number">1782.1391</span>,  <span class="number">1666.9347</span>, -<span class="number">2711.6822</span>, -<span class="number">2793.422</span> ,  <span class="number">3409.5128</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">235</span>]: mat.dot(inv(mat))</span><br><span class="line">Out[<span class="number">235</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">0.</span>, -<span class="number">0.</span>, -<span class="number">0.</span>, -<span class="number">0.</span>],</span><br><span class="line">       [-<span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [-<span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>, -<span class="number">0.</span>],</span><br><span class="line">       [-<span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">236</span>]: q, r = qr(mat)</span><br><span class="line"></span><br><span class="line">In [<span class="number">237</span>]: r</span><br><span class="line">Out[<span class="number">237</span>]: </span><br><span class="line">array([[-<span class="number">1.6914</span>,  <span class="number">4.38</span>  ,  <span class="number">0.1757</span>,  <span class="number">0.4075</span>, -<span class="number">0.7838</span>],</span><br><span class="line">       [ <span class="number">0.</span>    , -<span class="number">2.6436</span>,  <span class="number">0.1939</span>, -<span class="number">3.072</span> , -<span class="number">1.0702</span>],</span><br><span class="line">       [ <span class="number">0.</span>    ,  <span class="number">0.</span>    , -<span class="number">0.8138</span>,  <span class="number">1.5414</span>,  <span class="number">0.6155</span>],</span><br><span class="line">       [ <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    , -<span class="number">2.6445</span>, -<span class="number">2.1669</span>],</span><br><span class="line">       [ <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.0002</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表达式X.T.dot(X)计算X和它的转置X.T的点积。</p>
<p>表4-7中列出了一些最常用的线性代数函数。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-dcdb66e49e5f70ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<h1 id="伪随机数生成">4.6 伪随机数生成</h1>
<p>numpy.random模块对Python内置的random进行了补充，增加了一些用于高效生成多种概率分布的样本值的函数。例如，你可以用normal来得到一个标准正态分布的4×4样本数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">238</span>]: samples = np.random.normal(size=(<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">239</span>]: samples</span><br><span class="line">Out[<span class="number">239</span>]: </span><br><span class="line">array([[ <span class="number">0.5732</span>,  <span class="number">0.1933</span>,  <span class="number">0.4429</span>,  <span class="number">1.2796</span>],</span><br><span class="line">       [ <span class="number">0.575</span> ,  <span class="number">0.4339</span>, -<span class="number">0.7658</span>, -<span class="number">1.237</span> ],</span><br><span class="line">       [-<span class="number">0.5367</span>,  <span class="number">1.8545</span>, -<span class="number">0.92</span>  , -<span class="number">0.1082</span>],</span><br><span class="line">       [ <span class="number">0.1525</span>,  <span class="number">0.9435</span>, -<span class="number">1.0953</span>, -<span class="number">0.144</span> ]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而Python内置的random模块则只能一次生成一个样本值。从下面的测试结果中可以看出，如果需要产生大量样本值，numpy.random快了不止一个数量级：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">240</span>]: <span class="keyword">from</span> random <span class="keyword">import</span> normalvariate</span><br><span class="line"></span><br><span class="line">In [<span class="number">241</span>]: N = <span class="number">1000000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">242</span>]: %timeit samples = [normalvariate(<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"><span class="number">1.77</span> s +- <span class="number">126</span> ms per loop (mean +- std. dev. of <span class="number">7</span> runs, <span class="number">1</span> loop each)</span><br><span class="line"></span><br><span class="line">In [<span class="number">243</span>]: %timeit np.random.normal(size=N)</span><br><span class="line"><span class="number">61.7</span> ms +- <span class="number">1.32</span> ms per loop (mean +- std. dev. of <span class="number">7</span> runs, <span class="number">10</span> loops each)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们说这些都是伪随机数，是因为它们都是通过算法基于随机数生成器种子，在确定性的条件下生成的。你可以用NumPy的np.random.seed更改随机数生成种子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">244</span>]: np.random.seed(<span class="number">1234</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>numpy.random的数据生成函数使用了全局的随机种子。要避免全局状态，你可以使用numpy.random.RandomState，创建一个与其它隔离的随机数生成器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">245</span>]: rng = np.random.RandomState(<span class="number">1234</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">246</span>]: rng.randn(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">246</span>]: </span><br><span class="line">array([ <span class="number">0.4714</span>, -<span class="number">1.191</span> ,  <span class="number">1.4327</span>, -<span class="number">0.3127</span>, -<span class="number">0.7206</span>,  <span class="number">0.8872</span>,  <span class="number">0.8596</span>,</span><br><span class="line">       -<span class="number">0.6365</span>,  <span class="number">0.0157</span>, -<span class="number">2.2427</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表4-8列出了numpy.random中的部分函数。在下一节中，我将给出一些利用这些函数一次性生成大量样本值的范例。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-97ba09c96dab93a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-6ed04fae3d1178e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<h1 id="示例随机漫步">4.7 示例：随机漫步</h1>
<p>我们通过模拟随机漫步来说明如何运用数组运算。先来看一个简单的随机漫步的例子：从0开始，步长1和－1出现的概率相等。</p>
<p>下面是一个通过内置的random模块以纯Python的方式实现1000步的随机漫步：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">247</span>]: <span class="keyword">import</span> random</span><br><span class="line">   .....: position = <span class="number">0</span></span><br><span class="line">   .....: walk = [position]</span><br><span class="line">   .....: steps = <span class="number">1000</span></span><br><span class="line">   .....: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(steps):</span><br><span class="line">   .....:     step = <span class="number">1</span> <span class="keyword">if</span> random.randint(<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">   .....:     position += step</span><br><span class="line">   .....:     walk.append(position)</span><br><span class="line">   .....:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>图4-4是根据前100个随机漫步值生成的折线图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">249</span>]: plt.plot(walk[:<span class="number">100</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-0833621694f6dda0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4-4 简单的随机漫步" /><figcaption aria-hidden="true">图4-4 简单的随机漫步</figcaption>
</figure>
<p>不难看出，这其实就是随机漫步中各步的累计和，可以用一个数组运算来实现。因此，我用np.random模块一次性随机产生1000个“掷硬币”结果（即两个数中任选一个），将其分别设置为1或－1，然后计算累计和：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">251</span>]: nsteps = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">252</span>]: draws = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=nsteps)</span><br><span class="line"></span><br><span class="line">In [<span class="number">253</span>]: steps = np.where(draws &gt; <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">254</span>]: walk = steps.cumsum()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有了这些数据之后，我们就可以沿着漫步路径做一些统计工作了，比如求取最大值和最小值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">255</span>]: walk.<span class="built_in">min</span>()</span><br><span class="line">Out[<span class="number">255</span>]: -<span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">256</span>]: walk.<span class="built_in">max</span>()</span><br><span class="line">Out[<span class="number">256</span>]: <span class="number">31</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在来看一个复杂点的统计任务——首次穿越时间，即随机漫步过程中第一次到达某个特定值的时间。假设我们想要知道本次随机漫步需要多久才能距离初始0点至少10步远（任一方向均可）。np.abs(walk)&gt;=10可以得到一个布尔型数组，它表示的是距离是否达到或超过10，而我们想要知道的是第一个10或－10的索引。可以用argmax来解决这个问题，它返回的是该布尔型数组第一个最大值的索引（True就是最大值）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">257</span>]: (np.<span class="built_in">abs</span>(walk) &gt;= <span class="number">10</span>).argmax()</span><br><span class="line">Out[<span class="number">257</span>]: <span class="number">37</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，这里使用argmax并不是很高效，因为它无论如何都会对数组进行完全扫描。在本例中，只要发现了一个True，那我们就知道它是个最大值了。</p>
<h2 id="一次模拟多个随机漫步">一次模拟多个随机漫步</h2>
<p>如果你希望模拟多个随机漫步过程（比如5000个），只需对上面的代码做一点点修改即可生成所有的随机漫步过程。只要给numpy.random的函数传入一个二元元组就可以产生一个二维数组，然后我们就可以一次性计算5000个随机漫步过程（一行一个）的累计和了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">258</span>]: nwalks = <span class="number">5000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">259</span>]: nsteps = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">260</span>]: draws = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=(nwalks, nsteps)) <span class="comment"># 0 or 1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">261</span>]: steps = np.where(draws &gt; <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">262</span>]: walks = steps.cumsum(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">263</span>]: walks</span><br><span class="line">Out[<span class="number">263</span>]: </span><br><span class="line">array([[  <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>, ...,   <span class="number">8</span>,   <span class="number">7</span>,   <span class="number">8</span>],</span><br><span class="line">       [  <span class="number">1</span>,   <span class="number">0</span>,  -<span class="number">1</span>, ...,  <span class="number">34</span>,  <span class="number">33</span>,  <span class="number">32</span>],</span><br><span class="line">       [  <span class="number">1</span>,   <span class="number">0</span>,  -<span class="number">1</span>, ...,   <span class="number">4</span>,   <span class="number">5</span>,   <span class="number">4</span>],</span><br><span class="line">       ..., </span><br><span class="line">       [  <span class="number">1</span>,   <span class="number">2</span>,   <span class="number">1</span>, ...,  <span class="number">24</span>,  <span class="number">25</span>,  <span class="number">26</span>],</span><br><span class="line">       [  <span class="number">1</span>,   <span class="number">2</span>,   <span class="number">3</span>, ...,  <span class="number">14</span>,  <span class="number">13</span>,  <span class="number">14</span>],</span><br><span class="line">       [ -<span class="number">1</span>,  -<span class="number">2</span>,  -<span class="number">3</span>, ..., -<span class="number">24</span>, -<span class="number">23</span>, -<span class="number">22</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，我们来计算所有随机漫步过程的最大值和最小值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">264</span>]: walks.<span class="built_in">max</span>()</span><br><span class="line">Out[<span class="number">264</span>]: <span class="number">138</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">265</span>]: walks.<span class="built_in">min</span>()</span><br><span class="line">Out[<span class="number">265</span>]: -<span class="number">133</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>得到这些数据之后，我们来计算30或－30的最小穿越时间。这里稍微复杂些，因为不是5000个过程都到达了30。我们可以用any方法来对此进行检查：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">266</span>]: hits30 = (np.<span class="built_in">abs</span>(walks) &gt;= <span class="number">30</span>).<span class="built_in">any</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">267</span>]: hits30</span><br><span class="line">Out[<span class="number">267</span>]: array([<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>, ..., <span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>], dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">268</span>]: hits30.<span class="built_in">sum</span>() <span class="comment"># Number that hit 30 or -30</span></span><br><span class="line">Out[<span class="number">268</span>]: <span class="number">3410</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们利用这个布尔型数组选出那些穿越了30（绝对值）的随机漫步（行），并调用argmax在轴1上获取穿越时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">269</span>]: crossing_times = (np.<span class="built_in">abs</span>(walks[hits30]) &gt;= <span class="number">30</span>).argmax(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">270</span>]: crossing_times.mean()</span><br><span class="line">Out[<span class="number">270</span>]: <span class="number">498.88973607038122</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>请尝试用其他分布方式得到漫步数据。只需使用不同的随机数生成函数即可，如normal用于生成指定均值和标准差的正态分布数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">271</span>]: steps = np.random.normal(loc=<span class="number">0</span>, scale=<span class="number">0.25</span>,</span><br><span class="line">   .....:                          size=(nwalks, nsteps))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="结论">4.8 结论</h1>
<p>虽然本书剩下的章节大部分是用pandas规整数据，我们还是会用到相似的基于数组的计算。在附录A中，我们会深入挖掘NumPy的特点，进一步学习数组的技巧。</p>
]]></content>
      <categories>
        <category>Python 数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>第06章 数据加载、存储与文件格式</title>
    <url>/2019/04/09/%E7%AC%AC06%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E3%80%81%E5%AD%98%E5%82%A8%E4%B8%8E%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p>访问数据是使用本书所介绍的这些工具的第一步。我会着重介绍pandas的数据输入与输出，虽然别的库中也有不少以此为目的的工具。</p>
<p>输入输出通常可以划分为几个大类：读取文本文件和其他更高效的磁盘存储格式，加载数据库中的数据，利用Web API操作网络资源。<span id="more"></span></p>
<h1 id="读写文本格式的数据">6.1 读写文本格式的数据</h1>
<p>pandas提供了一些用于将表格型数据读取为DataFrame对象的函数。表6-1对它们进行了总结，其中read_csv和read_table可能会是你今后用得最多的。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-958f849e6067b19b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表6-1 pandas中的解析函数" /><figcaption aria-hidden="true">表6-1 pandas中的解析函数</figcaption>
</figure>
<p>我将大致介绍一下这些函数在将文本数据转换为DataFrame时所用到的一些技术。这些函数的选项可以划分为以下几个大类：</p>
<ul>
<li>索引：将一个或多个列当做返回的DataFrame处理，以及是否从文件、用户获取列名。</li>
<li>类型推断和数据转换：包括用户定义值的转换、和自定义的缺失值标记列表等。</li>
<li>日期解析：包括组合功能，比如将分散在多个列中的日期时间信息组合成结果中的单个列。</li>
<li>迭代：支持对大文件进行逐块迭代。</li>
<li>不规整数据问题：跳过一些行、页脚、注释或其他一些不重要的东西（比如由成千上万个逗号隔开的数值数据）。</li>
</ul>
<p>因为工作中实际碰到的数据可能十分混乱，一些数据加载函数（尤其是read_csv）的选项逐渐变得复杂起来。面对不同的参数，感到头痛很正常（read_csv有超过50个参数）。pandas文档有这些参数的例子，如果你感到阅读某个文件很难，可以通过相似的足够多的例子找到正确的参数。</p>
<p>其中一些函数，比如pandas.read_csv，有类型推断功能，因为列数据的类型不属于数据类型。也就是说，你不需要指定列的类型到底是数值、整数、布尔值，还是字符串。其它的数据格式，如HDF5、Feather和msgpack，会在格式中存储数据类型。</p>
<p>日期和其他自定义类型的处理需要多花点工夫才行。首先我们来看一个以逗号分隔的（CSV）文本文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">8</span>]: !cat examples/ex1.csv</span><br><span class="line">a,b,c,d,message</span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,hello</span><br><span class="line"><span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,world</span><br><span class="line"><span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,foo</span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：这里，我用的是Unix的cat shell命令将文件的原始内容打印到屏幕上。如果你用的是Windows，你可以使用type达到同样的效果。</p>
</blockquote>
<p>由于该文件以逗号分隔，所以我们可以使用read_csv将其读入一个DataFrame：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: df = pd.read_csv(<span class="string">&#x27;examples/ex1.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: df</span><br><span class="line">Out[<span class="number">10</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure>
<p>我们还可以使用read_table，并指定分隔符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: pd.read_table(<span class="string">&#x27;examples/ex1.csv&#x27;</span>, sep=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">Out[<span class="number">11</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure>
<p>并不是所有文件都有标题行。看看下面这个文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: !cat examples/ex2.csv</span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,hello</span><br><span class="line"><span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,world</span><br><span class="line"><span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,foo</span><br></pre></td></tr></table></figure>
<p>读入该文件的办法有两个。你可以让pandas为其分配默认的列名，也可以自己定义列名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: pd.read_csv(<span class="string">&#x27;examples/ex2.csv&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line">Out[<span class="number">13</span>]: </span><br><span class="line">   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>      <span class="number">4</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>  hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>  world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>    foo</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: pd.read_csv(<span class="string">&#x27;examples/ex2.csv&#x27;</span>, names=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;message&#x27;</span>])</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure>
<p>假设你希望将message列做成DataFrame的索引。你可以明确表示要将该列放到索引4的位置上，也可以通过index_col参数指定"message"：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: names = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;message&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: pd.read_csv(<span class="string">&#x27;examples/ex2.csv&#x27;</span>, names=names, index_col=<span class="string">&#x27;message&#x27;</span>)</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">         a   b   c   d</span><br><span class="line">message               </span><br><span class="line">hello    <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span></span><br><span class="line">world    <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span></span><br><span class="line">foo      <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>如果希望将多个列做成一个层次化索引，只需传入由列编号或列名组成的列表即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: !cat examples/csv_mindex.csv</span><br><span class="line">key1,key2,value1,value2</span><br><span class="line">one,a,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">one,b,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">one,c,<span class="number">5</span>,<span class="number">6</span></span><br><span class="line">one,d,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">two,a,<span class="number">9</span>,<span class="number">10</span></span><br><span class="line">two,b,<span class="number">11</span>,<span class="number">12</span></span><br><span class="line">two,c,<span class="number">13</span>,<span class="number">14</span></span><br><span class="line">two,d,<span class="number">15</span>,<span class="number">16</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: parsed = pd.read_csv(<span class="string">&#x27;examples/csv_mindex.csv&#x27;</span>,</span><br><span class="line">   ....:                      index_col=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: parsed</span><br><span class="line">Out[<span class="number">19</span>]: </span><br><span class="line">           value1  value2</span><br><span class="line">key1 key2                </span><br><span class="line">one  a          <span class="number">1</span>       <span class="number">2</span></span><br><span class="line">     b          <span class="number">3</span>       <span class="number">4</span></span><br><span class="line">     c          <span class="number">5</span>       <span class="number">6</span></span><br><span class="line">     d          <span class="number">7</span>       <span class="number">8</span></span><br><span class="line">two  a          <span class="number">9</span>      <span class="number">10</span></span><br><span class="line">     b         <span class="number">11</span>      <span class="number">12</span></span><br><span class="line">     c         <span class="number">13</span>      <span class="number">14</span></span><br><span class="line">     d         <span class="number">15</span>      <span class="number">16</span></span><br></pre></td></tr></table></figure>
<p>有些情况下，有些表格可能不是用固定的分隔符去分隔字段的（比如空白符或其它模式）。看看下面这个文本文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: <span class="built_in">list</span>(<span class="built_in">open</span>(<span class="string">&#x27;examples/ex3.txt&#x27;</span>))</span><br><span class="line">Out[<span class="number">20</span>]: </span><br><span class="line">[<span class="string">&#x27;            A         B         C\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;aaa -0.264438 -1.026059 -0.619500\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;bbb  0.927272  0.302904 -0.032399\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ccc -0.264273 -0.386314 -0.217601\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ddd -0.871858 -0.348382  1.100491\n&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>虽然可以手动对数据进行规整，这里的字段是被数量不同的空白字符间隔开的。这种情况下，你可以传递一个正则表达式作为read_table的分隔符。可以用正则表达式表达为+，于是有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: result = pd.read_table(<span class="string">&#x27;examples/ex3.txt&#x27;</span>, sep=<span class="string">&#x27;\s+&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: result</span><br><span class="line">Out[<span class="number">22</span>]: </span><br><span class="line">            A         B         C</span><br><span class="line">aaa -<span class="number">0.264438</span> -<span class="number">1.026059</span> -<span class="number">0.619500</span></span><br><span class="line">bbb  <span class="number">0.927272</span>  <span class="number">0.302904</span> -<span class="number">0.032399</span></span><br><span class="line">ccc -<span class="number">0.264273</span> -<span class="number">0.386314</span> -<span class="number">0.217601</span></span><br><span class="line">ddd -<span class="number">0.871858</span> -<span class="number">0.348382</span>  <span class="number">1.100491</span></span><br></pre></td></tr></table></figure>
<p>这里，由于列名比数据行的数量少，所以read_table推断第一列应该是DataFrame的索引。</p>
<p>这些解析器函数还有许多参数可以帮助你处理各种各样的异形文件格式（表6-2列出了一些）。比如说，你可以用skiprows跳过文件的第一行、第三行和第四行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">23</span>]: !cat examples/ex4.csv</span><br><span class="line"><span class="comment"># hey!</span></span><br><span class="line">a,b,c,d,message</span><br><span class="line"><span class="comment"># just wanted to make things more difficult for you</span></span><br><span class="line"><span class="comment"># who reads CSV files with computers, anyway?</span></span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,hello</span><br><span class="line"><span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,world</span><br><span class="line"><span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,foo</span><br><span class="line">In [<span class="number">24</span>]: pd.read_csv(<span class="string">&#x27;examples/ex4.csv&#x27;</span>, skiprows=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">Out[<span class="number">24</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure>
<p>缺失值处理是文件解析任务中的一个重要组成部分。缺失数据经常是要么没有（空字符串），要么用某个标记值表示。默认情况下，pandas会用一组经常出现的标记值进行识别，比如NA及NULL：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: !cat examples/ex5.csv</span><br><span class="line">something,a,b,c,d,message</span><br><span class="line">one,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,NA</span><br><span class="line">two,<span class="number">5</span>,<span class="number">6</span>,,<span class="number">8</span>,world</span><br><span class="line">three,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,foo</span><br><span class="line">In [<span class="number">26</span>]: result = pd.read_csv(<span class="string">&#x27;examples/ex5.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: result</span><br><span class="line">Out[<span class="number">27</span>]: </span><br><span class="line">  something  a   b     c   d message</span><br><span class="line"><span class="number">0</span>       one  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3.0</span>   <span class="number">4</span>     NaN</span><br><span class="line"><span class="number">1</span>       two  <span class="number">5</span>   <span class="number">6</span>   NaN   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>     three  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11.0</span>  <span class="number">12</span>     foo</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: pd.isnull(result)</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">   something      a      b      c      d  message</span><br><span class="line"><span class="number">0</span>      <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">1</span>      <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>   <span class="literal">True</span>  <span class="literal">False</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>      <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>    <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>na_values可以用一个列表或集合的字符串表示缺失值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">29</span>]: result = pd.read_csv(<span class="string">&#x27;examples/ex5.csv&#x27;</span>, na_values=[<span class="string">&#x27;NULL&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: result</span><br><span class="line">Out[<span class="number">30</span>]: </span><br><span class="line">  something  a   b     c   d message</span><br><span class="line"><span class="number">0</span>       one  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3.0</span>   <span class="number">4</span>     NaN</span><br><span class="line"><span class="number">1</span>       two  <span class="number">5</span>   <span class="number">6</span>   NaN   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>     three  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11.0</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure>
<p>字典的各列可以使用不同的NA标记值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">31</span>]: sentinels = &#123;<span class="string">&#x27;message&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;NA&#x27;</span>], <span class="string">&#x27;something&#x27;</span>: [<span class="string">&#x27;two&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: pd.read_csv(<span class="string">&#x27;examples/ex5.csv&#x27;</span>, na_values=sentinels)</span><br><span class="line">Out[<span class="number">32</span>]:</span><br><span class="line">something  a   b     c   d message</span><br><span class="line"><span class="number">0</span>       one  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3.0</span>   <span class="number">4</span>     NaN</span><br><span class="line"><span class="number">1</span>       NaN  <span class="number">5</span>   <span class="number">6</span>   NaN   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>     three  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11.0</span>  <span class="number">12</span>     NaN</span><br></pre></td></tr></table></figure>
<p>表6-2列出了pandas.read_csv和pandas.read_table常用的选项。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-082daf4a00ed9494.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-f2bcc0a703c7236f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-597327ade3e94c7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<h2 id="逐块读取文本文件">逐块读取文本文件</h2>
<p>在处理很大的文件时，或找出大文件中的参数集以便于后续处理时，你可能只想读取文件的一小部分或逐块对文件进行迭代。</p>
<p>在看大文件之前，我们先设置pandas显示地更紧些：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">33</span>]: pd.options.display.max_rows = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>然后有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">34</span>]: result = pd.read_csv(<span class="string">&#x27;examples/ex6.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: result</span><br><span class="line">Out[<span class="number">35</span>]: </span><br><span class="line">           one       two     three      four key</span><br><span class="line"><span class="number">0</span>     <span class="number">0.467976</span> -<span class="number">0.038649</span> -<span class="number">0.295344</span> -<span class="number">1.824726</span>   L</span><br><span class="line"><span class="number">1</span>    -<span class="number">0.358893</span>  <span class="number">1.404453</span>  <span class="number">0.704965</span> -<span class="number">0.200638</span>   B</span><br><span class="line"><span class="number">2</span>    -<span class="number">0.501840</span>  <span class="number">0.659254</span> -<span class="number">0.421691</span> -<span class="number">0.057688</span>   G</span><br><span class="line"><span class="number">3</span>     <span class="number">0.204886</span>  <span class="number">1.074134</span>  <span class="number">1.388361</span> -<span class="number">0.982404</span>   R</span><br><span class="line"><span class="number">4</span>     <span class="number">0.354628</span> -<span class="number">0.133116</span>  <span class="number">0.283763</span> -<span class="number">0.837063</span>   Q</span><br><span class="line"><span class="meta">... </span>       ...       ...       ...       ...  ..</span><br><span class="line"><span class="number">9995</span>  <span class="number">2.311896</span> -<span class="number">0.417070</span> -<span class="number">1.409599</span> -<span class="number">0.515821</span>   L</span><br><span class="line"><span class="number">9996</span> -<span class="number">0.479893</span> -<span class="number">0.650419</span>  <span class="number">0.745152</span> -<span class="number">0.646038</span>   E</span><br><span class="line"><span class="number">9997</span>  <span class="number">0.523331</span>  <span class="number">0.787112</span>  <span class="number">0.486066</span>  <span class="number">1.093156</span>   K</span><br><span class="line"><span class="number">9998</span> -<span class="number">0.362559</span>  <span class="number">0.598894</span> -<span class="number">1.843201</span>  <span class="number">0.887292</span>   G</span><br><span class="line"><span class="number">9999</span> -<span class="number">0.096376</span> -<span class="number">1.012999</span> -<span class="number">0.657431</span> -<span class="number">0.573315</span>   <span class="number">0</span></span><br><span class="line">[<span class="number">10000</span> rows x <span class="number">5</span> columns]</span><br><span class="line">If you want to only read a small</span><br></pre></td></tr></table></figure>
<p>如果只想读取几行（避免读取整个文件），通过nrows进行指定即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">36</span>]: pd.read_csv(<span class="string">&#x27;examples/ex6.csv&#x27;</span>, nrows=<span class="number">5</span>)</span><br><span class="line">Out[<span class="number">36</span>]: </span><br><span class="line">        one       two     three      four key</span><br><span class="line"><span class="number">0</span>  <span class="number">0.467976</span> -<span class="number">0.038649</span> -<span class="number">0.295344</span> -<span class="number">1.824726</span>   L</span><br><span class="line"><span class="number">1</span> -<span class="number">0.358893</span>  <span class="number">1.404453</span>  <span class="number">0.704965</span> -<span class="number">0.200638</span>   B</span><br><span class="line"><span class="number">2</span> -<span class="number">0.501840</span>  <span class="number">0.659254</span> -<span class="number">0.421691</span> -<span class="number">0.057688</span>   G</span><br><span class="line"><span class="number">3</span>  <span class="number">0.204886</span>  <span class="number">1.074134</span>  <span class="number">1.388361</span> -<span class="number">0.982404</span>   R</span><br><span class="line"><span class="number">4</span>  <span class="number">0.354628</span> -<span class="number">0.133116</span>  <span class="number">0.283763</span> -<span class="number">0.837063</span>   Q</span><br></pre></td></tr></table></figure>
<p>要逐块读取文件，可以指定chunksize（行数）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">874</span>]: chunker = pd.read_csv(<span class="string">&#x27;ch06/ex6.csv&#x27;</span>, chunksize=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">875</span>]: chunker</span><br><span class="line">Out[<span class="number">875</span>]: &lt;pandas.io.parsers.TextParser at <span class="number">0x8398150</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>read_csv所返回的这个TextParser对象使你可以根据chunksize对文件进行逐块迭代。比如说，我们可以迭代处理ex6.csv，将值计数聚合到"key"列中，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chunker = pd.read_csv(<span class="string">&#x27;examples/ex6.csv&#x27;</span>, chunksize=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">tot = pd.Series([])</span><br><span class="line"><span class="keyword">for</span> piece <span class="keyword">in</span> chunker:</span><br><span class="line">    tot = tot.add(piece[<span class="string">&#x27;key&#x27;</span>].value_counts(), fill_value=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">tot = tot.sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">40</span>]: tot[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">E    <span class="number">368.0</span></span><br><span class="line">X    <span class="number">364.0</span></span><br><span class="line">L    <span class="number">346.0</span></span><br><span class="line">O    <span class="number">343.0</span></span><br><span class="line">Q    <span class="number">340.0</span></span><br><span class="line">M    <span class="number">338.0</span></span><br><span class="line">J    <span class="number">337.0</span></span><br><span class="line">F    <span class="number">335.0</span></span><br><span class="line">K    <span class="number">334.0</span></span><br><span class="line">H    <span class="number">330.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>TextParser还有一个get_chunk方法，它使你可以读取任意大小的块。</p>
<h2 id="将数据写出到文本格式">将数据写出到文本格式</h2>
<p>数据也可以被输出为分隔符格式的文本。我们再来看看之前读过的一个CSV文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: data = pd.read_csv(<span class="string">&#x27;examples/ex5.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: data</span><br><span class="line">Out[<span class="number">42</span>]: </span><br><span class="line">  something  a   b     c   d message</span><br><span class="line"><span class="number">0</span>       one  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3.0</span>   <span class="number">4</span>     NaN</span><br><span class="line"><span class="number">1</span>       two  <span class="number">5</span>   <span class="number">6</span>   NaN   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>     three  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11.0</span>  <span class="number">12</span>     foo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>利用DataFrame的to_csv方法，我们可以将数据写到一个以逗号分隔的文件中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">43</span>]: data.to_csv(<span class="string">&#x27;examples/out.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: !cat examples/out.csv</span><br><span class="line">,something,a,b,c,d,message</span><br><span class="line"><span class="number">0</span>,one,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3.0</span>,<span class="number">4</span>,</span><br><span class="line"><span class="number">1</span>,two,<span class="number">5</span>,<span class="number">6</span>,,<span class="number">8</span>,world</span><br><span class="line"><span class="number">2</span>,three,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11.0</span>,<span class="number">12</span>,foo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然，还可以使用其他分隔符（由于这里直接写出到sys.stdout，所以仅仅是打印出文本结果而已）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">45</span>]: <span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: data.to_csv(sys.stdout, sep=<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">|something|a|b|c|d|message</span><br><span class="line"><span class="number">0</span>|one|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3.0</span>|<span class="number">4</span>|</span><br><span class="line"><span class="number">1</span>|two|<span class="number">5</span>|<span class="number">6</span>||<span class="number">8</span>|world</span><br><span class="line"><span class="number">2</span>|three|<span class="number">9</span>|<span class="number">10</span>|<span class="number">11.0</span>|<span class="number">12</span>|foo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>缺失值在输出结果中会被表示为空字符串。你可能希望将其表示为别的标记值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">47</span>]: data.to_csv(sys.stdout, na_rep=<span class="string">&#x27;NULL&#x27;</span>)</span><br><span class="line">,something,a,b,c,d,message</span><br><span class="line"><span class="number">0</span>,one,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3.0</span>,<span class="number">4</span>,NULL</span><br><span class="line"><span class="number">1</span>,two,<span class="number">5</span>,<span class="number">6</span>,NULL,<span class="number">8</span>,world</span><br><span class="line"><span class="number">2</span>,three,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11.0</span>,<span class="number">12</span>,foo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果没有设置其他选项，则会写出行和列的标签。当然，它们也都可以被禁用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">48</span>]: data.to_csv(sys.stdout, index=<span class="literal">False</span>, header=<span class="literal">False</span>)</span><br><span class="line">one,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3.0</span>,<span class="number">4</span>,</span><br><span class="line">two,<span class="number">5</span>,<span class="number">6</span>,,<span class="number">8</span>,world</span><br><span class="line">three,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11.0</span>,<span class="number">12</span>,foo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此外，你还可以只写出一部分的列，并以你指定的顺序排列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">49</span>]: data.to_csv(sys.stdout, index=<span class="literal">False</span>, columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">a,b,c</span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3.0</span></span><br><span class="line"><span class="number">5</span>,<span class="number">6</span>,</span><br><span class="line"><span class="number">9</span>,<span class="number">10</span>,<span class="number">11.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Series也有一个to_csv方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">50</span>]: dates = pd.date_range(<span class="string">&#x27;1/1/2000&#x27;</span>, periods=<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: ts = pd.Series(np.arange(<span class="number">7</span>), index=dates)</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: ts.to_csv(<span class="string">&#x27;examples/tseries.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: !cat examples/tseries.csv</span><br><span class="line"><span class="number">2000</span>-01-01,<span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-02,<span class="number">1</span></span><br><span class="line"><span class="number">2000</span>-01-03,<span class="number">2</span></span><br><span class="line"><span class="number">2000</span>-01-04,<span class="number">3</span></span><br><span class="line"><span class="number">2000</span>-01-05,<span class="number">4</span></span><br><span class="line"><span class="number">2000</span>-01-06,<span class="number">5</span></span><br><span class="line"><span class="number">2000</span>-01-07,<span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="处理分隔符格式">处理分隔符格式</h2>
<p>大部分存储在磁盘上的表格型数据都能用pandas.read_table进行加载。然而，有时还是需要做一些手工处理。由于接收到含有畸形行的文件而使read_table出毛病的情况并不少见。为了说明这些基本工具，看看下面这个简单的CSV文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">54</span>]: !cat examples/ex7.csv</span><br><span class="line"><span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于任何单字符分隔符文件，可以直接使用Python内置的csv模块。将任意已打开的文件或文件型的对象传给csv.reader：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;examples/ex7.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">reader = csv.reader(f)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对这个reader进行迭代将会为每行产生一个元组（并移除了所有的引号）：对这个reader进行迭代将会为每行产生一个元组（并移除了所有的引号）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: <span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">   ....:     <span class="built_in">print</span>(line)</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，为了使数据格式合乎要求，你需要对其做一些整理工作。我们一步一步来做。首先，读取文件到一个多行的列表中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">57</span>]: <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;examples/ex7.csv&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">   ....:     lines = <span class="built_in">list</span>(csv.reader(f))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，我们将这些行分为标题行和数据行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">58</span>]: header, values = lines[<span class="number">0</span>], lines[<span class="number">1</span>:]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，我们可以用字典构造式和zip(*values)，后者将行转置为列，创建数据列的字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">59</span>]: data_dict = &#123;h: v <span class="keyword">for</span> h, v <span class="keyword">in</span> <span class="built_in">zip</span>(header, <span class="built_in">zip</span>(*values))&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: data_dict</span><br><span class="line">Out[<span class="number">60</span>]: &#123;<span class="string">&#x27;a&#x27;</span>: (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>), <span class="string">&#x27;b&#x27;</span>: (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;2&#x27;</span>), <span class="string">&#x27;c&#x27;</span>: (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>CSV文件的形式有很多。只需定义csv.Dialect的一个子类即可定义出新格式（如专门的分隔符、字符串引用约定、行结束符等）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_dialect</span>(<span class="params">csv.Dialect</span>):</span></span><br><span class="line">    lineterminator = <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    delimiter = <span class="string">&#x27;;&#x27;</span></span><br><span class="line">    quotechar = <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">    quoting = csv.QUOTE_MINIMAL</span><br><span class="line">reader = csv.reader(f, dialect=my_dialect)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>各个CSV语支的参数也可以用关键字的形式提供给csv.reader，而无需定义子类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reader = csv.reader(f, delimiter=<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可用的选项（csv.Dialect的属性）及其功能如表6-3所示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-7a1cee622459072b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<blockquote>
<p>笔记：对于那些使用复杂分隔符或多字符分隔符的文件，csv模块就无能为力了。这种情况下，你就只能使用字符串的split方法或正则表达式方法re.split进行行拆分和其他整理工作了。</p>
</blockquote>
<p>要手工输出分隔符文件，你可以使用csv.writer。它接受一个已打开且可写的文件对象以及跟csv.reader相同的那些语支和格式化选项：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;mydata.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    writer = csv.writer(f, dialect=my_dialect)</span><br><span class="line">    writer.writerow((<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>))</span><br><span class="line">    writer.writerow((<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>))</span><br><span class="line">    writer.writerow((<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>))</span><br><span class="line">    writer.writerow((<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="json数据">JSON数据</h2>
<p>JSON（JavaScript Object Notation的简称）已经成为通过HTTP请求在Web浏览器和其他应用程序之间发送数据的标准格式之一。它是一种比表格型文本格式（如CSV）灵活得多的数据格式。下面是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&quot;name&quot;: &quot;Wes&quot;,</span></span><br><span class="line"><span class="string"> &quot;places_lived&quot;: [&quot;United States&quot;, &quot;Spain&quot;, &quot;Germany&quot;],</span></span><br><span class="line"><span class="string"> &quot;pet&quot;: null,</span></span><br><span class="line"><span class="string"> &quot;siblings&quot;: [&#123;&quot;name&quot;: &quot;Scott&quot;, &quot;age&quot;: 30, &quot;pets&quot;: [&quot;Zeus&quot;, &quot;Zuko&quot;]&#125;,</span></span><br><span class="line"><span class="string">              &#123;&quot;name&quot;: &quot;Katie&quot;, &quot;age&quot;: 38,</span></span><br><span class="line"><span class="string">               &quot;pets&quot;: [&quot;Sixes&quot;, &quot;Stache&quot;, &quot;Cisco&quot;]&#125;]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>除其空值null和一些其他的细微差别（如列表末尾不允许存在多余的逗号）之外，JSON非常接近于有效的Python代码。基本类型有对象（字典）、数组（列表）、字符串、数值、布尔值以及null。对象中所有的键都必须是字符串。许多Python库都可以读写JSON数据。我将使用json，因为它是构建于Python标准库中的。通过json.loads即可将JSON字符串转换成Python形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">62</span>]: <span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: result = json.loads(obj)</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: result</span><br><span class="line">Out[<span class="number">64</span>]: </span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Wes&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;pet&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">&#x27;places_lived&#x27;</span>: [<span class="string">&#x27;United States&#x27;</span>, <span class="string">&#x27;Spain&#x27;</span>, <span class="string">&#x27;Germany&#x27;</span>],</span><br><span class="line"> <span class="string">&#x27;siblings&#x27;</span>: [&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">30</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Scott&#x27;</span>, <span class="string">&#x27;pets&#x27;</span>: [<span class="string">&#x27;Zeus&#x27;</span>, <span class="string">&#x27;Zuko&#x27;</span>]&#125;,</span><br><span class="line">  &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">38</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Katie&#x27;</span>, <span class="string">&#x27;pets&#x27;</span>: [<span class="string">&#x27;Sixes&#x27;</span>, <span class="string">&#x27;Stache&#x27;</span>, <span class="string">&#x27;Cisco&#x27;</span>]&#125;]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>json.dumps则将Python对象转换成JSON格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">65</span>]: asjson = json.dumps(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如何将（一个或一组）JSON对象转换为DataFrame或其他便于分析的数据结构就由你决定了。最简单方便的方式是：向DataFrame构造器传入一个字典的列表（就是原先的JSON对象），并选取数据字段的子集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">66</span>]: siblings = pd.DataFrame(result[<span class="string">&#x27;siblings&#x27;</span>], columns=[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: siblings</span><br><span class="line">Out[<span class="number">67</span>]: </span><br><span class="line">    name  age</span><br><span class="line"><span class="number">0</span>  Scott   <span class="number">30</span></span><br><span class="line"><span class="number">1</span>  Katie   <span class="number">38</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>pandas.read_json可以自动将特别格式的JSON数据集转换为Series或DataFrame。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">68</span>]: !cat examples/example.json</span><br><span class="line">[&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&quot;a&quot;</span>: <span class="number">4</span>, <span class="string">&quot;b&quot;</span>: <span class="number">5</span>, <span class="string">&quot;c&quot;</span>: <span class="number">6</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&quot;a&quot;</span>: <span class="number">7</span>, <span class="string">&quot;b&quot;</span>: <span class="number">8</span>, <span class="string">&quot;c&quot;</span>: <span class="number">9</span>&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>pandas.read_json的默认选项假设JSON数组中的每个对象是表格中的一行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">69</span>]: data = pd.read_json(<span class="string">&#x27;examples/example.json&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: data</span><br><span class="line">Out[<span class="number">70</span>]: </span><br><span class="line">   a  b  c</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></span><br><span class="line"><span class="number">2</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第7章中关于USDA Food Database的那个例子进一步讲解了JSON数据的读取和处理（包括嵌套记录）。</p>
<p>如果你需要将数据从pandas输出到JSON，可以使用to_json方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">71</span>]: <span class="built_in">print</span>(data.to_json())</span><br><span class="line">&#123;<span class="string">&quot;a&quot;</span>:&#123;<span class="string">&quot;0&quot;</span>:<span class="number">1</span>,<span class="string">&quot;1&quot;</span>:<span class="number">4</span>,<span class="string">&quot;2&quot;</span>:<span class="number">7</span>&#125;,<span class="string">&quot;b&quot;</span>:&#123;<span class="string">&quot;0&quot;</span>:<span class="number">2</span>,<span class="string">&quot;1&quot;</span>:<span class="number">5</span>,<span class="string">&quot;2&quot;</span>:<span class="number">8</span>&#125;,<span class="string">&quot;c&quot;</span>:&#123;<span class="string">&quot;0&quot;</span>:<span class="number">3</span>,<span class="string">&quot;1&quot;</span>:<span class="number">6</span>,<span class="string">&quot;2&quot;</span>:<span class="number">9</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: <span class="built_in">print</span>(data.to_json(orient=<span class="string">&#x27;records&#x27;</span>))</span><br><span class="line">[&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>,<span class="string">&quot;b&quot;</span>:<span class="number">2</span>,<span class="string">&quot;c&quot;</span>:<span class="number">3</span>&#125;,&#123;<span class="string">&quot;a&quot;</span>:<span class="number">4</span>,<span class="string">&quot;b&quot;</span>:<span class="number">5</span>,<span class="string">&quot;c&quot;</span>:<span class="number">6</span>&#125;,&#123;<span class="string">&quot;a&quot;</span>:<span class="number">7</span>,<span class="string">&quot;b&quot;</span>:<span class="number">8</span>,<span class="string">&quot;c&quot;</span>:<span class="number">9</span>&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="xml和htmlweb信息收集">XML和HTML：Web信息收集</h2>
<p>Python有许多可以读写常见的HTML和XML格式数据的库，包括lxml、Beautiful Soup和html5lib。lxml的速度比较快，但其它的库处理有误的HTML或XML文件更好。</p>
<p>pandas有一个内置的功能，read_html，它可以使用lxml和Beautiful Soup自动将HTML文件中的表格解析为DataFrame对象。为了进行展示，我从美国联邦存款保险公司下载了一个HTML文件（pandas文档中也使用过），它记录了银行倒闭的情况。首先，你需要安装read_html用到的库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install lxml</span><br><span class="line">pip install beautifulsoup4 html5lib</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你用的不是conda，可以使用<code>pip install lxml</code>。</p>
pandas.read_html有一些选项，默认条件下，它会搜索、尝试解析
<table>
<p>标签内的的表格数据。结果是一个列表的DataFrame对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">73</span>]: tables = pd.read_html(<span class="string">&#x27;examples/fdic_failed_bank_list.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">74</span>]: <span class="built_in">len</span>(tables)</span><br><span class="line">Out[<span class="number">74</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: failures = tables[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: failures.head()</span><br><span class="line">Out[<span class="number">76</span>]: </span><br><span class="line">                      Bank Name             City  ST   CERT  \</span><br><span class="line"><span class="number">0</span>                   Allied Bank         Mulberry  AR     <span class="number">91</span>   </span><br><span class="line"><span class="number">1</span>  The Woodbury Banking Company         Woodbury  GA  <span class="number">11297</span>   </span><br><span class="line"><span class="number">2</span>        First CornerStone Bank  King of Prussia  PA  <span class="number">35312</span>   </span><br><span class="line"><span class="number">3</span>            Trust Company Bank          Memphis  TN   <span class="number">9956</span>   </span><br><span class="line"><span class="number">4</span>    North Milwaukee State Bank        Milwaukee  WI  <span class="number">20364</span>   </span><br><span class="line">                 Acquiring Institution        Closing Date       Updated Date  </span><br><span class="line"><span class="number">0</span>                         Today<span class="string">&#x27;s Bank  September 23, 2016  November 17, 2016  </span></span><br><span class="line"><span class="string">1                          United Bank     August 19, 2016  November 17, 2016  </span></span><br><span class="line"><span class="string">2  First-Citizens Bank &amp; Trust Company         May 6, 2016  September 6, 2016  </span></span><br><span class="line"><span class="string">3           The Bank of Fayette County      April 29, 2016  September 6, 2016  </span></span><br><span class="line"><span class="string">4  First-Citizens Bank &amp; Trust Company      March 11, 2016      June 16, 2016</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>因为failures有许多列，pandas插入了一个换行符。</p>
<p>这里，我们可以做一些数据清洗和分析（后面章节会进一步讲解），比如计算按年份计算倒闭的银行数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">77</span>]: close_timestamps = pd.to_datetime(failures[<span class="string">&#x27;Closing Date&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: close_timestamps.dt.year.value_counts()</span><br><span class="line">Out[<span class="number">78</span>]: </span><br><span class="line"><span class="number">2010</span>    <span class="number">157</span></span><br><span class="line"><span class="number">2009</span>    <span class="number">140</span></span><br><span class="line"><span class="number">2011</span>     <span class="number">92</span></span><br><span class="line"><span class="number">2012</span>     <span class="number">51</span></span><br><span class="line"><span class="number">2008</span>     <span class="number">25</span></span><br><span class="line">       ... </span><br><span class="line"><span class="number">2004</span>      <span class="number">4</span></span><br><span class="line"><span class="number">2001</span>      <span class="number">4</span></span><br><span class="line"><span class="number">2007</span>      <span class="number">3</span></span><br><span class="line"><span class="number">2003</span>      <span class="number">3</span></span><br><span class="line"><span class="number">2000</span>      <span class="number">2</span></span><br><span class="line">Name: Closing Date, Length: <span class="number">15</span>, dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="利用lxml.objectify解析xml">利用lxml.objectify解析XML</h2>
<p>XML（Extensible Markup Language）是另一种常见的支持分层、嵌套数据以及元数据的结构化数据格式。本书所使用的这些文件实际上来自于一个很大的XML文档。</p>
<p>前面，我介绍了pandas.read_html函数，它可以使用lxml或Beautiful Soup从HTML解析数据。XML和HTML的结构很相似，但XML更为通用。这里，我会用一个例子演示如何利用lxml从XML格式解析数据。</p>
<p>纽约大都会运输署发布了一些有关其公交和列车服务的数据资料（http://www.mta.info/developers/download.html）。这里，我们将看看包含在一组XML文件中的运行情况数据。每项列车或公交服务都有各自的文件（如Metro-North Railroad的文件是Performance_MNR.xml），其中每条XML记录就是一条月度数据，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">INDICATOR</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">INDICATOR_SEQ</span>&gt;</span>373889<span class="tag">&lt;/<span class="name">INDICATOR_SEQ</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PARENT_SEQ</span>&gt;</span><span class="tag">&lt;/<span class="name">PARENT_SEQ</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">AGENCY_NAME</span>&gt;</span>Metro-North Railroad<span class="tag">&lt;/<span class="name">AGENCY_NAME</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">INDICATOR_NAME</span>&gt;</span>Escalator Availability<span class="tag">&lt;/<span class="name">INDICATOR_NAME</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">DESCRIPTION</span>&gt;</span>Percent of the time that escalators are operational</span><br><span class="line">  systemwide. The availability rate is based on physical observations performed</span><br><span class="line">  the morning of regular business days only. This is a new indicator the agency</span><br><span class="line">  began reporting in 2009.<span class="tag">&lt;/<span class="name">DESCRIPTION</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PERIOD_YEAR</span>&gt;</span>2011<span class="tag">&lt;/<span class="name">PERIOD_YEAR</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PERIOD_MONTH</span>&gt;</span>12<span class="tag">&lt;/<span class="name">PERIOD_MONTH</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">CATEGORY</span>&gt;</span>Service Indicators<span class="tag">&lt;/<span class="name">CATEGORY</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">FREQUENCY</span>&gt;</span>M<span class="tag">&lt;/<span class="name">FREQUENCY</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">DESIRED_CHANGE</span>&gt;</span>U<span class="tag">&lt;/<span class="name">DESIRED_CHANGE</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">INDICATOR_UNIT</span>&gt;</span>%<span class="tag">&lt;/<span class="name">INDICATOR_UNIT</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">DECIMAL_PLACES</span>&gt;</span>1<span class="tag">&lt;/<span class="name">DECIMAL_PLACES</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">YTD_TARGET</span>&gt;</span>97.00<span class="tag">&lt;/<span class="name">YTD_TARGET</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">YTD_ACTUAL</span>&gt;</span><span class="tag">&lt;/<span class="name">YTD_ACTUAL</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MONTHLY_TARGET</span>&gt;</span>97.00<span class="tag">&lt;/<span class="name">MONTHLY_TARGET</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MONTHLY_ACTUAL</span>&gt;</span><span class="tag">&lt;/<span class="name">MONTHLY_ACTUAL</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">INDICATOR</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们先用lxml.objectify解析该文件，然后通过getroot得到该XML文件的根节点的引用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> objectify</span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;datasets/mta_perf/Performance_MNR.xml&#x27;</span></span><br><span class="line">parsed = objectify.parse(<span class="built_in">open</span>(path))</span><br><span class="line">root = parsed.getroot()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>root.INDICATOR返回一个用于产生各个<INDICATOR>XML元素的生成器。对于每条记录，我们可以用标记名（如YTD_ACTUAL）和数据值填充一个字典（排除几个标记）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = []</span><br><span class="line"></span><br><span class="line">skip_fields = [<span class="string">&#x27;PARENT_SEQ&#x27;</span>, <span class="string">&#x27;INDICATOR_SEQ&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;DESIRED_CHANGE&#x27;</span>, <span class="string">&#x27;DECIMAL_PLACES&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> elt <span class="keyword">in</span> root.INDICATOR:</span><br><span class="line">    el_data = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> elt.getchildren():</span><br><span class="line">        <span class="keyword">if</span> child.tag <span class="keyword">in</span> skip_fields:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        el_data[child.tag] = child.pyval</span><br><span class="line">    data.append(el_data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后，将这组字典转换为一个DataFrame：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">81</span>]: perf = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">82</span>]: perf.head()</span><br><span class="line">Out[<span class="number">82</span>]:</span><br><span class="line">Empty DataFrame</span><br><span class="line">Columns: []</span><br><span class="line">Index: []</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>XML数据可以比本例复杂得多。每个标记都可以有元数据。看看下面这个HTML的链接标签（它也算是一段有效的XML）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line">tag = <span class="string">&#x27;&lt;a href=&quot;http://www.google.com&quot;&gt;Google&lt;/a&gt;&#x27;</span></span><br><span class="line">root = objectify.parse(StringIO(tag)).getroot()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在就可以访问标签或链接文本中的任何字段了（如href）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">84</span>]: root</span><br><span class="line">Out[<span class="number">84</span>]: &lt;Element a at <span class="number">0x7f6b15817748</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">85</span>]: root.get(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">Out[<span class="number">85</span>]: <span class="string">&#x27;http://www.google.com&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: root.text</span><br><span class="line">Out[<span class="number">86</span>]: <span class="string">&#x27;Google&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="二进制数据格式">6.2 二进制数据格式</h1>
<p>实现数据的高效二进制格式存储最简单的办法之一是使用Python内置的pickle序列化。pandas对象都有一个用于将数据以pickle格式保存到磁盘上的to_pickle方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">87</span>]: frame = pd.read_csv(<span class="string">&#x27;examples/ex1.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: frame</span><br><span class="line">Out[<span class="number">88</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: frame.to_pickle(<span class="string">&#x27;examples/frame_pickle&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可以通过pickle直接读取被pickle化的数据，或是使用更为方便的pandas.read_pickle：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">90</span>]: pd.read_pickle(<span class="string">&#x27;examples/frame_pickle&#x27;</span>)</span><br><span class="line">Out[<span class="number">90</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：pickle仅建议用于短期存储格式。其原因是很难保证该格式永远是稳定的；今天pickle的对象可能无法被后续版本的库unpickle出来。虽然我尽力保证这种事情不会发生在pandas中，但是今后的某个时候说不定还是得“打破”该pickle格式。</p>
</blockquote>
<p>pandas内置支持两个二进制数据格式：HDF5和MessagePack。下一节，我会给出几个HDF5的例子，但我建议你尝试下不同的文件格式，看看它们的速度以及是否适合你的分析工作。pandas或NumPy数据的其它存储格式有：</p>
<ul>
<li>bcolz：一种可压缩的列存储二进制格式，基于Blosc压缩库。</li>
<li>Feather：我与R语言社区的Hadley Wickham设计的一种跨语言的列存储文件格式。Feather使用了Apache Arrow的列式内存格式。</li>
</ul>
<h2 id="使用hdf5格式">使用HDF5格式</h2>
<p>HDF5是一种存储大规模科学数组数据的非常好的文件格式。它可以被作为C标准库，带有许多语言的接口，如Java、Python和MATLAB等。HDF5中的HDF指的是层次型数据格式（hierarchical data format）。每个HDF5文件都含有一个文件系统式的节点结构，它使你能够存储多个数据集并支持元数据。与其他简单格式相比，HDF5支持多种压缩器的即时压缩，还能更高效地存储重复模式数据。对于那些非常大的无法直接放入内存的数据集，HDF5就是不错的选择，因为它可以高效地分块读写。</p>
<p>虽然可以用PyTables或h5py库直接访问HDF5文件，pandas提供了更为高级的接口，可以简化存储Series和DataFrame对象。HDFStore类可以像字典一样，处理低级的细节：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">92</span>]: frame = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: np.random.randn(<span class="number">100</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">93</span>]: store = pd.HDFStore(<span class="string">&#x27;mydata.h5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: store[<span class="string">&#x27;obj1&#x27;</span>] = frame</span><br><span class="line"></span><br><span class="line">In [<span class="number">95</span>]: store[<span class="string">&#x27;obj1_col&#x27;</span>] = frame[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">96</span>]: store</span><br><span class="line">Out[<span class="number">96</span>]: </span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">pandas</span>.<span class="title">io</span>.<span class="title">pytables</span>.<span class="title">HDFStore</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">File</span> <span class="title">path</span>:</span> mydata.h5</span><br><span class="line">/obj1                frame        (shape-&gt;[<span class="number">100</span>,<span class="number">1</span>])                               </span><br><span class="line">        </span><br><span class="line">/obj1_col            series       (shape-&gt;[<span class="number">100</span>])                                 </span><br><span class="line">        </span><br><span class="line">/obj2                frame_table  (typ-&gt;appendable,nrows-&gt;<span class="number">100</span>,ncols-&gt;<span class="number">1</span>,indexers-&gt;</span><br><span class="line">[index])</span><br><span class="line">/obj3                frame_table  (typ-&gt;appendable,nrows-&gt;<span class="number">100</span>,ncols-&gt;<span class="number">1</span>,indexers-&gt;</span><br><span class="line">[index])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>HDF5文件中的对象可以通过与字典一样的API进行获取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">97</span>]: store[<span class="string">&#x27;obj1&#x27;</span>]</span><br><span class="line">Out[<span class="number">97</span>]: </span><br><span class="line">           a</span><br><span class="line"><span class="number">0</span>  -<span class="number">0.204708</span></span><br><span class="line"><span class="number">1</span>   <span class="number">0.478943</span></span><br><span class="line"><span class="number">2</span>  -<span class="number">0.519439</span></span><br><span class="line"><span class="number">3</span>  -<span class="number">0.555730</span></span><br><span class="line"><span class="number">4</span>   <span class="number">1.965781</span></span><br><span class="line">..       ...</span><br><span class="line"><span class="number">95</span>  <span class="number">0.795253</span></span><br><span class="line"><span class="number">96</span>  <span class="number">0.118110</span></span><br><span class="line"><span class="number">97</span> -<span class="number">0.748532</span></span><br><span class="line"><span class="number">98</span>  <span class="number">0.584970</span></span><br><span class="line"><span class="number">99</span>  <span class="number">0.152677</span></span><br><span class="line">[<span class="number">100</span> rows x <span class="number">1</span> columns]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>HDFStore支持两种存储模式，'fixed'和'table'。后者通常会更慢，但是支持使用特殊语法进行查询操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">98</span>]: store.put(<span class="string">&#x27;obj2&#x27;</span>, frame, <span class="built_in">format</span>=<span class="string">&#x27;table&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: store.select(<span class="string">&#x27;obj2&#x27;</span>, where=[<span class="string">&#x27;index &gt;= 10 and index &lt;= 15&#x27;</span>])</span><br><span class="line">Out[<span class="number">99</span>]: </span><br><span class="line">           a</span><br><span class="line"><span class="number">10</span>  <span class="number">1.007189</span></span><br><span class="line"><span class="number">11</span> -<span class="number">1.296221</span></span><br><span class="line"><span class="number">12</span>  <span class="number">0.274992</span></span><br><span class="line"><span class="number">13</span>  <span class="number">0.228913</span></span><br><span class="line"><span class="number">14</span>  <span class="number">1.352917</span></span><br><span class="line"><span class="number">15</span>  <span class="number">0.886429</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: store.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>put是store['obj2'] = frame方法的显示版本，允许我们设置其它的选项，比如格式。</p>
<p>pandas.read_hdf函数可以快捷使用这些工具：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">101</span>]: frame.to_hdf(<span class="string">&#x27;mydata.h5&#x27;</span>, <span class="string">&#x27;obj3&#x27;</span>, <span class="built_in">format</span>=<span class="string">&#x27;table&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">102</span>]: pd.read_hdf(<span class="string">&#x27;mydata.h5&#x27;</span>, <span class="string">&#x27;obj3&#x27;</span>, where=[<span class="string">&#x27;index &lt; 5&#x27;</span>])</span><br><span class="line">Out[<span class="number">102</span>]: </span><br><span class="line">          a</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：如果你要处理的数据位于远程服务器，比如Amazon S3或HDFS，使用专门为分布式存储（比如Apache Parquet）的二进制格式也许更加合适。Python的Parquet和其它存储格式还在不断的发展之中，所以这本书中没有涉及。</p>
</blockquote>
<p>如果需要本地处理海量数据，我建议你好好研究一下PyTables和h5py，看看它们能满足你的哪些需求。。由于许多数据分析问题都是IO密集型（而不是CPU密集型），利用HDF5这样的工具能显著提升应用程序的效率。</p>
<blockquote>
<p>注意：HDF5不是数据库。它最适合用作“一次写多次读”的数据集。虽然数据可以在任何时候被添加到文件中，但如果同时发生多个写操作，文件就可能会被破坏。</p>
</blockquote>
<h2 id="读取microsoft-excel文件">读取Microsoft Excel文件</h2>
<p>pandas的ExcelFile类或pandas.read_excel函数支持读取存储在Excel 2003（或更高版本）中的表格型数据。这两个工具分别使用扩展包xlrd和openpyxl读取XLS和XLSX文件。你可以用pip或conda安装它们。</p>
<p>要使用ExcelFile，通过传递xls或xlsx路径创建一个实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">104</span>]: xlsx = pd.ExcelFile(<span class="string">&#x27;examples/ex1.xlsx&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>存储在表单中的数据可以read_excel读取到DataFrame（原书这里写的是用parse解析，但代码中用的是read_excel，是个笔误：只换了代码，没有改文字）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">105</span>]: pd.read_excel(xlsx, <span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line">Out[<span class="number">105</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果要读取一个文件中的多个表单，创建ExcelFile会更快，但你也可以将文件名传递到pandas.read_excel：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">106</span>]: frame = pd.read_excel(<span class="string">&#x27;examples/ex1.xlsx&#x27;</span>, <span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: frame</span><br><span class="line">Out[<span class="number">107</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果要将pandas数据写入为Excel格式，你必须首先创建一个ExcelWriter，然后使用pandas对象的to_excel方法将数据写入到其中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">108</span>]: writer = pd.ExcelWriter(<span class="string">&#x27;examples/ex2.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: frame.to_excel(writer, <span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">110</span>]: writer.save()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你还可以不使用ExcelWriter，而是传递文件的路径到to_excel：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">111</span>]: frame.to_excel(<span class="string">&#x27;examples/ex2.xlsx&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="web-apis交互">6.3 Web APIs交互</h1>
<p>许多网站都有一些通过JSON或其他格式提供数据的公共API。通过Python访问这些API的办法有不少。一个简单易用的办法（推荐）是requests包（http://docs.python-requests.org）。</p>
<p>为了搜索最新的30个GitHub上的pandas主题，我们可以发一个HTTP GET请求，使用requests扩展库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">113</span>]: <span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: url = <span class="string">&#x27;https://api.github.com/repos/pandas-dev/pandas/issues&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">115</span>]: resp = requests.get(url)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: resp</span><br><span class="line">Out[<span class="number">116</span>]: &lt;Response [<span class="number">200</span>]&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>响应对象的json方法会返回一个包含被解析过的JSON字典，加载到一个Python对象中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">117</span>]: data = resp.json()</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: data[<span class="number">0</span>][<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">Out[<span class="number">118</span>]: <span class="string">&#x27;Period does not round down for frequencies less that 1 hour&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>data中的每个元素都是一个包含所有GitHub主题页数据（不包含评论）的字典。我们可以直接传递数据到DataFrame，并提取感兴趣的字段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">119</span>]: issues = pd.DataFrame(data, columns=[<span class="string">&#x27;number&#x27;</span>, <span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">   .....:                                      <span class="string">&#x27;labels&#x27;</span>, <span class="string">&#x27;state&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: issues</span><br><span class="line">Out[<span class="number">120</span>]:</span><br><span class="line">    number                                              title  \</span><br><span class="line"><span class="number">0</span>    <span class="number">17666</span>  Period does <span class="keyword">not</span> <span class="built_in">round</span> down <span class="keyword">for</span> frequencies les...   </span><br><span class="line"><span class="number">1</span>    <span class="number">17665</span>           DOC: improve docstring of function where   </span><br><span class="line"><span class="number">2</span>    <span class="number">17664</span>               COMPAT: skip <span class="number">32</span>-bit test on <span class="built_in">int</span> <span class="built_in">repr</span>   </span><br><span class="line"><span class="number">3</span>    <span class="number">17662</span>                          implement Delegator <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class">4    17654  <span class="title">BUG</span>:</span> Fix series rename called <span class="keyword">with</span> <span class="built_in">str</span> alterin...   </span><br><span class="line">..     ...                                                ...   </span><br><span class="line"><span class="number">25</span>   <span class="number">17603</span>  BUG: Correctly localize naive datetime strings...   </span><br><span class="line"><span class="number">26</span>   <span class="number">17599</span>                     core.dtypes.generic --&gt; cython   </span><br><span class="line"><span class="number">27</span>   <span class="number">17596</span>   Merge cdate_range functionality into bdate_range   </span><br><span class="line"><span class="number">28</span>   <span class="number">17587</span>  Time Grouper bug fix when applied <span class="keyword">for</span> <span class="built_in">list</span> gro...   </span><br><span class="line"><span class="number">29</span>   <span class="number">17583</span>  BUG: fix tz-aware DatetimeIndex + TimedeltaInd...   </span><br><span class="line">                                               labels state  </span><br><span class="line"><span class="number">0</span>                                                  []  <span class="built_in">open</span>  </span><br><span class="line"><span class="number">1</span>   [&#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">134699</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;https://api.github.com...  open  </span></span><br><span class="line"><span class="string">2   [&#123;&#x27;</span><span class="built_in">id</span><span class="string">&#x27;: 563047854, &#x27;</span>url<span class="string">&#x27;: &#x27;</span>https://api.github....  <span class="built_in">open</span>  </span><br><span class="line"><span class="number">3</span>                                                  []  <span class="built_in">open</span>  </span><br><span class="line"><span class="number">4</span>   [&#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">76811</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;https://api.github.com/...  open  </span></span><br><span class="line"><span class="string">..                                                ...   ...  </span></span><br><span class="line"><span class="string">25  [&#123;&#x27;</span><span class="built_in">id</span><span class="string">&#x27;: 76811, &#x27;</span>url<span class="string">&#x27;: &#x27;</span>https://api.github.com/...  <span class="built_in">open</span>  </span><br><span class="line"><span class="number">26</span>  [&#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">49094459</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;https://api.github.c...  open  </span></span><br><span class="line"><span class="string">27  [&#123;&#x27;</span><span class="built_in">id</span><span class="string">&#x27;: 35818298, &#x27;</span>url<span class="string">&#x27;: &#x27;</span>https://api.github.c...  <span class="built_in">open</span>  </span><br><span class="line"><span class="number">28</span>  [&#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">233160</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;https://api.github.com...  open  </span></span><br><span class="line"><span class="string">29  [&#123;&#x27;</span><span class="built_in">id</span><span class="string">&#x27;: 76811, &#x27;</span>url<span class="string">&#x27;: &#x27;</span>https://api.github.com/...  <span class="built_in">open</span>  </span><br><span class="line">[<span class="number">30</span> rows x <span class="number">4</span> columns]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>花费一些精力，你就可以创建一些更高级的常见的Web API的接口，返回DataFrame对象，方便进行分析。</p>
<h1 id="数据库交互">6.4 数据库交互</h1>
<p>在商业场景下，大多数数据可能不是存储在文本或Excel文件中。基于SQL的关系型数据库（如SQL Server、PostgreSQL和MySQL等）使用非常广泛，其它一些数据库也很流行。数据库的选择通常取决于性能、数据完整性以及应用程序的伸缩性需求。</p>
<p>将数据从SQL加载到DataFrame的过程很简单，此外pandas还有一些能够简化该过程的函数。例如，我将使用SQLite数据库（通过Python内置的sqlite3驱动器）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">121</span>]: <span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: query = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   .....: CREATE TABLE test</span></span><br><span class="line"><span class="string">   .....: (a VARCHAR(20), b VARCHAR(20),</span></span><br><span class="line"><span class="string">   .....:  c REAL,        d INTEGER</span></span><br><span class="line"><span class="string">   .....: );&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: con = sqlite3.connect(<span class="string">&#x27;mydata.sqlite&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: con.execute(query)</span><br><span class="line">Out[<span class="number">124</span>]: &lt;sqlite3.Cursor at <span class="number">0x7f6b12a50f10</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: con.commit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后插入几行数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">126</span>]: data = [(<span class="string">&#x27;Atlanta&#x27;</span>, <span class="string">&#x27;Georgia&#x27;</span>, <span class="number">1.25</span>, <span class="number">6</span>),</span><br><span class="line">   .....:         (<span class="string">&#x27;Tallahassee&#x27;</span>, <span class="string">&#x27;Florida&#x27;</span>, <span class="number">2.6</span>, <span class="number">3</span>),</span><br><span class="line">   .....:         (<span class="string">&#x27;Sacramento&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="number">1.7</span>, <span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">127</span>]: stmt = <span class="string">&quot;INSERT INTO test VALUES(?, ?, ?, ?)&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">128</span>]: con.executemany(stmt, data)</span><br><span class="line">Out[<span class="number">128</span>]: &lt;sqlite3.Cursor at <span class="number">0x7f6b15c66ce0</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从表中选取数据时，大部分Python SQL驱动器（PyODBC、psycopg2、MySQLdb、pymssql等）都会返回一个元组列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">130</span>]: cursor = con.execute(<span class="string">&#x27;select * from test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">131</span>]: rows = cursor.fetchall()</span><br><span class="line"></span><br><span class="line">In [<span class="number">132</span>]: rows</span><br><span class="line">Out[<span class="number">132</span>]: </span><br><span class="line">[(<span class="string">&#x27;Atlanta&#x27;</span>, <span class="string">&#x27;Georgia&#x27;</span>, <span class="number">1.25</span>, <span class="number">6</span>),</span><br><span class="line"> (<span class="string">&#x27;Tallahassee&#x27;</span>, <span class="string">&#x27;Florida&#x27;</span>, <span class="number">2.6</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="string">&#x27;Sacramento&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="number">1.7</span>, <span class="number">5</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可以将这个元组列表传给DataFrame构造器，但还需要列名（位于光标的description属性中）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">133</span>]: cursor.description</span><br><span class="line">Out[<span class="number">133</span>]: </span><br><span class="line">((<span class="string">&#x27;a&#x27;</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>),</span><br><span class="line"> (<span class="string">&#x27;b&#x27;</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>),</span><br><span class="line"> (<span class="string">&#x27;c&#x27;</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>),</span><br><span class="line"> (<span class="string">&#x27;d&#x27;</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">134</span>]: pd.DataFrame(rows, columns=[x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> cursor.description])</span><br><span class="line">Out[<span class="number">134</span>]: </span><br><span class="line">             a           b     c  d</span><br><span class="line"><span class="number">0</span>      Atlanta     Georgia  <span class="number">1.25</span>  <span class="number">6</span></span><br><span class="line"><span class="number">1</span>  Tallahassee     Florida  <span class="number">2.60</span>  <span class="number">3</span></span><br><span class="line"><span class="number">2</span>   Sacramento  California  <span class="number">1.70</span>  <span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种数据规整操作相当多，你肯定不想每查一次数据库就重写一次。<a href="http://www.sqlalchemy.org/">SQLAlchemy项目</a>是一个流行的Python SQL工具，它抽象出了SQL数据库中的许多常见差异。pandas有一个read_sql函数，可以让你轻松的从SQLAlchemy连接读取数据。这里，我们用SQLAlchemy连接SQLite数据库，并从之前创建的表读取数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">135</span>]: <span class="keyword">import</span> sqlalchemy <span class="keyword">as</span> sqla</span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: db = sqla.create_engine(<span class="string">&#x27;sqlite:///mydata.sqlite&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">137</span>]: pd.read_sql(<span class="string">&#x27;select * from test&#x27;</span>, db)</span><br><span class="line">Out[<span class="number">137</span>]: </span><br><span class="line">             a           b     c  d</span><br><span class="line"><span class="number">0</span>      Atlanta     Georgia  <span class="number">1.25</span>  <span class="number">6</span></span><br><span class="line"><span class="number">1</span>  Tallahassee     Florida  <span class="number">2.60</span>  <span class="number">3</span></span><br><span class="line"><span class="number">2</span>   Sacramento  California  <span class="number">1.70</span>  <span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="总结">6.5 总结</h1>
<p>访问数据通常是数据分析的第一步。在本章中，我们已经学了一些有用的工具。在接下来的章节中，我们将深入研究数据规整、数据可视化、时间序列分析和其它主题。</p>
]]></content>
      <categories>
        <category>Python 数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>第05章 pandas入门</title>
    <url>/2019/04/09/%E7%AC%AC05%E7%AB%A0-pandas%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>pandas是本书后续内容的首选库。它含有使数据清洗和分析工作变得更快更简单的数据结构和操作工具。<span id="more"></span>pandas经常和其它工具一同使用，如数值计算工具NumPy和SciPy，分析库statsmodels和scikit-learn，和数据可视化库matplotlib。pandas是基于NumPy数组构建的，特别是基于数组的函数和不使用for循环的数据处理。</p>
<p>虽然pandas采用了大量的NumPy编码风格，但二者最大的不同是pandas是专门为处理表格和混杂数据设计的。而NumPy更适合处理统一的数值数组数据。</p>
<p>自从2010年pandas开源以来，pandas逐渐成长为一个非常大的库，应用于许多真实案例。开发者社区已经有了800个独立的贡献者，他们在解决日常数据问题的同时为这个项目提供贡献。</p>
<p>在本书后续部分中，我将使用下面这样的pandas引入约定：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<p>因此，只要你在代码中看到pd.，就得想到这是pandas。因为Series和DataFrame用的次数非常多，所以将其引入本地命名空间中会更方便：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">2</span>]: <span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</span><br></pre></td></tr></table></figure>
<h1 id="pandas的数据结构介绍">5.1 pandas的数据结构介绍</h1>
<p>要使用pandas，你首先就得熟悉它的两个主要数据结构：Series和DataFrame。虽然它们并不能解决所有问题，但它们为大多数应用提供了一种可靠的、易于使用的基础。</p>
<h2 id="series">Series</h2>
<p>Series是一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签（即索引）组成。仅由一组数据即可产生最简单的Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: obj = pd.Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: obj</span><br><span class="line">Out[<span class="number">12</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>Series的字符串表现形式为：索引在左边，值在右边。由于我们没有为数据指定索引，于是会自动创建一个0到N-1（N为数据的长度）的整数型索引。你可以通过Series 的values和index属性获取其数组表示形式和索引对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: obj.values</span><br><span class="line">Out[<span class="number">13</span>]: array([ <span class="number">4</span>,  <span class="number">7</span>, -<span class="number">5</span>,  <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: obj.index  <span class="comment"># like range(4)</span></span><br><span class="line">Out[<span class="number">14</span>]: RangeIndex(start=<span class="number">0</span>, stop=<span class="number">4</span>, step=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>通常，我们希望所创建的Series带有一个可以对各个数据点进行标记的索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: obj2 = pd.Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>], index=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: obj2</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">d    <span class="number">4</span></span><br><span class="line">b    <span class="number">7</span></span><br><span class="line">a   -<span class="number">5</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: obj2.index</span><br><span class="line">Out[<span class="number">17</span>]: Index([<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>与普通NumPy数组相比，你可以通过索引的方式选取Series中的单个或一组值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: obj2[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">Out[<span class="number">18</span>]: -<span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: obj2[<span class="string">&#x27;d&#x27;</span>] = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: obj2[[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]]</span><br><span class="line">Out[<span class="number">20</span>]: </span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">a   -<span class="number">5</span></span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>['c', 'a', 'd']是索引列表，即使它包含的是字符串而不是整数。</p>
<p>使用NumPy函数或类似NumPy的运算（如根据布尔型数组进行过滤、标量乘法、应用数学函数等）都会保留索引值的链接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: obj2[obj2 &gt; <span class="number">0</span>]</span><br><span class="line">Out[<span class="number">21</span>]: </span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">b    <span class="number">7</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: obj2 * <span class="number">2</span></span><br><span class="line">Out[<span class="number">22</span>]:</span><br><span class="line">d    <span class="number">12</span></span><br><span class="line">b    <span class="number">14</span></span><br><span class="line">a   -<span class="number">10</span></span><br><span class="line">c     <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: np.exp(obj2)</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">d     <span class="number">403.428793</span></span><br><span class="line">b    <span class="number">1096.633158</span></span><br><span class="line">a       <span class="number">0.006738</span></span><br><span class="line">c      <span class="number">20.085537</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>还可以将Series看成是一个定长的有序字典，因为它是索引值到数据值的一个映射。它可以用在许多原本需要字典参数的函数中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: <span class="string">&#x27;b&#x27;</span> <span class="keyword">in</span> obj2</span><br><span class="line">Out[<span class="number">24</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: <span class="string">&#x27;e&#x27;</span> <span class="keyword">in</span> obj2</span><br><span class="line">Out[<span class="number">25</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>如果数据被存放在一个Python字典中，也可以直接通过这个字典来创建Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">26</span>]: sdata = &#123;<span class="string">&#x27;Ohio&#x27;</span>: <span class="number">35000</span>, <span class="string">&#x27;Texas&#x27;</span>: <span class="number">71000</span>, <span class="string">&#x27;Oregon&#x27;</span>: <span class="number">16000</span>, <span class="string">&#x27;Utah&#x27;</span>: <span class="number">5000</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: obj3 = pd.Series(sdata)</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: obj3</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">Ohio      <span class="number">35000</span></span><br><span class="line">Oregon    <span class="number">16000</span></span><br><span class="line">Texas     <span class="number">71000</span></span><br><span class="line">Utah       <span class="number">5000</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>如果只传入一个字典，则结果Series中的索引就是原字典的键（有序排列）。你可以传入排好序的字典的键以改变顺序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">29</span>]: states = [<span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: obj4 = pd.Series(sdata, index=states)</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: obj4</span><br><span class="line">Out[<span class="number">31</span>]: </span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="number">35000.0</span></span><br><span class="line">Oregon        <span class="number">16000.0</span></span><br><span class="line">Texas         <span class="number">71000.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>在这个例子中，sdata中跟states索引相匹配的那3个值会被找出来并放到相应的位置上，但由于"California"所对应的sdata值找不到，所以其结果就为NaN（即“非数字”（not a number），在pandas中，它用于表示缺失或NA值）。因为‘Utah’不在states中，它被从结果中除去。</p>
<p>我将使用缺失（missing）或NA表示缺失数据。pandas的isnull和notnull函数可用于检测缺失数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">32</span>]: pd.isnull(obj4)</span><br><span class="line">Out[<span class="number">32</span>]: </span><br><span class="line">California     <span class="literal">True</span></span><br><span class="line">Ohio          <span class="literal">False</span></span><br><span class="line">Oregon        <span class="literal">False</span></span><br><span class="line">Texas         <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: pd.notnull(obj4)</span><br><span class="line">Out[<span class="number">33</span>]: </span><br><span class="line">California    <span class="literal">False</span></span><br><span class="line">Ohio           <span class="literal">True</span></span><br><span class="line">Oregon         <span class="literal">True</span></span><br><span class="line">Texas          <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure>
<p>Series也有类似的实例方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">34</span>]: obj4.isnull()</span><br><span class="line">Out[<span class="number">34</span>]: </span><br><span class="line">California     <span class="literal">True</span></span><br><span class="line">Ohio          <span class="literal">False</span></span><br><span class="line">Oregon        <span class="literal">False</span></span><br><span class="line">Texas         <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure>
<p>我将在第7章详细讲解如何处理缺失数据。</p>
<p>对于许多应用而言，Series最重要的一个功能是，它会根据运算的索引标签自动对齐数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">35</span>]: obj3</span><br><span class="line">Out[<span class="number">35</span>]: </span><br><span class="line">Ohio      <span class="number">35000</span></span><br><span class="line">Oregon    <span class="number">16000</span></span><br><span class="line">Texas     <span class="number">71000</span></span><br><span class="line">Utah       <span class="number">5000</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: obj4</span><br><span class="line">Out[<span class="number">36</span>]: </span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="number">35000.0</span></span><br><span class="line">Oregon        <span class="number">16000.0</span></span><br><span class="line">Texas         <span class="number">71000.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: obj3 + obj4</span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">California         NaN</span><br><span class="line">Ohio           <span class="number">70000.0</span></span><br><span class="line">Oregon         <span class="number">32000.0</span></span><br><span class="line">Texas         <span class="number">142000.0</span></span><br><span class="line">Utah               NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>数据对齐功能将在后面详细讲解。如果你使用过数据库，你可以认为是类似join的操作。</p>
<p>Series对象本身及其索引都有一个name属性，该属性跟pandas其他的关键功能关系非常密切：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">38</span>]: obj4.name = <span class="string">&#x27;population&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: obj4.index.name = <span class="string">&#x27;state&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: obj4</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">state</span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="number">35000.0</span></span><br><span class="line">Oregon        <span class="number">16000.0</span></span><br><span class="line">Texas         <span class="number">71000.0</span></span><br><span class="line">Name: population, dtype: float64</span><br></pre></td></tr></table></figure>
<p>Series的索引可以通过赋值的方式就地修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: obj</span><br><span class="line">Out[<span class="number">41</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: obj.index = [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Jeff&#x27;</span>, <span class="string">&#x27;Ryan&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: obj</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">Bob      <span class="number">4</span></span><br><span class="line">Steve    <span class="number">7</span></span><br><span class="line">Jeff    -<span class="number">5</span></span><br><span class="line">Ryan     <span class="number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h2 id="dataframe">DataFrame</h2>
<p>DataFrame是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）。DataFrame既有行索引也有列索引，它可以被看做由Series组成的字典（共用同一个索引）。DataFrame中的数据是以一个或多个二维块存放的（而不是列表、字典或别的一维数据结构）。有关DataFrame内部的技术细节远远超出了本书所讨论的范围。</p>
<blockquote>
<p>笔记：虽然DataFrame是以二维结构保存数据的，但你仍然可以轻松地将其表示为更高维度的数据（层次化索引的表格型结构，这是pandas中许多高级数据处理功能的关键要素，我们会在第8章讨论这个问题）。</p>
</blockquote>
<p>建DataFrame的办法有很多，最常用的一种是直接传入一个由等长列表或NumPy数组组成的字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = &#123;<span class="string">&#x27;state&#x27;</span>: [<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;year&#x27;</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2003</span>],</span><br><span class="line">        <span class="string">&#x27;pop&#x27;</span>: [<span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">3.6</span>, <span class="number">2.4</span>, <span class="number">2.9</span>, <span class="number">3.2</span>]&#125;</span><br><span class="line">frame = pd.DataFrame(data)</span><br></pre></td></tr></table></figure>
<p>结果DataFrame会自动加上索引（跟Series一样），且全部列会被有序排列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">45</span>]: frame</span><br><span class="line">Out[<span class="number">45</span>]: </span><br><span class="line">   pop   state  year</span><br><span class="line"><span class="number">0</span>  <span class="number">1.5</span>    Ohio  <span class="number">2000</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.7</span>    Ohio  <span class="number">2001</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3.6</span>    Ohio  <span class="number">2002</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2.4</span>  Nevada  <span class="number">2001</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2.9</span>  Nevada  <span class="number">2002</span></span><br><span class="line"><span class="number">5</span>  <span class="number">3.2</span>  Nevada  <span class="number">2003</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你使用的是Jupyter notebook，pandas DataFrame对象会以对浏览器友好的HTML表格的方式呈现。</p>
<p>对于特别大的DataFrame，head方法会选取前五行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">46</span>]: frame.head()</span><br><span class="line">Out[<span class="number">46</span>]: </span><br><span class="line">   pop   state  year</span><br><span class="line"><span class="number">0</span>  <span class="number">1.5</span>    Ohio  <span class="number">2000</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.7</span>    Ohio  <span class="number">2001</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3.6</span>    Ohio  <span class="number">2002</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2.4</span>  Nevada  <span class="number">2001</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2.9</span>  Nevada  <span class="number">2002</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果指定了列序列，则DataFrame的列就会按照指定顺序进行排列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">47</span>]: pd.DataFrame(data, columns=[<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>])</span><br><span class="line">Out[<span class="number">47</span>]: </span><br><span class="line">   year   state  pop</span><br><span class="line"><span class="number">0</span>  <span class="number">2000</span>    Ohio  <span class="number">1.5</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2001</span>    Ohio  <span class="number">1.7</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2002</span>    Ohio  <span class="number">3.6</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2001</span>  Nevada  <span class="number">2.4</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2002</span>  Nevada  <span class="number">2.9</span></span><br><span class="line"><span class="number">5</span>  <span class="number">2003</span>  Nevada  <span class="number">3.2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果传入的列在数据中找不到，就会在结果中产生缺失值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">48</span>]: frame2 = pd.DataFrame(data, columns=[<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;debt&#x27;</span>],</span><br><span class="line">   ....:                       index=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>,</span><br><span class="line">   ....:                              <span class="string">&#x27;five&#x27;</span>, <span class="string">&#x27;six&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: frame2</span><br><span class="line">Out[<span class="number">49</span>]: </span><br><span class="line">       year   state  pop debt</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>  NaN</span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  NaN</span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>  NaN</span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  NaN</span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  NaN</span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>  NaN</span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: frame2.columns</span><br><span class="line">Out[<span class="number">50</span>]: Index([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;debt&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过类似字典标记的方式或属性的方式，可以将DataFrame的列获取为一个Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">51</span>]: frame2[<span class="string">&#x27;state&#x27;</span>]</span><br><span class="line">Out[<span class="number">51</span>]: </span><br><span class="line">one        Ohio</span><br><span class="line">two        Ohio</span><br><span class="line">three      Ohio</span><br><span class="line">four     Nevada</span><br><span class="line">five     Nevada</span><br><span class="line">six      Nevada</span><br><span class="line">Name: state, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: frame2.year</span><br><span class="line">Out[<span class="number">52</span>]: </span><br><span class="line">one      <span class="number">2000</span></span><br><span class="line">two      <span class="number">2001</span></span><br><span class="line">three    <span class="number">2002</span></span><br><span class="line">four     <span class="number">2001</span></span><br><span class="line">five     <span class="number">2002</span></span><br><span class="line">six      <span class="number">2003</span></span><br><span class="line">Name: year, dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：IPython提供了类似属性的访问（即frame2.year）和tab补全。 frame2[column]适用于任何列的名，但是frame2.column只有在列名是一个合理的Python变量名时才适用。</p>
</blockquote>
<p>注意，返回的Series拥有原DataFrame相同的索引，且其name属性也已经被相应地设置好了。</p>
<p>行也可以通过位置或名称的方式进行获取，比如用loc属性（稍后将对此进行详细讲解）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">53</span>]: frame2.loc[<span class="string">&#x27;three&#x27;</span>]</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">year     <span class="number">2002</span></span><br><span class="line">state    Ohio</span><br><span class="line">pop       <span class="number">3.6</span></span><br><span class="line">debt      NaN</span><br><span class="line">Name: three, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>列可以通过赋值的方式进行修改。例如，我们可以给那个空的"debt"列赋上一个标量值或一组值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">54</span>]: frame2[<span class="string">&#x27;debt&#x27;</span>] = <span class="number">16.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: frame2</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">       year   state  pop  debt</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>  <span class="number">16.5</span></span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  <span class="number">16.5</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>  <span class="number">16.5</span></span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  <span class="number">16.5</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  <span class="number">16.5</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>  <span class="number">16.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">56</span>]: frame2[<span class="string">&#x27;debt&#x27;</span>] = np.arange(<span class="number">6.</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: frame2</span><br><span class="line">Out[<span class="number">57</span>]: </span><br><span class="line">       year   state  pop  debt</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>   <span class="number">0.0</span></span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>   <span class="number">1.0</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>   <span class="number">2.0</span></span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>   <span class="number">3.0</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>   <span class="number">4.0</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>   <span class="number">5.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将列表或数组赋值给某个列时，其长度必须跟DataFrame的长度相匹配。如果赋值的是一个Series，就会精确匹配DataFrame的索引，所有的空位都将被填上缺失值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">58</span>]: val = pd.Series([-<span class="number">1.2</span>, -<span class="number">1.5</span>, -<span class="number">1.7</span>], index=[<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: frame2[<span class="string">&#x27;debt&#x27;</span>] = val</span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: frame2</span><br><span class="line">Out[<span class="number">60</span>]: </span><br><span class="line">       year   state  pop  debt</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>   NaN</span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  -<span class="number">1.2</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>   NaN</span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  -<span class="number">1.5</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  -<span class="number">1.7</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>   NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为不存在的列赋值会创建出一个新列。关键字del用于删除列。</p>
<p>作为del的例子，我先添加一个新的布尔值的列，state是否为'Ohio'：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">61</span>]: frame2[<span class="string">&#x27;eastern&#x27;</span>] = frame2.state == <span class="string">&#x27;Ohio&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: frame2</span><br><span class="line">Out[<span class="number">62</span>]: </span><br><span class="line">       year   state  pop  debt  eastern</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>   NaN     <span class="literal">True</span></span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  -<span class="number">1.2</span>     <span class="literal">True</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>   NaN     <span class="literal">True</span></span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  -<span class="number">1.5</span>    <span class="literal">False</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  -<span class="number">1.7</span>    <span class="literal">False</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>   NaN    <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：不能用frame2.eastern创建新的列。</p>
</blockquote>
<p>del方法可以用来删除这列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">63</span>]: <span class="keyword">del</span> frame2[<span class="string">&#x27;eastern&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: frame2.columns</span><br><span class="line">Out[<span class="number">64</span>]: Index([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;debt&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：通过索引方式返回的列只是相应数据的视图而已，并不是副本。因此，对返回的Series所做的任何就地修改全都会反映到源DataFrame上。通过Series的copy方法即可指定复制列。</p>
</blockquote>
<p>另一种常见的数据形式是嵌套字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">65</span>]: pop = &#123;<span class="string">&#x27;Nevada&#x27;</span>: &#123;<span class="number">2001</span>: <span class="number">2.4</span>, <span class="number">2002</span>: <span class="number">2.9</span>&#125;,</span><br><span class="line">....:        <span class="string">&#x27;Ohio&#x27;</span>: &#123;<span class="number">2000</span>: <span class="number">1.5</span>, <span class="number">2001</span>: <span class="number">1.7</span>, <span class="number">2002</span>: <span class="number">3.6</span>&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果嵌套字典传给DataFrame，pandas就会被解释为：外层字典的键作为列，内层键则作为行索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">66</span>]: frame3 = pd.DataFrame(pop)</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: frame3</span><br><span class="line">Out[<span class="number">67</span>]: </span><br><span class="line">      Nevada  Ohio</span><br><span class="line"><span class="number">2000</span>     NaN   <span class="number">1.5</span></span><br><span class="line"><span class="number">2001</span>     <span class="number">2.4</span>   <span class="number">1.7</span></span><br><span class="line"><span class="number">2002</span>     <span class="number">2.9</span>   <span class="number">3.6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你也可以使用类似NumPy数组的方法，对DataFrame进行转置（交换行和列）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">68</span>]: frame3.T</span><br><span class="line">Out[<span class="number">68</span>]: </span><br><span class="line">        <span class="number">2000</span>  <span class="number">2001</span>  <span class="number">2002</span></span><br><span class="line">Nevada   NaN   <span class="number">2.4</span>   <span class="number">2.9</span></span><br><span class="line">Ohio     <span class="number">1.5</span>   <span class="number">1.7</span>   <span class="number">3.6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>内层字典的键会被合并、排序以形成最终的索引。如果明确指定了索引，则不会这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">69</span>]: pd.DataFrame(pop, index=[<span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2003</span>])</span><br><span class="line">Out[<span class="number">69</span>]: </span><br><span class="line">      Nevada  Ohio</span><br><span class="line"><span class="number">2001</span>     <span class="number">2.4</span>   <span class="number">1.7</span></span><br><span class="line"><span class="number">2002</span>     <span class="number">2.9</span>   <span class="number">3.6</span></span><br><span class="line"><span class="number">2003</span>     NaN   NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由Series组成的字典差不多也是一样的用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">70</span>]: pdata = &#123;<span class="string">&#x27;Ohio&#x27;</span>: frame3[<span class="string">&#x27;Ohio&#x27;</span>][:-<span class="number">1</span>],</span><br><span class="line">....:          <span class="string">&#x27;Nevada&#x27;</span>: frame3[<span class="string">&#x27;Nevada&#x27;</span>][:<span class="number">2</span>]&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: pd.DataFrame(pdata)</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line">      Nevada  Ohio</span><br><span class="line"><span class="number">2000</span>     NaN   <span class="number">1.5</span></span><br><span class="line"><span class="number">2001</span>     <span class="number">2.4</span>   <span class="number">1.7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表5-1列出了DataFrame构造函数所能接受的各种数据。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-106835b28c0cea5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>如果设置了DataFrame的index和columns的name属性，则这些信息也会被显示出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">72</span>]: frame3.index.name = <span class="string">&#x27;year&#x27;</span>; frame3.columns.name = <span class="string">&#x27;state&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">73</span>]: frame3</span><br><span class="line">Out[<span class="number">73</span>]: </span><br><span class="line">state  Nevada  Ohio</span><br><span class="line">year</span><br><span class="line"><span class="number">2000</span>      NaN   <span class="number">1.5</span></span><br><span class="line"><span class="number">2001</span>      <span class="number">2.4</span>   <span class="number">1.7</span></span><br><span class="line"><span class="number">2002</span>      <span class="number">2.9</span>   <span class="number">3.6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>跟Series一样，values属性也会以二维ndarray的形式返回DataFrame中的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: frame3.values</span><br><span class="line">Out[<span class="number">74</span>]: </span><br><span class="line">array([[ nan,  <span class="number">1.5</span>],</span><br><span class="line">       [ <span class="number">2.4</span>,  <span class="number">1.7</span>],</span><br><span class="line">       [ <span class="number">2.9</span>,  <span class="number">3.6</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果DataFrame各列的数据类型不同，则值数组的dtype就会选用能兼容所有列的数据类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">75</span>]: frame2.values</span><br><span class="line">Out[<span class="number">75</span>]:</span><br><span class="line">array([[<span class="number">2000</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="number">1.5</span>, nan],</span><br><span class="line">       [<span class="number">2001</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="number">1.7</span>, -<span class="number">1.2</span>],</span><br><span class="line">       [<span class="number">2002</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="number">3.6</span>, nan],</span><br><span class="line">       [<span class="number">2001</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="number">2.4</span>, -<span class="number">1.5</span>],</span><br><span class="line">       [<span class="number">2002</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="number">2.9</span>, -<span class="number">1.7</span>],</span><br><span class="line">       [<span class="number">2003</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="number">3.2</span>, nan]], dtype=<span class="built_in">object</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="索引对象">索引对象</h2>
<p>pandas的索引对象负责管理轴标签和其他元数据（比如轴名称等）。构建Series或DataFrame时，所用到的任何数组或其他序列的标签都会被转换成一个Index：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: obj = pd.Series(<span class="built_in">range</span>(<span class="number">3</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: index = obj.index</span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: index</span><br><span class="line">Out[<span class="number">78</span>]: Index([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: index[<span class="number">1</span>:]</span><br><span class="line">Out[<span class="number">79</span>]: Index([<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Index对象是不可变的，因此用户不能对其进行修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index[<span class="number">1</span>] = <span class="string">&#x27;d&#x27;</span>  <span class="comment"># TypeError</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不可变可以使Index对象在多个数据结构之间安全共享：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">80</span>]: labels = pd.Index(np.arange(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: labels</span><br><span class="line">Out[<span class="number">81</span>]: Int64Index([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], dtype=<span class="string">&#x27;int64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">82</span>]: obj2 = pd.Series([<span class="number">1.5</span>, -<span class="number">2.5</span>, <span class="number">0</span>], index=labels)</span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: obj2</span><br><span class="line">Out[<span class="number">83</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">1.5</span></span><br><span class="line"><span class="number">1</span>   -<span class="number">2.5</span></span><br><span class="line"><span class="number">2</span>    <span class="number">0.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: obj2.index <span class="keyword">is</span> labels</span><br><span class="line">Out[<span class="number">84</span>]: <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：虽然用户不需要经常使用Index的功能，但是因为一些操作会生成包含被索引化的数据，理解它们的工作原理是很重要的。</p>
</blockquote>
<p>除了类似于数组，Index的功能也类似一个固定大小的集合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">85</span>]: frame3</span><br><span class="line">Out[<span class="number">85</span>]: </span><br><span class="line">state  Nevada  Ohio</span><br><span class="line">year               </span><br><span class="line"><span class="number">2000</span>      NaN   <span class="number">1.5</span></span><br><span class="line"><span class="number">2001</span>      <span class="number">2.4</span>   <span class="number">1.7</span></span><br><span class="line"><span class="number">2002</span>      <span class="number">2.9</span>   <span class="number">3.6</span></span><br><span class="line">In [<span class="number">86</span>]: frame3.columns</span><br><span class="line">Out[<span class="number">86</span>]: Index([<span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>, name=<span class="string">&#x27;state&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: <span class="string">&#x27;Ohio&#x27;</span> <span class="keyword">in</span> frame3.columns</span><br><span class="line">Out[<span class="number">87</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: <span class="number">2003</span> <span class="keyword">in</span> frame3.index</span><br><span class="line">Out[<span class="number">88</span>]: <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与python的集合不同，pandas的Index可以包含重复的标签：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">89</span>]: dup_labels = pd.Index([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: dup_labels</span><br><span class="line">Out[<span class="number">90</span>]: Index([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>选择重复的标签，会显示所有的结果。</p>
<p>每个索引都有一些方法和属性，它们可用于设置逻辑并回答有关该索引所包含的数据的常见问题。表5-2列出了这些函数。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-5499d14f0e2cd639.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<h1 id="基本功能">5.2 基本功能</h1>
<p>本节中，我将介绍操作Series和DataFrame中的数据的基本手段。后续章节将更加深入地挖掘pandas在数据分析和处理方面的功能。本书不是pandas库的详尽文档，主要关注的是最重要的功能，那些不大常用的内容（也就是那些更深奥的内容）就交给你自己去摸索吧。</p>
<h2 id="重新索引">重新索引</h2>
<p>pandas对象的一个重要方法是reindex，其作用是创建一个新对象，它的数据符合新的索引。看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">91</span>]: obj = pd.Series([<span class="number">4.5</span>, <span class="number">7.2</span>, -<span class="number">5.3</span>, <span class="number">3.6</span>], index=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: obj</span><br><span class="line">Out[<span class="number">92</span>]: </span><br><span class="line">d    <span class="number">4.5</span></span><br><span class="line">b    <span class="number">7.2</span></span><br><span class="line">a   -<span class="number">5.3</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用该Series的reindex将会根据新索引进行重排。如果某个索引值当前不存在，就引入缺失值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">93</span>]: obj2 = obj.reindex([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: obj2</span><br><span class="line">Out[<span class="number">94</span>]: </span><br><span class="line">a   -<span class="number">5.3</span></span><br><span class="line">b    <span class="number">7.2</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">d    <span class="number">4.5</span></span><br><span class="line">e    NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于时间序列这样的有序数据，重新索引时可能需要做一些插值处理。method选项即可达到此目的，例如，使用ffill可以实现前向值填充：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">95</span>]: obj3 = pd.Series([<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;purple&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>], index=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">96</span>]: obj3</span><br><span class="line">Out[<span class="number">96</span>]: </span><br><span class="line"><span class="number">0</span>      blue</span><br><span class="line"><span class="number">2</span>    purple</span><br><span class="line"><span class="number">4</span>    yellow</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: obj3.reindex(<span class="built_in">range</span>(<span class="number">6</span>), method=<span class="string">&#x27;ffill&#x27;</span>)</span><br><span class="line">Out[<span class="number">97</span>]: </span><br><span class="line"><span class="number">0</span>      blue</span><br><span class="line"><span class="number">1</span>      blue</span><br><span class="line"><span class="number">2</span>    purple</span><br><span class="line"><span class="number">3</span>    purple</span><br><span class="line"><span class="number">4</span>    yellow</span><br><span class="line"><span class="number">5</span>    yellow</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>借助DataFrame，reindex可以修改（行）索引和列。只传递一个序列时，会重新索引结果的行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">98</span>]: frame = pd.DataFrame(np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)),</span><br><span class="line">   ....:                      index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">   ....:                      columns=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;California&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: frame</span><br><span class="line">Out[<span class="number">99</span>]: </span><br><span class="line">   Ohio  Texas  California</span><br><span class="line">a     <span class="number">0</span>      <span class="number">1</span>           <span class="number">2</span></span><br><span class="line">c     <span class="number">3</span>      <span class="number">4</span>           <span class="number">5</span></span><br><span class="line">d     <span class="number">6</span>      <span class="number">7</span>           <span class="number">8</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: frame2 = frame.reindex([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">101</span>]: frame2</span><br><span class="line">Out[<span class="number">101</span>]: </span><br><span class="line">   Ohio  Texas  California</span><br><span class="line">a   <span class="number">0.0</span>    <span class="number">1.0</span>         <span class="number">2.0</span></span><br><span class="line">b   NaN    NaN         NaN</span><br><span class="line">c   <span class="number">3.0</span>    <span class="number">4.0</span>         <span class="number">5.0</span></span><br><span class="line">d   <span class="number">6.0</span>    <span class="number">7.0</span>         <span class="number">8.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>列可以用columns关键字重新索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">102</span>]: states = [<span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;California&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: frame.reindex(columns=states)</span><br><span class="line">Out[<span class="number">103</span>]: </span><br><span class="line">   Texas  Utah  California</span><br><span class="line">a      <span class="number">1</span>   NaN           <span class="number">2</span></span><br><span class="line">c      <span class="number">4</span>   NaN           <span class="number">5</span></span><br><span class="line">d      <span class="number">7</span>   NaN           <span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表5-3列出了reindex函数的各参数及说明。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-efa3dbd4b83c61ec.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<h2 id="丢弃指定轴上的项">丢弃指定轴上的项</h2>
<p>丢弃某条轴上的一个或多个项很简单，只要有一个索引数组或列表即可。由于需要执行一些数据整理和集合逻辑，所以drop方法返回的是一个在指定轴上删除了指定值的新对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">105</span>]: obj = pd.Series(np.arange(<span class="number">5.</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: obj</span><br><span class="line">Out[<span class="number">106</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: new_obj = obj.drop(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">108</span>]: new_obj</span><br><span class="line">Out[<span class="number">108</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: obj.drop([<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">Out[<span class="number">109</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于DataFrame，可以删除任意轴上的索引值。为了演示，先新建一个DataFrame例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">110</span>]: data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                     index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>],</span><br><span class="line">   .....:                     columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: data</span><br><span class="line">Out[<span class="number">111</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用标签序列调用drop会从行标签（axis 0）删除值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">112</span>]: data.drop([<span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line">Out[<span class="number">112</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过传递axis=1或axis='columns'可以删除列的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">113</span>]: data.drop(<span class="string">&#x27;two&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">113</span>]: </span><br><span class="line">          one  three  four</span><br><span class="line">Ohio        <span class="number">0</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>     <span class="number">14</span>    <span class="number">15</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: data.drop([<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;four&#x27;</span>], axis=<span class="string">&#x27;columns&#x27;</span>)</span><br><span class="line">Out[<span class="number">114</span>]: </span><br><span class="line">          one  three</span><br><span class="line">Ohio        <span class="number">0</span>      <span class="number">2</span></span><br><span class="line">Colorado    <span class="number">4</span>      <span class="number">6</span></span><br><span class="line">Utah        <span class="number">8</span>     <span class="number">10</span></span><br><span class="line">New York   <span class="number">12</span>     <span class="number">14</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>许多函数，如drop，会修改Series或DataFrame的大小或形状，可以就地修改对象，不会返回新的对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">115</span>]: obj.drop(<span class="string">&#x27;c&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: obj</span><br><span class="line">Out[<span class="number">116</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>小心使用inplace，它会销毁所有被删除的数据。</p>
<h2 id="索引选取和过滤">索引、选取和过滤</h2>
<p>Series索引（obj[...]）的工作方式类似于NumPy数组的索引，只不过Series的索引值不只是整数。下面是几个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">117</span>]: obj = pd.Series(np.arange(<span class="number">4.</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: obj</span><br><span class="line">Out[<span class="number">118</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: obj[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">119</span>]: <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: obj[<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">120</span>]: <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: obj[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: obj[[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]]</span><br><span class="line">Out[<span class="number">122</span>]:</span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: obj[[<span class="number">1</span>, <span class="number">3</span>]]</span><br><span class="line">Out[<span class="number">123</span>]: </span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: obj[obj &lt; <span class="number">2</span>]</span><br><span class="line">Out[<span class="number">124</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>利用标签的切片运算与普通的Python切片运算不同，其末端是包含的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">125</span>]: obj[<span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">Out[<span class="number">125</span>]:</span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用切片可以对Series的相应部分进行设置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">126</span>]: obj[<span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;c&#x27;</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">127</span>]: obj</span><br><span class="line">Out[<span class="number">127</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">5.0</span></span><br><span class="line">c    <span class="number">5.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用一个值或序列对DataFrame进行索引其实就是获取一个或多个列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">128</span>]: data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                     index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>],</span><br><span class="line">   .....:                     columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: data</span><br><span class="line">Out[<span class="number">129</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">130</span>]: data[<span class="string">&#x27;two&#x27;</span>]</span><br><span class="line">Out[<span class="number">130</span>]: </span><br><span class="line">Ohio         <span class="number">1</span></span><br><span class="line">Colorado     <span class="number">5</span></span><br><span class="line">Utah         <span class="number">9</span></span><br><span class="line">New York    <span class="number">13</span></span><br><span class="line">Name: two, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">131</span>]: data[[<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;one&#x27;</span>]]</span><br><span class="line">Out[<span class="number">131</span>]: </span><br><span class="line">          three  one</span><br><span class="line">Ohio          <span class="number">2</span>    <span class="number">0</span></span><br><span class="line">Colorado      <span class="number">6</span>    <span class="number">4</span></span><br><span class="line">Utah         <span class="number">10</span>    <span class="number">8</span></span><br><span class="line">New York     <span class="number">14</span>   <span class="number">12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种索引方式有几个特殊的情况。首先通过切片或布尔型数组选取数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">132</span>]: data[:<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">132</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">133</span>]: data[data[<span class="string">&#x27;three&#x27;</span>] &gt; <span class="number">5</span>]</span><br><span class="line">Out[<span class="number">133</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>选取行的语法data[:2]十分方便。向[ ]传递单一的元素或列表，就可选择列。</p>
<p>另一种用法是通过布尔型DataFrame（比如下面这个由标量比较运算得出的）进行索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">134</span>]: data &lt; <span class="number">5</span></span><br><span class="line">Out[<span class="number">134</span>]: </span><br><span class="line">            one    two  three   four</span><br><span class="line">Ohio       <span class="literal">True</span>   <span class="literal">True</span>   <span class="literal">True</span>   <span class="literal">True</span></span><br><span class="line">Colorado   <span class="literal">True</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line">Utah      <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line">New York  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">135</span>]: data[data &lt; <span class="number">5</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: data</span><br><span class="line">Out[<span class="number">136</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">Colorado    <span class="number">0</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这使得DataFrame的语法与NumPy二维数组的语法很像。</p>
<h2 id="用loc和iloc进行选取">用loc和iloc进行选取</h2>
<p>对于DataFrame的行的标签索引，我引入了特殊的标签运算符loc和iloc。它们可以让你用类似NumPy的标记，使用轴标签（loc）或整数索引（iloc），从DataFrame选择行和列的子集。</p>
<p>作为一个初步示例，让我们通过标签选择一行和多列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">137</span>]: data.loc[<span class="string">&#x27;Colorado&#x27;</span>, [<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]]</span><br><span class="line">Out[<span class="number">137</span>]: </span><br><span class="line">two      <span class="number">5</span></span><br><span class="line">three    <span class="number">6</span></span><br><span class="line">Name: Colorado, dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后用iloc和整数进行选取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">138</span>]: data.iloc[<span class="number">2</span>, [<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">Out[<span class="number">138</span>]: </span><br><span class="line">four    <span class="number">11</span></span><br><span class="line">one      <span class="number">8</span></span><br><span class="line">two      <span class="number">9</span></span><br><span class="line">Name: Utah, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">139</span>]: data.iloc[<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">139</span>]: </span><br><span class="line">one       <span class="number">8</span></span><br><span class="line">two       <span class="number">9</span></span><br><span class="line">three    <span class="number">10</span></span><br><span class="line">four     <span class="number">11</span></span><br><span class="line">Name: Utah, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">140</span>]: data.iloc[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">Out[<span class="number">140</span>]: </span><br><span class="line">          four  one  two</span><br><span class="line">Colorado     <span class="number">7</span>    <span class="number">0</span>    <span class="number">5</span></span><br><span class="line">Utah        <span class="number">11</span>    <span class="number">8</span>    <span class="number">9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这两个索引函数也适用于一个标签或多个标签的切片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">141</span>]: data.loc[:<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;two&#x27;</span>]</span><br><span class="line">Out[<span class="number">141</span>]: </span><br><span class="line">Ohio        <span class="number">0</span></span><br><span class="line">Colorado    <span class="number">5</span></span><br><span class="line">Utah        <span class="number">9</span></span><br><span class="line">Name: two, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">142</span>]: data.iloc[:, :<span class="number">3</span>][data.three &gt; <span class="number">5</span>]</span><br><span class="line">Out[<span class="number">142</span>]: </span><br><span class="line">          one  two  three</span><br><span class="line">Colorado    <span class="number">0</span>    <span class="number">5</span>      <span class="number">6</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>所以，在pandas中，有多个方法可以选取和重新组合数据。对于DataFrame，表5-4进行了总结。后面会看到，还有更多的方法进行层级化索引。</p>
<blockquote>
<p>笔记：在一开始设计pandas时，我觉得用frame[:, col]选取列过于繁琐（也容易出错），因为列的选择是非常常见的操作。我做了些取舍，将花式索引的功能（标签和整数）放到了ix运算符中。在实践中，这会导致许多边缘情况，数据的轴标签是整数，所以pandas团队决定创造loc和iloc运算符分别处理严格基于标签和整数的索引。 ix运算符仍然可用，但并不推荐。</p>
</blockquote>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-64354f2ab777bd8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表5-4 DataFrame的索引选项" /><figcaption aria-hidden="true">表5-4 DataFrame的索引选项</figcaption>
</figure>
<h2 id="整数索引">整数索引</h2>
<p>处理整数索引的pandas对象常常难住新手，因为它与Python内置的列表和元组的索引语法不同。例如，你可能不认为下面的代码会出错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ser = pd.Series(np.arange(<span class="number">3.</span>))</span><br><span class="line">ser</span><br><span class="line">ser[-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，pandas可以勉强进行整数索引，但是会导致小bug。我们有包含0,1,2的索引，但是引入用户想要的东西（基于标签或位置的索引）很难：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">144</span>]: ser</span><br><span class="line">Out[<span class="number">144</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外，对于非整数索引，不会产生歧义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">145</span>]: ser2 = pd.Series(np.arange(<span class="number">3.</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">146</span>]: ser2[-<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">146</span>]: <span class="number">2.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了进行统一，如果轴索引含有整数，数据选取总会使用标签。为了更准确，请使用loc（标签）或iloc（整数）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">147</span>]: ser[:<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">147</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">0.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">148</span>]: ser.loc[:<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">148</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">149</span>]: ser.iloc[:<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">149</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">0.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="算术运算和数据对齐">算术运算和数据对齐</h2>
<p>pandas最重要的一个功能是，它可以对不同索引的对象进行算术运算。在将对象相加时，如果存在不同的索引对，则结果的索引就是该索引对的并集。对于有数据库经验的用户，这就像在索引标签上进行自动外连接。看一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">150</span>]: s1 = pd.Series([<span class="number">7.3</span>, -<span class="number">2.5</span>, <span class="number">3.4</span>, <span class="number">1.5</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">151</span>]: s2 = pd.Series([-<span class="number">2.1</span>, <span class="number">3.6</span>, -<span class="number">1.5</span>, <span class="number">4</span>, <span class="number">3.1</span>],</span><br><span class="line">   .....:                index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">152</span>]: s1</span><br><span class="line">Out[<span class="number">152</span>]: </span><br><span class="line">a    <span class="number">7.3</span></span><br><span class="line">c   -<span class="number">2.5</span></span><br><span class="line">d    <span class="number">3.4</span></span><br><span class="line">e    <span class="number">1.5</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">153</span>]: s2</span><br><span class="line">Out[<span class="number">153</span>]: </span><br><span class="line">a   -<span class="number">2.1</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">e   -<span class="number">1.5</span></span><br><span class="line">f    <span class="number">4.0</span></span><br><span class="line">g    <span class="number">3.1</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将它们相加就会产生：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">154</span>]: s1 + s2</span><br><span class="line">Out[<span class="number">154</span>]: </span><br><span class="line">a    <span class="number">5.2</span></span><br><span class="line">c    <span class="number">1.1</span></span><br><span class="line">d    NaN</span><br><span class="line">e    <span class="number">0.0</span></span><br><span class="line">f    NaN</span><br><span class="line">g    NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自动的数据对齐操作在不重叠的索引处引入了NA值。缺失值会在算术运算过程中传播。</p>
<p>对于DataFrame，对齐操作会同时发生在行和列上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">155</span>]: df1 = pd.DataFrame(np.arange(<span class="number">9.</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)), columns=<span class="built_in">list</span>(<span class="string">&#x27;bcd&#x27;</span>),</span><br><span class="line">   .....:                    index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">156</span>]: df2 = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)), columns=<span class="built_in">list</span>(<span class="string">&#x27;bde&#x27;</span>),</span><br><span class="line">   .....:                    index=[<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">157</span>]: df1</span><br><span class="line">Out[<span class="number">157</span>]: </span><br><span class="line">            b    c    d</span><br><span class="line">Ohio      <span class="number">0.0</span>  <span class="number">1.0</span>  <span class="number">2.0</span></span><br><span class="line">Texas     <span class="number">3.0</span>  <span class="number">4.0</span>  <span class="number">5.0</span></span><br><span class="line">Colorado  <span class="number">6.0</span>  <span class="number">7.0</span>  <span class="number">8.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">158</span>]: df2</span><br><span class="line">Out[<span class="number">158</span>]: </span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>把它们相加后将会返回一个新的DataFrame，其索引和列为原来那两个DataFrame的并集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">159</span>]: df1 + df2</span><br><span class="line">Out[<span class="number">159</span>]: </span><br><span class="line">            b   c     d   e</span><br><span class="line">Colorado  NaN NaN   NaN NaN</span><br><span class="line">Ohio      <span class="number">3.0</span> NaN   <span class="number">6.0</span> NaN</span><br><span class="line">Oregon    NaN NaN   NaN NaN</span><br><span class="line">Texas     <span class="number">9.0</span> NaN  <span class="number">12.0</span> NaN</span><br><span class="line">Utah      NaN NaN   NaN NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为'c'和'e'列均不在两个DataFrame对象中，在结果中以缺省值呈现。行也是同样。</p>
<p>如果DataFrame对象相加，没有共用的列或行标签，结果都会是空：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">160</span>]: df1 = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">161</span>]: df2 = pd.DataFrame(&#123;<span class="string">&#x27;B&#x27;</span>: [<span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">162</span>]: df1</span><br><span class="line">Out[<span class="number">162</span>]: </span><br><span class="line">   A</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">163</span>]: df2</span><br><span class="line">Out[<span class="number">163</span>]: </span><br><span class="line">   B</span><br><span class="line"><span class="number">0</span>  <span class="number">3</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">164</span>]: df1 - df2</span><br><span class="line">Out[<span class="number">164</span>]: </span><br><span class="line">    A   B</span><br><span class="line"><span class="number">0</span> NaN NaN</span><br><span class="line"><span class="number">1</span> NaN NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="在算术方法中填充值">在算术方法中填充值</h2>
<p>在对不同索引的对象进行算术运算时，你可能希望当一个对象中某个轴标签在另一个对象中找不到时填充一个特殊值（比如0）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">165</span>]: df1 = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                    columns=<span class="built_in">list</span>(<span class="string">&#x27;abcd&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">166</span>]: df2 = pd.DataFrame(np.arange(<span class="number">20.</span>).reshape((<span class="number">4</span>, <span class="number">5</span>)),</span><br><span class="line">   .....:                    columns=<span class="built_in">list</span>(<span class="string">&#x27;abcde&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">167</span>]: df2.loc[<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="number">168</span>]: df1</span><br><span class="line">Out[<span class="number">168</span>]: </span><br><span class="line">     a    b     c     d</span><br><span class="line"><span class="number">0</span>  <span class="number">0.0</span>  <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4.0</span>  <span class="number">5.0</span>   <span class="number">6.0</span>   <span class="number">7.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">8.0</span>  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">169</span>]: df2</span><br><span class="line">Out[<span class="number">169</span>]: </span><br><span class="line">      a     b     c     d     e</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span>   <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">5.0</span>   NaN   <span class="number">7.0</span>   <span class="number">8.0</span>   <span class="number">9.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">10.0</span>  <span class="number">11.0</span>  <span class="number">12.0</span>  <span class="number">13.0</span>  <span class="number">14.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">15.0</span>  <span class="number">16.0</span>  <span class="number">17.0</span>  <span class="number">18.0</span>  <span class="number">19.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将它们相加时，没有重叠的位置就会产生NA值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">170</span>]: df1 + df2</span><br><span class="line">Out[<span class="number">170</span>]: </span><br><span class="line">      a     b     c     d   e</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>   <span class="number">2.0</span>   <span class="number">4.0</span>   <span class="number">6.0</span> NaN</span><br><span class="line"><span class="number">1</span>   <span class="number">9.0</span>   NaN  <span class="number">13.0</span>  <span class="number">15.0</span> NaN</span><br><span class="line"><span class="number">2</span>  <span class="number">18.0</span>  <span class="number">20.0</span>  <span class="number">22.0</span>  <span class="number">24.0</span> NaN</span><br><span class="line"><span class="number">3</span>   NaN   NaN   NaN   NaN NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用df1的add方法，传入df2以及一个fill_value参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">171</span>]: df1.add(df2, fill_value=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">171</span>]: </span><br><span class="line">      a     b     c     d     e</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>   <span class="number">2.0</span>   <span class="number">4.0</span>   <span class="number">6.0</span>   <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">9.0</span>   <span class="number">5.0</span>  <span class="number">13.0</span>  <span class="number">15.0</span>   <span class="number">9.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">18.0</span>  <span class="number">20.0</span>  <span class="number">22.0</span>  <span class="number">24.0</span>  <span class="number">14.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">15.0</span>  <span class="number">16.0</span>  <span class="number">17.0</span>  <span class="number">18.0</span>  <span class="number">19.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表5-5列出了Series和DataFrame的算术方法。它们每个都有一个副本，以字母r开头，它会翻转参数。因此这两个语句是等价的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">172</span>]: <span class="number">1</span> / df1</span><br><span class="line">Out[<span class="number">172</span>]: </span><br><span class="line">          a         b         c         d</span><br><span class="line"><span class="number">0</span>       inf  <span class="number">1.000000</span>  <span class="number">0.500000</span>  <span class="number">0.333333</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.250000</span>  <span class="number">0.200000</span>  <span class="number">0.166667</span>  <span class="number">0.142857</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.125000</span>  <span class="number">0.111111</span>  <span class="number">0.100000</span>  <span class="number">0.090909</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">173</span>]: df1.rdiv(<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">173</span>]: </span><br><span class="line">          a         b         c         d</span><br><span class="line"><span class="number">0</span>       inf  <span class="number">1.000000</span>  <span class="number">0.500000</span>  <span class="number">0.333333</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.250000</span>  <span class="number">0.200000</span>  <span class="number">0.166667</span>  <span class="number">0.142857</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.125000</span>  <span class="number">0.111111</span>  <span class="number">0.100000</span>  <span class="number">0.090909</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-16857a1021f98d1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表5-5 灵活的算术方法" /><figcaption aria-hidden="true">表5-5 灵活的算术方法</figcaption>
</figure>
<p>与此类似，在对Series或DataFrame重新索引时，也可以指定一个填充值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">174</span>]: df1.reindex(columns=df2.columns, fill_value=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">174</span>]: </span><br><span class="line">     a    b     c     d  e</span><br><span class="line"><span class="number">0</span>  <span class="number">0.0</span>  <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4.0</span>  <span class="number">5.0</span>   <span class="number">6.0</span>   <span class="number">7.0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">8.0</span>  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span>  <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="dataframe和series之间的运算">DataFrame和Series之间的运算</h2>
<p>跟不同维度的NumPy数组一样，DataFrame和Series之间算术运算也是有明确规定的。先来看一个具有启发性的例子，计算一个二维数组与其某行之间的差：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">175</span>]: arr = np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">176</span>]: arr</span><br><span class="line">Out[<span class="number">176</span>]: </span><br><span class="line">array([[  <span class="number">0.</span>,   <span class="number">1.</span>,   <span class="number">2.</span>,   <span class="number">3.</span>],</span><br><span class="line">       [  <span class="number">4.</span>,   <span class="number">5.</span>,   <span class="number">6.</span>,   <span class="number">7.</span>],</span><br><span class="line">       [  <span class="number">8.</span>,   <span class="number">9.</span>,  <span class="number">10.</span>,  <span class="number">11.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">177</span>]: arr[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">177</span>]: array([ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">178</span>]: arr - arr[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">178</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>],</span><br><span class="line">       [ <span class="number">8.</span>,  <span class="number">8.</span>,  <span class="number">8.</span>,  <span class="number">8.</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当我们从arr减去arr[0]，每一行都会执行这个操作。这就叫做广播（broadcasting），附录A将对此进行详细讲解。DataFrame和Series之间的运算差不多也是如此：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">179</span>]: frame = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)),</span><br><span class="line">   .....:                      columns=<span class="built_in">list</span>(<span class="string">&#x27;bde&#x27;</span>),</span><br><span class="line">   .....:                      index=[<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">180</span>]: series = frame.iloc[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">181</span>]: frame</span><br><span class="line">Out[<span class="number">181</span>]: </span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">182</span>]: series</span><br><span class="line">Out[<span class="number">182</span>]: </span><br><span class="line">b    <span class="number">0.0</span></span><br><span class="line">d    <span class="number">1.0</span></span><br><span class="line">e    <span class="number">2.0</span></span><br><span class="line">Name: Utah, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认情况下，DataFrame和Series之间的算术运算会将Series的索引匹配到DataFrame的列，然后沿着行一直向下广播：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">183</span>]: frame - series</span><br><span class="line">Out[<span class="number">183</span>]: </span><br><span class="line">          b    d    e</span><br><span class="line">Utah    <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>  <span class="number">3.0</span>  <span class="number">3.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>  <span class="number">6.0</span>  <span class="number">6.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">9.0</span>  <span class="number">9.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果某个索引值在DataFrame的列或Series的索引中找不到，则参与运算的两个对象就会被重新索引以形成并集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">184</span>]: series2 = pd.Series(<span class="built_in">range</span>(<span class="number">3</span>), index=[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">185</span>]: frame + series2</span><br><span class="line">Out[<span class="number">185</span>]: </span><br><span class="line">          b   d     e   f</span><br><span class="line">Utah    <span class="number">0.0</span> NaN   <span class="number">3.0</span> NaN</span><br><span class="line">Ohio    <span class="number">3.0</span> NaN   <span class="number">6.0</span> NaN</span><br><span class="line">Texas   <span class="number">6.0</span> NaN   <span class="number">9.0</span> NaN</span><br><span class="line">Oregon  <span class="number">9.0</span> NaN  <span class="number">12.0</span> NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你希望匹配行且在列上广播，则必须使用算术运算方法。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">186</span>]: series3 = frame[<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">187</span>]: frame</span><br><span class="line">Out[<span class="number">187</span>]: </span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">188</span>]: series3</span><br><span class="line">Out[<span class="number">188</span>]: </span><br><span class="line">Utah       <span class="number">1.0</span></span><br><span class="line">Ohio       <span class="number">4.0</span></span><br><span class="line">Texas      <span class="number">7.0</span></span><br><span class="line">Oregon    <span class="number">10.0</span></span><br><span class="line">Name: d, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">189</span>]: frame.sub(series3, axis=<span class="string">&#x27;index&#x27;</span>)</span><br><span class="line">Out[<span class="number">189</span>]: </span><br><span class="line">          b    d    e</span><br><span class="line">Utah   -<span class="number">1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line">Ohio   -<span class="number">1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line">Texas  -<span class="number">1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line">Oregon -<span class="number">1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传入的轴号就是希望匹配的轴。在本例中，我们的目的是匹配DataFrame的行索引（axis='index' or axis=0）并进行广播。</p>
<h2 id="函数应用和映射">函数应用和映射</h2>
<p>NumPy的ufuncs（元素级数组方法）也可用于操作pandas对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">190</span>]: frame = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>), columns=<span class="built_in">list</span>(<span class="string">&#x27;bde&#x27;</span>),</span><br><span class="line">   .....:                      index=[<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">191</span>]: frame</span><br><span class="line">Out[<span class="number">191</span>]: </span><br><span class="line">               b         d         e</span><br><span class="line">Utah   -<span class="number">0.204708</span>  <span class="number">0.478943</span> -<span class="number">0.519439</span></span><br><span class="line">Ohio   -<span class="number">0.555730</span>  <span class="number">1.965781</span>  <span class="number">1.393406</span></span><br><span class="line">Texas   <span class="number">0.092908</span>  <span class="number">0.281746</span>  <span class="number">0.769023</span></span><br><span class="line">Oregon  <span class="number">1.246435</span>  <span class="number">1.007189</span> -<span class="number">1.296221</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">192</span>]: np.<span class="built_in">abs</span>(frame)</span><br><span class="line">Out[<span class="number">192</span>]: </span><br><span class="line">               b         d         e</span><br><span class="line">Utah    <span class="number">0.204708</span>  <span class="number">0.478943</span>  <span class="number">0.519439</span></span><br><span class="line">Ohio    <span class="number">0.555730</span>  <span class="number">1.965781</span>  <span class="number">1.393406</span></span><br><span class="line">Texas   <span class="number">0.092908</span>  <span class="number">0.281746</span>  <span class="number">0.769023</span></span><br><span class="line">Oregon  <span class="number">1.246435</span>  <span class="number">1.007189</span>  <span class="number">1.296221</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另一个常见的操作是，将函数应用到由各列或行所形成的一维数组上。DataFrame的apply方法即可实现此功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">193</span>]: f = <span class="keyword">lambda</span> x: x.<span class="built_in">max</span>() - x.<span class="built_in">min</span>()</span><br><span class="line"></span><br><span class="line">In [<span class="number">194</span>]: frame.apply(f)</span><br><span class="line">Out[<span class="number">194</span>]: </span><br><span class="line">b    <span class="number">1.802165</span></span><br><span class="line">d    <span class="number">1.684034</span></span><br><span class="line">e    <span class="number">2.689627</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的函数f，计算了一个Series的最大值和最小值的差，在frame的每列都执行了一次。结果是一个Series，使用frame的列作为索引。</p>
<p>如果传递axis='columns'到apply，这个函数会在每行执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">195</span>]: frame.apply(f, axis=<span class="string">&#x27;columns&#x27;</span>)</span><br><span class="line">Out[<span class="number">195</span>]:</span><br><span class="line">Utah      <span class="number">0.998382</span></span><br><span class="line">Ohio      <span class="number">2.521511</span></span><br><span class="line">Texas     <span class="number">0.676115</span></span><br><span class="line">Oregon    <span class="number">2.542656</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>许多最为常见的数组统计功能都被实现成DataFrame的方法（如sum和mean），因此无需使用apply方法。</p>
<p>传递到apply的函数不是必须返回一个标量，还可以返回由多个值组成的Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">196</span>]: <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">   .....:     <span class="keyword">return</span> pd.Series([x.<span class="built_in">min</span>(), x.<span class="built_in">max</span>()], index=[<span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;max&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">197</span>]: frame.apply(f)</span><br><span class="line">Out[<span class="number">197</span>]: </span><br><span class="line">            b         d         e</span><br><span class="line"><span class="built_in">min</span> -<span class="number">0.555730</span>  <span class="number">0.281746</span> -<span class="number">1.296221</span></span><br><span class="line"><span class="built_in">max</span>  <span class="number">1.246435</span>  <span class="number">1.965781</span>  <span class="number">1.393406</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>元素级的Python函数也是可以用的。假如你想得到frame中各个浮点值的格式化字符串，使用applymap即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">198</span>]: <span class="built_in">format</span> = <span class="keyword">lambda</span> x: <span class="string">&#x27;%.2f&#x27;</span> % x</span><br><span class="line"></span><br><span class="line">In [<span class="number">199</span>]: frame.applymap(<span class="built_in">format</span>)</span><br><span class="line">Out[<span class="number">199</span>]: </span><br><span class="line">            b     d      e</span><br><span class="line">Utah    -<span class="number">0.20</span>  <span class="number">0.48</span>  -<span class="number">0.52</span></span><br><span class="line">Ohio    -<span class="number">0.56</span>  <span class="number">1.97</span>   <span class="number">1.39</span></span><br><span class="line">Texas    <span class="number">0.09</span>  <span class="number">0.28</span>   <span class="number">0.77</span></span><br><span class="line">Oregon   <span class="number">1.25</span>  <span class="number">1.01</span>  -<span class="number">1.30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之所以叫做applymap，是因为Series有一个用于应用元素级函数的map方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">200</span>]: frame[<span class="string">&#x27;e&#x27;</span>].<span class="built_in">map</span>(<span class="built_in">format</span>)</span><br><span class="line">Out[<span class="number">200</span>]: </span><br><span class="line">Utah      -<span class="number">0.52</span></span><br><span class="line">Ohio       <span class="number">1.39</span></span><br><span class="line">Texas      <span class="number">0.77</span></span><br><span class="line">Oregon    -<span class="number">1.30</span></span><br><span class="line">Name: e, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="排序和排名">排序和排名</h2>
<p>根据条件对数据集排序（sorting）也是一种重要的内置运算。要对行或列索引进行排序（按字典顺序），可使用sort_index方法，它将返回一个已排序的新对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">201</span>]: obj = pd.Series(<span class="built_in">range</span>(<span class="number">4</span>), index=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">202</span>]: obj.sort_index()</span><br><span class="line">Out[<span class="number">202</span>]:</span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">d    <span class="number">0</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于DataFrame，则可以根据任意一个轴上的索引进行排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">203</span>]: frame = pd.DataFrame(np.arange(<span class="number">8</span>).reshape((<span class="number">2</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                      index=[<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">   .....:                      columns=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">204</span>]: frame.sort_index()</span><br><span class="line">Out[<span class="number">204</span>]: </span><br><span class="line">       d  a  b  c</span><br><span class="line">one    <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br><span class="line">three  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">205</span>]: frame.sort_index(axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">205</span>]:</span><br><span class="line">       a  b  c  d</span><br><span class="line">three  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">0</span></span><br><span class="line">one    <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数据默认是按升序排序的，但也可以降序排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">206</span>]: frame.sort_index(axis=<span class="number">1</span>, ascending=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">206</span>]: </span><br><span class="line">       d  c  b  a</span><br><span class="line">three  <span class="number">0</span>  <span class="number">3</span>  <span class="number">2</span>  <span class="number">1</span></span><br><span class="line">one    <span class="number">4</span>  <span class="number">7</span>  <span class="number">6</span>  <span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>若要按值对Series进行排序，可使用其sort_values方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">207</span>]: obj = pd.Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">208</span>]: obj.sort_values()</span><br><span class="line">Out[<span class="number">208</span>]: </span><br><span class="line"><span class="number">2</span>   -<span class="number">3</span></span><br><span class="line"><span class="number">3</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在排序时，任何缺失值默认都会被放到Series的末尾：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">209</span>]: obj = pd.Series([<span class="number">4</span>, np.nan, <span class="number">7</span>, np.nan, -<span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">210</span>]: obj.sort_values()</span><br><span class="line">Out[<span class="number">210</span>]: </span><br><span class="line"><span class="number">4</span>   -<span class="number">3.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">0</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">7.0</span></span><br><span class="line"><span class="number">1</span>    NaN</span><br><span class="line"><span class="number">3</span>    NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当排序一个DataFrame时，你可能希望根据一个或多个列中的值进行排序。将一个或多个列的名字传递给sort_values的by选项即可达到该目的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">211</span>]: frame = pd.DataFrame(&#123;<span class="string">&#x27;b&#x27;</span>: [<span class="number">4</span>, <span class="number">7</span>, -<span class="number">3</span>, <span class="number">2</span>], <span class="string">&#x27;a&#x27;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">212</span>]: frame</span><br><span class="line">Out[<span class="number">212</span>]: </span><br><span class="line">   a  b</span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">7</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0</span> -<span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">213</span>]: frame.sort_values(by=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">Out[<span class="number">213</span>]: </span><br><span class="line">   a  b</span><br><span class="line"><span class="number">2</span>  <span class="number">0</span> -<span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要根据多个列进行排序，传入名称的列表即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">214</span>]: frame.sort_values(by=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">Out[<span class="number">214</span>]: </span><br><span class="line">   a  b</span><br><span class="line"><span class="number">2</span>  <span class="number">0</span> -<span class="number">3</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>排名会从1开始一直到数组中有效数据的数量。接下来介绍Series和DataFrame的rank方法。默认情况下，rank是通过“为各组分配一个平均排名”的方式破坏平级关系的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">215</span>]: obj = pd.Series([<span class="number">7</span>, -<span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>])</span><br><span class="line">In [<span class="number">216</span>]: obj.rank()</span><br><span class="line">Out[<span class="number">216</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">6.5</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">6.5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">4.5</span></span><br><span class="line"><span class="number">4</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">4.5</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以根据值在原数据中出现的顺序给出排名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">217</span>]: obj.rank(method=<span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">Out[<span class="number">217</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">6.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">7.0</span></span><br><span class="line"><span class="number">3</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">4</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">5.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，条目0和2没有使用平均排名6.5，它们被设成了6和7，因为数据中标签0位于标签2的前面。</p>
<p>你也可以按降序进行排名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Assign tie values the maximum rank in the group</span></span><br><span class="line">In [<span class="number">218</span>]: obj.rank(ascending=<span class="literal">False</span>, method=<span class="string">&#x27;max&#x27;</span>)</span><br><span class="line">Out[<span class="number">218</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">4</span>    <span class="number">5.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">6.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表5-6列出了所有用于破坏平级关系的method选项。DataFrame可以在行或列上计算排名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">219</span>]: frame = pd.DataFrame(&#123;<span class="string">&#x27;b&#x27;</span>: [<span class="number">4.3</span>, <span class="number">7</span>, -<span class="number">3</span>, <span class="number">2</span>], <span class="string">&#x27;a&#x27;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">   .....:                       <span class="string">&#x27;c&#x27;</span>: [-<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, -<span class="number">2.5</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">220</span>]: frame</span><br><span class="line">Out[<span class="number">220</span>]: </span><br><span class="line">   a    b    c</span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">4.3</span> -<span class="number">2.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">7.0</span>  <span class="number">5.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0</span> -<span class="number">3.0</span>  <span class="number">8.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1</span>  <span class="number">2.0</span> -<span class="number">2.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">221</span>]: frame.rank(axis=<span class="string">&#x27;columns&#x27;</span>)</span><br><span class="line">Out[<span class="number">221</span>]: </span><br><span class="line">     a    b    c</span><br><span class="line"><span class="number">0</span>  <span class="number">2.0</span>  <span class="number">3.0</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  <span class="number">3.0</span>  <span class="number">2.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2.0</span>  <span class="number">1.0</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2.0</span>  <span class="number">3.0</span>  <span class="number">1.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-7edfab5b4a147581.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表5-6 排名时用于破坏平级关系的方法" /><figcaption aria-hidden="true">表5-6 排名时用于破坏平级关系的方法</figcaption>
</figure>
<h2 id="带有重复标签的轴索引">带有重复标签的轴索引</h2>
<p>直到目前为止，我所介绍的所有范例都有着唯一的轴标签（索引值）。虽然许多pandas函数（如reindex）都要求标签唯一，但这并不是强制性的。我们来看看下面这个简单的带有重复索引值的Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">222</span>]: obj = pd.Series(<span class="built_in">range</span>(<span class="number">5</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">223</span>]: obj</span><br><span class="line">Out[<span class="number">223</span>]: </span><br><span class="line">a    <span class="number">0</span></span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">b    <span class="number">3</span></span><br><span class="line">c    <span class="number">4</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>索引的is_unique属性可以告诉你它的值是否是唯一的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">224</span>]: obj.index.is_unique</span><br><span class="line">Out[<span class="number">224</span>]: <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于带有重复值的索引，数据选取的行为将会有些不同。如果某个索引对应多个值，则返回一个Series；而对应单个值的，则返回一个标量值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">225</span>]: obj[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">Out[<span class="number">225</span>]: </span><br><span class="line">a    <span class="number">0</span></span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">226</span>]: obj[<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">Out[<span class="number">226</span>]: <span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样会使代码变复杂，因为索引的输出类型会根据标签是否有重复发生变化。</p>
<p>对DataFrame的行进行索引时也是如此：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">227</span>]: df = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">228</span>]: df</span><br><span class="line">Out[<span class="number">228</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line">a  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line">a  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span></span><br><span class="line">b  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br><span class="line">b  <span class="number">0.476985</span>  <span class="number">3.248944</span> -<span class="number">1.021228</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">229</span>]: df.loc[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">229</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line">b  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br><span class="line">b  <span class="number">0.476985</span>  <span class="number">3.248944</span> -<span class="number">1.021228</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="汇总和计算描述统计">5.3 汇总和计算描述统计</h1>
<p>pandas对象拥有一组常用的数学和统计方法。它们大部分都属于约简和汇总统计，用于从Series中提取单个值（如sum或mean）或从DataFrame的行或列中提取一个Series。跟对应的NumPy数组方法相比，它们都是基于没有缺失数据的假设而构建的。看一个简单的DataFrame：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">230</span>]: df = pd.DataFrame([[<span class="number">1.4</span>, np.nan], [<span class="number">7.1</span>, -<span class="number">4.5</span>],</span><br><span class="line">   .....:                    [np.nan, np.nan], [<span class="number">0.75</span>, -<span class="number">1.3</span>]],</span><br><span class="line">   .....:                   index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">   .....:                   columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">231</span>]: df</span><br><span class="line">Out[<span class="number">231</span>]: </span><br><span class="line">    one  two</span><br><span class="line">a  <span class="number">1.40</span>  NaN</span><br><span class="line">b  <span class="number">7.10</span> -<span class="number">4.5</span></span><br><span class="line">c   NaN  NaN</span><br><span class="line">d  <span class="number">0.75</span> -<span class="number">1.3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调用DataFrame的sum方法将会返回一个含有列的和的Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">232</span>]: df.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">232</span>]: </span><br><span class="line">one    <span class="number">9.25</span></span><br><span class="line">two   -<span class="number">5.80</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传入axis='columns'或axis=1将会按行进行求和运算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">233</span>]: df.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">233</span>]:</span><br><span class="line">a    <span class="number">1.40</span></span><br><span class="line">b    <span class="number">2.60</span></span><br><span class="line">c     NaN</span><br><span class="line">d   -<span class="number">0.55</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>NA值会自动被排除，除非整个切片（这里指的是行或列）都是NA。通过skipna选项可以禁用该功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">234</span>]: df.mean(axis=<span class="string">&#x27;columns&#x27;</span>, skipna=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">234</span>]: </span><br><span class="line">a      NaN</span><br><span class="line">b    <span class="number">1.300</span></span><br><span class="line">c      NaN</span><br><span class="line">d   -<span class="number">0.275</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表5-7列出了这些约简方法的常用选项。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-af35e3809278410e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>有些方法（如idxmin和idxmax）返回的是间接统计（比如达到最小值或最大值的索引）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">235</span>]: df.idxmax()</span><br><span class="line">Out[<span class="number">235</span>]: </span><br><span class="line">one    b</span><br><span class="line">two    d</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另一些方法则是累计型的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">236</span>]: df.cumsum()</span><br><span class="line">Out[<span class="number">236</span>]: </span><br><span class="line">    one  two</span><br><span class="line">a  <span class="number">1.40</span>  NaN</span><br><span class="line">b  <span class="number">8.50</span> -<span class="number">4.5</span></span><br><span class="line">c   NaN  NaN</span><br><span class="line">d  <span class="number">9.25</span> -<span class="number">5.8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还有一种方法，它既不是约简型也不是累计型。describe就是一个例子，它用于一次性产生多个汇总统计：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">237</span>]: df.describe()</span><br><span class="line">Out[<span class="number">237</span>]: </span><br><span class="line">            one       two</span><br><span class="line">count  <span class="number">3.000000</span>  <span class="number">2.000000</span></span><br><span class="line">mean   <span class="number">3.083333</span> -<span class="number">2.900000</span></span><br><span class="line">std    <span class="number">3.493685</span>  <span class="number">2.262742</span></span><br><span class="line"><span class="built_in">min</span>    <span class="number">0.750000</span> -<span class="number">4.500000</span></span><br><span class="line"><span class="number">25</span>%    <span class="number">1.075000</span> -<span class="number">3.700000</span></span><br><span class="line"><span class="number">50</span>%    <span class="number">1.400000</span> -<span class="number">2.900000</span></span><br><span class="line"><span class="number">75</span>%    <span class="number">4.250000</span> -<span class="number">2.100000</span></span><br><span class="line"><span class="built_in">max</span>    <span class="number">7.100000</span> -<span class="number">1.300000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于非数值型数据，describe会产生另外一种汇总统计：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">238</span>]: obj = pd.Series([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>] * <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">239</span>]: obj.describe()</span><br><span class="line">Out[<span class="number">239</span>]: </span><br><span class="line">count     <span class="number">16</span></span><br><span class="line">unique     <span class="number">3</span></span><br><span class="line">top        a</span><br><span class="line">freq       <span class="number">8</span></span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表5-8列出了所有与描述统计相关的方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-11fa967f658ac314.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<h2 id="相关系数与协方差">相关系数与协方差</h2>
<p>有些汇总统计（如相关系数和协方差）是通过参数对计算出来的。我们来看几个DataFrame，它们的数据来自Yahoo!Finance的股票价格和成交量，使用的是pandas-datareader包（可以用conda或pip安装）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conda install pandas-datareader</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我使用pandas_datareader模块下载了一些股票数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas_datareader.data <span class="keyword">as</span> web</span><br><span class="line">all_data = &#123;ticker: web.get_data_yahoo(ticker)</span><br><span class="line">            <span class="keyword">for</span> ticker <span class="keyword">in</span> [<span class="string">&#x27;AAPL&#x27;</span>, <span class="string">&#x27;IBM&#x27;</span>, <span class="string">&#x27;MSFT&#x27;</span>, <span class="string">&#x27;GOOG&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line">price = pd.DataFrame(&#123;ticker: data[<span class="string">&#x27;Adj Close&#x27;</span>]</span><br><span class="line">                     <span class="keyword">for</span> ticker, data <span class="keyword">in</span> all_data.items()&#125;)</span><br><span class="line">volume = pd.DataFrame(&#123;ticker: data[<span class="string">&#x27;Volume&#x27;</span>]</span><br><span class="line">                      <span class="keyword">for</span> ticker, data <span class="keyword">in</span> all_data.items()&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：此时Yahoo! Finance已经不存在了，因为2017年Yahoo!被Verizon收购了。参阅pandas-datareader文档，可以学习最新的功能。</p>
</blockquote>
<p>现在计算价格的百分数变化，时间序列的操作会在第11章介绍：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">242</span>]: returns = price.pct_change()</span><br><span class="line"></span><br><span class="line">In [<span class="number">243</span>]: returns.tail()</span><br><span class="line">Out[<span class="number">243</span>]: </span><br><span class="line">                AAPL      GOOG       IBM      MSFT</span><br><span class="line">Date                                              </span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">17</span> -<span class="number">0.000680</span>  <span class="number">0.001837</span>  <span class="number">0.002072</span> -<span class="number">0.003483</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">18</span> -<span class="number">0.000681</span>  <span class="number">0.019616</span> -<span class="number">0.026168</span>  <span class="number">0.007690</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">19</span> -<span class="number">0.002979</span>  <span class="number">0.007846</span>  <span class="number">0.003583</span> -<span class="number">0.002255</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">20</span> -<span class="number">0.000512</span> -<span class="number">0.005652</span>  <span class="number">0.001719</span> -<span class="number">0.004867</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">21</span> -<span class="number">0.003930</span>  <span class="number">0.003011</span> -<span class="number">0.012474</span>  <span class="number">0.042096</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Series的corr方法用于计算两个Series中重叠的、非NA的、按索引对齐的值的相关系数。与此类似，cov用于计算协方差：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">244</span>]: returns[<span class="string">&#x27;MSFT&#x27;</span>].corr(returns[<span class="string">&#x27;IBM&#x27;</span>])</span><br><span class="line">Out[<span class="number">244</span>]: <span class="number">0.49976361144151144</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">245</span>]: returns[<span class="string">&#x27;MSFT&#x27;</span>].cov(returns[<span class="string">&#x27;IBM&#x27;</span>])</span><br><span class="line">Out[<span class="number">245</span>]: <span class="number">8.8706554797035462e-05</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为MSTF是一个合理的Python属性，我们还可以用更简洁的语法选择列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">246</span>]: returns.MSFT.corr(returns.IBM)</span><br><span class="line">Out[<span class="number">246</span>]: <span class="number">0.49976361144151144</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另一方面，DataFrame的corr和cov方法将以DataFrame的形式分别返回完整的相关系数或协方差矩阵：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">247</span>]: returns.corr()</span><br><span class="line">Out[<span class="number">247</span>]: </span><br><span class="line">          AAPL      GOOG       IBM      MSFT</span><br><span class="line">AAPL  <span class="number">1.000000</span>  <span class="number">0.407919</span>  <span class="number">0.386817</span>  <span class="number">0.389695</span></span><br><span class="line">GOOG  <span class="number">0.407919</span>  <span class="number">1.000000</span>  <span class="number">0.405099</span>  <span class="number">0.465919</span></span><br><span class="line">IBM   <span class="number">0.386817</span>  <span class="number">0.405099</span>  <span class="number">1.000000</span>  <span class="number">0.499764</span></span><br><span class="line">MSFT  <span class="number">0.389695</span>  <span class="number">0.465919</span>  <span class="number">0.499764</span>  <span class="number">1.000000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">248</span>]: returns.cov()</span><br><span class="line">Out[<span class="number">248</span>]: </span><br><span class="line">          AAPL      GOOG       IBM      MSFT</span><br><span class="line">AAPL  <span class="number">0.000277</span>  <span class="number">0.000107</span>  <span class="number">0.000078</span>  <span class="number">0.000095</span></span><br><span class="line">GOOG  <span class="number">0.000107</span>  <span class="number">0.000251</span>  <span class="number">0.000078</span>  <span class="number">0.000108</span></span><br><span class="line">IBM   <span class="number">0.000078</span>  <span class="number">0.000078</span>  <span class="number">0.000146</span>  <span class="number">0.000089</span></span><br><span class="line">MSFT  <span class="number">0.000095</span>  <span class="number">0.000108</span>  <span class="number">0.000089</span>  <span class="number">0.000215</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>利用DataFrame的corrwith方法，你可以计算其列或行跟另一个Series或DataFrame之间的相关系数。传入一个Series将会返回一个相关系数值Series（针对各列进行计算）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">249</span>]: returns.corrwith(returns.IBM)</span><br><span class="line">Out[<span class="number">249</span>]: </span><br><span class="line">AAPL    <span class="number">0.386817</span></span><br><span class="line">GOOG    <span class="number">0.405099</span></span><br><span class="line">IBM     <span class="number">1.000000</span></span><br><span class="line">MSFT    <span class="number">0.499764</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传入一个DataFrame则会计算按列名配对的相关系数。这里，我计算百分比变化与成交量的相关系数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">250</span>]: returns.corrwith(volume)</span><br><span class="line">Out[<span class="number">250</span>]: </span><br><span class="line">AAPL   -<span class="number">0.075565</span></span><br><span class="line">GOOG   -<span class="number">0.007067</span></span><br><span class="line">IBM    -<span class="number">0.204849</span></span><br><span class="line">MSFT   -<span class="number">0.092950</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传入axis='columns'即可按行进行计算。无论如何，在计算相关系数之前，所有的数据项都会按标签对齐。</p>
<h2 id="唯一值值计数以及成员资格">唯一值、值计数以及成员资格</h2>
<p>还有一类方法可以从一维Series的值中抽取信息。看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">251</span>]: obj = pd.Series([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第一个函数是unique，它可以得到Series中的唯一值数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">252</span>]: uniques = obj.unique()</span><br><span class="line"></span><br><span class="line">In [<span class="number">253</span>]: uniques</span><br><span class="line">Out[<span class="number">253</span>]: array([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], dtype=<span class="built_in">object</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>返回的唯一值是未排序的，如果需要的话，可以对结果再次进行排序（uniques.sort()）。相似的，value_counts用于计算一个Series中各值出现的频率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">254</span>]: obj.value_counts()</span><br><span class="line">Out[<span class="number">254</span>]: </span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">a    <span class="number">3</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">d    <span class="number">1</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了便于查看，结果Series是按值频率降序排列的。value_counts还是一个顶级pandas方法，可用于任何数组或序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">255</span>]: pd.value_counts(obj.values, sort=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">255</span>]: </span><br><span class="line">a    <span class="number">3</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">d    <span class="number">1</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>isin用于判断矢量化集合的成员资格，可用于过滤Series中或DataFrame列中数据的子集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">256</span>]: obj</span><br><span class="line">Out[<span class="number">256</span>]: </span><br><span class="line"><span class="number">0</span>    c</span><br><span class="line"><span class="number">1</span>    a</span><br><span class="line"><span class="number">2</span>    d</span><br><span class="line"><span class="number">3</span>    a</span><br><span class="line"><span class="number">4</span>    a</span><br><span class="line"><span class="number">5</span>    b</span><br><span class="line"><span class="number">6</span>    b</span><br><span class="line"><span class="number">7</span>    c</span><br><span class="line"><span class="number">8</span>    c</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">257</span>]: mask = obj.isin([<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">258</span>]: mask</span><br><span class="line">Out[<span class="number">258</span>]: </span><br><span class="line"><span class="number">0</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">1</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">3</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">4</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">5</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">6</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">7</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">8</span>     <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">259</span>]: obj[mask]</span><br><span class="line">Out[<span class="number">259</span>]: </span><br><span class="line"><span class="number">0</span>    c</span><br><span class="line"><span class="number">5</span>    b</span><br><span class="line"><span class="number">6</span>    b</span><br><span class="line"><span class="number">7</span>    c</span><br><span class="line"><span class="number">8</span>    c</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与isin类似的是Index.get_indexer方法，它可以给你一个索引数组，从可能包含重复值的数组到另一个不同值的数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">260</span>]: to_match = pd.Series([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">261</span>]: unique_vals = pd.Series([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">262</span>]: pd.Index(unique_vals).get_indexer(to_match)</span><br><span class="line">Out[<span class="number">262</span>]: array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表5-9给出了这几个方法的一些参考信息。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-b53c4a9d65a2db32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表5-9 唯一值、值计数、成员资格方法" /><figcaption aria-hidden="true">表5-9 唯一值、值计数、成员资格方法</figcaption>
</figure>
<p>有时，你可能希望得到DataFrame中多个相关列的一张柱状图。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">263</span>]: data = pd.DataFrame(&#123;<span class="string">&#x27;Qu1&#x27;</span>: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">   .....:                      <span class="string">&#x27;Qu2&#x27;</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">   .....:                      <span class="string">&#x27;Qu3&#x27;</span>: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">264</span>]: data</span><br><span class="line">Out[<span class="number">264</span>]: </span><br><span class="line">   Qu1  Qu2  Qu3</span><br><span class="line"><span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span>    <span class="number">1</span></span><br><span class="line"><span class="number">1</span>    <span class="number">3</span>    <span class="number">3</span>    <span class="number">5</span></span><br><span class="line"><span class="number">2</span>    <span class="number">4</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span>    <span class="number">2</span>    <span class="number">4</span></span><br><span class="line"><span class="number">4</span>    <span class="number">4</span>    <span class="number">3</span>    <span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将pandas.value_counts传给该DataFrame的apply函数，就会出现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">265</span>]: result = data.apply(pd.value_counts).fillna(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">266</span>]: result</span><br><span class="line">Out[<span class="number">266</span>]: </span><br><span class="line">   Qu1  Qu2  Qu3</span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.0</span>  <span class="number">2.0</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2.0</span>  <span class="number">2.0</span>  <span class="number">0.0</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2.0</span>  <span class="number">0.0</span>  <span class="number">2.0</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，结果中的行标签是所有列的唯一值。后面的频率值是每个列中这些值的相应计数。</p>
<h1 id="总结">5.4 总结</h1>
<p>在下一章，我们将讨论用pandas读取（或加载）和写入数据集的工具。</p>
<p>之后，我们将更深入地研究使用pandas进行数据清洗、规整、分析和可视化工具。</p>
]]></content>
      <categories>
        <category>Python 数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>第07章 数据清洗和准备</title>
    <url>/2019/04/09/%E7%AC%AC07%E7%AB%A0-%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E5%92%8C%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<p>在数据分析和建模的过程中，相当多的时间要用在数据准备上：加载、清理、转换以及重塑。这些工作会占到分析师时间的80%或更多。有时，存储在文件和数据库中的数据的格式不适合某个特定的任务。<span id="more"></span>许多研究者都选择使用通用编程语言（如Python、Perl、R或Java）或UNIX文本处理工具（如sed或awk）对数据格式进行专门处理。幸运的是，pandas和内置的Python标准库提供了一组高级的、灵活的、快速的工具，可以让你轻松地将数据规整为想要的格式。</p>
<p>如果你发现了一种本书或pandas库中没有的数据操作方式，请在邮件列表或GitHub网站上提出。实际上，pandas的许多设计和实现都是由真实应用的需求所驱动的。</p>
<p>在本章中，我会讨论处理缺失数据、重复数据、字符串操作和其它分析数据转换的工具。下一章，我会关注于用多种方法合并、重塑数据集。</p>
<h1 id="处理缺失数据">7.1 处理缺失数据</h1>
<p>在许多数据分析工作中，缺失数据是经常发生的。pandas的目标之一就是尽量轻松地处理缺失数据。例如，pandas对象的所有描述性统计默认都不包括缺失数据。</p>
<p>缺失数据在pandas中呈现的方式有些不完美，但对于大多数用户可以保证功能正常。对于数值数据，pandas使用浮点值NaN（Not a Number）表示缺失数据。我们称其为哨兵值，可以方便的检测出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: string_data = pd.Series([<span class="string">&#x27;aardvark&#x27;</span>, <span class="string">&#x27;artichoke&#x27;</span>, np.nan, <span class="string">&#x27;avocado&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: string_data</span><br><span class="line">Out[<span class="number">11</span>]:</span><br><span class="line"><span class="number">0</span>     aardvark</span><br><span class="line"><span class="number">1</span>    artichoke</span><br><span class="line"><span class="number">2</span>          NaN</span><br><span class="line"><span class="number">3</span>      avocado</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: string_data.isnull()</span><br><span class="line">Out[<span class="number">12</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">1</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">3</span>    <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure>
<p>在pandas中，我们采用了R语言中的惯用法，即将缺失值表示为NA，它表示不可用not available。在统计应用中，NA数据可能是不存在的数据或者虽然存在，但是没有观察到（例如，数据采集中发生了问题）。当进行数据清洗以进行分析时，最好直接对缺失数据进行分析，以判断数据采集的问题或缺失数据可能导致的偏差。</p>
<p>Python内置的None值在对象数组中也可以作为NA：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: string_data[<span class="number">0</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: string_data.isnull()</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line"><span class="number">0</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">1</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">3</span>    <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure>
<p>pandas项目中还在不断优化内部细节以更好处理缺失数据，像用户API功能，例如pandas.isnull，去除了许多恼人的细节。表7-1列出了一些关于缺失数据处理的函数。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-1a0f73e5bb26ea21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表7-1 NA处理方法" /><figcaption aria-hidden="true">表7-1 NA处理方法</figcaption>
</figure>
<h2 id="滤除缺失数据">滤除缺失数据</h2>
<p>过滤掉缺失数据的办法有很多种。你可以通过pandas.isnull或布尔索引的手工方法，但dropna可能会更实用一些。对于一个Series，dropna返回一个仅含非空数据和索引值的Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: <span class="keyword">from</span> numpy <span class="keyword">import</span> nan <span class="keyword">as</span> NA</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: data = pd.Series([<span class="number">1</span>, NA, <span class="number">3.5</span>, NA, <span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: data.dropna()</span><br><span class="line">Out[<span class="number">17</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">3.5</span></span><br><span class="line"><span class="number">4</span>    <span class="number">7.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>这等价于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: data[data.notnull()]</span><br><span class="line">Out[<span class="number">18</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">3.5</span></span><br><span class="line"><span class="number">4</span>    <span class="number">7.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>而对于DataFrame对象，事情就有点复杂了。你可能希望丢弃全NA或含有NA的行或列。dropna默认丢弃任何含有缺失值的行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">19</span>]: data = pd.DataFrame([[<span class="number">1.</span>, <span class="number">6.5</span>, <span class="number">3.</span>], [<span class="number">1.</span>, NA, NA],</span><br><span class="line">   ....:                      [NA, NA, NA], [NA, <span class="number">6.5</span>, <span class="number">3.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: cleaned = data.dropna()</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: data</span><br><span class="line">Out[<span class="number">21</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line"><span class="number">2</span>  NaN  NaN  NaN</span><br><span class="line"><span class="number">3</span>  NaN  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: cleaned</span><br><span class="line">Out[<span class="number">22</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span></span><br></pre></td></tr></table></figure>
<p>传入how='all'将只丢弃全为NA的那些行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">23</span>]: data.dropna(how=<span class="string">&#x27;all&#x27;</span>)</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line"><span class="number">3</span>  NaN  <span class="number">6.5</span>  <span class="number">3.0</span></span><br></pre></td></tr></table></figure>
<p>用这种方式丢弃列，只需传入axis=1即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: data[<span class="number">4</span>] = NA</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: data</span><br><span class="line">Out[<span class="number">25</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span> NaN</span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  NaN  NaN NaN</span><br><span class="line"><span class="number">2</span>  NaN  NaN  NaN NaN</span><br><span class="line"><span class="number">3</span>  NaN  <span class="number">6.5</span>  <span class="number">3.0</span> NaN</span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: data.dropna(axis=<span class="number">1</span>, how=<span class="string">&#x27;all&#x27;</span>)</span><br><span class="line">Out[<span class="number">26</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line"><span class="number">2</span>  NaN  NaN  NaN</span><br><span class="line"><span class="number">3</span>  NaN  <span class="number">6.5</span>  <span class="number">3.0</span></span><br></pre></td></tr></table></figure>
<p>另一个滤除DataFrame行的问题涉及时间序列数据。假设你只想留下一部分观测数据，可以用thresh参数实现此目的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">27</span>]: df = pd.DataFrame(np.random.randn(<span class="number">7</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: df.iloc[:<span class="number">4</span>, <span class="number">1</span>] = NA</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: df.iloc[:<span class="number">2</span>, <span class="number">2</span>] = NA</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: df</span><br><span class="line">Out[<span class="number">30</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>       NaN       NaN</span><br><span class="line"><span class="number">1</span> -<span class="number">0.555730</span>       NaN       NaN</span><br><span class="line"><span class="number">2</span>  <span class="number">0.092908</span>       NaN  <span class="number">0.769023</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.246435</span>       NaN -<span class="number">1.296221</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span></span><br><span class="line"><span class="number">6</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: df.dropna()</span><br><span class="line">Out[<span class="number">31</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span></span><br><span class="line"><span class="number">6</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: df.dropna(thresh=<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">32</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.092908</span>       NaN  <span class="number">0.769023</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.246435</span>       NaN -<span class="number">1.296221</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span></span><br><span class="line"><span class="number">6</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br></pre></td></tr></table></figure>
<h2 id="填充缺失数据">填充缺失数据</h2>
<p>你可能不想滤除缺失数据（有可能会丢弃跟它有关的其他数据），而是希望通过其他方式填补那些“空洞”。对于大多数情况而言，fillna方法是最主要的函数。通过一个常数调用fillna就会将缺失值替换为那个常数值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">33</span>]: df.fillna(<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">33</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.555730</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.092908</span>  <span class="number">0.000000</span>  <span class="number">0.769023</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.246435</span>  <span class="number">0.000000</span> -<span class="number">1.296221</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span></span><br><span class="line"><span class="number">6</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br></pre></td></tr></table></figure>
<p>若是通过一个字典调用fillna，就可以实现对不同的列填充不同的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">34</span>]: df.fillna(&#123;<span class="number">1</span>: <span class="number">0.5</span>, <span class="number">2</span>: <span class="number">0</span>&#125;)</span><br><span class="line">Out[<span class="number">34</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">0.500000</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.555730</span>  <span class="number">0.500000</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.092908</span>  <span class="number">0.500000</span>  <span class="number">0.769023</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.246435</span>  <span class="number">0.500000</span> -<span class="number">1.296221</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span></span><br><span class="line"><span class="number">6</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br></pre></td></tr></table></figure>
<p>fillna默认会返回新对象，但也可以对现有对象进行就地修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">35</span>]: _ = df.fillna(<span class="number">0</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: df</span><br><span class="line">Out[<span class="number">36</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.555730</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.092908</span>  <span class="number">0.000000</span>  <span class="number">0.769023</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.246435</span>  <span class="number">0.000000</span> -<span class="number">1.296221</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span></span><br><span class="line"><span class="number">6</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br></pre></td></tr></table></figure>
<p>对reindexing有效的那些插值方法也可用于fillna：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">37</span>]: df = pd.DataFrame(np.random.randn(<span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: df.iloc[<span class="number">2</span>:, <span class="number">1</span>] = NA</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: df.iloc[<span class="number">4</span>:, <span class="number">2</span>] = NA</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: df</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0.476985</span>  <span class="number">3.248944</span> -<span class="number">1.021228</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.577087</span>  <span class="number">0.124121</span>  <span class="number">0.302614</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.523772</span>       NaN  <span class="number">1.343810</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.713544</span>       NaN -<span class="number">2.370232</span></span><br><span class="line"><span class="number">4</span> -<span class="number">1.860761</span>       NaN       NaN</span><br><span class="line"><span class="number">5</span> -<span class="number">1.265934</span>       NaN       NaN</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: df.fillna(method=<span class="string">&#x27;ffill&#x27;</span>)</span><br><span class="line">Out[<span class="number">41</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0.476985</span>  <span class="number">3.248944</span> -<span class="number">1.021228</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.577087</span>  <span class="number">0.124121</span>  <span class="number">0.302614</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.523772</span>  <span class="number">0.124121</span>  <span class="number">1.343810</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.713544</span>  <span class="number">0.124121</span> -<span class="number">2.370232</span></span><br><span class="line"><span class="number">4</span> -<span class="number">1.860761</span>  <span class="number">0.124121</span> -<span class="number">2.370232</span></span><br><span class="line"><span class="number">5</span> -<span class="number">1.265934</span>  <span class="number">0.124121</span> -<span class="number">2.370232</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: df.fillna(method=<span class="string">&#x27;ffill&#x27;</span>, limit=<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">42</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0.476985</span>  <span class="number">3.248944</span> -<span class="number">1.021228</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.577087</span>  <span class="number">0.124121</span>  <span class="number">0.302614</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.523772</span>  <span class="number">0.124121</span>  <span class="number">1.343810</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.713544</span>  <span class="number">0.124121</span> -<span class="number">2.370232</span></span><br><span class="line"><span class="number">4</span> -<span class="number">1.860761</span>       NaN -<span class="number">2.370232</span></span><br><span class="line"><span class="number">5</span> -<span class="number">1.265934</span>       NaN -<span class="number">2.370232</span></span><br></pre></td></tr></table></figure>
<p>只要有些创新，你就可以利用fillna实现许多别的功能。比如说，你可以传入Series的平均值或中位数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">43</span>]: data = pd.Series([<span class="number">1.</span>, NA, <span class="number">3.5</span>, NA, <span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: data.fillna(data.mean())</span><br><span class="line">Out[<span class="number">44</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">1.000000</span></span><br><span class="line"><span class="number">1</span>    <span class="number">3.833333</span></span><br><span class="line"><span class="number">2</span>    <span class="number">3.500000</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3.833333</span></span><br><span class="line"><span class="number">4</span>    <span class="number">7.000000</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>表7-2列出了fillna的参考。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-0bf235386a64c3b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-4edd39e68f4dc530.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fillna函数参数" /><figcaption aria-hidden="true">fillna函数参数</figcaption>
</figure>
<h1 id="数据转换">7.2 数据转换</h1>
<p>本章到目前为止介绍的都是数据的重排。另一类重要操作则是过滤、清理以及其他的转换工作。</p>
<h2 id="移除重复数据">移除重复数据</h2>
<p>DataFrame中出现重复行有多种原因。下面就是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">45</span>]: data = pd.DataFrame(&#123;<span class="string">&#x27;k1&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>] * <span class="number">3</span> + [<span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">   ....:                      <span class="string">&#x27;k2&#x27;</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: data</span><br><span class="line">Out[<span class="number">46</span>]: </span><br><span class="line">    k1  k2</span><br><span class="line"><span class="number">0</span>  one   <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  two   <span class="number">1</span></span><br><span class="line"><span class="number">2</span>  one   <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  two   <span class="number">3</span></span><br><span class="line"><span class="number">4</span>  one   <span class="number">3</span></span><br><span class="line"><span class="number">5</span>  two   <span class="number">4</span></span><br><span class="line"><span class="number">6</span>  two   <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>DataFrame的duplicated方法返回一个布尔型Series，表示各行是否是重复行（前面出现过的行）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">47</span>]: data.duplicated()</span><br><span class="line">Out[<span class="number">47</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">1</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">3</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">4</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">5</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">6</span>     <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure>
<p>还有一个与此相关的drop_duplicates方法，它会返回一个DataFrame，重复的数组会标为False：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">48</span>]: data.drop_duplicates()</span><br><span class="line">Out[<span class="number">48</span>]: </span><br><span class="line">    k1  k2</span><br><span class="line"><span class="number">0</span>  one   <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  two   <span class="number">1</span></span><br><span class="line"><span class="number">2</span>  one   <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  two   <span class="number">3</span></span><br><span class="line"><span class="number">4</span>  one   <span class="number">3</span></span><br><span class="line"><span class="number">5</span>  two   <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>这两个方法默认会判断全部列，你也可以指定部分列进行重复项判断。假设我们还有一列值，且只希望根据k1列过滤重复项：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">49</span>]: data[<span class="string">&#x27;v1&#x27;</span>] = <span class="built_in">range</span>(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: data.drop_duplicates([<span class="string">&#x27;k1&#x27;</span>])</span><br><span class="line">Out[<span class="number">50</span>]: </span><br><span class="line">    k1  k2  v1</span><br><span class="line"><span class="number">0</span>  one   <span class="number">1</span>   <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  two   <span class="number">1</span>   <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>duplicated和drop_duplicates默认保留的是第一个出现的值组合。传入keep='last'则保留最后一个：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">51</span>]: data.drop_duplicates([<span class="string">&#x27;k1&#x27;</span>, <span class="string">&#x27;k2&#x27;</span>], keep=<span class="string">&#x27;last&#x27;</span>)</span><br><span class="line">Out[<span class="number">51</span>]: </span><br><span class="line">    k1  k2  v1</span><br><span class="line"><span class="number">0</span>  one   <span class="number">1</span>   <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  two   <span class="number">1</span>   <span class="number">1</span></span><br><span class="line"><span class="number">2</span>  one   <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  two   <span class="number">3</span>   <span class="number">3</span></span><br><span class="line"><span class="number">4</span>  one   <span class="number">3</span>   <span class="number">4</span></span><br><span class="line"><span class="number">6</span>  two   <span class="number">4</span>   <span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="利用函数或映射进行数据转换">利用函数或映射进行数据转换</h2>
<p>对于许多数据集，你可能希望根据数组、Series或DataFrame列中的值来实现转换工作。我们来看看下面这组有关肉类的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">52</span>]: data = pd.DataFrame(&#123;<span class="string">&#x27;food&#x27;</span>: [<span class="string">&#x27;bacon&#x27;</span>, <span class="string">&#x27;pulled pork&#x27;</span>, <span class="string">&#x27;bacon&#x27;</span>,</span><br><span class="line">   ....:                               <span class="string">&#x27;Pastrami&#x27;</span>, <span class="string">&#x27;corned beef&#x27;</span>, <span class="string">&#x27;Bacon&#x27;</span>,</span><br><span class="line">   ....:                               <span class="string">&#x27;pastrami&#x27;</span>, <span class="string">&#x27;honey ham&#x27;</span>, <span class="string">&#x27;nova lox&#x27;</span>],</span><br><span class="line">   ....:                      <span class="string">&#x27;ounces&#x27;</span>: [<span class="number">4</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: data</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">          food  ounces</span><br><span class="line"><span class="number">0</span>        bacon     <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>  pulled pork     <span class="number">3.0</span></span><br><span class="line"><span class="number">2</span>        bacon    <span class="number">12.0</span></span><br><span class="line"><span class="number">3</span>     Pastrami     <span class="number">6.0</span></span><br><span class="line"><span class="number">4</span>  corned beef     <span class="number">7.5</span></span><br><span class="line"><span class="number">5</span>        Bacon     <span class="number">8.0</span></span><br><span class="line"><span class="number">6</span>     pastrami     <span class="number">3.0</span></span><br><span class="line"><span class="number">7</span>    honey ham     <span class="number">5.0</span></span><br><span class="line"><span class="number">8</span>     nova lox     <span class="number">6.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设你想要添加一列表示该肉类食物来源的动物类型。我们先编写一个不同肉类到动物的映射：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">meat_to_animal = &#123;</span><br><span class="line">  <span class="string">&#x27;bacon&#x27;</span>: <span class="string">&#x27;pig&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pulled pork&#x27;</span>: <span class="string">&#x27;pig&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pastrami&#x27;</span>: <span class="string">&#x27;cow&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;corned beef&#x27;</span>: <span class="string">&#x27;cow&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;honey ham&#x27;</span>: <span class="string">&#x27;pig&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;nova lox&#x27;</span>: <span class="string">&#x27;salmon&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Series的map方法可以接受一个函数或含有映射关系的字典型对象，但是这里有一个小问题，即有些肉类的首字母大写了，而另一些则没有。因此，我们还需要使用Series的str.lower方法，将各个值转换为小写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">55</span>]: lowercased = data[<span class="string">&#x27;food&#x27;</span>].<span class="built_in">str</span>.lower()</span><br><span class="line"></span><br><span class="line">In [<span class="number">56</span>]: lowercased</span><br><span class="line">Out[<span class="number">56</span>]: </span><br><span class="line"><span class="number">0</span>          bacon</span><br><span class="line"><span class="number">1</span>    pulled pork</span><br><span class="line"><span class="number">2</span>          bacon</span><br><span class="line"><span class="number">3</span>       pastrami</span><br><span class="line"><span class="number">4</span>    corned beef</span><br><span class="line"><span class="number">5</span>          bacon</span><br><span class="line"><span class="number">6</span>       pastrami</span><br><span class="line"><span class="number">7</span>      honey ham</span><br><span class="line"><span class="number">8</span>       nova lox</span><br><span class="line">Name: food, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: data[<span class="string">&#x27;animal&#x27;</span>] = lowercased.<span class="built_in">map</span>(meat_to_animal)</span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: data</span><br><span class="line">Out[<span class="number">58</span>]: </span><br><span class="line">          food  ounces  animal</span><br><span class="line"><span class="number">0</span>        bacon     <span class="number">4.0</span>     pig</span><br><span class="line"><span class="number">1</span>  pulled pork     <span class="number">3.0</span>     pig</span><br><span class="line"><span class="number">2</span>        bacon    <span class="number">12.0</span>     pig</span><br><span class="line"><span class="number">3</span>     Pastrami     <span class="number">6.0</span>     cow</span><br><span class="line"><span class="number">4</span>  corned beef     <span class="number">7.5</span>     cow</span><br><span class="line"><span class="number">5</span>        Bacon     <span class="number">8.0</span>     pig</span><br><span class="line"><span class="number">6</span>     pastrami     <span class="number">3.0</span>     cow</span><br><span class="line"><span class="number">7</span>    honey ham     <span class="number">5.0</span>     pig</span><br><span class="line"><span class="number">8</span>     nova lox     <span class="number">6.0</span>  salmon</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们也可以传入一个能够完成全部这些工作的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">59</span>]: data[<span class="string">&#x27;food&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: meat_to_animal[x.lower()])</span><br><span class="line">Out[<span class="number">59</span>]: </span><br><span class="line"><span class="number">0</span>       pig</span><br><span class="line"><span class="number">1</span>       pig</span><br><span class="line"><span class="number">2</span>       pig</span><br><span class="line"><span class="number">3</span>       cow</span><br><span class="line"><span class="number">4</span>       cow</span><br><span class="line"><span class="number">5</span>       pig</span><br><span class="line"><span class="number">6</span>       cow</span><br><span class="line"><span class="number">7</span>       pig</span><br><span class="line"><span class="number">8</span>    salmon</span><br><span class="line">Name: food, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用map是一种实现元素级转换以及其他数据清理工作的便捷方式。</p>
<h2 id="替换值">替换值</h2>
<p>利用fillna方法填充缺失数据可以看做值替换的一种特殊情况。前面已经看到，map可用于修改对象的数据子集，而replace则提供了一种实现该功能的更简单、更灵活的方式。我们来看看下面这个Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">60</span>]: data = pd.Series([<span class="number">1.</span>, -<span class="number">999.</span>, <span class="number">2.</span>, -<span class="number">999.</span>, -<span class="number">1000.</span>, <span class="number">3.</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: data</span><br><span class="line">Out[<span class="number">61</span>]: </span><br><span class="line"><span class="number">0</span>       <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    -<span class="number">999.0</span></span><br><span class="line"><span class="number">2</span>       <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>    -<span class="number">999.0</span></span><br><span class="line"><span class="number">4</span>   -<span class="number">1000.0</span></span><br><span class="line"><span class="number">5</span>       <span class="number">3.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>-999这个值可能是一个表示缺失数据的标记值。要将其替换为pandas能够理解的NA值，我们可以利用replace来产生一个新的Series（除非传入inplace=True）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">62</span>]: data.replace(-<span class="number">999</span>, np.nan)</span><br><span class="line">Out[<span class="number">62</span>]: </span><br><span class="line"><span class="number">0</span>       <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>       NaN</span><br><span class="line"><span class="number">2</span>       <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>       NaN</span><br><span class="line"><span class="number">4</span>   -<span class="number">1000.0</span></span><br><span class="line"><span class="number">5</span>       <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你希望一次性替换多个值，可以传入一个由待替换值组成的列表以及一个替换值：：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">63</span>]: data.replace([-<span class="number">999</span>, -<span class="number">1000</span>], np.nan)</span><br><span class="line">Out[<span class="number">63</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    NaN</span><br><span class="line"><span class="number">2</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>    NaN</span><br><span class="line"><span class="number">4</span>    NaN</span><br><span class="line"><span class="number">5</span>    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要让每个值有不同的替换值，可以传递一个替换列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">64</span>]: data.replace([-<span class="number">999</span>, -<span class="number">1000</span>], [np.nan, <span class="number">0</span>])</span><br><span class="line">Out[<span class="number">64</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    NaN</span><br><span class="line"><span class="number">2</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>    NaN</span><br><span class="line"><span class="number">4</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传入的参数也可以是字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">65</span>]: data.replace(&#123;-<span class="number">999</span>: np.nan, -<span class="number">1000</span>: <span class="number">0</span>&#125;)</span><br><span class="line">Out[<span class="number">65</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    NaN</span><br><span class="line"><span class="number">2</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>    NaN</span><br><span class="line"><span class="number">4</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：data.replace方法与data.str.replace不同，后者做的是字符串的元素级替换。我们会在后面学习Series的字符串方法。</p>
</blockquote>
<h2 id="重命名轴索引">重命名轴索引</h2>
<p>跟Series中的值一样，轴标签也可以通过函数或映射进行转换，从而得到一个新的不同标签的对象。轴还可以被就地修改，而无需新建一个数据结构。接下来看看下面这个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">66</span>]: data = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>)),</span><br><span class="line">   ....:                     index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>],</span><br><span class="line">   ....:                     columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>跟Series一样，轴索引也有一个map方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">67</span>]: transform = <span class="keyword">lambda</span> x: x[:<span class="number">4</span>].upper()</span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: data.index.<span class="built_in">map</span>(transform)</span><br><span class="line">Out[<span class="number">68</span>]: Index([<span class="string">&#x27;OHIO&#x27;</span>, <span class="string">&#x27;COLO&#x27;</span>, <span class="string">&#x27;NEW &#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可以将其赋值给index，这样就可以对DataFrame进行就地修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">69</span>]: data.index = data.index.<span class="built_in">map</span>(transform)</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: data</span><br><span class="line">Out[<span class="number">70</span>]:</span><br><span class="line">one  two  three  four</span><br><span class="line">OHIO    <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">COLO    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">NEW     <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果想要创建数据集的转换版（而不是修改原始数据），比较实用的方法是rename：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">71</span>]: data.rename(index=<span class="built_in">str</span>.title, columns=<span class="built_in">str</span>.upper)</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line">      ONE  TWO  THREE  FOUR</span><br><span class="line">Ohio    <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colo    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">New     <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>特别说明一下，rename可以结合字典型对象实现对部分轴标签的更新：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">72</span>]: data.rename(index=&#123;<span class="string">&#x27;OHIO&#x27;</span>: <span class="string">&#x27;INDIANA&#x27;</span>&#125;,</span><br><span class="line">   ....:             columns=&#123;<span class="string">&#x27;three&#x27;</span>: <span class="string">&#x27;peekaboo&#x27;</span>&#125;)</span><br><span class="line">Out[<span class="number">72</span>]:</span><br><span class="line">one  two  peekaboo  four</span><br><span class="line">INDIANA    <span class="number">0</span>    <span class="number">1</span>         <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">COLO       <span class="number">4</span>    <span class="number">5</span>         <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">NEW        <span class="number">8</span>    <span class="number">9</span>        <span class="number">10</span>    <span class="number">11</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>rename可以实现复制DataFrame并对其索引和列标签进行赋值。如果希望就地修改某个数据集，传入inplace=True即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">73</span>]: data.rename(index=&#123;<span class="string">&#x27;OHIO&#x27;</span>: <span class="string">&#x27;INDIANA&#x27;</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">74</span>]: data</span><br><span class="line">Out[<span class="number">74</span>]: </span><br><span class="line">         one  two  three  four</span><br><span class="line">INDIANA    <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">COLO       <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">NEW        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="离散化和面元划分">离散化和面元划分</h2>
<p>为了便于分析，连续数据常常被离散化或拆分为“面元”（bin）。假设有一组人员数据，而你希望将它们划分为不同的年龄组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">75</span>]: ages = [<span class="number">20</span>, <span class="number">22</span>, <span class="number">25</span>, <span class="number">27</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">37</span>, <span class="number">31</span>, <span class="number">61</span>, <span class="number">45</span>, <span class="number">41</span>, <span class="number">32</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来将这些数据划分为“18到25”、“26到35”、“35到60”以及“60以上”几个面元。要实现该功能，你需要使用pandas的cut函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: bins = [<span class="number">18</span>, <span class="number">25</span>, <span class="number">35</span>, <span class="number">60</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: cats = pd.cut(ages, bins)</span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: cats</span><br><span class="line">Out[<span class="number">78</span>]: </span><br><span class="line">[(<span class="number">18</span>, <span class="number">25</span>], (<span class="number">18</span>, <span class="number">25</span>], (<span class="number">18</span>, <span class="number">25</span>], (<span class="number">25</span>, <span class="number">35</span>], (<span class="number">18</span>, <span class="number">25</span>], ..., (<span class="number">25</span>, <span class="number">35</span>], (<span class="number">60</span>, <span class="number">100</span>], (<span class="number">35</span>,<span class="number">60</span>], (<span class="number">35</span>, <span class="number">60</span>], (<span class="number">25</span>, <span class="number">35</span>]]</span><br><span class="line">Length: <span class="number">12</span></span><br><span class="line">Categories (<span class="number">4</span>, interval[int64]): [(<span class="number">18</span>, <span class="number">25</span>] &lt; (<span class="number">25</span>, <span class="number">35</span>] &lt; (<span class="number">35</span>, <span class="number">60</span>] &lt; (<span class="number">60</span>, <span class="number">100</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>pandas返回的是一个特殊的Categorical对象。结果展示了pandas.cut划分的面元。你可以将其看做一组表示面元名称的字符串。它的底层含有一个表示不同分类名称的类型数组，以及一个codes属性中的年龄数据的标签：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">79</span>]: cats.codes</span><br><span class="line">Out[<span class="number">79</span>]: array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], dtype=int8)</span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: cats.categories</span><br><span class="line">Out[<span class="number">80</span>]: </span><br><span class="line">IntervalIndex([(<span class="number">18</span>, <span class="number">25</span>], (<span class="number">25</span>, <span class="number">35</span>], (<span class="number">35</span>, <span class="number">60</span>], (<span class="number">60</span>, <span class="number">100</span>]]</span><br><span class="line">              closed=<span class="string">&#x27;right&#x27;</span>,</span><br><span class="line">              dtype=<span class="string">&#x27;interval[int64]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: pd.value_counts(cats)</span><br><span class="line">Out[<span class="number">81</span>]: </span><br><span class="line">(<span class="number">18</span>, <span class="number">25</span>]     <span class="number">5</span></span><br><span class="line">(<span class="number">35</span>, <span class="number">60</span>]     <span class="number">3</span></span><br><span class="line">(<span class="number">25</span>, <span class="number">35</span>]     <span class="number">3</span></span><br><span class="line">(<span class="number">60</span>, <span class="number">100</span>]    <span class="number">1</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>pd.value_counts(cats)是pandas.cut结果的面元计数。</p>
<p>跟“区间”的数学符号一样，圆括号表示开端，而方括号则表示闭端（包括）。哪边是闭端可以通过right=False进行修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">82</span>]: pd.cut(ages, [<span class="number">18</span>, <span class="number">26</span>, <span class="number">36</span>, <span class="number">61</span>, <span class="number">100</span>], right=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">82</span>]: </span><br><span class="line">[[<span class="number">18</span>, <span class="number">26</span>), [<span class="number">18</span>, <span class="number">26</span>), [<span class="number">18</span>, <span class="number">26</span>), [<span class="number">26</span>, <span class="number">36</span>), [<span class="number">18</span>, <span class="number">26</span>), ..., [<span class="number">26</span>, <span class="number">36</span>), [<span class="number">61</span>, <span class="number">100</span>), [<span class="number">36</span>,</span><br><span class="line"> <span class="number">61</span>), [<span class="number">36</span>, <span class="number">61</span>), [<span class="number">26</span>, <span class="number">36</span>)]</span><br><span class="line">Length: <span class="number">12</span></span><br><span class="line">Categories (<span class="number">4</span>, interval[int64]): [[<span class="number">18</span>, <span class="number">26</span>) &lt; [<span class="number">26</span>, <span class="number">36</span>) &lt; [<span class="number">36</span>, <span class="number">61</span>) &lt; [<span class="number">61</span>, <span class="number">100</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可 以通过传递一个列表或数组到labels，设置自己的面元名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">83</span>]: group_names = [<span class="string">&#x27;Youth&#x27;</span>, <span class="string">&#x27;YoungAdult&#x27;</span>, <span class="string">&#x27;MiddleAged&#x27;</span>, <span class="string">&#x27;Senior&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: pd.cut(ages, bins, labels=group_names)</span><br><span class="line">Out[<span class="number">84</span>]: </span><br><span class="line">[Youth, Youth, Youth, YoungAdult, Youth, ..., YoungAdult, Senior, MiddleAged, Mid</span><br><span class="line">dleAged, YoungAdult]</span><br><span class="line">Length: <span class="number">12</span></span><br><span class="line">Categories (<span class="number">4</span>, <span class="built_in">object</span>): [Youth &lt; YoungAdult &lt; MiddleAged &lt; Senior]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果向cut传入的是面元的数量而不是确切的面元边界，则它会根据数据的最小值和最大值计算等长面元。下面这个例子中，我们将一些均匀分布的数据分成四组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">85</span>]: data = np.random.rand(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: pd.cut(data, <span class="number">4</span>, precision=<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">86</span>]: </span><br><span class="line">[(<span class="number">0.34</span>, <span class="number">0.55</span>], (<span class="number">0.34</span>, <span class="number">0.55</span>], (<span class="number">0.76</span>, <span class="number">0.97</span>], (<span class="number">0.76</span>, <span class="number">0.97</span>], (<span class="number">0.34</span>, <span class="number">0.55</span>], ..., (<span class="number">0.34</span></span><br><span class="line">, <span class="number">0.55</span>], (<span class="number">0.34</span>, <span class="number">0.55</span>], (<span class="number">0.55</span>, <span class="number">0.76</span>], (<span class="number">0.34</span>, <span class="number">0.55</span>], (<span class="number">0.12</span>, <span class="number">0.34</span>]]</span><br><span class="line">Length: <span class="number">20</span></span><br><span class="line">Categories (<span class="number">4</span>, interval[float64]): [(<span class="number">0.12</span>, <span class="number">0.34</span>] &lt; (<span class="number">0.34</span>, <span class="number">0.55</span>] &lt; (<span class="number">0.55</span>, <span class="number">0.76</span>] &lt; </span><br><span class="line">(<span class="number">0.76</span>, <span class="number">0.97</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>选项precision=2，限定小数只有两位。</p>
<p>qcut是一个非常类似于cut的函数，它可以根据样本分位数对数据进行面元划分。根据数据的分布情况，cut可能无法使各个面元中含有相同数量的数据点。而qcut由于使用的是样本分位数，因此可以得到大小基本相等的面元：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">87</span>]: data = np.random.randn(<span class="number">1000</span>)  <span class="comment"># Normally distributed</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: cats = pd.qcut(data, <span class="number">4</span>)  <span class="comment"># Cut into quartiles</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: cats</span><br><span class="line">Out[<span class="number">89</span>]: </span><br><span class="line">[(-<span class="number">0.0265</span>, <span class="number">0.62</span>], (<span class="number">0.62</span>, <span class="number">3.928</span>], (-<span class="number">0.68</span>, -<span class="number">0.0265</span>], (<span class="number">0.62</span>, <span class="number">3.928</span>], (-<span class="number">0.0265</span>, <span class="number">0.62</span>]</span><br><span class="line">, ..., (-<span class="number">0.68</span>, -<span class="number">0.0265</span>], (-<span class="number">0.68</span>, -<span class="number">0.0265</span>], (-<span class="number">2.95</span>, -<span class="number">0.68</span>], (<span class="number">0.62</span>, <span class="number">3.928</span>], (-<span class="number">0.68</span>,</span><br><span class="line"> -<span class="number">0.0265</span>]]</span><br><span class="line">Length: <span class="number">1000</span></span><br><span class="line">Categories (<span class="number">4</span>, interval[float64]): [(-<span class="number">2.95</span>, -<span class="number">0.68</span>] &lt; (-<span class="number">0.68</span>, -<span class="number">0.0265</span>] &lt; (-<span class="number">0.0265</span>,</span><br><span class="line"> <span class="number">0.62</span>] &lt;</span><br><span class="line">                                    (<span class="number">0.62</span>, <span class="number">3.928</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: pd.value_counts(cats)</span><br><span class="line">Out[<span class="number">90</span>]:</span><br><span class="line">(<span class="number">0.62</span>, <span class="number">3.928</span>]       <span class="number">250</span></span><br><span class="line">(-<span class="number">0.0265</span>, <span class="number">0.62</span>]     <span class="number">250</span></span><br><span class="line">(-<span class="number">0.68</span>, -<span class="number">0.0265</span>]    <span class="number">250</span></span><br><span class="line">(-<span class="number">2.95</span>, -<span class="number">0.68</span>]      <span class="number">250</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与cut类似，你也可以传递自定义的分位数（0到1之间的数值，包含端点）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">91</span>]: pd.qcut(data, [<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">0.9</span>, <span class="number">1.</span>])</span><br><span class="line">Out[<span class="number">91</span>]: </span><br><span class="line">[(-<span class="number">0.0265</span>, <span class="number">1.286</span>], (-<span class="number">0.0265</span>, <span class="number">1.286</span>], (-<span class="number">1.187</span>, -<span class="number">0.0265</span>], (-<span class="number">0.0265</span>, <span class="number">1.286</span>], (-<span class="number">0.026</span></span><br><span class="line"><span class="number">5</span>, <span class="number">1.286</span>], ..., (-<span class="number">1.187</span>, -<span class="number">0.0265</span>], (-<span class="number">1.187</span>, -<span class="number">0.0265</span>], (-<span class="number">2.95</span>, -<span class="number">1.187</span>], (-<span class="number">0.0265</span>, </span><br><span class="line"><span class="number">1.286</span>], (-<span class="number">1.187</span>, -<span class="number">0.0265</span>]]</span><br><span class="line">Length: <span class="number">1000</span></span><br><span class="line">Categories (<span class="number">4</span>, interval[float64]): [(-<span class="number">2.95</span>, -<span class="number">1.187</span>] &lt; (-<span class="number">1.187</span>, -<span class="number">0.0265</span>] &lt; (-<span class="number">0.026</span></span><br><span class="line"><span class="number">5</span>, <span class="number">1.286</span>] &lt;</span><br><span class="line">                                    (<span class="number">1.286</span>, <span class="number">3.928</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>本章稍后在讲解聚合和分组运算时会再次用到cut和qcut，因为这两个离散化函数对分位和分组分析非常重要。</p>
<h2 id="检测和过滤异常值">检测和过滤异常值</h2>
<p>过滤或变换异常值（outlier）在很大程度上就是运用数组运算。来看一个含有正态分布数据的DataFrame：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">92</span>]: data = pd.DataFrame(np.random.randn(<span class="number">1000</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">93</span>]: data.describe()</span><br><span class="line">Out[<span class="number">93</span>]: </span><br><span class="line">                 <span class="number">0</span>            <span class="number">1</span>            <span class="number">2</span>            <span class="number">3</span></span><br><span class="line">count  <span class="number">1000.000000</span>  <span class="number">1000.000000</span>  <span class="number">1000.000000</span>  <span class="number">1000.000000</span></span><br><span class="line">mean      <span class="number">0.049091</span>     <span class="number">0.026112</span>    -<span class="number">0.002544</span>    -<span class="number">0.051827</span></span><br><span class="line">std       <span class="number">0.996947</span>     <span class="number">1.007458</span>     <span class="number">0.995232</span>     <span class="number">0.998311</span></span><br><span class="line"><span class="built_in">min</span>      -<span class="number">3.645860</span>    -<span class="number">3.184377</span>    -<span class="number">3.745356</span>    -<span class="number">3.428254</span></span><br><span class="line"><span class="number">25</span>%      -<span class="number">0.599807</span>    -<span class="number">0.612162</span>    -<span class="number">0.687373</span>    -<span class="number">0.747478</span></span><br><span class="line"><span class="number">50</span>%       <span class="number">0.047101</span>    -<span class="number">0.013609</span>    -<span class="number">0.022158</span>    -<span class="number">0.088274</span></span><br><span class="line"><span class="number">75</span>%       <span class="number">0.756646</span>     <span class="number">0.695298</span>     <span class="number">0.699046</span>     <span class="number">0.623331</span></span><br><span class="line"><span class="built_in">max</span>       <span class="number">2.653656</span>     <span class="number">3.525865</span>     <span class="number">2.735527</span>     <span class="number">3.366626</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设你想要找出某列中绝对值大小超过3的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">94</span>]: col = data[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">95</span>]: col[np.<span class="built_in">abs</span>(col) &gt; <span class="number">3</span>]</span><br><span class="line">Out[<span class="number">95</span>]: </span><br><span class="line"><span class="number">41</span>    -<span class="number">3.399312</span></span><br><span class="line"><span class="number">136</span>   -<span class="number">3.745356</span></span><br><span class="line">Name: <span class="number">2</span>, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要选出全部含有“超过3或－3的值”的行，你可以在布尔型DataFrame中使用any方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">96</span>]: data[(np.<span class="built_in">abs</span>(data) &gt; <span class="number">3</span>).<span class="built_in">any</span>(<span class="number">1</span>)]</span><br><span class="line">Out[<span class="number">96</span>]: </span><br><span class="line">            <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span>         <span class="number">3</span></span><br><span class="line"><span class="number">41</span>   <span class="number">0.457246</span> -<span class="number">0.025907</span> -<span class="number">3.399312</span> -<span class="number">0.974657</span></span><br><span class="line"><span class="number">60</span>   <span class="number">1.951312</span>  <span class="number">3.260383</span>  <span class="number">0.963301</span>  <span class="number">1.201206</span></span><br><span class="line"><span class="number">136</span>  <span class="number">0.508391</span> -<span class="number">0.196713</span> -<span class="number">3.745356</span> -<span class="number">1.520113</span></span><br><span class="line"><span class="number">235</span> -<span class="number">0.242459</span> -<span class="number">3.056990</span>  <span class="number">1.918403</span> -<span class="number">0.578828</span></span><br><span class="line"><span class="number">258</span>  <span class="number">0.682841</span>  <span class="number">0.326045</span>  <span class="number">0.425384</span> -<span class="number">3.428254</span></span><br><span class="line"><span class="number">322</span>  <span class="number">1.179227</span> -<span class="number">3.184377</span>  <span class="number">1.369891</span> -<span class="number">1.074833</span></span><br><span class="line"><span class="number">544</span> -<span class="number">3.548824</span>  <span class="number">1.553205</span> -<span class="number">2.186301</span>  <span class="number">1.277104</span></span><br><span class="line"><span class="number">635</span> -<span class="number">0.578093</span>  <span class="number">0.193299</span>  <span class="number">1.397822</span>  <span class="number">3.366626</span></span><br><span class="line"><span class="number">782</span> -<span class="number">0.207434</span>  <span class="number">3.525865</span>  <span class="number">0.283070</span>  <span class="number">0.544635</span></span><br><span class="line"><span class="number">803</span> -<span class="number">3.645860</span>  <span class="number">0.255475</span> -<span class="number">0.549574</span> -<span class="number">1.907459</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据这些条件，就可以对值进行设置。下面的代码可以将值限制在区间－3到3以内：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">97</span>]: data[np.<span class="built_in">abs</span>(data) &gt; <span class="number">3</span>] = np.sign(data) * <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: data.describe()</span><br><span class="line">Out[<span class="number">98</span>]: </span><br><span class="line">                 <span class="number">0</span>            <span class="number">1</span>            <span class="number">2</span>            <span class="number">3</span></span><br><span class="line">count  <span class="number">1000.000000</span>  <span class="number">1000.000000</span>  <span class="number">1000.000000</span>  <span class="number">1000.000000</span></span><br><span class="line">mean      <span class="number">0.050286</span>     <span class="number">0.025567</span>    -<span class="number">0.001399</span>    -<span class="number">0.051765</span></span><br><span class="line">std       <span class="number">0.992920</span>     <span class="number">1.004214</span>     <span class="number">0.991414</span>     <span class="number">0.995761</span></span><br><span class="line"><span class="built_in">min</span>      -<span class="number">3.000000</span>    -<span class="number">3.000000</span>    -<span class="number">3.000000</span>    -<span class="number">3.000000</span></span><br><span class="line"><span class="number">25</span>%      -<span class="number">0.599807</span>    -<span class="number">0.612162</span>    -<span class="number">0.687373</span>    -<span class="number">0.747478</span></span><br><span class="line"><span class="number">50</span>%       <span class="number">0.047101</span>    -<span class="number">0.013609</span>    -<span class="number">0.022158</span>    -<span class="number">0.088274</span></span><br><span class="line"><span class="number">75</span>%       <span class="number">0.756646</span>     <span class="number">0.695298</span>     <span class="number">0.699046</span>     <span class="number">0.623331</span></span><br><span class="line"><span class="built_in">max</span>       <span class="number">2.653656</span>     <span class="number">3.000000</span>     <span class="number">2.735527</span>     <span class="number">3.000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据数据的值是正还是负，np.sign(data)可以生成1和-1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">99</span>]: np.sign(data).head()</span><br><span class="line">Out[<span class="number">99</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span>    <span class="number">3</span></span><br><span class="line"><span class="number">0</span> -<span class="number">1.0</span>  <span class="number">1.0</span> -<span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span> -<span class="number">1.0</span>  <span class="number">1.0</span> -<span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span> -<span class="number">1.0</span></span><br><span class="line"><span class="number">3</span> -<span class="number">1.0</span> -<span class="number">1.0</span>  <span class="number">1.0</span> -<span class="number">1.0</span></span><br><span class="line"><span class="number">4</span> -<span class="number">1.0</span>  <span class="number">1.0</span> -<span class="number">1.0</span> -<span class="number">1.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="排列和随机采样">排列和随机采样</h2>
<p>利用numpy.random.permutation函数可以轻松实现对Series或DataFrame的列的排列工作（permuting，随机重排序）。通过需要排列的轴的长度调用permutation，可产生一个表示新顺序的整数数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">100</span>]: df = pd.DataFrame(np.arange(<span class="number">5</span> * <span class="number">4</span>).reshape((<span class="number">5</span>, <span class="number">4</span>)))</span><br><span class="line"></span><br><span class="line">In [<span class="number">101</span>]: sampler = np.random.permutation(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">102</span>]: sampler</span><br><span class="line">Out[<span class="number">102</span>]: array([<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后就可以在基于iloc的索引操作或take函数中使用该数组了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">103</span>]: df</span><br><span class="line">Out[<span class="number">103</span>]: </span><br><span class="line">    <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">0</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">1</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></span><br><span class="line"><span class="number">3</span>  <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span></span><br><span class="line"><span class="number">4</span>  <span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: df.take(sampler)</span><br><span class="line">Out[<span class="number">104</span>]: </span><br><span class="line">    <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span></span><br><span class="line"><span class="number">1</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></span><br><span class="line"><span class="number">4</span>  <span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span></span><br><span class="line"><span class="number">2</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></span><br><span class="line"><span class="number">0</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果不想用替换的方式选取随机子集，可以在Series和DataFrame上使用sample方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">105</span>]: df.sample(n=<span class="number">3</span>)</span><br><span class="line">Out[<span class="number">105</span>]: </span><br><span class="line">    <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span></span><br><span class="line"><span class="number">4</span>  <span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span></span><br><span class="line"><span class="number">2</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要通过替换的方式产生样本（允许重复选择），可以传递replace=True到sample：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">106</span>]: choices = pd.Series([<span class="number">5</span>, <span class="number">7</span>, -<span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: draws = choices.sample(n=<span class="number">10</span>, replace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">108</span>]: draws</span><br><span class="line">Out[<span class="number">108</span>]: </span><br><span class="line"><span class="number">4</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line"><span class="number">4</span>    <span class="number">4</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">1</span></span><br><span class="line"><span class="number">0</span>    <span class="number">5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">6</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line"><span class="number">4</span>    <span class="number">4</span></span><br><span class="line"><span class="number">0</span>    <span class="number">5</span></span><br><span class="line"><span class="number">4</span>    <span class="number">4</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="计算指标哑变量">计算指标/哑变量</h2>
<p>另一种常用于统计建模或机器学习的转换方式是：将分类变量（categorical variable）转换为“哑变量”或“指标矩阵”。</p>
<p>如果DataFrame的某一列中含有k个不同的值，则可以派生出一个k列矩阵或DataFrame（其值全为1和0）。pandas有一个get_dummies函数可以实现该功能（其实自己动手做一个也不难）。使用之前的一个DataFrame例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">109</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">   .....:                    <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">6</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">110</span>]: pd.get_dummies(df[<span class="string">&#x27;key&#x27;</span>])</span><br><span class="line">Out[<span class="number">110</span>]: </span><br><span class="line">   a  b  c</span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有时候，你可能想给指标DataFrame的列加上一个前缀，以便能够跟其他数据进行合并。get_dummies的prefix参数可以实现该功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">111</span>]: dummies = pd.get_dummies(df[<span class="string">&#x27;key&#x27;</span>], prefix=<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">112</span>]: df_with_dummy = df[[<span class="string">&#x27;data1&#x27;</span>]].join(dummies)</span><br><span class="line"></span><br><span class="line">In [<span class="number">113</span>]: df_with_dummy</span><br><span class="line">Out[<span class="number">113</span>]: </span><br><span class="line">   data1  key_a  key_b  key_c</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">1</span>      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>      <span class="number">0</span>      <span class="number">1</span>      <span class="number">0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>      <span class="number">1</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">3</span>      <span class="number">3</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">1</span></span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>      <span class="number">1</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>      <span class="number">0</span>      <span class="number">1</span>      <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果DataFrame中的某行同属于多个分类，则事情就会有点复杂。看一下MovieLens 1M数据集，14章会更深入地研究它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">114</span>]: mnames = [<span class="string">&#x27;movie_id&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;genres&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">115</span>]: movies = pd.read_table(<span class="string">&#x27;datasets/movielens/movies.dat&#x27;</span>, sep=<span class="string">&#x27;::&#x27;</span>,</span><br><span class="line">   .....:                        header=<span class="literal">None</span>, names=mnames)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: movies[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">116</span>]: </span><br><span class="line">   movie_id                               title                        genres</span><br><span class="line"><span class="number">0</span>         <span class="number">1</span>                    Toy Story (<span class="number">1995</span>)   Animation|Children<span class="string">&#x27;s|Comedy</span></span><br><span class="line"><span class="string">1         2                      Jumanji (1995)  Adventure|Children&#x27;</span>s|Fantasy</span><br><span class="line"><span class="number">2</span>         <span class="number">3</span>             Grumpier Old Men (<span class="number">1995</span>)                Comedy|Romance</span><br><span class="line"><span class="number">3</span>         <span class="number">4</span>            Waiting to Exhale (<span class="number">1995</span>)                  Comedy|Drama</span><br><span class="line"><span class="number">4</span>         <span class="number">5</span>  Father of the Bride Part II (<span class="number">1995</span>)                        Comedy</span><br><span class="line"><span class="number">5</span>         <span class="number">6</span>                         Heat (<span class="number">1995</span>)         Action|Crime|Thriller</span><br><span class="line"><span class="number">6</span>         <span class="number">7</span>                      Sabrina (<span class="number">1995</span>)                Comedy|Romance</span><br><span class="line"><span class="number">7</span>         <span class="number">8</span>                 Tom <span class="keyword">and</span> Huck (<span class="number">1995</span>)          Adventure|Children<span class="string">&#x27;s</span></span><br><span class="line"><span class="string">8         9                 Sudden Death (1995)</span></span><br><span class="line"><span class="string">Action</span></span><br><span class="line"><span class="string">9        10                    GoldenEye (1995)     Action|Adventure|Thriller</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>要为每个genre添加指标变量就需要做一些数据规整操作。首先，我们从数据集中抽取出不同的genre值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">117</span>]: all_genres = []</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: <span class="keyword">for</span> x <span class="keyword">in</span> movies.genres:</span><br><span class="line">   .....:     all_genres.extend(x.split(<span class="string">&#x27;|&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: genres = pd.unique(all_genres)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">120</span>]: genres</span><br><span class="line">Out[<span class="number">120</span>]: </span><br><span class="line">array([<span class="string">&#x27;Animation&#x27;</span>, <span class="string">&quot;Children&#x27;s&quot;</span>, <span class="string">&#x27;Comedy&#x27;</span>, <span class="string">&#x27;Adventure&#x27;</span>, <span class="string">&#x27;Fantasy&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Romance&#x27;</span>, <span class="string">&#x27;Drama&#x27;</span>, <span class="string">&#x27;Action&#x27;</span>, <span class="string">&#x27;Crime&#x27;</span>, <span class="string">&#x27;Thriller&#x27;</span>,<span class="string">&#x27;Horror&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Sci-Fi&#x27;</span>, <span class="string">&#x27;Documentary&#x27;</span>, <span class="string">&#x27;War&#x27;</span>, <span class="string">&#x27;Musical&#x27;</span>, <span class="string">&#x27;Mystery&#x27;</span>, <span class="string">&#x27;Film-Noir&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Western&#x27;</span>], dtype=<span class="built_in">object</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>构建指标DataFrame的方法之一是从一个全零DataFrame开始：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">121</span>]: zero_matrix = np.zeros((<span class="built_in">len</span>(movies), <span class="built_in">len</span>(genres)))</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: dummies = pd.DataFrame(zero_matrix, columns=genres)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，迭代每一部电影，并将dummies各行的条目设为1。要这么做，我们使用dummies.columns来计算每个类型的列索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">123</span>]: gen = movies.genres[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: gen.split(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">Out[<span class="number">124</span>]: [<span class="string">&#x27;Animation&#x27;</span>, <span class="string">&quot;Children&#x27;s&quot;</span>, <span class="string">&#x27;Comedy&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: dummies.columns.get_indexer(gen.split(<span class="string">&#x27;|&#x27;</span>))</span><br><span class="line">Out[<span class="number">125</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，根据索引，使用.iloc设定值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">126</span>]: <span class="keyword">for</span> i, gen <span class="keyword">in</span> <span class="built_in">enumerate</span>(movies.genres):</span><br><span class="line">   .....:     indices = dummies.columns.get_indexer(gen.split(<span class="string">&#x27;|&#x27;</span>))</span><br><span class="line">   .....:     dummies.iloc[i, indices] = <span class="number">1</span></span><br><span class="line">   .....:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，和以前一样，再将其与movies合并起来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">127</span>]: movies_windic = movies.join(dummies.add_prefix(<span class="string">&#x27;Genre_&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">128</span>]: movies_windic.iloc[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">128</span>]: </span><br><span class="line">movie_id                                       <span class="number">1</span></span><br><span class="line">title                           Toy Story (<span class="number">1995</span>)</span><br><span class="line">genres               Animation|Children<span class="string">&#x27;s|Comedy</span></span><br><span class="line"><span class="string">Genre_Animation                                1</span></span><br><span class="line"><span class="string">Genre_Children&#x27;</span>s                               <span class="number">1</span></span><br><span class="line">Genre_Comedy                                   <span class="number">1</span></span><br><span class="line">Genre_Adventure                                <span class="number">0</span></span><br><span class="line">Genre_Fantasy                                  <span class="number">0</span></span><br><span class="line">Genre_Romance                                  <span class="number">0</span></span><br><span class="line">Genre_Drama                                    <span class="number">0</span></span><br><span class="line">                                ...             </span><br><span class="line">Genre_Crime                                    <span class="number">0</span></span><br><span class="line">Genre_Thriller                                 <span class="number">0</span></span><br><span class="line">Genre_Horror                                   <span class="number">0</span></span><br><span class="line">Genre_Sci-Fi                                   <span class="number">0</span></span><br><span class="line">Genre_Documentary                              <span class="number">0</span></span><br><span class="line">Genre_War                                      <span class="number">0</span></span><br><span class="line">Genre_Musical                                  <span class="number">0</span></span><br><span class="line">Genre_Mystery                                  <span class="number">0</span></span><br><span class="line">Genre_Film-Noir                                <span class="number">0</span></span><br><span class="line">Genre_Western                                  <span class="number">0</span></span><br><span class="line">Name: <span class="number">0</span>, Length: <span class="number">21</span>, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：对于很大的数据，用这种方式构建多成员指标变量就会变得非常慢。最好使用更低级的函数，将其写入NumPy数组，然后结果包装在DataFrame中。</p>
</blockquote>
<p>一个对统计应用有用的秘诀是：结合get_dummies和诸如cut之类的离散化函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">129</span>]: np.random.seed(<span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">130</span>]: values = np.random.rand(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">131</span>]: values</span><br><span class="line">Out[<span class="number">131</span>]: </span><br><span class="line">array([ <span class="number">0.9296</span>,  <span class="number">0.3164</span>,  <span class="number">0.1839</span>,  <span class="number">0.2046</span>,  <span class="number">0.5677</span>,  <span class="number">0.5955</span>,  <span class="number">0.9645</span>,</span><br><span class="line">        <span class="number">0.6532</span>,  <span class="number">0.7489</span>,  <span class="number">0.6536</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">132</span>]: bins = [<span class="number">0</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">133</span>]: pd.get_dummies(pd.cut(values, bins))</span><br><span class="line">Out[<span class="number">133</span>]: </span><br><span class="line">   (<span class="number">0.0</span>, <span class="number">0.2</span>]  (<span class="number">0.2</span>, <span class="number">0.4</span>]  (<span class="number">0.4</span>, <span class="number">0.6</span>]  (<span class="number">0.6</span>, <span class="number">0.8</span>]  (<span class="number">0.8</span>, <span class="number">1.0</span>]</span><br><span class="line"><span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span></span><br><span class="line"><span class="number">1</span>           <span class="number">0</span>           <span class="number">1</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">2</span>           <span class="number">1</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">3</span>           <span class="number">0</span>           <span class="number">1</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">4</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span>           <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">5</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span>           <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">6</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span></span><br><span class="line"><span class="number">7</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"><span class="number">8</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"><span class="number">9</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们用numpy.random.seed，使这个例子具有确定性。本书后面会介绍pandas.get_dummies。</p>
<h1 id="字符串操作">7.3 字符串操作</h1>
<p>Python能够成为流行的数据处理语言，部分原因是其简单易用的字符串和文本处理功能。大部分文本运算都直接做成了字符串对象的内置方法。对于更为复杂的模式匹配和文本操作，则可能需要用到正则表达式。pandas对此进行了加强，它使你能够对整组数据应用字符串表达式和正则表达式，而且能处理烦人的缺失数据。</p>
<h2 id="字符串对象方法">字符串对象方法</h2>
<p>对于许多字符串处理和脚本应用，内置的字符串方法已经能够满足要求了。例如，以逗号分隔的字符串可以用split拆分成数段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">134</span>]: val = <span class="string">&#x27;a,b,  guido&#x27;</span></span><br><span class="line">In [<span class="number">135</span>]: val.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">Out[<span class="number">135</span>]: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;  guido&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>split常常与strip一起使用，以去除空白符（包括换行符）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">136</span>]: pieces = [x.strip() <span class="keyword">for</span> x <span class="keyword">in</span> val.split(<span class="string">&#x27;,&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">137</span>]: pieces</span><br><span class="line">Out[<span class="number">137</span>]: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;guido&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>利用加法，可以将这些子字符串以双冒号分隔符的形式连接起来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">138</span>]: first, second, third = pieces</span><br><span class="line"></span><br><span class="line">In [<span class="number">139</span>]: first + <span class="string">&#x27;::&#x27;</span> + second + <span class="string">&#x27;::&#x27;</span> + third</span><br><span class="line">Out[<span class="number">139</span>]: <span class="string">&#x27;a::b::guido&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但这种方式并不是很实用。一种更快更符合Python风格的方式是，向字符串"::"的join方法传入一个列表或元组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">140</span>]: <span class="string">&#x27;::&#x27;</span>.join(pieces)</span><br><span class="line">Out[<span class="number">140</span>]: <span class="string">&#x27;a::b::guido&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其它方法关注的是子串定位。检测子串的最佳方式是利用Python的in关键字，还可以使用index和find：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">141</span>]: <span class="string">&#x27;guido&#x27;</span> <span class="keyword">in</span> val</span><br><span class="line">Out[<span class="number">141</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">142</span>]: val.index(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">Out[<span class="number">142</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">143</span>]: val.find(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">Out[<span class="number">143</span>]: -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意find和index的区别：如果找不到字符串，index将会引发一个异常（而不是返回－1）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">144</span>]: val.index(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">144</span>-280f8b2856ce&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> val.index(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">ValueError: substring <span class="keyword">not</span> found</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与此相关，count可以返回指定子串的出现次数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">145</span>]: val.count(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">Out[<span class="number">145</span>]: <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>replace用于将指定模式替换为另一个模式。通过传入空字符串，它也常常用于删除模式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">146</span>]: val.replace(<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;::&#x27;</span>)</span><br><span class="line">Out[<span class="number">146</span>]: <span class="string">&#x27;a::b::  guido&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">147</span>]: val.replace(<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">Out[<span class="number">147</span>]: <span class="string">&#x27;ab  guido&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表7-3列出了Python内置的字符串方法。</p>
<p>这些运算大部分都能使用正则表达式实现（马上就会看到）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-087fe67bf6db0701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-d1f0d4ed3e895016.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>casefold 将字符转换为小写，并将任何特定区域的变量字符组合转换成一个通用的可比较形式。</p>
<h2 id="正则表达式">正则表达式</h2>
<p>正则表达式提供了一种灵活的在文本中搜索或匹配（通常比前者复杂）字符串模式的方式。正则表达式，常称作regex，是根据正则表达式语言编写的字符串。Python内置的re模块负责对字符串应用正则表达式。我将通过一些例子说明其使用方法。</p>
<blockquote>
<p>笔记：正则表达式的编写技巧可以自成一章，超出了本书的范围。从网上和其它书可以找到许多非常不错的教程和参考资料。</p>
</blockquote>
<p>re模块的函数可以分为三个大类：模式匹配、替换以及拆分。当然，它们之间是相辅相成的。一个regex描述了需要在文本中定位的一个模式，它可以用于许多目的。我们先来看一个简单的例子：假设我想要拆分一个字符串，分隔符为数量不定的一组空白符（制表符、空格、换行符等）。描述一个或多个空白符的regex是+：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">148</span>]: <span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">In [<span class="number">149</span>]: text = <span class="string">&quot;foo    bar\t baz  \tqux&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">150</span>]: re.split(<span class="string">&#x27;\s+&#x27;</span>, text)</span><br><span class="line">Out[<span class="number">150</span>]: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调用re.split('+',text)时，正则表达式会先被编译，然后再在text上调用其split方法。你可以用re.compile自己编译regex以得到一个可重用的regex对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">151</span>]: regex = re.<span class="built_in">compile</span>(<span class="string">&#x27;\s+&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">152</span>]: regex.split(text)</span><br><span class="line">Out[<span class="number">152</span>]: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果只希望得到匹配regex的所有模式，则可以使用findall方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">153</span>]: regex.findall(text)</span><br><span class="line">Out[<span class="number">153</span>]: [<span class="string">&#x27;    &#x27;</span>, <span class="string">&#x27;\t &#x27;</span>, <span class="string">&#x27;  \t&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：如果想避免正则表达式中不需要的转义（），则可以使用原始字符串字面量如r'C:'（也可以编写其等价式'C:\x'）。</p>
</blockquote>
<p>如果打算对许多字符串应用同一条正则表达式，强烈建议通过re.compile创建regex对象。这样将可以节省大量的CPU时间。</p>
<p>match和search跟findall功能类似。findall返回的是字符串中所有的匹配项，而search则只返回第一个匹配项。match更加严格，它只匹配字符串的首部。来看一个小例子，假设我们有一段文本以及一条能够识别大部分电子邮件地址的正则表达式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&quot;&quot;&quot;Dave dave@google.com</span></span><br><span class="line"><span class="string">Steve steve@gmail.com</span></span><br><span class="line"><span class="string">Rob rob@gmail.com</span></span><br><span class="line"><span class="string">Ryan ryan@yahoo.com</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">pattern = <span class="string">r&#x27;[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]&#123;2,4&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># re.IGNORECASE makes the regex case-insensitive</span></span><br><span class="line">regex = re.<span class="built_in">compile</span>(pattern, flags=re.IGNORECASE)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对text使用findall将得到一组电子邮件地址：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">155</span>]: regex.findall(text)</span><br><span class="line">Out[<span class="number">155</span>]: </span><br><span class="line">[<span class="string">&#x27;dave@google.com&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;steve@gmail.com&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;rob@gmail.com&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ryan@yahoo.com&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>search返回的是文本中第一个电子邮件地址（以特殊的匹配项对象形式返回）。对于上面那个regex，匹配项对象只能告诉我们模式在原字符串中的起始和结束位置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">156</span>]: m = regex.search(text)</span><br><span class="line"></span><br><span class="line">In [<span class="number">157</span>]: m</span><br><span class="line">Out[<span class="number">157</span>]: &lt;_sre.SRE_Match <span class="built_in">object</span>; span=(<span class="number">5</span>, <span class="number">20</span>), match=<span class="string">&#x27;dave@google.com&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">158</span>]: text[m.start():m.end()]</span><br><span class="line">Out[<span class="number">158</span>]: <span class="string">&#x27;dave@google.com&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>regex.match则将返回None，因为它只匹配出现在字符串开头的模式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">159</span>]: <span class="built_in">print</span>(regex.match(text))</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>相关的，sub方法可以将匹配到的模式替换为指定字符串，并返回所得到的新字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">160</span>]: <span class="built_in">print</span>(regex.sub(<span class="string">&#x27;REDACTED&#x27;</span>, text))</span><br><span class="line">Dave REDACTED</span><br><span class="line">Steve REDACTED</span><br><span class="line">Rob REDACTED</span><br><span class="line">Ryan REDACTED</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设你不仅想要找出电子邮件地址，还想将各个地址分成3个部分：用户名、域名以及域后缀。要实现此功能，只需将待分段的模式的各部分用圆括号包起来即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">161</span>]: pattern = <span class="string">r&#x27;([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\.([A-Z]&#123;2,4&#125;)&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">162</span>]: regex = re.<span class="built_in">compile</span>(pattern, flags=re.IGNORECASE)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由这种修改过的正则表达式所产生的匹配项对象，可以通过其groups方法返回一个由模式各段组成的元组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">163</span>]: m = regex.match(<span class="string">&#x27;wesm@bright.net&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">164</span>]: m.groups()</span><br><span class="line">Out[<span class="number">164</span>]: (<span class="string">&#x27;wesm&#x27;</span>, <span class="string">&#x27;bright&#x27;</span>, <span class="string">&#x27;net&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于带有分组功能的模式，findall会返回一个元组列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">165</span>]: regex.findall(text)</span><br><span class="line">Out[<span class="number">165</span>]:</span><br><span class="line">[(<span class="string">&#x27;dave&#x27;</span>, <span class="string">&#x27;google&#x27;</span>, <span class="string">&#x27;com&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;steve&#x27;</span>, <span class="string">&#x27;gmail&#x27;</span>, <span class="string">&#x27;com&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;rob&#x27;</span>, <span class="string">&#x27;gmail&#x27;</span>, <span class="string">&#x27;com&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;ryan&#x27;</span>, <span class="string">&#x27;yahoo&#x27;</span>, <span class="string">&#x27;com&#x27;</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>sub还能通过诸如\1、\2之类的特殊符号访问各匹配项中的分组。符号\1对应第一个匹配的组，\2对应第二个匹配的组，以此类推：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">166</span>]: <span class="built_in">print</span>(regex.sub(<span class="string">r&#x27;Username: \1, Domain: \2, Suffix: \3&#x27;</span>, text))</span><br><span class="line">Dave Username: dave, Domain: google, Suffix: com</span><br><span class="line">Steve Username: steve, Domain: gmail, Suffix: com</span><br><span class="line">Rob Username: rob, Domain: gmail, Suffix: com</span><br><span class="line">Ryan Username: ryan, Domain: yahoo, Suffix: com</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python中还有许多的正则表达式，但大部分都超出了本书的范围。表7-4是一个简要概括。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-efbb80a793759fc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<h2 id="pandas的矢量化字符串函数">pandas的矢量化字符串函数</h2>
<p>清理待分析的散乱数据时，常常需要做一些字符串规整化工作。更为复杂的情况是，含有字符串的列有时还含有缺失数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">167</span>]: data = &#123;<span class="string">&#x27;Dave&#x27;</span>: <span class="string">&#x27;dave@google.com&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>: <span class="string">&#x27;steve@gmail.com&#x27;</span>,</span><br><span class="line">   .....:         <span class="string">&#x27;Rob&#x27;</span>: <span class="string">&#x27;rob@gmail.com&#x27;</span>, <span class="string">&#x27;Wes&#x27;</span>: np.nan&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">168</span>]: data = pd.Series(data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">169</span>]: data</span><br><span class="line">Out[<span class="number">169</span>]: </span><br><span class="line">Dave     dave@google.com</span><br><span class="line">Rob        rob@gmail.com</span><br><span class="line">Steve    steve@gmail.com</span><br><span class="line">Wes                  NaN</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">170</span>]: data.isnull()</span><br><span class="line">Out[<span class="number">170</span>]: </span><br><span class="line">Dave     <span class="literal">False</span></span><br><span class="line">Rob      <span class="literal">False</span></span><br><span class="line">Steve    <span class="literal">False</span></span><br><span class="line">Wes       <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过data.map，所有字符串和正则表达式方法都能被应用于（传入lambda表达式或其他函数）各个值，但是如果存在NA（null）就会报错。为了解决这个问题，Series有一些能够跳过NA值的面向数组方法，进行字符串操作。通过Series的str属性即可访问这些方法。例如，我们可以通过str.contains检查各个电子邮件地址是否含有"gmail"：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">171</span>]: data.<span class="built_in">str</span>.contains(<span class="string">&#x27;gmail&#x27;</span>)</span><br><span class="line">Out[<span class="number">171</span>]: </span><br><span class="line">Dave     <span class="literal">False</span></span><br><span class="line">Rob       <span class="literal">True</span></span><br><span class="line">Steve     <span class="literal">True</span></span><br><span class="line">Wes        NaN</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以使用正则表达式，还可以加上任意re选项（如IGNORECASE）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">172</span>]: pattern</span><br><span class="line">Out[<span class="number">172</span>]: <span class="string">&#x27;([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\\.([A-Z]&#123;2,4&#125;)&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">173</span>]: data.<span class="built_in">str</span>.findall(pattern, flags=re.IGNORECASE)</span><br><span class="line">Out[<span class="number">173</span>]: </span><br><span class="line">Dave     [(dave, google, com)]</span><br><span class="line">Rob        [(rob, gmail, com)]</span><br><span class="line">Steve    [(steve, gmail, com)]</span><br><span class="line">Wes                        NaN</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有两个办法可以实现矢量化的元素获取操作：要么使用str.get，要么在str属性上使用索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">174</span>]: matches = data.<span class="built_in">str</span>.match(pattern, flags=re.IGNORECASE)</span><br><span class="line"></span><br><span class="line">In [<span class="number">175</span>]: matches</span><br><span class="line">Out[<span class="number">175</span>]: </span><br><span class="line">Dave     <span class="literal">True</span></span><br><span class="line">Rob      <span class="literal">True</span></span><br><span class="line">Steve    <span class="literal">True</span></span><br><span class="line">Wes       NaN</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要访问嵌入列表中的元素，我们可以传递索引到这两个函数中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">176</span>]: matches.<span class="built_in">str</span>.get(<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">176</span>]: </span><br><span class="line">Dave    NaN</span><br><span class="line">Rob     NaN</span><br><span class="line">Steve   NaN</span><br><span class="line">Wes     NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">177</span>]: matches.<span class="built_in">str</span>[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">177</span>]: </span><br><span class="line">Dave    NaN</span><br><span class="line">Rob     NaN</span><br><span class="line">Steve   NaN</span><br><span class="line">Wes     NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可以利用这种方法对字符串进行截取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">178</span>]: data.<span class="built_in">str</span>[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">178</span>]: </span><br><span class="line">Dave     dave@</span><br><span class="line">Rob      rob@g</span><br><span class="line">Steve    steve</span><br><span class="line">Wes        NaN</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表7-5介绍了更多的pandas字符串方法。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-a634364ed6d5d5c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表7-5 部分矢量化字符串方法" /><figcaption aria-hidden="true">表7-5 部分矢量化字符串方法</figcaption>
</figure>
<h1 id="总结">7.4 总结</h1>
<p>高效的数据准备可以让你将更多的时间用于数据分析，花较少的时间用于准备工作，这样就可以极大地提高生产力。我们在本章中学习了许多工具，但覆盖并不全面。下一章，我们会学习pandas的聚合与分组。</p>
]]></content>
      <categories>
        <category>Python 数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>第08章 数据规整：聚合、合并和重塑</title>
    <url>/2019/04/09/%E7%AC%AC08%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%A7%84%E6%95%B4%EF%BC%9A%E8%81%9A%E5%90%88%E3%80%81%E5%90%88%E5%B9%B6%E5%92%8C%E9%87%8D%E5%A1%91/</url>
    <content><![CDATA[<p>在许多应用中，数据可能分散在许多文件或数据库中，存储的形式也不利于分析。本章关注可以聚合、合并、重塑数据的方法。</p>
<p>首先，我会介绍pandas的层次化索引，它广泛用于以上操作。然后，我深入介绍了一些特殊的数据操作。在第14章，你可以看到这些工具的多种应用。<span id="more"></span></p>
<h1 id="层次化索引">8.1 层次化索引</h1>
<p>层次化索引（hierarchical indexing）是pandas的一项重要功能，它使你能在一个轴上拥有多个（两个以上）索引级别。抽象点说，它使你能以低维度形式处理高维度数据。我们先来看一个简单的例子：创建一个Series，并用一个由列表或数组组成的列表作为索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: data = pd.Series(np.random.randn(<span class="number">9</span>),</span><br><span class="line">   ...:                  index=[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">   ...:                         [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: data</span><br><span class="line">Out[<span class="number">10</span>]: </span><br><span class="line">a  <span class="number">1</span>   -<span class="number">0.204708</span></span><br><span class="line">   <span class="number">2</span>    <span class="number">0.478943</span></span><br><span class="line">   <span class="number">3</span>   -<span class="number">0.519439</span></span><br><span class="line">b  <span class="number">1</span>   -<span class="number">0.555730</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">1.965781</span></span><br><span class="line">c  <span class="number">1</span>    <span class="number">1.393406</span></span><br><span class="line">   <span class="number">2</span>    <span class="number">0.092908</span></span><br><span class="line">d  <span class="number">2</span>    <span class="number">0.281746</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">0.769023</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>看到的结果是经过美化的带有MultiIndex索引的Series的格式。索引之间的“间隔”表示“直接使用上面的标签”：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: data.index</span><br><span class="line">Out[<span class="number">11</span>]: </span><br><span class="line">MultiIndex(levels=[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]],</span><br><span class="line">           labels=[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<p>对于一个层次化索引的对象，可以使用所谓的部分索引，使用它选取数据子集的操作更简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: data[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">12</span>]: </span><br><span class="line"><span class="number">1</span>   -<span class="number">0.555730</span></span><br><span class="line"><span class="number">3</span>    <span class="number">1.965781</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: data[<span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">Out[<span class="number">13</span>]: </span><br><span class="line">b  <span class="number">1</span>   -<span class="number">0.555730</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">1.965781</span></span><br><span class="line">c  <span class="number">1</span>    <span class="number">1.393406</span></span><br><span class="line">   <span class="number">2</span>    <span class="number">0.092908</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: data.loc[[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]]</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">b  <span class="number">1</span>   -<span class="number">0.555730</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">1.965781</span></span><br><span class="line">d  <span class="number">2</span>    <span class="number">0.281746</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">0.769023</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>有时甚至还可以在“内层”中进行选取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: data.loc[:, <span class="number">2</span>]</span><br><span class="line">Out[<span class="number">15</span>]: </span><br><span class="line">a    <span class="number">0.478943</span></span><br><span class="line">c    <span class="number">0.092908</span></span><br><span class="line">d    <span class="number">0.281746</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>层次化索引在数据重塑和基于分组的操作（如透视表生成）中扮演着重要的角色。例如，可以通过unstack方法将这段数据重新安排到一个DataFrame中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">16</span>]: data.unstack()</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">          <span class="number">1</span>         <span class="number">2</span>         <span class="number">3</span></span><br><span class="line">a -<span class="number">0.204708</span>  <span class="number">0.478943</span> -<span class="number">0.519439</span></span><br><span class="line">b -<span class="number">0.555730</span>       NaN  <span class="number">1.965781</span></span><br><span class="line">c  <span class="number">1.393406</span>  <span class="number">0.092908</span>       NaN</span><br><span class="line">d       NaN  <span class="number">0.281746</span>  <span class="number">0.769023</span></span><br></pre></td></tr></table></figure>
<p>unstack的逆运算是stack：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: data.unstack().stack()</span><br><span class="line">Out[<span class="number">17</span>]: </span><br><span class="line">a  <span class="number">1</span>   -<span class="number">0.204708</span></span><br><span class="line">   <span class="number">2</span>    <span class="number">0.478943</span></span><br><span class="line">   <span class="number">3</span>   -<span class="number">0.519439</span></span><br><span class="line">b  <span class="number">1</span>   -<span class="number">0.555730</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">1.965781</span></span><br><span class="line">c  <span class="number">1</span>    <span class="number">1.393406</span></span><br><span class="line">   <span class="number">2</span>    <span class="number">0.092908</span></span><br><span class="line">d  <span class="number">2</span>    <span class="number">0.281746</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">0.769023</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>stack和unstack将在本章后面详细讲解。</p>
<p>对于一个DataFrame，每条轴都可以有分层索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: frame = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)),</span><br><span class="line">   ....:                      index=[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]],</span><br><span class="line">   ....:                      columns=[[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>],</span><br><span class="line">   ....:                               [<span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Red&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: frame</span><br><span class="line">Out[<span class="number">19</span>]: </span><br><span class="line">     Ohio     Colorado</span><br><span class="line">    Green Red    Green</span><br><span class="line">a <span class="number">1</span>     <span class="number">0</span>   <span class="number">1</span>        <span class="number">2</span></span><br><span class="line">  <span class="number">2</span>     <span class="number">3</span>   <span class="number">4</span>        <span class="number">5</span></span><br><span class="line">b <span class="number">1</span>     <span class="number">6</span>   <span class="number">7</span>        <span class="number">8</span></span><br><span class="line">  <span class="number">2</span>     <span class="number">9</span>  <span class="number">10</span>       <span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>各层都可以有名字（可以是字符串，也可以是别的Python对象）。如果指定了名称，它们就会显示在控制台输出中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: frame.index.names = [<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: frame.columns.names = [<span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;color&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: frame</span><br><span class="line">Out[<span class="number">22</span>]: </span><br><span class="line">state      Ohio     Colorado</span><br><span class="line">color     Green Red    Green</span><br><span class="line">key1 key2                   </span><br><span class="line">a    <span class="number">1</span>        <span class="number">0</span>   <span class="number">1</span>        <span class="number">2</span></span><br><span class="line">     <span class="number">2</span>        <span class="number">3</span>   <span class="number">4</span>        <span class="number">5</span></span><br><span class="line">b    <span class="number">1</span>        <span class="number">6</span>   <span class="number">7</span>        <span class="number">8</span></span><br><span class="line">     <span class="number">2</span>        <span class="number">9</span>  <span class="number">10</span>       <span class="number">11</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：小心区分索引名state、color与行标签。</p>
</blockquote>
<p>有了部分列索引，因此可以轻松选取列分组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">23</span>]: frame[<span class="string">&#x27;Ohio&#x27;</span>]</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">color      Green  Red</span><br><span class="line">key1 key2            </span><br><span class="line">a    <span class="number">1</span>         <span class="number">0</span>    <span class="number">1</span></span><br><span class="line">     <span class="number">2</span>         <span class="number">3</span>    <span class="number">4</span></span><br><span class="line">b    <span class="number">1</span>         <span class="number">6</span>    <span class="number">7</span></span><br><span class="line">     <span class="number">2</span>         <span class="number">9</span>   <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>可以单独创建MultiIndex然后复用。上面那个DataFrame中的（带有分级名称）列可以这样创建：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MultiIndex.from_arrays([[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>], [<span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Red&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>]],</span><br><span class="line">                       names=[<span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;color&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h2 id="重排与分级排序">重排与分级排序</h2>
<p>有时，你需要重新调整某条轴上各级别的顺序，或根据指定级别上的值对数据进行排序。swaplevel接受两个级别编号或名称，并返回一个互换了级别的新对象（但数据不会发生变化）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: frame.swaplevel(<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>)</span><br><span class="line">Out[<span class="number">24</span>]: </span><br><span class="line">state      Ohio     Colorado</span><br><span class="line">color     Green Red    Green</span><br><span class="line">key2 key1                   </span><br><span class="line"><span class="number">1</span>    a        <span class="number">0</span>   <span class="number">1</span>        <span class="number">2</span></span><br><span class="line"><span class="number">2</span>    a        <span class="number">3</span>   <span class="number">4</span>        <span class="number">5</span></span><br><span class="line"><span class="number">1</span>    b        <span class="number">6</span>   <span class="number">7</span>        <span class="number">8</span></span><br><span class="line"><span class="number">2</span>    b        <span class="number">9</span>  <span class="number">10</span>       <span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>而sort_index则根据单个级别中的值对数据进行排序。交换级别时，常常也会用到sort_index，这样最终结果就是按照指定顺序进行字母排序了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: frame.sort_index(level=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">25</span>]: </span><br><span class="line">state      Ohio     Colorado</span><br><span class="line">color     Green Red    Green</span><br><span class="line">key1 key2                   </span><br><span class="line">a    <span class="number">1</span>        <span class="number">0</span>   <span class="number">1</span>        <span class="number">2</span></span><br><span class="line">b    <span class="number">1</span>        <span class="number">6</span>   <span class="number">7</span>        <span class="number">8</span></span><br><span class="line">a    <span class="number">2</span>        <span class="number">3</span>   <span class="number">4</span>        <span class="number">5</span></span><br><span class="line">b    <span class="number">2</span>        <span class="number">9</span>  <span class="number">10</span>       <span class="number">11</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: frame.swaplevel(<span class="number">0</span>, <span class="number">1</span>).sort_index(level=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">26</span>]: </span><br><span class="line">state      Ohio     Colorado</span><br><span class="line">color     Green Red    Green</span><br><span class="line">key2 key1                   </span><br><span class="line"><span class="number">1</span>    a        <span class="number">0</span>   <span class="number">1</span>        <span class="number">2</span></span><br><span class="line">     b        <span class="number">6</span>   <span class="number">7</span>        <span class="number">8</span></span><br><span class="line"><span class="number">2</span>    a        <span class="number">3</span>   <span class="number">4</span>        <span class="number">5</span></span><br><span class="line">     b        <span class="number">9</span>  <span class="number">10</span>       <span class="number">11</span></span><br></pre></td></tr></table></figure>
<h2 id="根据级别汇总统计">根据级别汇总统计</h2>
<p>许多对DataFrame和Series的描述和汇总统计都有一个level选项，它用于指定在某条轴上求和的级别。再以上面那个DataFrame为例，我们可以根据行或列上的级别来进行求和：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">27</span>]: frame.<span class="built_in">sum</span>(level=<span class="string">&#x27;key2&#x27;</span>)</span><br><span class="line">Out[<span class="number">27</span>]: </span><br><span class="line">state  Ohio     Colorado</span><br><span class="line">color Green Red    Green</span><br><span class="line">key2                    </span><br><span class="line"><span class="number">1</span>         <span class="number">6</span>   <span class="number">8</span>       <span class="number">10</span></span><br><span class="line"><span class="number">2</span>        <span class="number">12</span>  <span class="number">14</span>       <span class="number">16</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: frame.<span class="built_in">sum</span>(level=<span class="string">&#x27;color&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">color      Green  Red</span><br><span class="line">key1 key2            </span><br><span class="line">a    <span class="number">1</span>         <span class="number">2</span>    <span class="number">1</span></span><br><span class="line">     <span class="number">2</span>         <span class="number">8</span>    <span class="number">4</span></span><br><span class="line">b    <span class="number">1</span>        <span class="number">14</span>    <span class="number">7</span></span><br><span class="line">     <span class="number">2</span>        <span class="number">20</span>   <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>这其实是利用了pandas的groupby功能，本书稍后将对其进行详细讲解。</p>
<h2 id="使用dataframe的列进行索引">使用DataFrame的列进行索引</h2>
<p>人们经常想要将DataFrame的一个或多个列当做行索引来用，或者可能希望将行索引变成DataFrame的列。以下面这个DataFrame为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">29</span>]: frame = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>), <span class="string">&#x27;b&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>, <span class="number">0</span>, -<span class="number">1</span>),</span><br><span class="line">   ....:                       <span class="string">&#x27;c&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>,</span><br><span class="line">   ....:                             <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">   ....:                       <span class="string">&#x27;d&#x27;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: frame</span><br><span class="line">Out[<span class="number">30</span>]: </span><br><span class="line">   a  b    c  d</span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">7</span>  one  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">6</span>  one  <span class="number">1</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2</span>  <span class="number">5</span>  one  <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  <span class="number">3</span>  <span class="number">4</span>  two  <span class="number">0</span></span><br><span class="line"><span class="number">4</span>  <span class="number">4</span>  <span class="number">3</span>  two  <span class="number">1</span></span><br><span class="line"><span class="number">5</span>  <span class="number">5</span>  <span class="number">2</span>  two  <span class="number">2</span></span><br><span class="line"><span class="number">6</span>  <span class="number">6</span>  <span class="number">1</span>  two  <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>DataFrame的set_index函数会将其一个或多个列转换为行索引，并创建一个新的DataFrame：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">31</span>]: frame2 = frame.set_index([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: frame2</span><br><span class="line">Out[<span class="number">32</span>]: </span><br><span class="line">       a  b</span><br><span class="line">c   d      </span><br><span class="line">one <span class="number">0</span>  <span class="number">0</span>  <span class="number">7</span></span><br><span class="line">    <span class="number">1</span>  <span class="number">1</span>  <span class="number">6</span></span><br><span class="line">    <span class="number">2</span>  <span class="number">2</span>  <span class="number">5</span></span><br><span class="line">two <span class="number">0</span>  <span class="number">3</span>  <span class="number">4</span></span><br><span class="line">    <span class="number">1</span>  <span class="number">4</span>  <span class="number">3</span></span><br><span class="line">    <span class="number">2</span>  <span class="number">5</span>  <span class="number">2</span></span><br><span class="line">    <span class="number">3</span>  <span class="number">6</span>  <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，那些列会从DataFrame中移除，但也可以将其保留下来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">33</span>]: frame.set_index([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], drop=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">33</span>]: </span><br><span class="line">       a  b    c  d</span><br><span class="line">c   d              </span><br><span class="line">one <span class="number">0</span>  <span class="number">0</span>  <span class="number">7</span>  one  <span class="number">0</span></span><br><span class="line">    <span class="number">1</span>  <span class="number">1</span>  <span class="number">6</span>  one  <span class="number">1</span></span><br><span class="line">    <span class="number">2</span>  <span class="number">2</span>  <span class="number">5</span>  one  <span class="number">2</span></span><br><span class="line">two <span class="number">0</span>  <span class="number">3</span>  <span class="number">4</span>  two  <span class="number">0</span></span><br><span class="line">    <span class="number">1</span>  <span class="number">4</span>  <span class="number">3</span>  two  <span class="number">1</span></span><br><span class="line">    <span class="number">2</span>  <span class="number">5</span>  <span class="number">2</span>  two  <span class="number">2</span></span><br><span class="line">    <span class="number">3</span>  <span class="number">6</span>  <span class="number">1</span>  two  <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>reset_index的功能跟set_index刚好相反，层次化索引的级别会被转移到列里面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">34</span>]: frame2.reset_index()</span><br><span class="line">Out[<span class="number">34</span>]:</span><br><span class="line">c  d  a  b</span><br><span class="line"><span class="number">0</span>  one  <span class="number">0</span>  <span class="number">0</span>  <span class="number">7</span></span><br><span class="line"><span class="number">1</span>  one  <span class="number">1</span>  <span class="number">1</span>  <span class="number">6</span></span><br><span class="line"><span class="number">2</span>  one  <span class="number">2</span>  <span class="number">2</span>  <span class="number">5</span></span><br><span class="line"><span class="number">3</span>  two  <span class="number">0</span>  <span class="number">3</span>  <span class="number">4</span></span><br><span class="line"><span class="number">4</span>  two  <span class="number">1</span>  <span class="number">4</span>  <span class="number">3</span></span><br><span class="line"><span class="number">5</span>  two  <span class="number">2</span>  <span class="number">5</span>  <span class="number">2</span></span><br><span class="line"><span class="number">6</span>  two  <span class="number">3</span>  <span class="number">6</span>  <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="合并数据集">8.2 合并数据集</h1>
<p>pandas对象中的数据可以通过一些方式进行合并：</p>
<ul>
<li>pandas.merge可根据一个或多个键将不同DataFrame中的行连接起来。SQL或其他关系型数据库的用户对此应该会比较熟悉，因为它实现的就是数据库的join操作。</li>
<li>pandas.concat可以沿着一条轴将多个对象堆叠到一起。</li>
<li>实例方法combine_first可以将重复数据拼接在一起，用一个对象中的值填充另一个对象中的缺失值。</li>
</ul>
<p>我将分别对它们进行讲解，并给出一些例子。本书剩余部分的示例中将经常用到它们。</p>
<h2 id="数据库风格的dataframe合并">数据库风格的DataFrame合并</h2>
<p>数据集的合并（merge）或连接（join）运算是通过一个或多个键将行连接起来的。这些运算是关系型数据库（基于SQL）的核心。pandas的merge函数是对数据应用这些算法的主要切入点。</p>
<p>以一个简单的例子开始：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">35</span>]: df1 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">   ....:                     <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: df2 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">   ....:                     <span class="string">&#x27;data2&#x27;</span>: <span class="built_in">range</span>(<span class="number">3</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: df1</span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">   data1 key</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b</span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>   a</span><br><span class="line"><span class="number">3</span>      <span class="number">3</span>   c</span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   a</span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   a</span><br><span class="line"><span class="number">6</span>      <span class="number">6</span>   b</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: df2</span><br><span class="line">Out[<span class="number">38</span>]: </span><br><span class="line">   data2 key</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   a</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b</span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>   d</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是一种多对一的合并。df1中的数据有多个被标记为a和b的行，而df2中key列的每个值则仅对应一行。对这些对象调用merge即可得到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">39</span>]: pd.merge(df1, df2)</span><br><span class="line">Out[<span class="number">39</span>]: </span><br><span class="line">   data1 key  data2</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>      <span class="number">6</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">3</span>      <span class="number">2</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   a      <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，我并没有指明要用哪个列进行连接。如果没有指定，merge就会将重叠列的列名当做键。不过，最好明确指定一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">40</span>]: pd.merge(df1, df2, on=<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">   data1 key  data2</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>      <span class="number">6</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">3</span>      <span class="number">2</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   a      <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果两个对象的列名不同，也可以分别进行指定：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: df3 = pd.DataFrame(&#123;<span class="string">&#x27;lkey&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">   ....:                     <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: df4 = pd.DataFrame(&#123;<span class="string">&#x27;rkey&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">   ....:                     <span class="string">&#x27;data2&#x27;</span>: <span class="built_in">range</span>(<span class="number">3</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: pd.merge(df3, df4, left_on=<span class="string">&#x27;lkey&#x27;</span>, right_on=<span class="string">&#x27;rkey&#x27;</span>)</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">   data1 lkey  data2 rkey</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>    b      <span class="number">1</span>    b</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>    b      <span class="number">1</span>    b</span><br><span class="line"><span class="number">2</span>      <span class="number">6</span>    b      <span class="number">1</span>    b</span><br><span class="line"><span class="number">3</span>      <span class="number">2</span>    a      <span class="number">0</span>    a</span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>    a      <span class="number">0</span>    a</span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>    a      <span class="number">0</span>    a</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可能你已经注意到了，结果里面c和d以及与之相关的数据消失了。默认情况下，merge做的是“内连接”；结果中的键是交集。其他方式还有"left"、"right"以及"outer"。外连接求取的是键的并集，组合了左连接和右连接的效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">44</span>]: pd.merge(df1, df2, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">Out[<span class="number">44</span>]: </span><br><span class="line">   data1 key  data2</span><br><span class="line"><span class="number">0</span>    <span class="number">0.0</span>   b    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span>   b    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">6.0</span>   b    <span class="number">1.0</span></span><br><span class="line"><span class="number">3</span>    <span class="number">2.0</span>   a    <span class="number">0.0</span></span><br><span class="line"><span class="number">4</span>    <span class="number">4.0</span>   a    <span class="number">0.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">5.0</span>   a    <span class="number">0.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">3.0</span>   c    NaN</span><br><span class="line"><span class="number">7</span>    NaN   d    <span class="number">2.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表8-1对这些选项进行了总结。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-e49b3341f4a3c90e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表8-1 不同的连接类型" /><figcaption aria-hidden="true">表8-1 不同的连接类型</figcaption>
</figure>
<p>多对多的合并有些不直观。看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">45</span>]: df1 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">   ....:                     <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">6</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: df2 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">   ....:                     <span class="string">&#x27;data2&#x27;</span>: <span class="built_in">range</span>(<span class="number">5</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: df1</span><br><span class="line">Out[<span class="number">47</span>]: </span><br><span class="line">   data1 key</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b</span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>   a</span><br><span class="line"><span class="number">3</span>      <span class="number">3</span>   c</span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   a</span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   b</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: df2</span><br><span class="line">Out[<span class="number">48</span>]: </span><br><span class="line">   data2 key</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   a</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b</span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>   a</span><br><span class="line"><span class="number">3</span>      <span class="number">3</span>   b</span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   d</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: pd.merge(df1, df2, on=<span class="string">&#x27;key&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">Out[<span class="number">49</span>]: </span><br><span class="line">    data1 key  data2</span><br><span class="line"><span class="number">0</span>       <span class="number">0</span>   b    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>       <span class="number">0</span>   b    <span class="number">3.0</span></span><br><span class="line"><span class="number">2</span>       <span class="number">1</span>   b    <span class="number">1.0</span></span><br><span class="line"><span class="number">3</span>       <span class="number">1</span>   b    <span class="number">3.0</span></span><br><span class="line"><span class="number">4</span>       <span class="number">2</span>   a    <span class="number">0.0</span></span><br><span class="line"><span class="number">5</span>       <span class="number">2</span>   a    <span class="number">2.0</span></span><br><span class="line"><span class="number">6</span>       <span class="number">3</span>   c    NaN</span><br><span class="line"><span class="number">7</span>       <span class="number">4</span>   a    <span class="number">0.0</span></span><br><span class="line"><span class="number">8</span>       <span class="number">4</span>   a    <span class="number">2.0</span></span><br><span class="line"><span class="number">9</span>       <span class="number">5</span>   b    <span class="number">1.0</span></span><br><span class="line"><span class="number">10</span>      <span class="number">5</span>   b    <span class="number">3.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>多对多连接产生的是行的笛卡尔积。由于左边的DataFrame有3个"b"行，右边的有2个，所以最终结果中就有6个"b"行。连接方式只影响出现在结果中的不同的键的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">50</span>]: pd.merge(df1, df2, how=<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line">Out[<span class="number">50</span>]: </span><br><span class="line">   data1 key  data2</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>      <span class="number">0</span>   b      <span class="number">3</span></span><br><span class="line"><span class="number">2</span>      <span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">3</span>      <span class="number">1</span>   b      <span class="number">3</span></span><br><span class="line"><span class="number">4</span>      <span class="number">5</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   b      <span class="number">3</span></span><br><span class="line"><span class="number">6</span>      <span class="number">2</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">7</span>      <span class="number">2</span>   a      <span class="number">2</span></span><br><span class="line"><span class="number">8</span>      <span class="number">4</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">9</span>      <span class="number">4</span>   a      <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要根据多个键进行合并，传入一个由列名组成的列表即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">51</span>]: left = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">   ....:                      <span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">   ....:                      <span class="string">&#x27;lval&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: right = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">   ....:                       <span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">   ....:                       <span class="string">&#x27;rval&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: pd.merge(left, right, on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>], how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">  key1 key2  lval  rval</span><br><span class="line"><span class="number">0</span>  foo  one   <span class="number">1.0</span>   <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>  foo  one   <span class="number">1.0</span>   <span class="number">5.0</span></span><br><span class="line"><span class="number">2</span>  foo  two   <span class="number">2.0</span>   NaN</span><br><span class="line"><span class="number">3</span>  bar  one   <span class="number">3.0</span>   <span class="number">6.0</span></span><br><span class="line"><span class="number">4</span>  bar  two   NaN   <span class="number">7.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果中会出现哪些键组合取决于所选的合并方式，你可以这样来理解：多个键形成一系列元组，并将其当做单个连接键（当然，实际上并不是这么回事）。</p>
<blockquote>
<p>注意：在进行列－列连接时，DataFrame对象中的索引会被丢弃。</p>
</blockquote>
<p>对于合并运算需要考虑的最后一个问题是对重复列名的处理。虽然你可以手工处理列名重叠的问题（查看前面介绍的重命名轴标签），但merge有一个更实用的suffixes选项，用于指定附加到左右两个DataFrame对象的重叠列名上的字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">54</span>]: pd.merge(left, right, on=<span class="string">&#x27;key1&#x27;</span>)</span><br><span class="line">Out[<span class="number">54</span>]: </span><br><span class="line">  key1 key2_x  lval key2_y  rval</span><br><span class="line"><span class="number">0</span>  foo    one     <span class="number">1</span>    one     <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  foo    one     <span class="number">1</span>    one     <span class="number">5</span></span><br><span class="line"><span class="number">2</span>  foo    two     <span class="number">2</span>    one     <span class="number">4</span></span><br><span class="line"><span class="number">3</span>  foo    two     <span class="number">2</span>    one     <span class="number">5</span></span><br><span class="line"><span class="number">4</span>  bar    one     <span class="number">3</span>    one     <span class="number">6</span></span><br><span class="line"><span class="number">5</span>  bar    one     <span class="number">3</span>    two     <span class="number">7</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: pd.merge(left, right, on=<span class="string">&#x27;key1&#x27;</span>, suffixes=(<span class="string">&#x27;_left&#x27;</span>, <span class="string">&#x27;_right&#x27;</span>))</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">  key1 key2_left  lval key2_right  rval</span><br><span class="line"><span class="number">0</span>  foo       one     <span class="number">1</span>        one     <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  foo       one     <span class="number">1</span>        one     <span class="number">5</span></span><br><span class="line"><span class="number">2</span>  foo       two     <span class="number">2</span>        one     <span class="number">4</span></span><br><span class="line"><span class="number">3</span>  foo       two     <span class="number">2</span>        one     <span class="number">5</span></span><br><span class="line"><span class="number">4</span>  bar       one     <span class="number">3</span>        one     <span class="number">6</span></span><br><span class="line"><span class="number">5</span>  bar       one     <span class="number">3</span>        two     <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>merge的参数请参见表8-2。使用DataFrame的行索引合并是下一节的主题。</p>
<p>表8-2 merge函数的参数</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-35ca716a4f1b8475.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-c86672e733ceccd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>indicator 添加特殊的列_merge，它可以指明每个行的来源，它的值有left_only、right_only或both，根据每行的合并数据的来源。</p>
<h2 id="索引上的合并">索引上的合并</h2>
<p>有时候，DataFrame中的连接键位于其索引中。在这种情况下，你可以传入left_index=True或right_index=True（或两个都传）以说明索引应该被用作连接键：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: left1 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">   ....:                       <span class="string">&#x27;value&#x27;</span>: <span class="built_in">range</span>(<span class="number">6</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: right1 = pd.DataFrame(&#123;<span class="string">&#x27;group_val&#x27;</span>: [<span class="number">3.5</span>, <span class="number">7</span>]&#125;, index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: left1</span><br><span class="line">Out[<span class="number">58</span>]:</span><br><span class="line"></span><br><span class="line">  key  value</span><br><span class="line"><span class="number">0</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span></span><br><span class="line"><span class="number">3</span>   a      <span class="number">3</span></span><br><span class="line"><span class="number">4</span>   b      <span class="number">4</span></span><br><span class="line"><span class="number">5</span>   c      <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: right1</span><br><span class="line">Out[<span class="number">59</span>]: </span><br><span class="line">   group_val</span><br><span class="line">a        <span class="number">3.5</span></span><br><span class="line">b        <span class="number">7.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: pd.merge(left1, right1, left_on=<span class="string">&#x27;key&#x27;</span>, right_index=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">60</span>]: </span><br><span class="line">  key  value  group_val</span><br><span class="line"><span class="number">0</span>   a      <span class="number">0</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">3</span>   a      <span class="number">3</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span>        <span class="number">7.0</span></span><br><span class="line"><span class="number">4</span>   b      <span class="number">4</span>        <span class="number">7.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于默认的merge方法是求取连接键的交集，因此你可以通过外连接的方式得到它们的并集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">61</span>]: pd.merge(left1, right1, left_on=<span class="string">&#x27;key&#x27;</span>, right_index=<span class="literal">True</span>, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">Out[<span class="number">61</span>]: </span><br><span class="line">  key  value  group_val</span><br><span class="line"><span class="number">0</span>   a      <span class="number">0</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">3</span>   a      <span class="number">3</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span>        <span class="number">7.0</span></span><br><span class="line"><span class="number">4</span>   b      <span class="number">4</span>        <span class="number">7.0</span></span><br><span class="line"><span class="number">5</span>   c      <span class="number">5</span>        NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于层次化索引的数据，事情就有点复杂了，因为索引的合并默认是多键合并：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">62</span>]: lefth = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>,</span><br><span class="line">   ....:                                <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>],</span><br><span class="line">   ....:                       <span class="string">&#x27;key2&#x27;</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>],</span><br><span class="line">   ....:                       <span class="string">&#x27;data&#x27;</span>: np.arange(<span class="number">5.</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: righth = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">6</span>, <span class="number">2</span>)),</span><br><span class="line">   ....:                       index=[[<span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>,</span><br><span class="line">   ....:                               <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>],</span><br><span class="line">   ....:                              [<span class="number">2001</span>, <span class="number">2000</span>, <span class="number">2000</span>, <span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>]],</span><br><span class="line">   ....:                       columns=[<span class="string">&#x27;event1&#x27;</span>, <span class="string">&#x27;event2&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: lefth</span><br><span class="line">Out[<span class="number">64</span>]: </span><br><span class="line">   data    key1  key2</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>    Ohio  <span class="number">2000</span></span><br><span class="line"><span class="number">1</span>   <span class="number">1.0</span>    Ohio  <span class="number">2001</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2.0</span>    Ohio  <span class="number">2002</span></span><br><span class="line"><span class="number">3</span>   <span class="number">3.0</span>  Nevada  <span class="number">2001</span></span><br><span class="line"><span class="number">4</span>   <span class="number">4.0</span>  Nevada  <span class="number">2002</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: righth</span><br><span class="line">Out[<span class="number">65</span>]: </span><br><span class="line">             event1  event2</span><br><span class="line">Nevada <span class="number">2001</span>       <span class="number">0</span>       <span class="number">1</span></span><br><span class="line">       <span class="number">2000</span>       <span class="number">2</span>       <span class="number">3</span></span><br><span class="line">Ohio   <span class="number">2000</span>       <span class="number">4</span>       <span class="number">5</span></span><br><span class="line">       <span class="number">2000</span>       <span class="number">6</span>       <span class="number">7</span></span><br><span class="line">       <span class="number">2001</span>       <span class="number">8</span>       <span class="number">9</span></span><br><span class="line">       <span class="number">2002</span>      <span class="number">10</span>      <span class="number">11</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种情况下，你必须以列表的形式指明用作合并键的多个列（注意用how='outer'对重复索引值的处理）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">66</span>]: pd.merge(lefth, righth, left_on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>], right_index=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">66</span>]: </span><br><span class="line">   data    key1  key2  event1  event2</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>    Ohio  <span class="number">2000</span>       <span class="number">4</span>       <span class="number">5</span></span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>    Ohio  <span class="number">2000</span>       <span class="number">6</span>       <span class="number">7</span></span><br><span class="line"><span class="number">1</span>   <span class="number">1.0</span>    Ohio  <span class="number">2001</span>       <span class="number">8</span>       <span class="number">9</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2.0</span>    Ohio  <span class="number">2002</span>      <span class="number">10</span>      <span class="number">11</span></span><br><span class="line"><span class="number">3</span>   <span class="number">3.0</span>  Nevada  <span class="number">2001</span>       <span class="number">0</span>       <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: pd.merge(lefth, righth, left_on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>],</span><br><span class="line">   ....:          right_index=<span class="literal">True</span>, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">Out[<span class="number">67</span>]: </span><br><span class="line">   data    key1  key2  event1  event2</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>    Ohio  <span class="number">2000</span>     <span class="number">4.0</span>     <span class="number">5.0</span></span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>    Ohio  <span class="number">2000</span>     <span class="number">6.0</span>     <span class="number">7.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">1.0</span>    Ohio  <span class="number">2001</span>     <span class="number">8.0</span>     <span class="number">9.0</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2.0</span>    Ohio  <span class="number">2002</span>    <span class="number">10.0</span>    <span class="number">11.0</span></span><br><span class="line"><span class="number">3</span>   <span class="number">3.0</span>  Nevada  <span class="number">2001</span>     <span class="number">0.0</span>     <span class="number">1.0</span></span><br><span class="line"><span class="number">4</span>   <span class="number">4.0</span>  Nevada  <span class="number">2002</span>     NaN     NaN</span><br><span class="line"><span class="number">4</span>   NaN  Nevada  <span class="number">2000</span>     <span class="number">2.0</span>     <span class="number">3.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同时使用合并双方的索引也没问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">68</span>]: left2 = pd.DataFrame([[<span class="number">1.</span>, <span class="number">2.</span>], [<span class="number">3.</span>, <span class="number">4.</span>], [<span class="number">5.</span>, <span class="number">6.</span>]],</span><br><span class="line">   ....:                      index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>],</span><br><span class="line">   ....:                      columns=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: right2 = pd.DataFrame([[<span class="number">7.</span>, <span class="number">8.</span>], [<span class="number">9.</span>, <span class="number">10.</span>], [<span class="number">11.</span>, <span class="number">12.</span>], [<span class="number">13</span>, <span class="number">14</span>]],</span><br><span class="line">   ....:                       index=[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>],</span><br><span class="line">   ....:                       columns=[<span class="string">&#x27;Missouri&#x27;</span>, <span class="string">&#x27;Alabama&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: left2</span><br><span class="line">Out[<span class="number">70</span>]: </span><br><span class="line">   Ohio  Nevada</span><br><span class="line">a   <span class="number">1.0</span>     <span class="number">2.0</span></span><br><span class="line">c   <span class="number">3.0</span>     <span class="number">4.0</span></span><br><span class="line">e   <span class="number">5.0</span>     <span class="number">6.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: right2</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line">   Missouri  Alabama</span><br><span class="line">b       <span class="number">7.0</span>      <span class="number">8.0</span></span><br><span class="line">c       <span class="number">9.0</span>     <span class="number">10.0</span></span><br><span class="line">d      <span class="number">11.0</span>     <span class="number">12.0</span></span><br><span class="line">e      <span class="number">13.0</span>     <span class="number">14.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: pd.merge(left2, right2, how=<span class="string">&#x27;outer&#x27;</span>, left_index=<span class="literal">True</span>, right_index=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">72</span>]: </span><br><span class="line">   Ohio  Nevada  Missouri  Alabama</span><br><span class="line">a   <span class="number">1.0</span>     <span class="number">2.0</span>       NaN      NaN</span><br><span class="line">b   NaN     NaN       <span class="number">7.0</span>      <span class="number">8.0</span></span><br><span class="line">c   <span class="number">3.0</span>     <span class="number">4.0</span>       <span class="number">9.0</span>     <span class="number">10.0</span></span><br><span class="line">d   NaN     NaN      <span class="number">11.0</span>     <span class="number">12.0</span></span><br><span class="line">e   <span class="number">5.0</span>     <span class="number">6.0</span>      <span class="number">13.0</span>     <span class="number">14.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>DataFrame还有一个便捷的join实例方法，它能更为方便地实现按索引合并。它还可用于合并多个带有相同或相似索引的DataFrame对象，但要求没有重叠的列。在上面那个例子中，我们可以编写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">73</span>]: left2.join(right2, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">Out[<span class="number">73</span>]: </span><br><span class="line">   Ohio  Nevada  Missouri  Alabama</span><br><span class="line">a   <span class="number">1.0</span>     <span class="number">2.0</span>       NaN      NaN</span><br><span class="line">b   NaN     NaN       <span class="number">7.0</span>      <span class="number">8.0</span></span><br><span class="line">c   <span class="number">3.0</span>     <span class="number">4.0</span>       <span class="number">9.0</span>     <span class="number">10.0</span></span><br><span class="line">d   NaN     NaN      <span class="number">11.0</span>     <span class="number">12.0</span></span><br><span class="line">e   <span class="number">5.0</span>     <span class="number">6.0</span>      <span class="number">13.0</span>     <span class="number">14.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为一些历史版本的遗留原因，DataFrame的join方法默认使用的是左连接，保留左边表的行索引。它还支持在调用的DataFrame的列上，连接传递的DataFrame索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: left1.join(right1, on=<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">Out[<span class="number">74</span>]: </span><br><span class="line">  key  value  group_val</span><br><span class="line"><span class="number">0</span>   a      <span class="number">0</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span>        <span class="number">7.0</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">3</span>   a      <span class="number">3</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">4</span>   b      <span class="number">4</span>        <span class="number">7.0</span></span><br><span class="line"><span class="number">5</span>   c      <span class="number">5</span>        NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后，对于简单的索引合并，你还可以向join传入一组DataFrame，下一节会介绍更为通用的concat函数，也能实现此功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">75</span>]: another = pd.DataFrame([[<span class="number">7.</span>, <span class="number">8.</span>], [<span class="number">9.</span>, <span class="number">10.</span>], [<span class="number">11.</span>, <span class="number">12.</span>], [<span class="number">16.</span>, <span class="number">17.</span>]],</span><br><span class="line">   ....:                        index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>],</span><br><span class="line">   ....:                        columns=[<span class="string">&#x27;New York&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: another</span><br><span class="line">Out[<span class="number">76</span>]: </span><br><span class="line">   New York  Oregon</span><br><span class="line">a       <span class="number">7.0</span>     <span class="number">8.0</span></span><br><span class="line">c       <span class="number">9.0</span>    <span class="number">10.0</span></span><br><span class="line">e      <span class="number">11.0</span>    <span class="number">12.0</span></span><br><span class="line">f      <span class="number">16.0</span>    <span class="number">17.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: left2.join([right2, another])</span><br><span class="line">Out[<span class="number">77</span>]: </span><br><span class="line">   Ohio  Nevada  Missouri  Alabama  New York  Oregon</span><br><span class="line">a   <span class="number">1.0</span>     <span class="number">2.0</span>       NaN      NaN       <span class="number">7.0</span>     <span class="number">8.0</span></span><br><span class="line">c   <span class="number">3.0</span>     <span class="number">4.0</span>       <span class="number">9.0</span>     <span class="number">10.0</span>       <span class="number">9.0</span>    <span class="number">10.0</span></span><br><span class="line">e   <span class="number">5.0</span>     <span class="number">6.0</span>      <span class="number">13.0</span>     <span class="number">14.0</span>      <span class="number">11.0</span>    <span class="number">12.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: left2.join([right2, another], how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">Out[<span class="number">78</span>]: </span><br><span class="line">   Ohio  Nevada  Missouri  Alabama  New York  Oregon</span><br><span class="line">a   <span class="number">1.0</span>     <span class="number">2.0</span>       NaN      NaN       <span class="number">7.0</span>     <span class="number">8.0</span></span><br><span class="line">b   NaN     NaN       <span class="number">7.0</span>      <span class="number">8.0</span>       NaN     NaN</span><br><span class="line">c   <span class="number">3.0</span>     <span class="number">4.0</span>       <span class="number">9.0</span>     <span class="number">10.0</span>       <span class="number">9.0</span>    <span class="number">10.0</span></span><br><span class="line">d   NaN     NaN      <span class="number">11.0</span>     <span class="number">12.0</span>       NaN     NaN</span><br><span class="line">e   <span class="number">5.0</span>     <span class="number">6.0</span>      <span class="number">13.0</span>     <span class="number">14.0</span>      <span class="number">11.0</span>    <span class="number">12.0</span></span><br><span class="line">f   NaN     NaN       NaN      NaN      <span class="number">16.0</span>    <span class="number">17.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="轴向连接">轴向连接</h2>
<p>另一种数据合并运算也被称作连接（concatenation）、绑定（binding）或堆叠（stacking）。NumPy的concatenation函数可以用NumPy数组来做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">79</span>]: arr = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: arr</span><br><span class="line">Out[<span class="number">80</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: np.concatenate([arr, arr], axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">81</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于pandas对象（如Series和DataFrame），带有标签的轴使你能够进一步推广数组的连接运算。具体点说，你还需要考虑以下这些东西：</p>
<ul>
<li>如果对象在其它轴上的索引不同，我们应该合并这些轴的不同元素还是只使用交集？</li>
<li>连接的数据集是否需要在结果对象中可识别？</li>
<li>连接轴中保存的数据是否需要保留？许多情况下，DataFrame默认的整数标签最好在连接时删掉。</li>
</ul>
<p>pandas的concat函数提供了一种能够解决这些问题的可靠方式。我将给出一些例子来讲解其使用方式。假设有三个没有重叠索引的Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">82</span>]: s1 = pd.Series([<span class="number">0</span>, <span class="number">1</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: s2 = pd.Series([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: s3 = pd.Series([<span class="number">5</span>, <span class="number">6</span>], index=[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对这些对象调用concat可以将值和索引粘合在一起：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">85</span>]: pd.concat([s1, s2, s3])</span><br><span class="line">Out[<span class="number">85</span>]: </span><br><span class="line">a    <span class="number">0</span></span><br><span class="line">b    <span class="number">1</span></span><br><span class="line">c    <span class="number">2</span></span><br><span class="line">d    <span class="number">3</span></span><br><span class="line">e    <span class="number">4</span></span><br><span class="line">f    <span class="number">5</span></span><br><span class="line">g    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认情况下，concat是在axis=0上工作的，最终产生一个新的Series。如果传入axis=1，则结果就会变成一个DataFrame（axis=1是列）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">86</span>]: pd.concat([s1, s2, s3], axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">86</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line">a  <span class="number">0.0</span>  NaN  NaN</span><br><span class="line">b  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line">c  NaN  <span class="number">2.0</span>  NaN</span><br><span class="line">d  NaN  <span class="number">3.0</span>  NaN</span><br><span class="line">e  NaN  <span class="number">4.0</span>  NaN</span><br><span class="line">f  NaN  NaN  <span class="number">5.0</span></span><br><span class="line">g  NaN  NaN  <span class="number">6.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种情况下，另外的轴上没有重叠，从索引的有序并集（外连接）上就可以看出来。传入join='inner'即可得到它们的交集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">87</span>]: s4 = pd.concat([s1, s3])</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: s4</span><br><span class="line">Out[<span class="number">88</span>]: </span><br><span class="line">a    <span class="number">0</span></span><br><span class="line">b    <span class="number">1</span></span><br><span class="line">f    <span class="number">5</span></span><br><span class="line">g    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: pd.concat([s1, s4], axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">89</span>]: </span><br><span class="line">     <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">a  <span class="number">0.0</span>  <span class="number">0</span></span><br><span class="line">b  <span class="number">1.0</span>  <span class="number">1</span></span><br><span class="line">f  NaN  <span class="number">5</span></span><br><span class="line">g  NaN  <span class="number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: pd.concat([s1, s4], axis=<span class="number">1</span>, join=<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line">Out[<span class="number">90</span>]: </span><br><span class="line">   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">a  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">b  <span class="number">1</span>  <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中，f和g标签消失了，是因为使用的是join='inner'选项。</p>
<p>你可以通过join_axes指定要在其它轴上使用的索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">91</span>]: pd.concat([s1, s4], axis=<span class="number">1</span>, join_axes=[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]])</span><br><span class="line">Out[<span class="number">91</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span></span><br><span class="line">a  <span class="number">0.0</span>  <span class="number">0.0</span></span><br><span class="line">c  NaN  NaN</span><br><span class="line">b  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line">e  NaN  NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不过有个问题，参与连接的片段在结果中区分不开。假设你想要在连接轴上创建一个层次化索引。使用keys参数即可达到这个目的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">92</span>]: result = pd.concat([s1, s1, s3], keys=[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">93</span>]: result</span><br><span class="line">Out[<span class="number">93</span>]: </span><br><span class="line">one    a    <span class="number">0</span></span><br><span class="line">       b    <span class="number">1</span></span><br><span class="line">two    a    <span class="number">0</span></span><br><span class="line">       b    <span class="number">1</span></span><br><span class="line">three  f    <span class="number">5</span></span><br><span class="line">       g    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: result.unstack()</span><br><span class="line">Out[<span class="number">94</span>]: </span><br><span class="line">         a    b    f    g</span><br><span class="line">one    <span class="number">0.0</span>  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line">two    <span class="number">0.0</span>  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line">three  NaN  NaN  <span class="number">5.0</span>  <span class="number">6.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果沿着axis=1对Series进行合并，则keys就会成为DataFrame的列头：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">95</span>]: pd.concat([s1, s2, s3], axis=<span class="number">1</span>, keys=[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>])</span><br><span class="line">Out[<span class="number">95</span>]: </span><br><span class="line">   one  two  three</span><br><span class="line">a  <span class="number">0.0</span>  NaN    NaN</span><br><span class="line">b  <span class="number">1.0</span>  NaN    NaN</span><br><span class="line">c  NaN  <span class="number">2.0</span>    NaN</span><br><span class="line">d  NaN  <span class="number">3.0</span>    NaN</span><br><span class="line">e  NaN  <span class="number">4.0</span>    NaN</span><br><span class="line">f  NaN  NaN    <span class="number">5.0</span></span><br><span class="line">g  NaN  NaN    <span class="number">6.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同样的逻辑也适用于DataFrame对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">96</span>]: df1 = pd.DataFrame(np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>, <span class="number">2</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">   ....:                    columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: df2 = pd.DataFrame(<span class="number">5</span> + np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>, <span class="number">2</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">   ....:                    columns=[<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: df1</span><br><span class="line">Out[<span class="number">98</span>]: </span><br><span class="line">   one  two</span><br><span class="line">a    <span class="number">0</span>    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">c    <span class="number">4</span>    <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: df2</span><br><span class="line">Out[<span class="number">99</span>]: </span><br><span class="line">   three  four</span><br><span class="line">a      <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">c      <span class="number">7</span>     <span class="number">8</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: pd.concat([df1, df2], axis=<span class="number">1</span>, keys=[<span class="string">&#x27;level1&#x27;</span>, <span class="string">&#x27;level2&#x27;</span>])</span><br><span class="line">Out[<span class="number">100</span>]: </span><br><span class="line">  level1     level2     </span><br><span class="line">     one two  three four</span><br><span class="line">a      <span class="number">0</span>   <span class="number">1</span>    <span class="number">5.0</span>  <span class="number">6.0</span></span><br><span class="line">b      <span class="number">2</span>   <span class="number">3</span>    NaN  NaN</span><br><span class="line">c      <span class="number">4</span>   <span class="number">5</span>    <span class="number">7.0</span>  <span class="number">8.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果传入的不是列表而是一个字典，则字典的键就会被当做keys选项的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">101</span>]: pd.concat(&#123;<span class="string">&#x27;level1&#x27;</span>: df1, <span class="string">&#x27;level2&#x27;</span>: df2&#125;, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">Out[<span class="number">101</span>]: </span><br><span class="line">  level1     level2     </span><br><span class="line">     one two  three four</span><br><span class="line">a      <span class="number">0</span>   <span class="number">1</span>    <span class="number">5.0</span>  <span class="number">6.0</span></span><br><span class="line">b      <span class="number">2</span>   <span class="number">3</span>    NaN  NaN</span><br><span class="line">c      <span class="number">4</span>   <span class="number">5</span>    <span class="number">7.0</span>  <span class="number">8.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此外还有两个用于管理层次化索引创建方式的参数（参见表8-3）。举个例子，我们可以用names参数命名创建的轴级别：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">102</span>]: pd.concat([df1, df2], axis=<span class="number">1</span>, keys=[<span class="string">&#x27;level1&#x27;</span>, <span class="string">&#x27;level2&#x27;</span>],</span><br><span class="line">   .....:           names=[<span class="string">&#x27;upper&#x27;</span>, <span class="string">&#x27;lower&#x27;</span>])</span><br><span class="line">Out[<span class="number">102</span>]: </span><br><span class="line">upper level1     level2     </span><br><span class="line">lower    one two  three four</span><br><span class="line">a          <span class="number">0</span>   <span class="number">1</span>    <span class="number">5.0</span>  <span class="number">6.0</span></span><br><span class="line">b          <span class="number">2</span>   <span class="number">3</span>    NaN  NaN</span><br><span class="line">c          <span class="number">4</span>   <span class="number">5</span>    <span class="number">7.0</span>  <span class="number">8.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后一个关于DataFrame的问题是，DataFrame的行索引不包含任何相关数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">103</span>]: df1 = pd.DataFrame(np.random.randn(<span class="number">3</span>, <span class="number">4</span>), columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: df2 = pd.DataFrame(np.random.randn(<span class="number">2</span>, <span class="number">3</span>), columns=[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: df1</span><br><span class="line">Out[<span class="number">105</span>]: </span><br><span class="line">          a         b         c         d</span><br><span class="line"><span class="number">0</span>  <span class="number">1.246435</span>  <span class="number">1.007189</span> -<span class="number">1.296221</span>  <span class="number">0.274992</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.371843</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: df2</span><br><span class="line">Out[<span class="number">106</span>]: </span><br><span class="line">          b         d         a</span><br><span class="line"><span class="number">0</span>  <span class="number">0.476985</span>  <span class="number">3.248944</span> -<span class="number">1.021228</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.577087</span>  <span class="number">0.124121</span>  <span class="number">0.302614</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这种情况下，传入ignore_index=True即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">107</span>]: pd.concat([df1, df2], ignore_index=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">107</span>]: </span><br><span class="line">          a         b         c         d</span><br><span class="line"><span class="number">0</span>  <span class="number">1.246435</span>  <span class="number">1.007189</span> -<span class="number">1.296221</span>  <span class="number">0.274992</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.371843</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br><span class="line"><span class="number">3</span> -<span class="number">1.021228</span>  <span class="number">0.476985</span>       NaN  <span class="number">3.248944</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.302614</span> -<span class="number">0.577087</span>       NaN  <span class="number">0.124121</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-339436563b519415.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表8-3 concat函数的参数" /><figcaption aria-hidden="true">表8-3 concat函数的参数</figcaption>
</figure>
<h2 id="合并重叠数据">合并重叠数据</h2>
<p>还有一种数据组合问题不能用简单的合并（merge）或连接（concatenation）运算来处理。比如说，你可能有索引全部或部分重叠的两个数据集。举个有启发性的例子，我们使用NumPy的where函数，它表示一种等价于面向数组的if-else：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">108</span>]: a = pd.Series([np.nan, <span class="number">2.5</span>, np.nan, <span class="number">3.5</span>, <span class="number">4.5</span>, np.nan],</span><br><span class="line">   .....:               index=[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: b = pd.Series(np.arange(<span class="built_in">len</span>(a), dtype=np.float64),</span><br><span class="line">   .....:               index=[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">110</span>]: b[-<span class="number">1</span>] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: a</span><br><span class="line">Out[<span class="number">111</span>]: </span><br><span class="line">f    NaN</span><br><span class="line">e    <span class="number">2.5</span></span><br><span class="line">d    NaN</span><br><span class="line">c    <span class="number">3.5</span></span><br><span class="line">b    <span class="number">4.5</span></span><br><span class="line">a    NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">112</span>]: b</span><br><span class="line">Out[<span class="number">112</span>]: </span><br><span class="line">f    <span class="number">0.0</span></span><br><span class="line">e    <span class="number">1.0</span></span><br><span class="line">d    <span class="number">2.0</span></span><br><span class="line">c    <span class="number">3.0</span></span><br><span class="line">b    <span class="number">4.0</span></span><br><span class="line">a    NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">113</span>]: np.where(pd.isnull(a), b, a)</span><br><span class="line">Out[<span class="number">113</span>]: array([ <span class="number">0.</span> ,  <span class="number">2.5</span>,  <span class="number">2.</span> ,  <span class="number">3.5</span>,  <span class="number">4.5</span>,  nan])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Series有一个combine_first方法，实现的也是一样的功能，还带有pandas的数据对齐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">114</span>]: b[:-<span class="number">2</span>].combine_first(a[<span class="number">2</span>:])</span><br><span class="line">Out[<span class="number">114</span>]: </span><br><span class="line">a    NaN</span><br><span class="line">b    <span class="number">4.5</span></span><br><span class="line">c    <span class="number">3.0</span></span><br><span class="line">d    <span class="number">2.0</span></span><br><span class="line">e    <span class="number">1.0</span></span><br><span class="line">f    <span class="number">0.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于DataFrame，combine_first自然也会在列上做同样的事情，因此你可以将其看做：用传递对象中的数据为调用对象的缺失数据“打补丁”：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">115</span>]: df1 = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">1.</span>, np.nan, <span class="number">5.</span>, np.nan],</span><br><span class="line">   .....:                     <span class="string">&#x27;b&#x27;</span>: [np.nan, <span class="number">2.</span>, np.nan, <span class="number">6.</span>],</span><br><span class="line">   .....:                     <span class="string">&#x27;c&#x27;</span>: <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">18</span>, <span class="number">4</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: df2 = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">5.</span>, <span class="number">4.</span>, np.nan, <span class="number">3.</span>, <span class="number">7.</span>],</span><br><span class="line">   .....:                     <span class="string">&#x27;b&#x27;</span>: [np.nan, <span class="number">3.</span>, <span class="number">4.</span>, <span class="number">6.</span>, <span class="number">8.</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">117</span>]: df1</span><br><span class="line">Out[<span class="number">117</span>]: </span><br><span class="line">     a    b   c</span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  NaN   <span class="number">2</span></span><br><span class="line"><span class="number">1</span>  NaN  <span class="number">2.0</span>   <span class="number">6</span></span><br><span class="line"><span class="number">2</span>  <span class="number">5.0</span>  NaN  <span class="number">10</span></span><br><span class="line"><span class="number">3</span>  NaN  <span class="number">6.0</span>  <span class="number">14</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: df2</span><br><span class="line">Out[<span class="number">118</span>]: </span><br><span class="line">     a    b</span><br><span class="line"><span class="number">0</span>  <span class="number">5.0</span>  NaN</span><br><span class="line"><span class="number">1</span>  <span class="number">4.0</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">2</span>  NaN  <span class="number">4.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">3.0</span>  <span class="number">6.0</span></span><br><span class="line"><span class="number">4</span>  <span class="number">7.0</span>  <span class="number">8.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: df1.combine_first(df2)</span><br><span class="line">Out[<span class="number">119</span>]: </span><br><span class="line">     a    b     c</span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  NaN   <span class="number">2.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4.0</span>  <span class="number">2.0</span>   <span class="number">6.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">5.0</span>  <span class="number">4.0</span>  <span class="number">10.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">3.0</span>  <span class="number">6.0</span>  <span class="number">14.0</span></span><br><span class="line"><span class="number">4</span>  <span class="number">7.0</span>  <span class="number">8.0</span>   NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="重塑和轴向旋转">8.3 重塑和轴向旋转</h1>
<p>有许多用于重新排列表格型数据的基础运算。这些函数也称作重塑（reshape）或轴向旋转（pivot）运算。</p>
<h2 id="重塑层次化索引">重塑层次化索引</h2>
<p>层次化索引为DataFrame数据的重排任务提供了一种具有良好一致性的方式。主要功能有二：</p>
<ul>
<li>stack：将数据的列“旋转”为行。</li>
<li>unstack：将数据的行“旋转”为列。</li>
</ul>
<p>我将通过一系列的范例来讲解这些操作。接下来看一个简单的DataFrame，其中的行列索引均为字符串数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">120</span>]: data = pd.DataFrame(np.arange(<span class="number">6</span>).reshape((<span class="number">2</span>, <span class="number">3</span>)),</span><br><span class="line">   .....:                     index=pd.Index([<span class="string">&#x27;Ohio&#x27;</span>,<span class="string">&#x27;Colorado&#x27;</span>], name=<span class="string">&#x27;state&#x27;</span>),</span><br><span class="line">   .....:                     columns=pd.Index([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">   .....:                     name=<span class="string">&#x27;number&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: data</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line">number    one  two  three</span><br><span class="line">state                    </span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span></span><br><span class="line">Colorado    <span class="number">3</span>    <span class="number">4</span>      <span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对该数据使用stack方法即可将列转换为行，得到一个Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">122</span>]: result = data.stack()</span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: result</span><br><span class="line">Out[<span class="number">123</span>]: </span><br><span class="line">state     number</span><br><span class="line">Ohio      one       <span class="number">0</span></span><br><span class="line">          two       <span class="number">1</span></span><br><span class="line">          three     <span class="number">2</span></span><br><span class="line">Colorado  one       <span class="number">3</span></span><br><span class="line">          two       <span class="number">4</span></span><br><span class="line">          three     <span class="number">5</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于一个层次化索引的Series，你可以用unstack将其重排为一个DataFrame：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">124</span>]: result.unstack()</span><br><span class="line">Out[<span class="number">124</span>]: </span><br><span class="line">number    one  two  three</span><br><span class="line">state                    </span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span></span><br><span class="line">Colorado    <span class="number">3</span>    <span class="number">4</span>      <span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认情况下，unstack操作的是最内层（stack也是如此）。传入分层级别的编号或名称即可对其它级别进行unstack操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">125</span>]: result.unstack(<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">125</span>]: </span><br><span class="line">state   Ohio  Colorado</span><br><span class="line">number                </span><br><span class="line">one        <span class="number">0</span>         <span class="number">3</span></span><br><span class="line">two        <span class="number">1</span>         <span class="number">4</span></span><br><span class="line">three      <span class="number">2</span>         <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">126</span>]: result.unstack(<span class="string">&#x27;state&#x27;</span>)</span><br><span class="line">Out[<span class="number">126</span>]: </span><br><span class="line">state   Ohio  Colorado</span><br><span class="line">number                </span><br><span class="line">one        <span class="number">0</span>         <span class="number">3</span></span><br><span class="line">two        <span class="number">1</span>         <span class="number">4</span></span><br><span class="line">three      <span class="number">2</span>         <span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果不是所有的级别值都能在各分组中找到的话，则unstack操作可能会引入缺失数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">127</span>]: s1 = pd.Series([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">128</span>]: s2 = pd.Series([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], index=[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: data2 = pd.concat([s1, s2], keys=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">130</span>]: data2</span><br><span class="line">Out[<span class="number">130</span>]: </span><br><span class="line">one  a    <span class="number">0</span></span><br><span class="line">     b    <span class="number">1</span></span><br><span class="line">     c    <span class="number">2</span></span><br><span class="line">     d    <span class="number">3</span></span><br><span class="line">two  c    <span class="number">4</span></span><br><span class="line">     d    <span class="number">5</span></span><br><span class="line">     e    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">131</span>]: data2.unstack()</span><br><span class="line">Out[<span class="number">131</span>]: </span><br><span class="line">       a    b    c    d    e</span><br><span class="line">one  <span class="number">0.0</span>  <span class="number">1.0</span>  <span class="number">2.0</span>  <span class="number">3.0</span>  NaN</span><br><span class="line">two  NaN  NaN  <span class="number">4.0</span>  <span class="number">5.0</span>  <span class="number">6.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>stack默认会滤除缺失数据，因此该运算是可逆的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">132</span>]: data2.unstack()</span><br><span class="line">Out[<span class="number">132</span>]: </span><br><span class="line">       a    b    c    d    e</span><br><span class="line">one  <span class="number">0.0</span>  <span class="number">1.0</span>  <span class="number">2.0</span>  <span class="number">3.0</span>  NaN</span><br><span class="line">two  NaN  NaN  <span class="number">4.0</span>  <span class="number">5.0</span>  <span class="number">6.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">133</span>]: data2.unstack().stack()</span><br><span class="line">Out[<span class="number">133</span>]: </span><br><span class="line">one  a    <span class="number">0.0</span></span><br><span class="line">     b    <span class="number">1.0</span></span><br><span class="line">     c    <span class="number">2.0</span></span><br><span class="line">     d    <span class="number">3.0</span></span><br><span class="line">two  c    <span class="number">4.0</span></span><br><span class="line">     d    <span class="number">5.0</span></span><br><span class="line">     e    <span class="number">6.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">134</span>]: data2.unstack().stack(dropna=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">134</span>]: </span><br><span class="line">one  a    <span class="number">0.0</span></span><br><span class="line">     b    <span class="number">1.0</span></span><br><span class="line">     c    <span class="number">2.0</span></span><br><span class="line">     d    <span class="number">3.0</span></span><br><span class="line">     e    NaN</span><br><span class="line">two  a    NaN</span><br><span class="line">     b    NaN</span><br><span class="line">     c    <span class="number">4.0</span></span><br><span class="line">     d    <span class="number">5.0</span></span><br><span class="line">     e    <span class="number">6.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在对DataFrame进行unstack操作时，作为旋转轴的级别将会成为结果中的最低级别：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">135</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;left&#x27;</span>: result, <span class="string">&#x27;right&#x27;</span>: result + <span class="number">5</span>&#125;,</span><br><span class="line">   .....:                   columns=pd.Index([<span class="string">&#x27;left&#x27;</span>, <span class="string">&#x27;right&#x27;</span>], name=<span class="string">&#x27;side&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: df</span><br><span class="line">Out[<span class="number">136</span>]: </span><br><span class="line">side             left  right</span><br><span class="line">state    number             </span><br><span class="line">Ohio     one        <span class="number">0</span>      <span class="number">5</span></span><br><span class="line">         two        <span class="number">1</span>      <span class="number">6</span></span><br><span class="line">         three      <span class="number">2</span>      <span class="number">7</span></span><br><span class="line">Colorado one        <span class="number">3</span>      <span class="number">8</span></span><br><span class="line">         two        <span class="number">4</span>      <span class="number">9</span></span><br><span class="line">         three      <span class="number">5</span>     <span class="number">10</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">137</span>]: df.unstack(<span class="string">&#x27;state&#x27;</span>)</span><br><span class="line">Out[<span class="number">137</span>]: </span><br><span class="line">side   left          right</span><br><span class="line">state  Ohio Colorado  Ohio Colorado</span><br><span class="line">number                             </span><br><span class="line">one       <span class="number">0</span>        <span class="number">3</span>     <span class="number">5</span>        <span class="number">8</span></span><br><span class="line">two       <span class="number">1</span>        <span class="number">4</span>     <span class="number">6</span>        <span class="number">9</span></span><br><span class="line">three     <span class="number">2</span>        <span class="number">5</span>     <span class="number">7</span>       <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当调用stack，我们可以指明轴的名字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">138</span>]: df.unstack(<span class="string">&#x27;state&#x27;</span>).stack(<span class="string">&#x27;side&#x27;</span>)</span><br><span class="line">Out[<span class="number">138</span>]: </span><br><span class="line">state         Colorado  Ohio</span><br><span class="line">number side                 </span><br><span class="line">one    left          <span class="number">3</span>     <span class="number">0</span></span><br><span class="line">       right         <span class="number">8</span>     <span class="number">5</span></span><br><span class="line">two    left          <span class="number">4</span>     <span class="number">1</span></span><br><span class="line">       right         <span class="number">9</span>     <span class="number">6</span></span><br><span class="line">three  left          <span class="number">5</span>     <span class="number">2</span></span><br><span class="line">       right        <span class="number">10</span>     <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="将长格式旋转为宽格式">将“长格式”旋转为“宽格式”</h2>
<p>多个时间序列数据通常是以所谓的“长格式”（long）或“堆叠格式”（stacked）存储在数据库和CSV中的。我们先加载一些示例数据，做一些时间序列规整和数据清洗：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">139</span>]: data = pd.read_csv(<span class="string">&#x27;examples/macrodata.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">140</span>]: data.head()</span><br><span class="line">Out[<span class="number">140</span>]: </span><br><span class="line">     year  quarter   realgdp  realcons  realinv  realgovt  realdpi    cpi  \</span><br><span class="line"><span class="number">0</span>  <span class="number">1959.0</span>      <span class="number">1.0</span>  <span class="number">2710.349</span>    <span class="number">1707.4</span>  <span class="number">286.898</span>   <span class="number">470.045</span>   <span class="number">1886.9</span>  <span class="number">28.98</span>   </span><br><span class="line"><span class="number">1</span>  <span class="number">1959.0</span>      <span class="number">2.0</span>  <span class="number">2778.801</span>    <span class="number">1733.7</span>  <span class="number">310.859</span>   <span class="number">481.301</span>   <span class="number">1919.7</span>  <span class="number">29.15</span>   </span><br><span class="line"><span class="number">2</span>  <span class="number">1959.0</span>      <span class="number">3.0</span>  <span class="number">2775.488</span>    <span class="number">1751.8</span>  <span class="number">289.226</span>   <span class="number">491.260</span>   <span class="number">1916.4</span>  <span class="number">29.35</span>   </span><br><span class="line"><span class="number">3</span>  <span class="number">1959.0</span>      <span class="number">4.0</span>  <span class="number">2785.204</span>    <span class="number">1753.7</span>  <span class="number">299.356</span>   <span class="number">484.052</span>   <span class="number">1931.3</span>  <span class="number">29.37</span>   </span><br><span class="line"><span class="number">4</span>  <span class="number">1960.0</span>      <span class="number">1.0</span>  <span class="number">2847.699</span>    <span class="number">1770.5</span>  <span class="number">331.722</span>   <span class="number">462.199</span>   <span class="number">1955.5</span>  <span class="number">29.54</span>   </span><br><span class="line">      m1  tbilrate  unemp      pop  infl  realint  </span><br><span class="line"><span class="number">0</span>  <span class="number">139.7</span>      <span class="number">2.82</span>    <span class="number">5.8</span>  <span class="number">177.146</span>  <span class="number">0.00</span>     <span class="number">0.00</span></span><br><span class="line"><span class="number">1</span>  <span class="number">141.7</span>      <span class="number">3.08</span>    <span class="number">5.1</span>  <span class="number">177.830</span>  <span class="number">2.34</span>     <span class="number">0.74</span>  </span><br><span class="line"><span class="number">2</span>  <span class="number">140.5</span>      <span class="number">3.82</span>    <span class="number">5.3</span>  <span class="number">178.657</span>  <span class="number">2.74</span>     <span class="number">1.09</span>  </span><br><span class="line"><span class="number">3</span>  <span class="number">140.0</span>      <span class="number">4.33</span>    <span class="number">5.6</span>  <span class="number">179.386</span>  <span class="number">0.27</span>     <span class="number">4.06</span>  </span><br><span class="line"><span class="number">4</span>  <span class="number">139.6</span>      <span class="number">3.50</span>    <span class="number">5.2</span>  <span class="number">180.007</span>  <span class="number">2.31</span>     <span class="number">1.19</span>  </span><br><span class="line"></span><br><span class="line">In [<span class="number">141</span>]: periods = pd.PeriodIndex(year=data.year, quarter=data.quarter,</span><br><span class="line">   .....:                          name=<span class="string">&#x27;date&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">142</span>]: columns = pd.Index([<span class="string">&#x27;realgdp&#x27;</span>, <span class="string">&#x27;infl&#x27;</span>, <span class="string">&#x27;unemp&#x27;</span>], name=<span class="string">&#x27;item&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">143</span>]: data = data.reindex(columns=columns)</span><br><span class="line"></span><br><span class="line">In [<span class="number">144</span>]: data.index = periods.to_timestamp(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">145</span>]: ldata = data.stack().reset_index().rename(columns=&#123;<span class="number">0</span>: <span class="string">&#x27;value&#x27;</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这就是多个时间序列（或者其它带有两个或多个键的可观察数据，这里，我们的键是date和item）的长格式。表中的每行代表一次观察。</p>
<p>关系型数据库（如MySQL）中的数据经常都是这样存储的，因为固定架构（即列名和数据类型）有一个好处：随着表中数据的添加，item列中的值的种类能够增加。在前面的例子中，date和item通常就是主键（用关系型数据库的说法），不仅提供了关系完整性，而且提供了更为简单的查询支持。有的情况下，使用这样的数据会很麻烦，你可能会更喜欢DataFrame，不同的item值分别形成一列，date列中的时间戳则用作索引。DataFrame的pivot方法完全可以实现这个转换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">147</span>]: pivoted = ldata.pivot(<span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;item&#x27;</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">148</span>]: pivoted</span><br><span class="line">Out[<span class="number">148</span>]: </span><br><span class="line">item        infl    realgdp  unemp</span><br><span class="line">date                              </span><br><span class="line"><span class="number">1959</span>-03-<span class="number">31</span>  <span class="number">0.00</span>   <span class="number">2710.349</span>    <span class="number">5.8</span></span><br><span class="line"><span class="number">1959</span>-06-<span class="number">30</span>  <span class="number">2.34</span>   <span class="number">2778.801</span>    <span class="number">5.1</span></span><br><span class="line"><span class="number">1959</span>-09-<span class="number">30</span>  <span class="number">2.74</span>   <span class="number">2775.488</span>    <span class="number">5.3</span></span><br><span class="line"><span class="number">1959</span>-<span class="number">12</span>-<span class="number">31</span>  <span class="number">0.27</span>   <span class="number">2785.204</span>    <span class="number">5.6</span></span><br><span class="line"><span class="number">1960</span>-03-<span class="number">31</span>  <span class="number">2.31</span>   <span class="number">2847.699</span>    <span class="number">5.2</span></span><br><span class="line"><span class="number">1960</span>-06-<span class="number">30</span>  <span class="number">0.14</span>   <span class="number">2834.390</span>    <span class="number">5.2</span></span><br><span class="line"><span class="number">1960</span>-09-<span class="number">30</span>  <span class="number">2.70</span>   <span class="number">2839.022</span>    <span class="number">5.6</span></span><br><span class="line"><span class="number">1960</span>-<span class="number">12</span>-<span class="number">31</span>  <span class="number">1.21</span>   <span class="number">2802.616</span>    <span class="number">6.3</span></span><br><span class="line"><span class="number">1961</span>-03-<span class="number">31</span> -<span class="number">0.40</span>   <span class="number">2819.264</span>    <span class="number">6.8</span></span><br><span class="line"><span class="number">1961</span>-06-<span class="number">30</span>  <span class="number">1.47</span>   <span class="number">2872.005</span>    <span class="number">7.0</span></span><br><span class="line"><span class="meta">... </span>         ...        ...    ...</span><br><span class="line"><span class="number">2007</span>-06-<span class="number">30</span>  <span class="number">2.75</span>  <span class="number">13203.977</span>    <span class="number">4.5</span></span><br><span class="line"><span class="number">2007</span>-09-<span class="number">30</span>  <span class="number">3.45</span>  <span class="number">13321.109</span>    <span class="number">4.7</span></span><br><span class="line"><span class="number">2007</span>-<span class="number">12</span>-<span class="number">31</span>  <span class="number">6.38</span>  <span class="number">13391.249</span>    <span class="number">4.8</span></span><br><span class="line"><span class="number">2008</span>-03-<span class="number">31</span>  <span class="number">2.82</span>  <span class="number">13366.865</span>    <span class="number">4.9</span></span><br><span class="line"><span class="number">2008</span>-06-<span class="number">30</span>  <span class="number">8.53</span>  <span class="number">13415.266</span>    <span class="number">5.4</span></span><br><span class="line"><span class="number">2008</span>-09-<span class="number">30</span> -<span class="number">3.16</span>  <span class="number">13324.600</span>    <span class="number">6.0</span></span><br><span class="line"><span class="number">2008</span>-<span class="number">12</span>-<span class="number">31</span> -<span class="number">8.79</span>  <span class="number">13141.920</span>    <span class="number">6.9</span></span><br><span class="line"><span class="number">2009</span>-03-<span class="number">31</span>  <span class="number">0.94</span>  <span class="number">12925.410</span>    <span class="number">8.1</span></span><br><span class="line"><span class="number">2009</span>-06-<span class="number">30</span>  <span class="number">3.37</span>  <span class="number">12901.504</span>    <span class="number">9.2</span></span><br><span class="line"><span class="number">2009</span>-09-<span class="number">30</span>  <span class="number">3.56</span>  <span class="number">12990.341</span>    <span class="number">9.6</span></span><br><span class="line">[<span class="number">203</span> rows x <span class="number">3</span> columns]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>前两个传递的值分别用作行和列索引，最后一个可选值则是用于填充DataFrame的数据列。假设有两个需要同时重塑的数据列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">149</span>]: ldata[<span class="string">&#x27;value2&#x27;</span>] = np.random.randn(<span class="built_in">len</span>(ldata))</span><br><span class="line"></span><br><span class="line">In [<span class="number">150</span>]: ldata[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">150</span>]: </span><br><span class="line">        date     item     value    value2</span><br><span class="line"><span class="number">0</span> <span class="number">1959</span>-03-<span class="number">31</span>  realgdp  <span class="number">2710.349</span>  <span class="number">0.523772</span></span><br><span class="line"><span class="number">1</span> <span class="number">1959</span>-03-<span class="number">31</span>     infl     <span class="number">0.000</span>  <span class="number">0.000940</span></span><br><span class="line"><span class="number">2</span> <span class="number">1959</span>-03-<span class="number">31</span>    unemp     <span class="number">5.800</span>  <span class="number">1.343810</span></span><br><span class="line"><span class="number">3</span> <span class="number">1959</span>-06-<span class="number">30</span>  realgdp  <span class="number">2778.801</span> -<span class="number">0.713544</span></span><br><span class="line"><span class="number">4</span> <span class="number">1959</span>-06-<span class="number">30</span>     infl     <span class="number">2.340</span> -<span class="number">0.831154</span></span><br><span class="line"><span class="number">5</span> <span class="number">1959</span>-06-<span class="number">30</span>    unemp     <span class="number">5.100</span> -<span class="number">2.370232</span></span><br><span class="line"><span class="number">6</span> <span class="number">1959</span>-09-<span class="number">30</span>  realgdp  <span class="number">2775.488</span> -<span class="number">1.860761</span></span><br><span class="line"><span class="number">7</span> <span class="number">1959</span>-09-<span class="number">30</span>     infl     <span class="number">2.740</span> -<span class="number">0.860757</span></span><br><span class="line"><span class="number">8</span> <span class="number">1959</span>-09-<span class="number">30</span>    unemp     <span class="number">5.300</span>  <span class="number">0.560145</span></span><br><span class="line"><span class="number">9</span> <span class="number">1959</span>-<span class="number">12</span>-<span class="number">31</span>  realgdp  <span class="number">2785.204</span> -<span class="number">1.265934</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果忽略最后一个参数，得到的DataFrame就会带有层次化的列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">151</span>]: pivoted = ldata.pivot(<span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;item&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">152</span>]: pivoted[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">152</span>]: </span><br><span class="line">           value                    value2                    </span><br><span class="line">item        infl   realgdp unemp      infl   realgdp     unemp</span><br><span class="line">date                                                          </span><br><span class="line"><span class="number">1959</span>-03-<span class="number">31</span>  <span class="number">0.00</span>  <span class="number">2710.349</span>   <span class="number">5.8</span>  <span class="number">0.000940</span>  <span class="number">0.523772</span>  <span class="number">1.343810</span></span><br><span class="line"><span class="number">1959</span>-06-<span class="number">30</span>  <span class="number">2.34</span>  <span class="number">2778.801</span>   <span class="number">5.1</span> -<span class="number">0.831154</span> -<span class="number">0.713544</span> -<span class="number">2.370232</span></span><br><span class="line"><span class="number">1959</span>-09-<span class="number">30</span>  <span class="number">2.74</span>  <span class="number">2775.488</span>   <span class="number">5.3</span> -<span class="number">0.860757</span> -<span class="number">1.860761</span>  <span class="number">0.560145</span></span><br><span class="line"><span class="number">1959</span>-<span class="number">12</span>-<span class="number">31</span>  <span class="number">0.27</span>  <span class="number">2785.204</span>   <span class="number">5.6</span>  <span class="number">0.119827</span> -<span class="number">1.265934</span> -<span class="number">1.063512</span></span><br><span class="line"><span class="number">1960</span>-03-<span class="number">31</span>  <span class="number">2.31</span>  <span class="number">2847.699</span>   <span class="number">5.2</span> -<span class="number">2.359419</span>  <span class="number">0.332883</span> -<span class="number">0.199543</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">153</span>]: pivoted[<span class="string">&#x27;value&#x27;</span>][:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">153</span>]: </span><br><span class="line">item        infl   realgdp  unemp</span><br><span class="line">date                             </span><br><span class="line"><span class="number">1959</span>-03-<span class="number">31</span>  <span class="number">0.00</span>  <span class="number">2710.349</span>    <span class="number">5.8</span></span><br><span class="line"><span class="number">1959</span>-06-<span class="number">30</span>  <span class="number">2.34</span>  <span class="number">2778.801</span>    <span class="number">5.1</span></span><br><span class="line"><span class="number">1959</span>-09-<span class="number">30</span>  <span class="number">2.74</span>  <span class="number">2775.488</span>    <span class="number">5.3</span></span><br><span class="line"><span class="number">1959</span>-<span class="number">12</span>-<span class="number">31</span>  <span class="number">0.27</span>  <span class="number">2785.204</span>    <span class="number">5.6</span></span><br><span class="line"><span class="number">1960</span>-03-<span class="number">31</span>  <span class="number">2.31</span>  <span class="number">2847.699</span>    <span class="number">5.2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，pivot其实就是用set_index创建层次化索引，再用unstack重塑：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">154</span>]: unstacked = ldata.set_index([<span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;item&#x27;</span>]).unstack(<span class="string">&#x27;item&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">155</span>]: unstacked[:<span class="number">7</span>]</span><br><span class="line">Out[<span class="number">155</span>]: </span><br><span class="line">           value                    value2                    </span><br><span class="line">item        infl   realgdp unemp      infl   realgdp     unemp</span><br><span class="line">date                                                          </span><br><span class="line"><span class="number">1959</span>-03-<span class="number">31</span>  <span class="number">0.00</span>  <span class="number">2710.349</span>   <span class="number">5.8</span>  <span class="number">0.000940</span>  <span class="number">0.523772</span>  <span class="number">1.343810</span></span><br><span class="line"><span class="number">1959</span>-06-<span class="number">30</span>  <span class="number">2.34</span>  <span class="number">2778.801</span>   <span class="number">5.1</span> -<span class="number">0.831154</span> -<span class="number">0.713544</span> -<span class="number">2.370232</span></span><br><span class="line"><span class="number">1959</span>-09-<span class="number">30</span>  <span class="number">2.74</span>  <span class="number">2775.488</span>   <span class="number">5.3</span> -<span class="number">0.860757</span> -<span class="number">1.860761</span>  <span class="number">0.560145</span></span><br><span class="line"><span class="number">1959</span>-<span class="number">12</span>-<span class="number">31</span>  <span class="number">0.27</span>  <span class="number">2785.204</span>   <span class="number">5.6</span>  <span class="number">0.119827</span> -<span class="number">1.265934</span> -<span class="number">1.063512</span></span><br><span class="line"><span class="number">1960</span>-03-<span class="number">31</span>  <span class="number">2.31</span>  <span class="number">2847.699</span>   <span class="number">5.2</span> -<span class="number">2.359419</span>  <span class="number">0.332883</span> -<span class="number">0.199543</span></span><br><span class="line"><span class="number">1960</span>-06-<span class="number">30</span>  <span class="number">0.14</span>  <span class="number">2834.390</span>   <span class="number">5.2</span> -<span class="number">0.970736</span> -<span class="number">1.541996</span> -<span class="number">1.307030</span></span><br><span class="line"><span class="number">1960</span>-09-<span class="number">30</span>  <span class="number">2.70</span>  <span class="number">2839.022</span>   <span class="number">5.6</span>  <span class="number">0.377984</span>  <span class="number">0.286350</span> -<span class="number">0.753887</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="将宽格式旋转为长格式">将“宽格式”旋转为“长格式”</h2>
<p>旋转DataFrame的逆运算是pandas.melt。它不是将一列转换到多个新的DataFrame，而是合并多个列成为一个，产生一个比输入长的DataFrame。看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">157</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>],</span><br><span class="line">   .....:                    <span class="string">&#x27;A&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">   .....:                    <span class="string">&#x27;B&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">   .....:                    <span class="string">&#x27;C&#x27;</span>: [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">158</span>]: df</span><br><span class="line">Out[<span class="number">158</span>]: </span><br><span class="line">   A  B  C  key</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">4</span>  <span class="number">7</span>  foo</span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">8</span>  bar</span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">9</span>  baz</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>key列可能是分组指标，其它的列是数据值。当使用pandas.melt，我们必须指明哪些列是分组指标。下面使用key作为唯一的分组指标：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">159</span>]: melted = pd.melt(df, [<span class="string">&#x27;key&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">160</span>]: melted</span><br><span class="line">Out[<span class="number">160</span>]: </span><br><span class="line">   key variable  value</span><br><span class="line"><span class="number">0</span>  foo        A      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  bar        A      <span class="number">2</span></span><br><span class="line"><span class="number">2</span>  baz        A      <span class="number">3</span></span><br><span class="line"><span class="number">3</span>  foo        B      <span class="number">4</span></span><br><span class="line"><span class="number">4</span>  bar        B      <span class="number">5</span></span><br><span class="line"><span class="number">5</span>  baz        B      <span class="number">6</span></span><br><span class="line"><span class="number">6</span>  foo        C      <span class="number">7</span></span><br><span class="line"><span class="number">7</span>  bar        C      <span class="number">8</span></span><br><span class="line"><span class="number">8</span>  baz        C      <span class="number">9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用pivot，可以重塑回原来的样子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">161</span>]: reshaped = melted.pivot(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;variable&#x27;</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">162</span>]: reshaped</span><br><span class="line">Out[<span class="number">162</span>]: </span><br><span class="line">variable  A  B  C</span><br><span class="line">key              </span><br><span class="line">bar       <span class="number">2</span>  <span class="number">5</span>  <span class="number">8</span></span><br><span class="line">baz       <span class="number">3</span>  <span class="number">6</span>  <span class="number">9</span></span><br><span class="line">foo       <span class="number">1</span>  <span class="number">4</span>  <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为pivot的结果从列创建了一个索引，用作行标签，我们可以使用reset_index将数据移回列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">163</span>]: reshaped.reset_index()</span><br><span class="line">Out[<span class="number">163</span>]: </span><br><span class="line">variable  key  A  B  C</span><br><span class="line"><span class="number">0</span>         bar  <span class="number">2</span>  <span class="number">5</span>  <span class="number">8</span></span><br><span class="line"><span class="number">1</span>         baz  <span class="number">3</span>  <span class="number">6</span>  <span class="number">9</span></span><br><span class="line"><span class="number">2</span>         foo  <span class="number">1</span>  <span class="number">4</span>  <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你还可以指定列的子集，作为值的列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">164</span>]: pd.melt(df, id_vars=[<span class="string">&#x27;key&#x27;</span>], value_vars=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br><span class="line">Out[<span class="number">164</span>]: </span><br><span class="line">   key variable  value</span><br><span class="line"><span class="number">0</span>  foo        A      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  bar        A      <span class="number">2</span></span><br><span class="line"><span class="number">2</span>  baz        A      <span class="number">3</span></span><br><span class="line"><span class="number">3</span>  foo        B      <span class="number">4</span></span><br><span class="line"><span class="number">4</span>  bar        B      <span class="number">5</span></span><br><span class="line"><span class="number">5</span>  baz        B      <span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>pandas.melt也可以不用分组指标：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">165</span>]: pd.melt(df, value_vars=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>])</span><br><span class="line">Out[<span class="number">165</span>]: </span><br><span class="line">  variable  value</span><br><span class="line"><span class="number">0</span>        A      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>        A      <span class="number">2</span></span><br><span class="line"><span class="number">2</span>        A      <span class="number">3</span></span><br><span class="line"><span class="number">3</span>        B      <span class="number">4</span></span><br><span class="line"><span class="number">4</span>        B      <span class="number">5</span></span><br><span class="line"><span class="number">5</span>        B      <span class="number">6</span></span><br><span class="line"><span class="number">6</span>        C      <span class="number">7</span></span><br><span class="line"><span class="number">7</span>        C      <span class="number">8</span></span><br><span class="line"><span class="number">8</span>        C      <span class="number">9</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">166</span>]: pd.melt(df, value_vars=[<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br><span class="line">Out[<span class="number">166</span>]: </span><br><span class="line">  variable value</span><br><span class="line"><span class="number">0</span>      key   foo</span><br><span class="line"><span class="number">1</span>      key   bar</span><br><span class="line"><span class="number">2</span>      key   baz</span><br><span class="line"><span class="number">3</span>        A     <span class="number">1</span></span><br><span class="line"><span class="number">4</span>        A     <span class="number">2</span></span><br><span class="line"><span class="number">5</span>        A     <span class="number">3</span></span><br><span class="line"><span class="number">6</span>        B     <span class="number">4</span></span><br><span class="line"><span class="number">7</span>        B     <span class="number">5</span></span><br><span class="line"><span class="number">8</span>        B     <span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="总结">8.4 总结</h1>
<p>现在你已经掌握了pandas数据导入、清洗、重塑，我们可以进一步学习matplotlib数据可视化。我们在稍后会回到pandas，学习更高级的分析。</p>
]]></content>
      <categories>
        <category>Python 数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>第09章 绘图和可视化</title>
    <url>/2019/04/09/%E7%AC%AC09%E7%AB%A0-%E7%BB%98%E5%9B%BE%E5%92%8C%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<p>信息可视化（也叫绘图）是数据分析中最重要的工作之一。它可能是探索过程的一部分，例如，帮助我们找出异常值、必要的数据转换、得出有关模型的idea等。另外，做一个可交互的数据可视化也许是工作的最终目标。<span id="more"></span>Python有许多库进行静态或动态的数据可视化，但我这里重要关注于<a href="http://matplotlib.org/">matplotlib</a>和基于它的库。</p>
<p>matplotlib是一个用于创建出版质量图表的桌面绘图包（主要是2D方面）。该项目是由John Hunter于2002年启动的，其目的是为Python构建一个MATLAB式的绘图接口。matplotlib和IPython社区进行合作，简化了从IPython shell（包括现在的Jupyter notebook）进行交互式绘图。matplotlib支持各种操作系统上许多不同的GUI后端，而且还能将图片导出为各种常见的矢量（vector）和光栅（raster）图：PDF、SVG、JPG、PNG、BMP、GIF等。除了几张，本书中的大部分图都是用它生成的。</p>
<p>随着时间的发展，matplotlib衍生出了多个数据可视化的工具集，它们使用matplotlib作为底层。其中之一是<a href="http://seaborn.pydata.org">seaborn</a>，本章后面会学习它。</p>
<p>学习本章代码案例的最简单方法是在Jupyter notebook进行交互式绘图。在Jupyter notebook中执行下面的语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib notebook</span><br></pre></td></tr></table></figure>
<h1 id="matplotlib-api入门">9.1 matplotlib API入门</h1>
<p>matplotlib的通常引入约定是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<p>在Jupyter中运行%matplotlib notebook（或在IPython中运行%matplotlib），就可以创建一个简单的图形。如果一切设置正确，会看到图9-1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: data = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: data</span><br><span class="line">Out[<span class="number">14</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: plt.plot(data)</span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-7032e333a6ecdd37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-1 简单的线图" /><figcaption aria-hidden="true">图9-1 简单的线图</figcaption>
</figure>
<p>虽然seaborn这样的库和pandas的内置绘图函数能够处理许多普通的绘图任务，但如果需要自定义一些高级功能的话就必须学习matplotlib API。</p>
<blockquote>
<p>笔记：虽然本书没有详细地讨论matplotlib的各种功能，但足以将你引入门。matplotlib的示例库和文档是学习高级特性的最好资源。</p>
</blockquote>
<h2 id="figure和subplot">Figure和Subplot</h2>
<p>matplotlib的图像都位于Figure对象中。你可以用plt.figure创建一个新的Figure：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">16</span>]: fig = plt.figure(figsize=(a,b))</span><br></pre></td></tr></table></figure>
<p>如果用的是IPython，这时会弹出一个空窗口，但在Jupyter中，必须再输入更多命令才能看到。plt.figure有一些选项，特别是figsize，它用于确保当图片保存到磁盘时具有一定的大小和纵横比。</p>
<p>不能通过空Figure绘图。必须用add_subplot创建一个或多个subplot才行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: ax1 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>这条代码的意思是：图像应该是2×2的（即最多4张图），且当前选中的是4个subplot中的第一个（编号从1开始）。如果再把后面两个subplot也创建出来，最终得到的图像如图9-2所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: ax2 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: ax3 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-b8cff158e64eae74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-2 带有三个subplot的Figure" /><figcaption aria-hidden="true">图9-2 带有三个subplot的Figure</figcaption>
</figure>
<blockquote>
<p>提示：使用Jupyter notebook有一点不同，即每个小窗重新执行后，图形会被重置。因此，对于复杂的图形，，你必须将所有的绘图命令存在一个小窗里。</p>
</blockquote>
<p>这里，我们运行同一个小窗里的所有命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">ax2 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">ax3 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>如果这时执行一条绘图命令（如plt.plot([1.5, 3.5, -2, 1.6])），matplotlib就会在最后一个用过的subplot（如果没有则创建一个）上进行绘制，隐藏创建figure和subplot的过程。因此，如果我们执行下列命令，你就会得到如图9-3所示的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: plt.plot(np.random.randn(<span class="number">50</span>).cumsum(), <span class="string">&#x27;k--&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-7bcbd5e56fdbbd92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-3 绘制一次之后的图像" /><figcaption aria-hidden="true">图9-3 绘制一次之后的图像</figcaption>
</figure>
<p>"k--"是一个线型选项，用于告诉matplotlib绘制黑色虚线图。上面那些由fig.add_subplot所返回的对象是AxesSubplot对象，直接调用它们的实例方法就可以在其它空着的格子里面画图了，如图9-4所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: ax1.hist(np.random.randn(<span class="number">100</span>), bins=<span class="number">20</span>, color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: ax2.scatter(np.arange(<span class="number">30</span>), np.arange(<span class="number">30</span>) + <span class="number">3</span> * np.random.randn(<span class="number">30</span>))</span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-2297bcaf355db24c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-4 继续绘制两次之后的图像" /><figcaption aria-hidden="true">图9-4 继续绘制两次之后的图像</figcaption>
</figure>
<p>你可以在matplotlib的文档中找到各种图表类型。</p>
<p>创建包含subplot网格的figure是一个非常常见的任务，matplotlib有一个更为方便的方法plt.subplots，它可以创建一个新的Figure，并返回一个含有已创建的subplot对象的NumPy数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: axes</span><br><span class="line">Out[<span class="number">25</span>]: </span><br><span class="line">array([[&lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x7fb626374048</span>&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x7fb62625db00</span>&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x7fb6262f6c88</span>&gt;],</span><br><span class="line">       [&lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x7fb6261a36a0</span>&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x7fb626181860</span>&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x7fb6260fd4e0</span>&gt;]], dtype</span><br><span class="line">=<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure>
<p>这是非常实用的，因为可以轻松地对axes数组进行索引，就好像是一个二维数组一样，例如axes[0,1]。你还可以通过sharex和sharey指定subplot应该具有相同的X轴或Y轴。在比较相同范围的数据时，这也是非常实用的，否则，matplotlib会自动缩放各图表的界限。有关该方法的更多信息，请参见表9-1。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-88bb55faca7d01ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表9-1 pyplot.subplots的选项" /><figcaption aria-hidden="true">表9-1 pyplot.subplots的选项</figcaption>
</figure>
<h2 id="调整subplot周围的间距">调整subplot周围的间距</h2>
<p>默认情况下，matplotlib会在subplot外围留下一定的边距，并在subplot之间留下一定的间距。间距跟图像的高度和宽度有关，因此，如果你调整了图像大小（不管是编程还是手工），间距也会自动调整。利用Figure的subplots_adjust方法可以轻而易举地修改间距，此外，它也是个顶级函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">subplots_adjust(left=<span class="literal">None</span>, bottom=<span class="literal">None</span>, right=<span class="literal">None</span>, top=<span class="literal">None</span>,</span><br><span class="line">                wspace=<span class="literal">None</span>, hspace=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>wspace和hspace用于控制宽度和高度的百分比，可以用作subplot之间的间距。下面是一个简单的例子，其中我将间距收缩到了0（如图9-5所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        axes[i, j].hist(np.random.randn(<span class="number">500</span>), bins=<span class="number">50</span>, color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.subplots_adjust(wspace=<span class="number">0</span>, hspace=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-80be7ffc3dec88a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-5 各subplot之间没有间距" /><figcaption aria-hidden="true">图9-5 各subplot之间没有间距</figcaption>
</figure>
<p>不难看出，其中的轴标签重叠了。matplotlib不会检查标签是否重叠，所以对于这种情况，你只能自己设定刻度位置和刻度标签。后面几节将会详细介绍该内容。</p>
<h2 id="颜色标记和线型">颜色、标记和线型</h2>
<p>matplotlib的plot函数接受一组X和Y坐标，还可以接受一个表示颜色和线型的字符串缩写。例如，要根据x和y绘制绿色虚线，你可以执行如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax.plot(x, y, <span class="string">&#x27;g--&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这种在一个字符串中指定颜色和线型的方式非常方便。在实际中，如果你是用代码绘图，你可能不想通过处理字符串来获得想要的格式。通过下面这种更为明确的方式也能得到同样的效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax.plot(x, y, linestyle=<span class="string">&#x27;--&#x27;</span>, color=<span class="string">&#x27;g&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>常用的颜色可以使用颜色缩写，你也可以指定颜色码（例如，'#CECECE'）。你可以通过查看plot的文档字符串查看所有线型的合集（在IPython和Jupyter中使用plot?）。</p>
<p>线图可以使用标记强调数据点。因为matplotlib可以创建连续线图，在点之间进行插值，因此有时可能不太容易看出真实数据点的位置。标记也可以放到格式字符串中，但标记类型和线型必须放在颜色后面（见图9-6）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">30</span>]: <span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: plt.plot(randn(<span class="number">30</span>).cumsum(), <span class="string">&#x27;ko--&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-404d816f3e1d6621.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-6 带有标记的线型图示例" /><figcaption aria-hidden="true">图9-6 带有标记的线型图示例</figcaption>
</figure>
<p>还可以将其写成更为明确的形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plot(randn(<span class="number">30</span>).cumsum(), color=<span class="string">&#x27;k&#x27;</span>, linestyle=<span class="string">&#x27;dashed&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在线型图中，非实际数据点默认是按线性方式插值的。可以通过drawstyle选项修改（见图9-7）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">33</span>]: data = np.random.randn(<span class="number">30</span>).cumsum()</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: plt.plot(data, <span class="string">&#x27;k--&#x27;</span>, label=<span class="string">&#x27;Default&#x27;</span>)</span><br><span class="line">Out[<span class="number">34</span>]: [&lt;matplotlib.lines.Line2D at <span class="number">0x7fb624d86160</span>&gt;]</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: plt.plot(data, <span class="string">&#x27;k-&#x27;</span>, drawstyle=<span class="string">&#x27;steps-post&#x27;</span>, label=<span class="string">&#x27;steps-post&#x27;</span>)</span><br><span class="line">Out[<span class="number">35</span>]: [&lt;matplotlib.lines.Line2D at <span class="number">0x7fb624d869e8</span>&gt;]</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-3ec7642e1a592f08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-7 不同drawstyle选项的线型图" /><figcaption aria-hidden="true">图9-7 不同drawstyle选项的线型图</figcaption>
</figure>
<p>你可能注意到运行上面代码时有输出&lt;matplotlib.lines.Line2D at ...&gt;。matplotlib会返回引用了新添加的子组件的对象。大多数时候，你可以放心地忽略这些输出。这里，因为我们传递了label参数到plot，我们可以创建一个plot图例，指明每条使用plt.legend的线。</p>
<blockquote>
<p>笔记：你必须调用plt.legend（或使用ax.legend，如果引用了轴的话）来创建图例，无论你绘图时是否传递label标签选项。</p>
</blockquote>
<h2 id="刻度标签和图例">刻度、标签和图例</h2>
<p>对于大多数的图表装饰项，其主要实现方式有二：使用过程型的pyplot接口（例如，matplotlib.pyplot）以及更为面向对象的原生matplotlib API。</p>
<p>pyplot接口的设计目的就是交互式使用，含有诸如xlim、xticks和xticklabels之类的方法。它们分别控制图表的范围、刻度位置、刻度标签等。其使用方式有以下两种：</p>
<ul>
<li>调用时不带参数，则返回当前的参数值（例如，plt.xlim()返回当前的X轴绘图范围）。</li>
<li>调用时带参数，则设置参数值（例如，plt.xlim([0,10])会将X轴的范围设置为0到10）。</li>
</ul>
<p>所有这些方法都是对当前或最近创建的AxesSubplot起作用的。它们各自对应subplot对象上的两个方法，以xlim为例，就是ax.get_xlim和ax.set_xlim。我更喜欢使用subplot的实例方法（因为我喜欢明确的事情，而且在处理多个subplot时这样也更清楚一些）。当然你完全可以选择自己觉得方便的那个。</p>
<h2 id="设置标题轴标签刻度以及刻度标签">设置标题、轴标签、刻度以及刻度标签</h2>
<p>为了说明自定义轴，我将创建一个简单的图像并绘制一段随机漫步（如图9-8所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">37</span>]: fig = plt.figure()</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: ax.plot(np.random.randn(<span class="number">1000</span>).cumsum())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-caf9300dacb61fa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-8 用于演示xticks的简单线型图（带有标签）" /><figcaption aria-hidden="true">图9-8 用于演示xticks的简单线型图（带有标签）</figcaption>
</figure>
<p>要改变x轴刻度，最简单的办法是使用set_xticks和set_xticklabels。前者告诉matplotlib要将刻度放在数据范围中的哪些位置，默认情况下，这些位置也就是刻度标签。但我们可以通过set_xticklabels将任何其他的值用作标签：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">40</span>]: ticks = ax.set_xticks([<span class="number">0</span>, <span class="number">250</span>, <span class="number">500</span>, <span class="number">750</span>, <span class="number">1000</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: labels = ax.set_xticklabels([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>],</span><br><span class="line">   ....:                             rotation=<span class="number">30</span>, fontsize=<span class="string">&#x27;small&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>rotation选项设定x刻度标签倾斜30度。最后，再用set_xlabel为X轴设置一个名称，并用set_title设置一个标题（见图9-9的结果）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">42</span>]: ax.set_title(<span class="string">&#x27;My first matplotlib plot&#x27;</span>)</span><br><span class="line">Out[<span class="number">42</span>]: &lt;matplotlib.text.Text at <span class="number">0x7fb624d055f8</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: ax.set_xlabel(<span class="string">&#x27;Stages&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-741f968323bd818f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-9 用于演示xticks的简单线型图" /><figcaption aria-hidden="true">图9-9 用于演示xticks的简单线型图</figcaption>
</figure>
<p>Y轴的修改方式与此类似，只需将上述代码中的x替换为y即可。轴的类有集合方法，可以批量设定绘图选项。前面的例子，也可以写为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">props = &#123;</span><br><span class="line">    <span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;My first matplotlib plot&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;xlabel&#x27;</span>: <span class="string">&#x27;Stages&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">ax.<span class="built_in">set</span>(**props)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="添加图例">添加图例</h2>
<p>图例（legend）是另一种用于标识图表元素的重要工具。添加图例的方式有多种。最简单的是在添加subplot的时候传入label参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">44</span>]: <span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: fig = plt.figure(); ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">&#x27;k&#x27;</span>, label=<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">Out[<span class="number">46</span>]: [&lt;matplotlib.lines.Line2D at <span class="number">0x7fb624bdf860</span>&gt;]</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">&#x27;k--&#x27;</span>, label=<span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">Out[<span class="number">47</span>]: [&lt;matplotlib.lines.Line2D at <span class="number">0x7fb624be90f0</span>&gt;]</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">&#x27;k.&#x27;</span>, label=<span class="string">&#x27;three&#x27;</span>)</span><br><span class="line">Out[<span class="number">48</span>]: [&lt;matplotlib.lines.Line2D at <span class="number">0x7fb624be9160</span>&gt;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在此之后，你可以调用ax.legend()或plt.legend()来自动创建图例（结果见图9-10）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">49</span>]: ax.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-651ff89750c0a89b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-10 带有三条线以及图例的简单线型图" /><figcaption aria-hidden="true">图9-10 带有三条线以及图例的简单线型图</figcaption>
</figure>
<p>legend方法有几个其它的loc位置参数选项。请查看文档字符串（使用ax.legend?）。</p>
<p>loc告诉matplotlib要将图例放在哪。如果你不是吹毛求疵的话，"best"是不错的选择，因为它会选择最不碍事的位置。要从图例中去除一个或多个元素，不传入label或传入label='<em>nolegend</em>'即可。（中文第一版这里把best错写成了beat）</p>
<h2 id="注解以及在subplot上绘图">注解以及在Subplot上绘图</h2>
<p>除标准的绘图类型，你可能还希望绘制一些子集的注解，可能是文本、箭头或其他图形等。注解和文字可以通过text、arrow和annotate函数进行添加。text可以将文本绘制在图表的指定坐标(x,y)，还可以加上一些自定义格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax.text(x, y, <span class="string">&#x27;Hello world!&#x27;</span>,</span><br><span class="line">        family=<span class="string">&#x27;monospace&#x27;</span>, fontsize=<span class="number">10</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注解中可以既含有文本也含有箭头。例如，我们根据最近的标准普尔500指数价格（来自Yahoo!Finance）绘制一张曲线图，并标出2008年到2009年金融危机期间的一些重要日期。你可以在Jupyter notebook的一个小窗中试验这段代码（图9-11是结果）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;examples/spx.csv&#x27;</span>, index_col=<span class="number">0</span>, parse_dates=<span class="literal">True</span>)</span><br><span class="line">spx = data[<span class="string">&#x27;SPX&#x27;</span>]</span><br><span class="line"></span><br><span class="line">spx.plot(ax=ax, style=<span class="string">&#x27;k-&#x27;</span>)</span><br><span class="line"></span><br><span class="line">crisis_data = [</span><br><span class="line">    (datetime(<span class="number">2007</span>, <span class="number">10</span>, <span class="number">11</span>), <span class="string">&#x27;Peak of bull market&#x27;</span>),</span><br><span class="line">    (datetime(<span class="number">2008</span>, <span class="number">3</span>, <span class="number">12</span>), <span class="string">&#x27;Bear Stearns Fails&#x27;</span>),</span><br><span class="line">    (datetime(<span class="number">2008</span>, <span class="number">9</span>, <span class="number">15</span>), <span class="string">&#x27;Lehman Bankruptcy&#x27;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> date, label <span class="keyword">in</span> crisis_data:</span><br><span class="line">    ax.annotate(label, xy=(date, spx.asof(date) + <span class="number">75</span>),</span><br><span class="line">                xytext=(date, spx.asof(date) + <span class="number">225</span>),</span><br><span class="line">                arrowprops=<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;black&#x27;</span>, headwidth=<span class="number">4</span>, width=<span class="number">2</span>,</span><br><span class="line">                                headlength=<span class="number">4</span>),</span><br><span class="line">                horizontalalignment=<span class="string">&#x27;left&#x27;</span>, verticalalignment=<span class="string">&#x27;top&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Zoom in on 2007-2010</span></span><br><span class="line">ax.set_xlim([<span class="string">&#x27;1/1/2007&#x27;</span>, <span class="string">&#x27;1/1/2011&#x27;</span>])</span><br><span class="line">ax.set_ylim([<span class="number">600</span>, <span class="number">1800</span>])</span><br><span class="line"></span><br><span class="line">ax.set_title(<span class="string">&#x27;Important dates in the 2008-2009 financial crisis&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-3127eaa51f5e4c2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-11 2008-2009年金融危机期间的重要日期" /><figcaption aria-hidden="true">图9-11 2008-2009年金融危机期间的重要日期</figcaption>
</figure>
<p>这张图中有几个重要的点要强调：ax.annotate方法可以在指定的x和y坐标轴绘制标签。我们使用set_xlim和set_ylim人工设定起始和结束边界，而不使用matplotlib的默认方法。最后，用ax.set_title添加图标标题。</p>
<p>更多有关注解的示例，请访问matplotlib的在线示例库。</p>
<p>图形的绘制要麻烦一些。matplotlib有一些表示常见图形的对象。这些对象被称为块（patch）。其中有些（如Rectangle和Circle），可以在matplotlib.pyplot中找到，但完整集合位于matplotlib.patches。</p>
<p>要在图表中添加一个图形，你需要创建一个块对象shp，然后通过ax.add_patch(shp)将其添加到subplot中（如图9-12所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">rect = plt.Rectangle((<span class="number">0.2</span>, <span class="number">0.75</span>), <span class="number">0.4</span>, <span class="number">0.15</span>, color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">circ = plt.Circle((<span class="number">0.7</span>, <span class="number">0.2</span>), <span class="number">0.15</span>, color=<span class="string">&#x27;b&#x27;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">pgon = plt.Polygon([[<span class="number">0.15</span>, <span class="number">0.15</span>], [<span class="number">0.35</span>, <span class="number">0.4</span>], [<span class="number">0.2</span>, <span class="number">0.6</span>]],</span><br><span class="line">                   color=<span class="string">&#x27;g&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">ax.add_patch(rect)</span><br><span class="line">ax.add_patch(circ)</span><br><span class="line">ax.add_patch(pgon)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-1f8a3d7a3a02d7d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-12 由三个块图形组成的图" /><figcaption aria-hidden="true">图9-12 由三个块图形组成的图</figcaption>
</figure>
<p>如果查看许多常见图表对象的具体实现代码，你就会发现它们其实就是由块patch组装而成的。</p>
<h2 id="将图表保存到文件">将图表保存到文件</h2>
<p>利用plt.savefig可以将当前图表保存到文件。该方法相当于Figure对象的实例方法savefig。例如，要将图表保存为SVG文件，你只需输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.savefig(<span class="string">&#x27;figpath.svg&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>文件类型是通过文件扩展名推断出来的。因此，如果你使用的是.pdf，就会得到一个PDF文件。我在发布图片时最常用到两个重要的选项是dpi（控制“每英寸点数”分辨率）和bbox_inches（可以剪除当前图表周围的空白部分）。要得到一张带有最小白边且分辨率为400DPI的PNG图片，你可以：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.savefig(<span class="string">&#x27;figpath.png&#x27;</span>, dpi=<span class="number">400</span>, bbox_inches=<span class="string">&#x27;tight&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>savefig并非一定要写入磁盘，也可以写入任何文件型的对象，比如BytesIO：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line">buffer = BytesIO()</span><br><span class="line">plt.savefig(buffer)</span><br><span class="line">plot_data = buffer.getvalue()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表9-2列出了savefig的其它选项。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-4bee796bf7262423.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表9-2 Figure.savefig的选项" /><figcaption aria-hidden="true">表9-2 Figure.savefig的选项</figcaption>
</figure>
<h2 id="matplotlib配置">matplotlib配置</h2>
<p>matplotlib自带一些配色方案，以及为生成出版质量的图片而设定的默认配置信息。幸运的是，几乎所有默认行为都能通过一组全局参数进行自定义，它们可以管理图像大小、subplot边距、配色方案、字体大小、网格类型等。一种Python编程方式配置系统的方法是使用rc方法。例如，要将全局的图像默认大小设置为10×10，你可以执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rc(<span class="string">&#x27;figure&#x27;</span>, figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>rc的第一个参数是希望自定义的对象，如'figure'、'axes'、'xtick'、'ytick'、'grid'、'legend'等。其后可以跟上一系列的关键字参数。一个简单的办法是将这些选项写成一个字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">font_options = &#123;<span class="string">&#x27;family&#x27;</span> : <span class="string">&#x27;monospace&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;weight&#x27;</span> : <span class="string">&#x27;bold&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;size&#x27;</span>   : <span class="string">&#x27;small&#x27;</span>&#125;</span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>, **font_options)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要了解全部的自定义选项，请查阅matplotlib的配置文件matplotlibrc（位于matplotlib/mpl-data目录中）。如果对该文件进行了自定义，并将其放在你自己的.matplotlibrc目录中，则每次使用matplotlib时就会加载该文件。</p>
<p>下一节，我们会看到，seaborn包有若干内置的绘图主题或类型，它们使用了matplotlib的内部配置。</p>
<h1 id="使用pandas和seaborn绘图">9.2 使用pandas和seaborn绘图</h1>
<p>matplotlib实际上是一种比较低级的工具。要绘制一张图表，你组装一些基本组件就行：数据展示（即图表类型：线型图、柱状图、盒形图、散布图、等值线图等）、图例、标题、刻度标签以及其他注解型信息。</p>
<p>在pandas中，我们有多列数据，还有行和列标签。pandas自身就有内置的方法，用于简化从DataFrame和Series绘制图形。另一个库<a href="https://seaborn.pydata.org/">seaborn</a>，由Michael Waskom创建的静态图形库。Seaborn简化了许多常见可视类型的创建。</p>
<blockquote>
<p>提示：引入seaborn会修改matplotlib默认的颜色方案和绘图类型，以提高可读性和美观度。即使你不使用seaborn API，你可能也会引入seaborn，作为提高美观度和绘制常见matplotlib图形的简化方法。</p>
</blockquote>
<h2 id="线型图">线型图</h2>
<p>Series和DataFrame都有一个用于生成各类图表的plot方法。默认情况下，它们所生成的是线型图（如图9-13所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">60</span>]: s = pd.Series(np.random.randn(<span class="number">10</span>).cumsum(), index=np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: s.plot()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-f28e5ab2ac94c7a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-13 简单的Series图表示例" /><figcaption aria-hidden="true">图9-13 简单的Series图表示例</figcaption>
</figure>
<p>该Series对象的索引会被传给matplotlib，并用以绘制X轴。可以通过use_index=False禁用该功能。X轴的刻度和界限可以通过xticks和xlim选项进行调节，Y轴就用yticks和ylim。plot参数的完整列表请参见表9-3。我只会讲解其中几个，剩下的就留给读者自己去研究了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-6d9fbf863c09370a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-44e50562aeb5eb49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表9-3 Series.plot方法的参数" /><figcaption aria-hidden="true">表9-3 Series.plot方法的参数</figcaption>
</figure>
<p>pandas的大部分绘图方法都有一个可选的ax参数，它可以是一个matplotlib的subplot对象。这使你能够在网格布局中更为灵活地处理subplot的位置。</p>
<p>DataFrame的plot方法会在一个subplot中为各列绘制一条线，并自动创建图例（如图9-14所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">62</span>]: df = pd.DataFrame(np.random.randn(<span class="number">10</span>, <span class="number">4</span>).cumsum(<span class="number">0</span>),</span><br><span class="line">   ....:                   columns=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>],</span><br><span class="line">   ....:                   index=np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: df.plot()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-a1234d5e5ee41a40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-14 简单的DataFrame绘图" /><figcaption aria-hidden="true">图9-14 简单的DataFrame绘图</figcaption>
</figure>
<p>plot属性包含一批不同绘图类型的方法。例如，df.plot()等价于df.plot.line()。后面会学习这些方法。</p>
<blockquote>
<p>笔记：plot的其他关键字参数会被传给相应的matplotlib绘图函数，所以要更深入地自定义图表，就必须学习更多有关matplotlib API的知识。</p>
</blockquote>
<p>DataFrame还有一些用于对列进行灵活处理的选项，例如，是要将所有列都绘制到一个subplot中还是创建各自的subplot。详细信息请参见表9-4。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-96651ecaa90f1c68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表9-4 专用于DataFrame的plot参数" /><figcaption aria-hidden="true">表9-4 专用于DataFrame的plot参数</figcaption>
</figure>
<blockquote>
<p>注意： 有关时间序列的绘图，请见第11章。</p>
</blockquote>
<h2 id="柱状图">柱状图</h2>
<p>plot.bar()和plot.barh()分别绘制水平和垂直的柱状图。这时，Series和DataFrame的索引将会被用作X（bar）或Y（barh）刻度（如图9-15所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">64</span>]: fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: data = pd.Series(np.random.rand(<span class="number">16</span>), index=<span class="built_in">list</span>(<span class="string">&#x27;abcdefghijklmnop&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: data.plot.bar(ax=axes[<span class="number">0</span>], color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line">Out[<span class="number">66</span>]: &lt;matplotlib.axes._subplots.AxesSubplot at <span class="number">0x7fb62493d470</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: data.plot.barh(ax=axes[<span class="number">1</span>], color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-cd54c7ccfa3f0687.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-15 水平和垂直的柱状图" /><figcaption aria-hidden="true">图9-15 水平和垂直的柱状图</figcaption>
</figure>
<p>color='k'和alpha=0.7设定了图形的颜色为黑色，并使用部分的填充透明度。对于DataFrame，柱状图会将每一行的值分为一组，并排显示，如图9-16所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">69</span>]: df = pd.DataFrame(np.random.rand(<span class="number">6</span>, <span class="number">4</span>),</span><br><span class="line">   ....:                   index=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>, <span class="string">&#x27;six&#x27;</span>],</span><br><span class="line">   ....:                   columns=pd.Index([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>], name=<span class="string">&#x27;Genus&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: df</span><br><span class="line">Out[<span class="number">70</span>]: </span><br><span class="line">Genus         A         B         C         D</span><br><span class="line">one    <span class="number">0.370670</span>  <span class="number">0.602792</span>  <span class="number">0.229159</span>  <span class="number">0.486744</span></span><br><span class="line">two    <span class="number">0.420082</span>  <span class="number">0.571653</span>  <span class="number">0.049024</span>  <span class="number">0.880592</span></span><br><span class="line">three  <span class="number">0.814568</span>  <span class="number">0.277160</span>  <span class="number">0.880316</span>  <span class="number">0.431326</span></span><br><span class="line">four   <span class="number">0.374020</span>  <span class="number">0.899420</span>  <span class="number">0.460304</span>  <span class="number">0.100843</span></span><br><span class="line">five   <span class="number">0.433270</span>  <span class="number">0.125107</span>  <span class="number">0.494675</span>  <span class="number">0.961825</span></span><br><span class="line">six    <span class="number">0.601648</span>  <span class="number">0.478576</span>  <span class="number">0.205690</span>  <span class="number">0.560547</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: df.plot.bar()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-bfc141acb37d99b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-16 DataFrame的柱状图" /><figcaption aria-hidden="true">图9-16 DataFrame的柱状图</figcaption>
</figure>
<p>注意，DataFrame各列的名称"Genus"被用作了图例的标题。</p>
<p>设置stacked=True即可为DataFrame生成堆积柱状图，这样每行的值就会被堆积在一起（如图9-17所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">73</span>]: df.plot.barh(stacked=<span class="literal">True</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-c19e4246eb897978.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-17 DataFrame的堆积柱状图" /><figcaption aria-hidden="true">图9-17 DataFrame的堆积柱状图</figcaption>
</figure>
<blockquote>
<p>笔记：柱状图有一个非常不错的用法：利用value_counts图形化显示Series中各值的出现频率，比如s.value_counts().plot.bar()。</p>
</blockquote>
<p>再以本书前面用过的那个有关小费的数据集为例，假设我们想要做一张堆积柱状图以展示每天各种聚会规模的数据点的百分比。我用read_csv将数据加载进来，然后根据日期和聚会规模创建一张交叉表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">75</span>]: tips = pd.read_csv(<span class="string">&#x27;examples/tips.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: party_counts = pd.crosstab(tips[<span class="string">&#x27;day&#x27;</span>], tips[<span class="string">&#x27;size&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: party_counts</span><br><span class="line">Out[<span class="number">77</span>]: </span><br><span class="line">size  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></span><br><span class="line">day                      </span><br><span class="line">Fri   <span class="number">1</span>  <span class="number">16</span>   <span class="number">1</span>   <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">Sat   <span class="number">2</span>  <span class="number">53</span>  <span class="number">18</span>  <span class="number">13</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line">Sun   <span class="number">0</span>  <span class="number">39</span>  <span class="number">15</span>  <span class="number">18</span>  <span class="number">3</span>  <span class="number">1</span></span><br><span class="line">Thur  <span class="number">1</span>  <span class="number">48</span>   <span class="number">4</span>   <span class="number">5</span>  <span class="number">1</span>  <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Not many 1- and 6-person parties</span></span><br><span class="line">In [<span class="number">78</span>]: party_counts = party_counts.loc[:, <span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后进行规格化，使得各行的和为1，并生成图表（如图9-18所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Normalize to sum to 1</span></span><br><span class="line">In [<span class="number">79</span>]: party_pcts = party_counts.div(party_counts.<span class="built_in">sum</span>(<span class="number">1</span>), axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: party_pcts</span><br><span class="line">Out[<span class="number">80</span>]: </span><br><span class="line">size         <span class="number">2</span>         <span class="number">3</span>         <span class="number">4</span>         <span class="number">5</span></span><br><span class="line">day                                         </span><br><span class="line">Fri   <span class="number">0.888889</span>  <span class="number">0.055556</span>  <span class="number">0.055556</span>  <span class="number">0.000000</span></span><br><span class="line">Sat   <span class="number">0.623529</span>  <span class="number">0.211765</span>  <span class="number">0.152941</span>  <span class="number">0.011765</span></span><br><span class="line">Sun   <span class="number">0.520000</span>  <span class="number">0.200000</span>  <span class="number">0.240000</span>  <span class="number">0.040000</span></span><br><span class="line">Thur  <span class="number">0.827586</span>  <span class="number">0.068966</span>  <span class="number">0.086207</span>  <span class="number">0.017241</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: party_pcts.plot.bar()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-2918f67936823834.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-18 每天各种聚会规模的比例" /><figcaption aria-hidden="true">图9-18 每天各种聚会规模的比例</figcaption>
</figure>
<p>于是，通过该数据集就可以看出，聚会规模在周末会变大。</p>
<p>对于在绘制一个图形之前，需要进行合计的数据，使用seaborn可以减少工作量。用seaborn来看每天的小费比例（图9-19是结果）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">83</span>]: <span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: tips[<span class="string">&#x27;tip_pct&#x27;</span>] = tips[<span class="string">&#x27;tip&#x27;</span>] / (tips[<span class="string">&#x27;total_bill&#x27;</span>] - tips[<span class="string">&#x27;tip&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">85</span>]: tips.head()</span><br><span class="line">Out[<span class="number">85</span>]: </span><br><span class="line">   total_bill   tip smoker  day    time  size   tip_pct</span><br><span class="line"><span class="number">0</span>       <span class="number">16.99</span>  <span class="number">1.01</span>     No  Sun  Dinner     <span class="number">2</span>  <span class="number">0.063204</span></span><br><span class="line"><span class="number">1</span>       <span class="number">10.34</span>  <span class="number">1.66</span>     No  Sun  Dinner     <span class="number">3</span>  <span class="number">0.191244</span></span><br><span class="line"><span class="number">2</span>       <span class="number">21.01</span>  <span class="number">3.50</span>     No  Sun  Dinner     <span class="number">3</span>  <span class="number">0.199886</span></span><br><span class="line"><span class="number">3</span>       <span class="number">23.68</span>  <span class="number">3.31</span>     No  Sun  Dinner     <span class="number">2</span>  <span class="number">0.162494</span></span><br><span class="line"><span class="number">4</span>       <span class="number">24.59</span>  <span class="number">3.61</span>     No  Sun  Dinner     <span class="number">4</span>  <span class="number">0.172069</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: sns.barplot(x=<span class="string">&#x27;tip_pct&#x27;</span>, y=<span class="string">&#x27;day&#x27;</span>, data=tips, orient=<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-c33e8b3add99904b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-19 小费的每日比例，带有误差条" /><figcaption aria-hidden="true">图9-19 小费的每日比例，带有误差条</figcaption>
</figure>
<p>seaborn的绘制函数使用data参数，它可能是pandas的DataFrame。其它的参数是关于列的名字。因为一天的每个值有多次观察，柱状图的值是tip_pct的平均值。绘制在柱状图上的黑线代表95%置信区间（可以通过可选参数配置）。</p>
<p>seaborn.barplot有颜色选项，使我们能够通过一个额外的值设置（见图9-20）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">88</span>]: sns.barplot(x=<span class="string">&#x27;tip_pct&#x27;</span>, y=<span class="string">&#x27;day&#x27;</span>, hue=<span class="string">&#x27;time&#x27;</span>, data=tips, orient=<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-06abe2f070222115.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-20 根据天和时间的小费比例" /><figcaption aria-hidden="true">图9-20 根据天和时间的小费比例</figcaption>
</figure>
<p>注意，seaborn已经自动修改了图形的美观度：默认调色板，图形背景和网格线的颜色。你可以用seaborn.set在不同的图形外观之间切换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">90</span>]: sns.<span class="built_in">set</span>(style=<span class="string">&quot;whitegrid&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="直方图和密度图">直方图和密度图</h2>
<p>直方图（histogram）是一种可以对值频率进行离散化显示的柱状图。数据点被拆分到离散的、间隔均匀的面元中，绘制的是各面元中数据点的数量。再以前面那个小费数据为例，通过在Series使用plot.hist方法，我们可以生成一张“小费占消费总额百分比”的直方图（如图9-21所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">92</span>]: tips[<span class="string">&#x27;tip_pct&#x27;</span>].plot.hist(bins=<span class="number">50</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-255279376f7649a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-21 小费百分比的直方图" /><figcaption aria-hidden="true">图9-21 小费百分比的直方图</figcaption>
</figure>
<p>与此相关的一种图表类型是密度图，它是通过计算“可能会产生观测数据的连续概率分布的估计”而产生的。一般的过程是将该分布近似为一组核（即诸如正态分布之类的较为简单的分布）。因此，密度图也被称作KDE（Kernel Density Estimate，核密度估计）图。使用plot.kde和标准混合正态分布估计即可生成一张密度图（见图9-22）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">94</span>]: tips[<span class="string">&#x27;tip_pct&#x27;</span>].plot.density()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-ee929d033159516a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-22 小费百分比的密度图" /><figcaption aria-hidden="true">图9-22 小费百分比的密度图</figcaption>
</figure>
<p>seaborn的distplot方法绘制直方图和密度图更加简单，还可以同时画出直方图和连续密度估计图。作为例子，考虑一个双峰分布，由两个不同的标准正态分布组成（见图9-23）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">96</span>]: comp1 = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, size=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: comp2 = np.random.normal(<span class="number">10</span>, <span class="number">2</span>, size=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: values = pd.Series(np.concatenate([comp1, comp2]))</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: sns.distplot(values, bins=<span class="number">100</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-975f04d750c4efe2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-23 标准混合密度估计的标准直方图" /><figcaption aria-hidden="true">图9-23 标准混合密度估计的标准直方图</figcaption>
</figure>
<h2 id="散布图或点图">散布图或点图</h2>
<p>点图或散布图是观察两个一维数据序列之间的关系的有效手段。在下面这个例子中，我加载了来自statsmodels项目的macrodata数据集，选择了几个变量，然后计算对数差：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">100</span>]: macro = pd.read_csv(<span class="string">&#x27;examples/macrodata.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">101</span>]: data = macro[[<span class="string">&#x27;cpi&#x27;</span>, <span class="string">&#x27;m1&#x27;</span>, <span class="string">&#x27;tbilrate&#x27;</span>, <span class="string">&#x27;unemp&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">102</span>]: trans_data = np.log(data).diff().dropna()</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: trans_data[-<span class="number">5</span>:]</span><br><span class="line">Out[<span class="number">103</span>]: </span><br><span class="line">          cpi        m1  tbilrate     unemp</span><br><span class="line"><span class="number">198</span> -<span class="number">0.007904</span>  <span class="number">0.045361</span> -<span class="number">0.396881</span>  <span class="number">0.105361</span></span><br><span class="line"><span class="number">199</span> -<span class="number">0.021979</span>  <span class="number">0.066753</span> -<span class="number">2.277267</span>  <span class="number">0.139762</span></span><br><span class="line"><span class="number">200</span>  <span class="number">0.002340</span>  <span class="number">0.010286</span>  <span class="number">0.606136</span>  <span class="number">0.160343</span></span><br><span class="line"><span class="number">201</span>  <span class="number">0.008419</span>  <span class="number">0.037461</span> -<span class="number">0.200671</span>  <span class="number">0.127339</span></span><br><span class="line"><span class="number">202</span>  <span class="number">0.008894</span>  <span class="number">0.012202</span> -<span class="number">0.405465</span>  <span class="number">0.042560</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后可以使用seaborn的regplot方法，它可以做一个散布图，并加上一条线性回归的线（见图9-24）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">105</span>]: sns.regplot(<span class="string">&#x27;m1&#x27;</span>, <span class="string">&#x27;unemp&#x27;</span>, data=trans_data)</span><br><span class="line">Out[<span class="number">105</span>]: &lt;matplotlib.axes._subplots.AxesSubplot at <span class="number">0x7fb613720be0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: plt.title(<span class="string">&#x27;Changes in log %s versus log %s&#x27;</span> % (<span class="string">&#x27;m1&#x27;</span>, <span class="string">&#x27;unemp&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-2133d20739478a80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-24 seaborn的回归/散布图" /><figcaption aria-hidden="true">图9-24 seaborn的回归/散布图</figcaption>
</figure>
<p>在探索式数据分析工作中，同时观察一组变量的散布图是很有意义的，这也被称为散布图矩阵（scatter plot matrix）。纯手工创建这样的图表很费工夫，所以seaborn提供了一个便捷的pairplot函数，它支持在对角线上放置每个变量的直方图或密度估计（见图9-25）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">107</span>]: sns.pairplot(trans_data, diag_kind=<span class="string">&#x27;kde&#x27;</span>, plot_kws=&#123;<span class="string">&#x27;alpha&#x27;</span>: <span class="number">0.2</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-20aa530a44e06f61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-25 statsmodels macro data的散布图矩阵" /><figcaption aria-hidden="true">图9-25 statsmodels macro data的散布图矩阵</figcaption>
</figure>
<p>你可能注意到了plot_kws参数。它可以让我们传递配置选项到非对角线元素上的图形使用。对于更详细的配置选项，可以查阅seaborn.pairplot文档字符串。</p>
<h2 id="分面网格facet-grid和类型数据">分面网格（facet grid）和类型数据</h2>
<p>要是数据集有额外的分组维度呢？有多个分类变量的数据可视化的一种方法是使用小面网格。seaborn有一个有用的内置函数factorplot，可以简化制作多种分面图（见图9-26）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">108</span>]: sns.factorplot(x=<span class="string">&#x27;day&#x27;</span>, y=<span class="string">&#x27;tip_pct&#x27;</span>, hue=<span class="string">&#x27;time&#x27;</span>, col=<span class="string">&#x27;smoker&#x27;</span>,</span><br><span class="line">  .....:                kind=<span class="string">&#x27;bar&#x27;</span>, data=tips[tips.tip_pct &lt; <span class="number">1</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-737ba19a0cbdd46f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-26 按照天/时间/吸烟者的小费百分比" /><figcaption aria-hidden="true">图9-26 按照天/时间/吸烟者的小费百分比</figcaption>
</figure>
<p>除了在分面中用不同的颜色按时间分组，我们还可以通过给每个时间值添加一行来扩展分面网格：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">109</span>]: sns.factorplot(x=<span class="string">&#x27;day&#x27;</span>, y=<span class="string">&#x27;tip_pct&#x27;</span>, row=<span class="string">&#x27;time&#x27;</span>,</span><br><span class="line">   .....:                col=<span class="string">&#x27;smoker&#x27;</span>,</span><br><span class="line">   .....:                kind=<span class="string">&#x27;bar&#x27;</span>, data=tips[tips.tip_pct &lt; <span class="number">1</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-4e52192441c609f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-27 按天的tip_pct，通过time/smoker分面" /><figcaption aria-hidden="true">图9-27 按天的tip_pct，通过time/smoker分面</figcaption>
</figure>
<p>factorplot支持其它的绘图类型，你可能会用到。例如，盒图（它可以显示中位数，四分位数，和异常值）就是一个有用的可视化类型（见图9-28）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">110</span>]: sns.factorplot(x=<span class="string">&#x27;tip_pct&#x27;</span>, y=<span class="string">&#x27;day&#x27;</span>, kind=<span class="string">&#x27;box&#x27;</span>,</span><br><span class="line">   .....:                data=tips[tips.tip_pct &lt; <span class="number">0.5</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-356fb27a7c658920.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-28 按天的tip_pct的盒图" /><figcaption aria-hidden="true">图9-28 按天的tip_pct的盒图</figcaption>
</figure>
<p>使用更通用的seaborn.FacetGrid类，你可以创建自己的分面网格。请查阅seaborn的文档<a href="https://seaborn.pydata.org/" class="uri">https://seaborn.pydata.org/</a>。</p>
<h1 id="其它的python可视化工具">9.3 其它的Python可视化工具</h1>
<p>与其它开源库类似，Python创建图形的方式非常多（根本罗列不完）。自从2010年，许多开发工作都集中在创建交互式图形以便在Web上发布。利用工具如Boken<a href="https://bokeh.pydata.org/en/latest/" class="uri">https://bokeh.pydata.org/en/latest/</a>和Plotly<a href="https://github.com/plotly/plotly.py" class="uri">https://github.com/plotly/plotly.py</a>，现在可以创建动态交互图形，用于网页浏览器。</p>
<p>对于创建用于打印或网页的静态图形，我建议默认使用matplotlib和附加的库，比如pandas和seaborn。对于其它数据可视化要求，学习其它的可用工具可能是有用的。我鼓励你探索绘图的生态系统，因为它将持续发展。</p>
<h1 id="总结">9.4 总结</h1>
<p>本章的目的是熟悉一些基本的数据可视化操作，使用pandas，matplotlib，和seaborn。如果视觉显示数据分析的结果对你的工作很重要，我鼓励你寻求更多的资源来了解更高效的数据可视化。这是一个活跃的研究领域，你可以通过在线和纸质的形式学习许多优秀的资源。</p>
<p>下一章，我们将重点放在pandas的数据聚合和分组操作上。</p>
]]></content>
      <categories>
        <category>Python 数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>第12章 pandas高级应用</title>
    <url>/2019/04/09/%E7%AC%AC12%E7%AB%A0-pandas%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>前面的章节关注于不同类型的数据规整流程和NumPy、pandas与其它库的特点。随着时间的发展，pandas发展出了更多适合高级用户的功能。本章就要深入学习pandas的高级功能。<span id="more"></span></p>
<h1 id="分类数据">12.1 分类数据</h1>
<p>这一节介绍的是pandas的分类类型。我会向你展示通过使用它，提高性能和内存的使用率。我还会介绍一些在统计和机器学习中使用分类数据的工具。</p>
<h2 id="背景和目的">背景和目的</h2>
<p>表中的一列通常会有重复的包含不同值的小集合的情况。我们已经学过了unique和value_counts，它们可以从数组提取出不同的值，并分别计算频率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np; <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: values = pd.Series([<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">   ....:                     <span class="string">&#x27;apple&#x27;</span>] * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: values</span><br><span class="line">Out[<span class="number">12</span>]: </span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">1</span>    orange</span><br><span class="line"><span class="number">2</span>     apple</span><br><span class="line"><span class="number">3</span>     apple</span><br><span class="line"><span class="number">4</span>     apple</span><br><span class="line"><span class="number">5</span>    orange</span><br><span class="line"><span class="number">6</span>     apple</span><br><span class="line"><span class="number">7</span>     apple</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: pd.unique(values)</span><br><span class="line">Out[<span class="number">13</span>]: array([<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>], dtype=<span class="built_in">object</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: pd.value_counts(values)</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">apple     <span class="number">6</span></span><br><span class="line">orange    <span class="number">2</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>许多数据系统（数据仓库、统计计算或其它应用）都发展出了特定的表征重复值的方法，以进行高效的存储和计算。在数据仓库中，最好的方法是使用所谓的包含不同值的维表(Dimension Table)，将主要的参数存储为引用维表整数键：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: values = pd.Series([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>] * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: dim = pd.Series([<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: values</span><br><span class="line">Out[<span class="number">17</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1</span></span><br><span class="line"><span class="number">2</span>    <span class="number">0</span></span><br><span class="line"><span class="number">3</span>    <span class="number">0</span></span><br><span class="line"><span class="number">4</span>    <span class="number">0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">1</span></span><br><span class="line"><span class="number">6</span>    <span class="number">0</span></span><br><span class="line"><span class="number">7</span>    <span class="number">0</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: dim</span><br><span class="line">Out[<span class="number">18</span>]: </span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">1</span>    orange</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>可以使用take方法存储原始的字符串Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">19</span>]: dim.take(values)</span><br><span class="line">Out[<span class="number">19</span>]: </span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">1</span>    orange</span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">1</span>    orange</span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>这种用整数表示的方法称为分类或字典编码表示法。不同值得数组称为分类、字典或数据级。本书中，我们使用分类的说法。表示分类的整数值称为分类编码或简单地称为编码。</p>
<p>分类表示可以在进行分析时大大的提高性能。你也可以在保持编码不变的情况下，对分类进行转换。一些相对简单的转变例子包括：</p>
<ul>
<li>重命名分类。</li>
<li>加入一个新的分类，不改变已经存在的分类的顺序或位置。</li>
</ul>
<h2 id="pandas的分类类型">pandas的分类类型</h2>
<p>pandas有一个特殊的分类类型，用于保存使用整数分类表示法的数据。看一个之前的Series例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: fruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>] * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: N = <span class="built_in">len</span>(fruits)</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;fruit&#x27;</span>: fruits,</span><br><span class="line">   ....:                    <span class="string">&#x27;basket_id&#x27;</span>: np.arange(N),</span><br><span class="line">   ....:                    <span class="string">&#x27;count&#x27;</span>: np.random.randint(<span class="number">3</span>, <span class="number">15</span>, size=N),</span><br><span class="line">   ....:                    <span class="string">&#x27;weight&#x27;</span>: np.random.uniform(<span class="number">0</span>, <span class="number">4</span>, size=N)&#125;,</span><br><span class="line">   ....:                   columns=[<span class="string">&#x27;basket_id&#x27;</span>, <span class="string">&#x27;fruit&#x27;</span>, <span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;weight&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: df</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">   basket_id   fruit  count    weight</span><br><span class="line"><span class="number">0</span>          <span class="number">0</span>   apple      <span class="number">5</span>  <span class="number">3.858058</span></span><br><span class="line"><span class="number">1</span>          <span class="number">1</span>  orange      <span class="number">8</span>  <span class="number">2.612708</span></span><br><span class="line"><span class="number">2</span>          <span class="number">2</span>   apple      <span class="number">4</span>  <span class="number">2.995627</span></span><br><span class="line"><span class="number">3</span>          <span class="number">3</span>   apple      <span class="number">7</span>  <span class="number">2.614279</span></span><br><span class="line"><span class="number">4</span>          <span class="number">4</span>   apple     <span class="number">12</span>  <span class="number">2.990859</span></span><br><span class="line"><span class="number">5</span>          <span class="number">5</span>  orange      <span class="number">8</span>  <span class="number">3.845227</span></span><br><span class="line"><span class="number">6</span>          <span class="number">6</span>   apple      <span class="number">5</span>  <span class="number">0.033553</span></span><br><span class="line"><span class="number">7</span>          <span class="number">7</span>   apple      <span class="number">4</span>  <span class="number">0.425778</span></span><br></pre></td></tr></table></figure>
<p>这里，df['fruit']是一个Python字符串对象的数组。我们可以通过调用它，将它转变为分类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: fruit_cat = df[<span class="string">&#x27;fruit&#x27;</span>].astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: fruit_cat</span><br><span class="line">Out[<span class="number">25</span>]: </span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">1</span>    orange</span><br><span class="line"><span class="number">2</span>     apple</span><br><span class="line"><span class="number">3</span>     apple</span><br><span class="line"><span class="number">4</span>     apple</span><br><span class="line"><span class="number">5</span>    orange</span><br><span class="line"><span class="number">6</span>     apple</span><br><span class="line"><span class="number">7</span>     apple</span><br><span class="line">Name: fruit, dtype: category</span><br><span class="line">Categories (<span class="number">2</span>, <span class="built_in">object</span>): [apple, orange]</span><br></pre></td></tr></table></figure>
<p>fruit_cat的值不是NumPy数组，而是一个pandas.Categorical实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">26</span>]: c = fruit_cat.values</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: <span class="built_in">type</span>(c)</span><br><span class="line">Out[<span class="number">27</span>]: pandas.core.categorical.Categorical</span><br></pre></td></tr></table></figure>
<p>分类对象有categories和codes属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">28</span>]: c.categories</span><br><span class="line">Out[<span class="number">28</span>]: Index([<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: c.codes</span><br><span class="line">Out[<span class="number">29</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], dtype=int8)</span><br></pre></td></tr></table></figure>
<p>你可将DataFrame的列通过分配转换结果，转换为分类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">30</span>]: df[<span class="string">&#x27;fruit&#x27;</span>] = df[<span class="string">&#x27;fruit&#x27;</span>].astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: df.fruit</span><br><span class="line">Out[<span class="number">31</span>]:</span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">1</span>    orange</span><br><span class="line"><span class="number">2</span>     apple</span><br><span class="line"><span class="number">3</span>     apple</span><br><span class="line"><span class="number">4</span>     apple</span><br><span class="line"><span class="number">5</span>    orange</span><br><span class="line"><span class="number">6</span>     apple</span><br><span class="line"><span class="number">7</span>     apple</span><br><span class="line">Name: fruit, dtype: category</span><br><span class="line">Categories (<span class="number">2</span>, <span class="built_in">object</span>): [apple, orange]</span><br></pre></td></tr></table></figure>
<p>你还可以从其它Python序列直接创建pandas.Categorical：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">32</span>]: my_categories = pd.Categorical([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: my_categories</span><br><span class="line">Out[<span class="number">33</span>]: </span><br><span class="line">[foo, bar, baz, foo, bar]</span><br><span class="line">Categories (<span class="number">3</span>, <span class="built_in">object</span>): [bar, baz, foo]</span><br></pre></td></tr></table></figure>
<p>如果你已经从其它源获得了分类编码，你还可以使用from_codes构造器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">34</span>]: categories = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: codes = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: my_cats_2 = pd.Categorical.from_codes(codes, categories)</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: my_cats_2</span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">[foo, bar, baz, foo, foo, bar]</span><br><span class="line">Categories (<span class="number">3</span>, <span class="built_in">object</span>): [foo, bar, baz]</span><br></pre></td></tr></table></figure>
<p>与显示指定不同，分类变换不认定指定的分类顺序。因此取决于输入数据的顺序，categories数组的顺序会不同。当使用from_codes或其它的构造器时，你可以指定分类一个有意义的顺序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">38</span>]: ordered_cat = pd.Categorical.from_codes(codes, categories,</span><br><span class="line">   ....:                                         ordered=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: ordered_cat</span><br><span class="line">Out[<span class="number">39</span>]: </span><br><span class="line">[foo, bar, baz, foo, foo, bar]</span><br><span class="line">Categories (<span class="number">3</span>, <span class="built_in">object</span>): [foo &lt; bar &lt; baz]</span><br></pre></td></tr></table></figure>
<p>输出[foo &lt; bar &lt; baz]指明‘foo’位于‘bar’的前面，以此类推。无序的分类实例可以通过as_ordered排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">40</span>]: my_cats_2.as_ordered()</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">[foo, bar, baz, foo, foo, bar]</span><br><span class="line">Categories (<span class="number">3</span>, <span class="built_in">object</span>): [foo &lt; bar &lt; baz]</span><br></pre></td></tr></table></figure>
<p>最后要注意，分类数据不需要字符串，尽管我仅仅展示了字符串的例子。分类数组可以包括任意不可变类型。</p>
<h2 id="用分类进行计算">用分类进行计算</h2>
<p>与非编码版本（比如字符串数组）相比，使用pandas的Categorical有些类似。某些pandas组件，比如groupby函数，更适合进行分类。还有一些函数可以使用有序标志位。</p>
<p>来看一些随机的数值数据，使用pandas.qcut面元函数。它会返回pandas.Categorical，我们之前使用过pandas.cut，但没解释分类是如何工作的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: np.random.seed(<span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: draws = np.random.randn(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: draws[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">43</span>]: array([-<span class="number">0.2047</span>,  <span class="number">0.4789</span>, -<span class="number">0.5194</span>, -<span class="number">0.5557</span>,  <span class="number">1.9658</span>])</span><br></pre></td></tr></table></figure>
<p>计算这个数据的分位面元，提取一些统计信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">44</span>]: bins = pd.qcut(draws, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: bins</span><br><span class="line">Out[<span class="number">45</span>]: </span><br><span class="line">[(-<span class="number">0.684</span>, -<span class="number">0.0101</span>], (-<span class="number">0.0101</span>, <span class="number">0.63</span>], (-<span class="number">0.684</span>, -<span class="number">0.0101</span>], (-<span class="number">0.684</span>, -<span class="number">0.0101</span>], (<span class="number">0.63</span>,</span><br><span class="line"> <span class="number">3.928</span>], ..., (-<span class="number">0.0101</span>, <span class="number">0.63</span>], (-<span class="number">0.684</span>, -<span class="number">0.0101</span>], (-<span class="number">2.95</span>, -<span class="number">0.684</span>], (-<span class="number">0.0101</span>, <span class="number">0.63</span></span><br><span class="line">], (<span class="number">0.63</span>, <span class="number">3.928</span>]]</span><br><span class="line">Length: <span class="number">1000</span></span><br><span class="line">Categories (<span class="number">4</span>, interval[float64]): [(-<span class="number">2.95</span>, -<span class="number">0.684</span>] &lt; (-<span class="number">0.684</span>, -<span class="number">0.0101</span>] &lt; (-<span class="number">0.010</span></span><br><span class="line"><span class="number">1</span>, <span class="number">0.63</span>] &lt;</span><br><span class="line">                                    (<span class="number">0.63</span>, <span class="number">3.928</span>]]</span><br></pre></td></tr></table></figure>
<p>虽然有用，确切的样本分位数与分位的名称相比，不利于生成汇总。我们可以使用labels参数qcut，实现目的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">46</span>]: bins = pd.qcut(draws, <span class="number">4</span>, labels=[<span class="string">&#x27;Q1&#x27;</span>, <span class="string">&#x27;Q2&#x27;</span>, <span class="string">&#x27;Q3&#x27;</span>, <span class="string">&#x27;Q4&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: bins</span><br><span class="line">Out[<span class="number">47</span>]: </span><br><span class="line">[Q2, Q3, Q2, Q2, Q4, ..., Q3, Q2, Q1, Q3, Q4]</span><br><span class="line">Length: <span class="number">1000</span></span><br><span class="line">Categories (<span class="number">4</span>, <span class="built_in">object</span>): [Q1 &lt; Q2 &lt; Q3 &lt; Q4]</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: bins.codes[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">48</span>]: array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>], dtype=int8)</span><br></pre></td></tr></table></figure>
<p>加上标签的面元分类不包含数据面元边界的信息，因此可以使用groupby提取一些汇总信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">49</span>]: bins = pd.Series(bins, name=<span class="string">&#x27;quartile&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: results = (pd.Series(draws)</span><br><span class="line">   ....:            .groupby(bins)</span><br><span class="line">   ....:            .agg([<span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;max&#x27;</span>])</span><br><span class="line">   ....:            .reset_index())</span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: results</span><br><span class="line">Out[<span class="number">51</span>]: </span><br><span class="line">  quartile  count       <span class="built_in">min</span>       <span class="built_in">max</span></span><br><span class="line"><span class="number">0</span>       Q1    <span class="number">250</span> -<span class="number">2.949343</span> -<span class="number">0.685484</span></span><br><span class="line"><span class="number">1</span>       Q2    <span class="number">250</span> -<span class="number">0.683066</span> -<span class="number">0.010115</span></span><br><span class="line"><span class="number">2</span>       Q3    <span class="number">250</span> -<span class="number">0.010032</span>  <span class="number">0.628894</span></span><br><span class="line"><span class="number">3</span>       Q4    <span class="number">250</span>  <span class="number">0.634238</span>  <span class="number">3.927528</span></span><br></pre></td></tr></table></figure>
<p>分位数列保存了原始的面元分类信息，包括排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">52</span>]: results[<span class="string">&#x27;quartile&#x27;</span>]</span><br><span class="line">Out[<span class="number">52</span>]:</span><br><span class="line"><span class="number">0</span>    Q1</span><br><span class="line"><span class="number">1</span>    Q2</span><br><span class="line"><span class="number">2</span>    Q3</span><br><span class="line"><span class="number">3</span>    Q4</span><br><span class="line">Name: quartile, dtype: category</span><br><span class="line">Categories (<span class="number">4</span>, <span class="built_in">object</span>): [Q1 &lt; Q2 &lt; Q3 &lt; Q4]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="用分类提高性能">用分类提高性能</h2>
<p>如果你是在一个特定数据集上做大量分析，将其转换为分类可以极大地提高效率。DataFrame列的分类使用的内存通常少的多。来看一些包含一千万元素的Series，和一些不同的分类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">53</span>]: N = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: draws = pd.Series(np.random.randn(N))</span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: labels = pd.Series([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>] * (N // <span class="number">4</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，将标签转换为分类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: categories = labels.astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这时，可以看到标签使用的内存远比分类多：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">57</span>]: labels.memory_usage()</span><br><span class="line">Out[<span class="number">57</span>]: <span class="number">80000080</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: categories.memory_usage()</span><br><span class="line">Out[<span class="number">58</span>]: <span class="number">10000272</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>转换为分类不是没有代价的，但这是一次性的代价：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">59</span>]: %time _ = labels.astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line">CPU times: user <span class="number">490</span> ms, sys: <span class="number">240</span> ms, total: <span class="number">730</span> ms</span><br><span class="line">Wall time: <span class="number">726</span> ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>GroupBy使用分类操作明显更快，是因为底层的算法使用整数编码数组，而不是字符串数组。</p>
<h2 id="分类方法">分类方法</h2>
<p>包含分类数据的Series有一些特殊的方法，类似于Series.str字符串方法。它还提供了方便的分类和编码的使用方法。看下面的Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">60</span>]: s = pd.Series([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>] * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: cat_s = s.astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: cat_s</span><br><span class="line">Out[<span class="number">62</span>]: </span><br><span class="line"><span class="number">0</span>    a</span><br><span class="line"><span class="number">1</span>    b</span><br><span class="line"><span class="number">2</span>    c</span><br><span class="line"><span class="number">3</span>    d</span><br><span class="line"><span class="number">4</span>    a</span><br><span class="line"><span class="number">5</span>    b</span><br><span class="line"><span class="number">6</span>    c</span><br><span class="line"><span class="number">7</span>    d</span><br><span class="line">dtype: category</span><br><span class="line">Categories (<span class="number">4</span>, <span class="built_in">object</span>): [a, b, c, d]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>特别的cat属性提供了分类方法的入口：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">63</span>]: cat_s.cat.codes</span><br><span class="line">Out[<span class="number">63</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span></span><br><span class="line"><span class="number">4</span>    <span class="number">0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">1</span></span><br><span class="line"><span class="number">6</span>    <span class="number">2</span></span><br><span class="line"><span class="number">7</span>    <span class="number">3</span></span><br><span class="line">dtype: int8</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: cat_s.cat.categories</span><br><span class="line">Out[<span class="number">64</span>]: Index([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设我们知道这个数据的实际分类集，超出了数据中的四个值。我们可以使用set_categories方法改变它们：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">65</span>]: actual_categories = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: cat_s2 = cat_s.cat.set_categories(actual_categories)</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: cat_s2</span><br><span class="line">Out[<span class="number">67</span>]: </span><br><span class="line"><span class="number">0</span>    a</span><br><span class="line"><span class="number">1</span>    b</span><br><span class="line"><span class="number">2</span>    c</span><br><span class="line"><span class="number">3</span>    d</span><br><span class="line"><span class="number">4</span>    a</span><br><span class="line"><span class="number">5</span>    b</span><br><span class="line"><span class="number">6</span>    c</span><br><span class="line"><span class="number">7</span>    d</span><br><span class="line">dtype: category</span><br><span class="line">Categories (<span class="number">5</span>, <span class="built_in">object</span>): [a, b, c, d, e]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然数据看起来没变，新的分类将反映在它们的操作中。例如，如果有的话，value_counts表示分类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">68</span>]: cat_s.value_counts()</span><br><span class="line">Out[<span class="number">68</span>]: </span><br><span class="line">d    <span class="number">2</span></span><br><span class="line">c    <span class="number">2</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">a    <span class="number">2</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: cat_s2.value_counts()</span><br><span class="line">Out[<span class="number">69</span>]: </span><br><span class="line">d    <span class="number">2</span></span><br><span class="line">c    <span class="number">2</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">a    <span class="number">2</span></span><br><span class="line">e    <span class="number">0</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在大数据集中，分类经常作为节省内存和高性能的便捷工具。过滤完大DataFrame或Series之后，许多分类可能不会出现在数据中。我们可以使用remove_unused_categories方法删除没看到的分类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">70</span>]: cat_s3 = cat_s[cat_s.isin([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])]</span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: cat_s3</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line"><span class="number">0</span>    a</span><br><span class="line"><span class="number">1</span>    b</span><br><span class="line"><span class="number">4</span>    a</span><br><span class="line"><span class="number">5</span>    b</span><br><span class="line">dtype: category</span><br><span class="line">Categories (<span class="number">4</span>, <span class="built_in">object</span>): [a, b, c, d]</span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: cat_s3.cat.remove_unused_categories()</span><br><span class="line">Out[<span class="number">72</span>]: </span><br><span class="line"><span class="number">0</span>    a</span><br><span class="line"><span class="number">1</span>    b</span><br><span class="line"><span class="number">4</span>    a</span><br><span class="line"><span class="number">5</span>    b</span><br><span class="line">dtype: category</span><br><span class="line">Categories (<span class="number">2</span>, <span class="built_in">object</span>): [a, b]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表12-1列出了可用的分类方法。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-6c602152c2bba658.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表12-1 pandas的Series的分类方法" /><figcaption aria-hidden="true">表12-1 pandas的Series的分类方法</figcaption>
</figure>
<h2 id="为建模创建虚拟变量">为建模创建虚拟变量</h2>
<p>当你使用统计或机器学习工具时，通常会将分类数据转换为虚拟变量，也称为one-hot编码。这包括创建一个不同类别的列的DataFrame；这些列包含给定分类的1s，其它为0。</p>
<p>看前面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">73</span>]: cat_s = pd.Series([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>] * <span class="number">2</span>, dtype=<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>前面的第7章提到过，pandas.get_dummies函数可以转换这个分类数据为包含虚拟变量的DataFrame：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: pd.get_dummies(cat_s)</span><br><span class="line">Out[<span class="number">74</span>]: </span><br><span class="line">   a  b  c  d</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">6</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line"><span class="number">7</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="groupby高级应用">12.2 GroupBy高级应用</h1>
<p>尽管我们在第10章已经深度学习了Series和DataFrame的Groupby方法，还有一些方法也是很有用的。</p>
<h2 id="分组转换和解封groupby">分组转换和“解封”GroupBy</h2>
<p>在第10章，我们在分组操作中学习了apply方法，进行转换。还有另一个transform方法，它与apply很像，但是对使用的函数有一定限制：</p>
<ul>
<li>它可以产生向分组形状广播标量值</li>
<li>它可以产生一个和输入组形状相同的对象</li>
<li>它不能修改输入</li>
</ul>
<p>来看一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">75</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>] * <span class="number">4</span>,</span><br><span class="line">   ....:                    <span class="string">&#x27;value&#x27;</span>: np.arange(<span class="number">12.</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: df</span><br><span class="line">Out[<span class="number">76</span>]: </span><br><span class="line">   key  value</span><br><span class="line"><span class="number">0</span>    a    <span class="number">0.0</span></span><br><span class="line"><span class="number">1</span>    b    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    c    <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>    a    <span class="number">3.0</span></span><br><span class="line"><span class="number">4</span>    b    <span class="number">4.0</span></span><br><span class="line"><span class="number">5</span>    c    <span class="number">5.0</span></span><br><span class="line"><span class="number">6</span>    a    <span class="number">6.0</span></span><br><span class="line"><span class="number">7</span>    b    <span class="number">7.0</span></span><br><span class="line"><span class="number">8</span>    c    <span class="number">8.0</span></span><br><span class="line"><span class="number">9</span>    a    <span class="number">9.0</span></span><br><span class="line"><span class="number">10</span>   b   <span class="number">10.0</span></span><br><span class="line"><span class="number">11</span>   c   <span class="number">11.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>按键进行分组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">77</span>]: g = df.groupby(<span class="string">&#x27;key&#x27;</span>).value</span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: g.mean()</span><br><span class="line">Out[<span class="number">78</span>]: </span><br><span class="line">key</span><br><span class="line">a    <span class="number">4.5</span></span><br><span class="line">b    <span class="number">5.5</span></span><br><span class="line">c    <span class="number">6.5</span></span><br><span class="line">Name: value, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设我们想产生一个和df['value']形状相同的Series，但值替换为按键分组的平均值。我们可以传递函数lambda x: x.mean()进行转换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">79</span>]: g.transform(<span class="keyword">lambda</span> x: x.mean())</span><br><span class="line">Out[<span class="number">79</span>]: </span><br><span class="line"><span class="number">0</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">1</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">2</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">3</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">4</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">5</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">6</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">7</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">8</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">9</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">10</span>    <span class="number">5.5</span></span><br><span class="line"><span class="number">11</span>    <span class="number">6.5</span></span><br><span class="line">Name: value, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于内置的聚合函数，我们可以传递一个字符串假名作为GroupBy的agg方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">80</span>]: g.transform(<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">Out[<span class="number">80</span>]: </span><br><span class="line"><span class="number">0</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">1</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">2</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">3</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">4</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">5</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">6</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">7</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">8</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">9</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">10</span>    <span class="number">5.5</span></span><br><span class="line"><span class="number">11</span>    <span class="number">6.5</span></span><br><span class="line">Name: value, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与apply类似，transform的函数会返回Series，但是结果必须与输入大小相同。举个例子，我们可以用lambda函数将每个分组乘以2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">81</span>]: g.transform(<span class="keyword">lambda</span> x: x * <span class="number">2</span>)</span><br><span class="line">Out[<span class="number">81</span>]: </span><br><span class="line"><span class="number">0</span>      <span class="number">0.0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">2.0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">4.0</span></span><br><span class="line"><span class="number">3</span>      <span class="number">6.0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">8.0</span></span><br><span class="line"><span class="number">5</span>     <span class="number">10.0</span></span><br><span class="line"><span class="number">6</span>     <span class="number">12.0</span></span><br><span class="line"><span class="number">7</span>     <span class="number">14.0</span></span><br><span class="line"><span class="number">8</span>     <span class="number">16.0</span></span><br><span class="line"><span class="number">9</span>     <span class="number">18.0</span></span><br><span class="line"><span class="number">10</span>    <span class="number">20.0</span></span><br><span class="line"><span class="number">11</span>    <span class="number">22.0</span></span><br><span class="line">Name: value, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再举一个复杂的例子，我们可以计算每个分组的降序排名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">82</span>]: g.transform(<span class="keyword">lambda</span> x: x.rank(ascending=<span class="literal">False</span>))</span><br><span class="line">Out[<span class="number">82</span>]: </span><br><span class="line"><span class="number">0</span>     <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>     <span class="number">4.0</span></span><br><span class="line"><span class="number">2</span>     <span class="number">4.0</span></span><br><span class="line"><span class="number">3</span>     <span class="number">3.0</span></span><br><span class="line"><span class="number">4</span>     <span class="number">3.0</span></span><br><span class="line"><span class="number">5</span>     <span class="number">3.0</span></span><br><span class="line"><span class="number">6</span>     <span class="number">2.0</span></span><br><span class="line"><span class="number">7</span>     <span class="number">2.0</span></span><br><span class="line"><span class="number">8</span>     <span class="number">2.0</span></span><br><span class="line"><span class="number">9</span>     <span class="number">1.0</span></span><br><span class="line"><span class="number">10</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">11</span>    <span class="number">1.0</span></span><br><span class="line">Name: value, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看一个由简单聚合构造的的分组转换函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (x - x.mean()) / x.std()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们用transform或apply可以获得等价的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">84</span>]: g.transform(normalize)</span><br><span class="line">Out[<span class="number">84</span>]: </span><br><span class="line"><span class="number">0</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">1</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">2</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">3</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">4</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">5</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">6</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">7</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">8</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">9</span>     <span class="number">1.161895</span></span><br><span class="line"><span class="number">10</span>    <span class="number">1.161895</span></span><br><span class="line"><span class="number">11</span>    <span class="number">1.161895</span></span><br><span class="line">Name: value, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">85</span>]: g.apply(normalize)</span><br><span class="line">Out[<span class="number">85</span>]: </span><br><span class="line"><span class="number">0</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">1</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">2</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">3</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">4</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">5</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">6</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">7</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">8</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">9</span>     <span class="number">1.161895</span></span><br><span class="line"><span class="number">10</span>    <span class="number">1.161895</span></span><br><span class="line"><span class="number">11</span>    <span class="number">1.161895</span></span><br><span class="line">Name: value, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>内置的聚合函数，比如mean或sum，通常比apply函数快，也比transform快。这允许我们进行一个所谓的解封（unwrapped）分组操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">86</span>]: g.transform(<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">Out[<span class="number">86</span>]: </span><br><span class="line"><span class="number">0</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">1</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">2</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">3</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">4</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">5</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">6</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">7</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">8</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">9</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">10</span>    <span class="number">5.5</span></span><br><span class="line"><span class="number">11</span>    <span class="number">6.5</span></span><br><span class="line">Name: value, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: normalized = (df[<span class="string">&#x27;value&#x27;</span>] - g.transform(<span class="string">&#x27;mean&#x27;</span>)) / g.transform(<span class="string">&#x27;std&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: normalized</span><br><span class="line">Out[<span class="number">88</span>]: </span><br><span class="line"><span class="number">0</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">1</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">2</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">3</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">4</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">5</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">6</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">7</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">8</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">9</span>     <span class="number">1.161895</span></span><br><span class="line"><span class="number">10</span>    <span class="number">1.161895</span></span><br><span class="line"><span class="number">11</span>    <span class="number">1.161895</span></span><br><span class="line">Name: value, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解封分组操作可能包括多个分组聚合，但是矢量化操作还是会带来收益。</p>
<h2 id="分组的时间重采样">分组的时间重采样</h2>
<p>对于时间序列数据，resample方法从语义上是一个基于内在时间的分组操作。下面是一个示例表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">89</span>]: N = <span class="number">15</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: times = pd.date_range(<span class="string">&#x27;2017-05-20 00:00&#x27;</span>, freq=<span class="string">&#x27;1min&#x27;</span>, periods=N)</span><br><span class="line"></span><br><span class="line">In [<span class="number">91</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;time&#x27;</span>: times,</span><br><span class="line">   ....:                    <span class="string">&#x27;value&#x27;</span>: np.arange(N)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: df</span><br><span class="line">Out[<span class="number">92</span>]: </span><br><span class="line">                  time  value</span><br><span class="line"><span class="number">0</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:01:<span class="number">00</span>      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:02:<span class="number">00</span>      <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:03:<span class="number">00</span>      <span class="number">3</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:04:<span class="number">00</span>      <span class="number">4</span></span><br><span class="line"><span class="number">5</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>      <span class="number">5</span></span><br><span class="line"><span class="number">6</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:06:<span class="number">00</span>      <span class="number">6</span></span><br><span class="line"><span class="number">7</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:07:<span class="number">00</span>      <span class="number">7</span></span><br><span class="line"><span class="number">8</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:08:<span class="number">00</span>      <span class="number">8</span></span><br><span class="line"><span class="number">9</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:09:<span class="number">00</span>      <span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>     <span class="number">10</span></span><br><span class="line"><span class="number">11</span> <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">11</span>:<span class="number">00</span>     <span class="number">11</span></span><br><span class="line"><span class="number">12</span> <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">12</span>:<span class="number">00</span>     <span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">13</span>:<span class="number">00</span>     <span class="number">13</span></span><br><span class="line"><span class="number">14</span> <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">14</span>:<span class="number">00</span>     <span class="number">14</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，我们可以用time作为索引，然后重采样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">93</span>]: df.set_index(<span class="string">&#x27;time&#x27;</span>).resample(<span class="string">&#x27;5min&#x27;</span>).count()</span><br><span class="line">Out[<span class="number">93</span>]: </span><br><span class="line">                     value</span><br><span class="line">time                      </span><br><span class="line"><span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>      <span class="number">5</span></span><br><span class="line"><span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>      <span class="number">5</span></span><br><span class="line"><span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>      <span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设DataFrame包含多个时间序列，用一个额外的分组键的列进行标记：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">94</span>]: df2 = pd.DataFrame(&#123;<span class="string">&#x27;time&#x27;</span>: times.repeat(<span class="number">3</span>),</span><br><span class="line">   ....:                     <span class="string">&#x27;key&#x27;</span>: np.tile([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], N),</span><br><span class="line">   ....:                     <span class="string">&#x27;value&#x27;</span>: np.arange(N * <span class="number">3.</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">95</span>]: df2[:<span class="number">7</span>]</span><br><span class="line">Out[<span class="number">95</span>]: </span><br><span class="line">  key                time  value</span><br><span class="line"><span class="number">0</span>   a <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">1</span>   b <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>   c <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>   a <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:01:<span class="number">00</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">4</span>   b <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:01:<span class="number">00</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">5</span>   c <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:01:<span class="number">00</span>    <span class="number">5.0</span></span><br><span class="line"><span class="number">6</span>   a <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:02:<span class="number">00</span>    <span class="number">6.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要对每个key值进行相同的重采样，我们引入pandas.TimeGrouper对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">96</span>]: time_key = pd.TimeGrouper(<span class="string">&#x27;5min&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们然后设定时间索引，用key和time_key分组，然后聚合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">97</span>]: resampled = (df2.set_index(<span class="string">&#x27;time&#x27;</span>)</span><br><span class="line">   ....:              .groupby([<span class="string">&#x27;key&#x27;</span>, time_key])</span><br><span class="line">   ....:              .<span class="built_in">sum</span>())</span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: resampled</span><br><span class="line">Out[<span class="number">98</span>]: </span><br><span class="line">                         value</span><br><span class="line">key time                      </span><br><span class="line">a   <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">30.0</span></span><br><span class="line">    <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>  <span class="number">105.0</span></span><br><span class="line">    <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>  <span class="number">180.0</span></span><br><span class="line">b   <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">35.0</span></span><br><span class="line">    <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>  <span class="number">110.0</span></span><br><span class="line">    <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>  <span class="number">185.0</span></span><br><span class="line">c   <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">40.0</span></span><br><span class="line">    <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>  <span class="number">115.0</span></span><br><span class="line">    <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>  <span class="number">190.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: resampled.reset_index()</span><br><span class="line">Out[<span class="number">99</span>]:</span><br><span class="line">key                time  value</span><br><span class="line"><span class="number">0</span>   a <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">30.0</span></span><br><span class="line"><span class="number">1</span>   a <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>  <span class="number">105.0</span></span><br><span class="line"><span class="number">2</span>   a <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>  <span class="number">180.0</span></span><br><span class="line"><span class="number">3</span>   b <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">35.0</span></span><br><span class="line"><span class="number">4</span>   b <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>  <span class="number">110.0</span></span><br><span class="line"><span class="number">5</span>   b <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>  <span class="number">185.0</span></span><br><span class="line"><span class="number">6</span>   c <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">40.0</span></span><br><span class="line"><span class="number">7</span>   c <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>  <span class="number">115.0</span></span><br><span class="line"><span class="number">8</span>   c <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>  <span class="number">190.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用TimeGrouper的限制是时间必须是Series或DataFrame的索引。</p>
<h1 id="链式编程技术">12.3 链式编程技术</h1>
<p>当对数据集进行一系列变换时，你可能发现创建的多个临时变量其实并没有在分析中用到。看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = load_data()</span><br><span class="line">df2 = df[df[<span class="string">&#x27;col2&#x27;</span>] &lt; <span class="number">0</span>]</span><br><span class="line">df2[<span class="string">&#x27;col1_demeaned&#x27;</span>] = df2[<span class="string">&#x27;col1&#x27;</span>] - df2[<span class="string">&#x27;col1&#x27;</span>].mean()</span><br><span class="line">result = df2.groupby(<span class="string">&#x27;key&#x27;</span>).col1_demeaned.std()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然这里没有使用真实的数据，这个例子却指出了一些新方法。首先，DataFrame.assign方法是一个df[k] = v形式的函数式的列分配方法。它不是就地修改对象，而是返回新的修改过的DataFrame。因此，下面的语句是等价的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Usual non-functional way</span></span><br><span class="line">df2 = df.copy()</span><br><span class="line">df2[<span class="string">&#x27;k&#x27;</span>] = v</span><br><span class="line"></span><br><span class="line"><span class="comment"># Functional assign way</span></span><br><span class="line">df2 = df.assign(k=v)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>就地分配可能会比assign快，但是assign可以方便地进行链式编程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = (df2.assign(col1_demeaned=df2.col1 - df2.col2.mean())</span><br><span class="line">          .groupby(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">          .col1_demeaned.std())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我使用外括号，这样便于添加换行符。</p>
<p>使用链式编程时要注意，你可能会需要涉及临时对象。在前面的例子中，我们不能使用load_data的结果，直到它被赋值给临时变量df。为了这么做，assign和许多其它pandas函数可以接收类似函数的参数，即可调用对象（callable）。为了展示可调用对象，看一个前面例子的片段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = load_data()</span><br><span class="line">df2 = df[df[<span class="string">&#x27;col2&#x27;</span>] &lt; <span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它可以重写为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = (load_data()</span><br><span class="line">      [<span class="keyword">lambda</span> x: x[<span class="string">&#x27;col2&#x27;</span>] &lt; <span class="number">0</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，load_data的结果没有赋值给某个变量，因此传递到[ ]的函数在这一步被绑定到了对象。</p>
<p>我们可以把整个过程写为一个单链表达式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = (load_data()</span><br><span class="line">          [<span class="keyword">lambda</span> x: x.col2 &lt; <span class="number">0</span>]</span><br><span class="line">          .assign(col1_demeaned=<span class="keyword">lambda</span> x: x.col1 - x.col1.mean())</span><br><span class="line">          .groupby(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">          .col1_demeaned.std())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>是否将代码写成这种形式只是习惯而已，将它分开成若干步可以提高可读性。</p>
<h2 id="管道方法">管道方法</h2>
<p>你可以用Python内置的pandas函数和方法，用带有可调用对象的链式编程做许多工作。但是，有时你需要使用自己的函数，或是第三方库的函数。这时就要用到管道方法。</p>
<p>看下面的函数调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = f(df, arg1=v1)</span><br><span class="line">b = g(a, v2, arg3=v3)</span><br><span class="line">c = h(b, arg4=v4)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当使用接收、返回Series或DataFrame对象的函数式，你可以调用pipe将其重写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = (df.pipe(f, arg1=v1)</span><br><span class="line">          .pipe(g, v2, arg3=v3)</span><br><span class="line">          .pipe(h, arg4=v4))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>f(df)和df.pipe(f)是等价的，但是pipe使得链式声明更容易。</p>
<p>pipe的另一个有用的地方是提炼操作为可复用的函数。看一个从列减去分组方法的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])</span><br><span class="line">df[<span class="string">&#x27;col1&#x27;</span>] = df[<span class="string">&#x27;col1&#x27;</span>] - g.transform(<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设你想转换多列，并修改分组的键。另外，你想用链式编程做这个转换。下面就是一个方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">group_demean</span>(<span class="params">df, by, cols</span>):</span></span><br><span class="line">    result = df.copy()</span><br><span class="line">    g = df.groupby(by)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> cols:</span><br><span class="line">        result[c] = df[c] - g[c].transform(<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后可以写为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = (df[df.col1 &lt; <span class="number">0</span>]</span><br><span class="line">          .pipe(group_demean, [<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>], [<span class="string">&#x27;col1&#x27;</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="总结">12.4 总结</h1>
<p>和其它许多开源项目一样，pandas仍然在不断的变化和进步中。和本书中其它地方一样，这里的重点是放在接下来几年不会发生什么改变且稳定的功能。</p>
<p>为了深入学习pandas的知识，我建议你学习官方文档，并阅读开发团队发布的文档更新。我们还邀请你加入pandas的开发工作：修改bug、创建新功能、完善文档。</p>
]]></content>
      <categories>
        <category>Python 数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>第13章 Python建模库介绍</title>
    <url>/2019/04/09/%E7%AC%AC13%E7%AB%A0-Python%E5%BB%BA%E6%A8%A1%E5%BA%93%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>本书中，我已经介绍了Python数据分析的编程基础。因为数据分析师和科学家总是在数据规整和准备上花费大量时间，这本书的重点在于掌握这些功能。<span id="more"></span></p>
<p>开发模型选用什么库取决于应用本身。许多统计问题可以用简单方法解决，比如普通的最小二乘回归，其它问题可能需要复杂的机器学习方法。幸运的是，Python已经成为了运用这些分析方法的语言之一，因此读完此书，你可以探索许多工具。</p>
<p>本章中，我会回顾一些pandas的特点，在你胶着于pandas数据规整和模型拟合和评分时，它们可能派上用场。然后我会简短介绍两个流行的建模工具，statsmodels和scikit-learn。这二者每个都值得再写一本书，我就不做全面的介绍，而是建议你学习两个项目的线上文档和其它基于Python的数据科学、统计和机器学习的书籍。</p>
<h1 id="pandas与模型代码的接口">13.1 pandas与模型代码的接口</h1>
<p>模型开发的通常工作流是使用pandas进行数据加载和清洗，然后切换到建模库进行建模。开发模型的重要一环是机器学习中的“特征工程”。它可以描述从原始数据集中提取信息的任何数据转换或分析，这些数据集可能在建模中有用。本书中学习的数据聚合和GroupBy工具常用于特征工程中。</p>
<p>优秀的特征工程超出了本书的范围，我会尽量直白地介绍一些用于数据操作和建模切换的方法。</p>
<p>pandas与其它分析库通常是靠NumPy的数组联系起来的。将DataFrame转换为NumPy数组，可以使用.values属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: data = pd.DataFrame(&#123;</span><br><span class="line">   ....:     <span class="string">&#x27;x0&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">   ....:     <span class="string">&#x27;x1&#x27;</span>: [<span class="number">0.01</span>, -<span class="number">0.01</span>, <span class="number">0.25</span>, -<span class="number">4.1</span>, <span class="number">0.</span>],</span><br><span class="line">   ....:     <span class="string">&#x27;y&#x27;</span>: [-<span class="number">1.5</span>, <span class="number">0.</span>, <span class="number">3.6</span>, <span class="number">1.3</span>, -<span class="number">2.</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: data</span><br><span class="line">Out[<span class="number">13</span>]: </span><br><span class="line">   x0    x1    y</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>  <span class="number">0.01</span> -<span class="number">1.5</span></span><br><span class="line"><span class="number">1</span>   <span class="number">2</span> -<span class="number">0.01</span>  <span class="number">0.0</span></span><br><span class="line"><span class="number">2</span>   <span class="number">3</span>  <span class="number">0.25</span>  <span class="number">3.6</span></span><br><span class="line"><span class="number">3</span>   <span class="number">4</span> -<span class="number">4.10</span>  <span class="number">1.3</span></span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>  <span class="number">0.00</span> -<span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: data.columns</span><br><span class="line">Out[<span class="number">14</span>]: Index([<span class="string">&#x27;x0&#x27;</span>, <span class="string">&#x27;x1&#x27;</span>, <span class="string">&#x27;y&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: data.values</span><br><span class="line">Out[<span class="number">15</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>  ,  <span class="number">0.01</span>, -<span class="number">1.5</span> ],</span><br><span class="line">       [ <span class="number">2.</span>  , -<span class="number">0.01</span>,  <span class="number">0.</span>  ],</span><br><span class="line">       [ <span class="number">3.</span>  ,  <span class="number">0.25</span>,  <span class="number">3.6</span> ],</span><br><span class="line">       [ <span class="number">4.</span>  , -<span class="number">4.1</span> ,  <span class="number">1.3</span> ],</span><br><span class="line">       [ <span class="number">5.</span>  ,  <span class="number">0.</span>  , -<span class="number">2.</span>  ]])</span><br></pre></td></tr></table></figure>
<p>要转换回DataFrame，可以传递一个二维ndarray，可带有列名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">16</span>]: df2 = pd.DataFrame(data.values, columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: df2</span><br><span class="line">Out[<span class="number">17</span>]: </span><br><span class="line">   one   two  three</span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">0.01</span>   -<span class="number">1.5</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2.0</span> -<span class="number">0.01</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3.0</span>  <span class="number">0.25</span>    <span class="number">3.6</span></span><br><span class="line"><span class="number">3</span>  <span class="number">4.0</span> -<span class="number">4.10</span>    <span class="number">1.3</span></span><br><span class="line"><span class="number">4</span>  <span class="number">5.0</span>  <span class="number">0.00</span>   -<span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：最好当数据是均匀的时候使用.values属性。例如，全是数值类型。如果数据是不均匀的，结果会是Python对象的ndarray：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: df3 = data.copy()</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: df3[<span class="string">&#x27;strings&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: df3</span><br><span class="line">Out[<span class="number">20</span>]: </span><br><span class="line">x0    x1    y strings</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>  <span class="number">0.01</span> -<span class="number">1.5</span>       a</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span> -<span class="number">0.01</span>  <span class="number">0.0</span>       b</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span>  <span class="number">0.25</span>  <span class="number">3.6</span>       c</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span> -<span class="number">4.10</span>  <span class="number">1.3</span>       d</span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>  <span class="number">0.00</span> -<span class="number">2.0</span>       e</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: df3.values</span><br><span class="line">Out[<span class="number">21</span>]: </span><br><span class="line">array([[<span class="number">1</span>, <span class="number">0.01</span>, -<span class="number">1.5</span>, <span class="string">&#x27;a&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, -<span class="number">0.01</span>, <span class="number">0.0</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">0.25</span>, <span class="number">3.6</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">  [<span class="number">4</span>, -<span class="number">4.1</span>, <span class="number">1.3</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">0.0</span>, -<span class="number">2.0</span>, <span class="string">&#x27;e&#x27;</span>]], dtype=<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>对于一些模型，你可能只想使用列的子集。我建议你使用loc，用values作索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">22</span>]: model_cols = [<span class="string">&#x27;x0&#x27;</span>, <span class="string">&#x27;x1&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: data.loc[:, model_cols].values</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>  ,  <span class="number">0.01</span>],</span><br><span class="line">       [ <span class="number">2.</span>  , -<span class="number">0.01</span>],</span><br><span class="line">       [ <span class="number">3.</span>  ,  <span class="number">0.25</span>],</span><br><span class="line">       [ <span class="number">4.</span>  , -<span class="number">4.1</span> ],</span><br><span class="line">       [ <span class="number">5.</span>  ,  <span class="number">0.</span>  ]])</span><br></pre></td></tr></table></figure>
<p>一些库原生支持pandas，会自动完成工作：从DataFrame转换到NumPy，将模型的参数名添加到输出表的列或Series。其它情况，你可以手工进行“元数据管理”。</p>
<p>在第12章，我们学习了pandas的Categorical类型和pandas.get_dummies函数。假设数据集中有一个非数值列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: data[<span class="string">&#x27;category&#x27;</span>] = pd.Categorical([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">   ....:                                   categories=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: data</span><br><span class="line">Out[<span class="number">25</span>]: </span><br><span class="line">   x0    x1    y category</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>  <span class="number">0.01</span> -<span class="number">1.5</span>        a</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span> -<span class="number">0.01</span>  <span class="number">0.0</span>        b</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span>  <span class="number">0.25</span>  <span class="number">3.6</span>        a</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span> -<span class="number">4.10</span>  <span class="number">1.3</span>        a</span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>  <span class="number">0.00</span> -<span class="number">2.0</span>        b</span><br></pre></td></tr></table></figure>
<p>如果我们想替换category列为虚变量，我们可以创建虚变量，删除category列，然后添加到结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">26</span>]: dummies = pd.get_dummies(data.category, prefix=<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: data_with_dummies = data.drop(<span class="string">&#x27;category&#x27;</span>, axis=<span class="number">1</span>).join(dummies)</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: data_with_dummies</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">   x0    x1    y  category_a  category_b</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>  <span class="number">0.01</span> -<span class="number">1.5</span>           <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">2</span> -<span class="number">0.01</span>  <span class="number">0.0</span>           <span class="number">0</span>           <span class="number">1</span></span><br><span class="line"><span class="number">2</span>   <span class="number">3</span>  <span class="number">0.25</span>  <span class="number">3.6</span>           <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"><span class="number">3</span>   <span class="number">4</span> -<span class="number">4.10</span>  <span class="number">1.3</span>           <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>  <span class="number">0.00</span> -<span class="number">2.0</span>           <span class="number">0</span>           <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>用虚变量拟合某些统计模型会有一些细微差别。当你不只有数字列时，使用Patsy（下一节的主题）可能更简单，更不容易出错。</p>
<h1 id="用patsy创建模型描述">13.2 用Patsy创建模型描述</h1>
<p>Patsy是Python的一个库，使用简短的字符串“公式语法”描述统计模型（尤其是线性模型），可能是受到了R和S统计编程语言的公式语法的启发。</p>
<p>Patsy适合描述statsmodels的线性模型，因此我会关注于它的主要特点，让你尽快掌握。Patsy的公式是一个特殊的字符串语法，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y ~ x0 + x1</span><br></pre></td></tr></table></figure>
<p>a+b不是将a与b相加的意思，而是为模型创建的设计矩阵。patsy.dmatrices函数接收一个公式字符串和一个数据集（可以是DataFrame或数组的字典），为线性模型创建设计矩阵：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">29</span>]: data = pd.DataFrame(&#123;</span><br><span class="line">   ....:     <span class="string">&#x27;x0&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">   ....:     <span class="string">&#x27;x1&#x27;</span>: [<span class="number">0.01</span>, -<span class="number">0.01</span>, <span class="number">0.25</span>, -<span class="number">4.1</span>, <span class="number">0.</span>],</span><br><span class="line">   ....:     <span class="string">&#x27;y&#x27;</span>: [-<span class="number">1.5</span>, <span class="number">0.</span>, <span class="number">3.6</span>, <span class="number">1.3</span>, -<span class="number">2.</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: data</span><br><span class="line">Out[<span class="number">30</span>]: </span><br><span class="line">   x0    x1    y</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>  <span class="number">0.01</span> -<span class="number">1.5</span></span><br><span class="line"><span class="number">1</span>   <span class="number">2</span> -<span class="number">0.01</span>  <span class="number">0.0</span></span><br><span class="line"><span class="number">2</span>   <span class="number">3</span>  <span class="number">0.25</span>  <span class="number">3.6</span></span><br><span class="line"><span class="number">3</span>   <span class="number">4</span> -<span class="number">4.10</span>  <span class="number">1.3</span></span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>  <span class="number">0.00</span> -<span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: <span class="keyword">import</span> patsy</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: y, X = patsy.dmatrices(<span class="string">&#x27;y ~ x0 + x1&#x27;</span>, data)</span><br></pre></td></tr></table></figure>
<p>现在有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">33</span>]: y</span><br><span class="line">Out[<span class="number">33</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">     y</span><br><span class="line">  -<span class="number">1.5</span></span><br><span class="line">   <span class="number">0.0</span></span><br><span class="line">   <span class="number">3.6</span></span><br><span class="line">   <span class="number">1.3</span></span><br><span class="line">  -<span class="number">2.0</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;y&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: X</span><br><span class="line">Out[<span class="number">34</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">  Intercept  x0     x1</span><br><span class="line">          <span class="number">1</span>   <span class="number">1</span>   <span class="number">0.01</span></span><br><span class="line">          <span class="number">1</span>   <span class="number">2</span>  -<span class="number">0.01</span></span><br><span class="line">          <span class="number">1</span>   <span class="number">3</span>   <span class="number">0.25</span></span><br><span class="line">          <span class="number">1</span>   <span class="number">4</span>  -<span class="number">4.10</span></span><br><span class="line">          <span class="number">1</span>   <span class="number">5</span>   <span class="number">0.00</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;Intercept&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line">    <span class="string">&#x27;x0&#x27;</span> (column <span class="number">1</span>)</span><br><span class="line">    <span class="string">&#x27;x1&#x27;</span> (column <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>这些Patsy的DesignMatrix实例是NumPy的ndarray，带有附加元数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">35</span>]: np.asarray(y)</span><br><span class="line">Out[<span class="number">35</span>]: </span><br><span class="line">array([[-<span class="number">1.5</span>],</span><br><span class="line">       [ <span class="number">0.</span> ],</span><br><span class="line">       [ <span class="number">3.6</span>],</span><br><span class="line">       [ <span class="number">1.3</span>],</span><br><span class="line">       [-<span class="number">2.</span> ]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: np.asarray(X)</span><br><span class="line">Out[<span class="number">36</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>  ,  <span class="number">1.</span>  ,  <span class="number">0.01</span>],</span><br><span class="line">       [ <span class="number">1.</span>  ,  <span class="number">2.</span>  , -<span class="number">0.01</span>],</span><br><span class="line">       [ <span class="number">1.</span>  ,  <span class="number">3.</span>  ,  <span class="number">0.25</span>],</span><br><span class="line">       [ <span class="number">1.</span>  ,  <span class="number">4.</span>  , -<span class="number">4.1</span> ],</span><br><span class="line">       [ <span class="number">1.</span>  ,  <span class="number">5.</span>  ,  <span class="number">0.</span>  ]])</span><br></pre></td></tr></table></figure>
<p>你可能想Intercept是哪里来的。这是线性模型（比如普通最小二乘回归）的惯例用法。添加 +0 到模型可以不显示intercept：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">37</span>]: patsy.dmatrices(<span class="string">&#x27;y ~ x0 + x1 + 0&#x27;</span>, data)[<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">  x0     x1</span><br><span class="line">   <span class="number">1</span>   <span class="number">0.01</span></span><br><span class="line">   <span class="number">2</span>  -<span class="number">0.01</span></span><br><span class="line">   <span class="number">3</span>   <span class="number">0.25</span></span><br><span class="line">   <span class="number">4</span>  -<span class="number">4.10</span></span><br><span class="line">   <span class="number">5</span>   <span class="number">0.00</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;x0&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line">    <span class="string">&#x27;x1&#x27;</span> (column <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>Patsy对象可以直接传递到算法（比如numpy.linalg.lstsq）中，它执行普通最小二乘回归：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">38</span>]: coef, resid, _, _ = np.linalg.lstsq(X, y)</span><br></pre></td></tr></table></figure>
<p>模型的元数据保留在design_info属性中，因此你可以重新附加列名到拟合系数，以获得一个Series，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">39</span>]: coef</span><br><span class="line">Out[<span class="number">39</span>]: </span><br><span class="line">array([[ <span class="number">0.3129</span>],</span><br><span class="line">       [-<span class="number">0.0791</span>],</span><br><span class="line">       [-<span class="number">0.2655</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: coef = pd.Series(coef.squeeze(), index=X.design_info.column_names)</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: coef</span><br><span class="line">Out[<span class="number">41</span>]: </span><br><span class="line">Intercept    <span class="number">0.312910</span></span><br><span class="line">x0          -<span class="number">0.079106</span></span><br><span class="line">x1          -<span class="number">0.265464</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h2 id="用patsy公式进行数据转换">用Patsy公式进行数据转换</h2>
<p>你可以将Python代码与patsy公式结合。在评估公式时，库将尝试查找在封闭作用域内使用的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">42</span>]: y, X = patsy.dmatrices(<span class="string">&#x27;y ~ x0 + np.log(np.abs(x1) + 1)&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: X</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">  Intercept  x0  np.log(np.<span class="built_in">abs</span>(x1) + <span class="number">1</span>)</span><br><span class="line">          <span class="number">1</span>   <span class="number">1</span>                 <span class="number">0.00995</span></span><br><span class="line">          <span class="number">1</span>   <span class="number">2</span>                 <span class="number">0.00995</span></span><br><span class="line">          <span class="number">1</span>   <span class="number">3</span>                 <span class="number">0.22314</span></span><br><span class="line">          <span class="number">1</span>   <span class="number">4</span>                 <span class="number">1.62924</span></span><br><span class="line">          <span class="number">1</span>   <span class="number">5</span>                 <span class="number">0.00000</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;Intercept&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line">    <span class="string">&#x27;x0&#x27;</span> (column <span class="number">1</span>)</span><br><span class="line">    <span class="string">&#x27;np.log(np.abs(x1) + 1)&#x27;</span> (column <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>常见的变量转换包括标准化（平均值为0，方差为1）和中心化（减去平均值）。Patsy有内置的函数进行这样的工作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">44</span>]: y, X = patsy.dmatrices(<span class="string">&#x27;y ~ standardize(x0) + center(x1)&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: X</span><br><span class="line">Out[<span class="number">45</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">  Intercept  standardize(x0)  center(x1)</span><br><span class="line">          <span class="number">1</span>         -<span class="number">1.41421</span>        <span class="number">0.78</span></span><br><span class="line">          <span class="number">1</span>         -<span class="number">0.70711</span>        <span class="number">0.76</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0.00000</span>        <span class="number">1.02</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0.70711</span>       -<span class="number">3.33</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1.41421</span>        <span class="number">0.77</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;Intercept&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line">    <span class="string">&#x27;standardize(x0)&#x27;</span> (column <span class="number">1</span>)</span><br><span class="line">    <span class="string">&#x27;center(x1)&#x27;</span> (column <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>作为建模的一步，你可能拟合模型到一个数据集，然后用另一个数据集评估模型。另一个数据集可能是剩余的部分或是新数据。当执行中心化和标准化转变，用新数据进行预测要格外小心。因为你必须使用平均值或标准差转换新数据集，这也称作状态转换。</p>
<p>patsy.build_design_matrices函数可以使用原始样本数据集的保存信息，来转换新数据，：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">46</span>]: new_data = pd.DataFrame(&#123;</span><br><span class="line">   ....:     <span class="string">&#x27;x0&#x27;</span>: [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">   ....:     <span class="string">&#x27;x1&#x27;</span>: [<span class="number">3.1</span>, -<span class="number">0.5</span>, <span class="number">0</span>, <span class="number">2.3</span>],</span><br><span class="line">   ....:     <span class="string">&#x27;y&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: new_X = patsy.build_design_matrices([X.design_info], new_data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: new_X</span><br><span class="line">Out[<span class="number">48</span>]: </span><br><span class="line">[DesignMatrix <span class="keyword">with</span> shape (<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">   Intercept  standardize(x0)  center(x1)</span><br><span class="line">           <span class="number">1</span>          <span class="number">2.12132</span>        <span class="number">3.87</span></span><br><span class="line">           <span class="number">1</span>          <span class="number">2.82843</span>        <span class="number">0.27</span></span><br><span class="line">           <span class="number">1</span>          <span class="number">3.53553</span>        <span class="number">0.77</span></span><br><span class="line">           <span class="number">1</span>          <span class="number">4.24264</span>        <span class="number">3.07</span></span><br><span class="line">   Terms:</span><br><span class="line">     <span class="string">&#x27;Intercept&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line">     <span class="string">&#x27;standardize(x0)&#x27;</span> (column <span class="number">1</span>)</span><br><span class="line">     <span class="string">&#x27;center(x1)&#x27;</span> (column <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>
<p>因为Patsy中的加号不是加法的意义，当你按照名称将数据集的列相加时，你必须用特殊I函数将它们封装起来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">49</span>]: y, X = patsy.dmatrices(<span class="string">&#x27;y ~ I(x0 + x1)&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: X</span><br><span class="line">Out[<span class="number">50</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">  Intercept  I(x0 + x1)</span><br><span class="line">          <span class="number">1</span>        <span class="number">1.01</span></span><br><span class="line">          <span class="number">1</span>        <span class="number">1.99</span></span><br><span class="line">          <span class="number">1</span>        <span class="number">3.25</span></span><br><span class="line">          <span class="number">1</span>       -<span class="number">0.10</span></span><br><span class="line">          <span class="number">1</span>        <span class="number">5.00</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;Intercept&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line">    <span class="string">&#x27;I(x0 + x1)&#x27;</span> (column <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Patsy的patsy.builtins模块还有一些其它的内置转换。请查看线上文档。</p>
<p>分类数据有一个特殊的转换类，下面进行讲解。</p>
<h2 id="分类数据和patsy">分类数据和Patsy</h2>
<p>非数值数据可以用多种方式转换为模型设计矩阵。完整的讲解超出了本书范围，最好和统计课一起学习。</p>
<p>当你在Patsy公式中使用非数值数据，它们会默认转换为虚变量。如果有截距，会去掉一个，避免共线性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">51</span>]: data = pd.DataFrame(&#123;</span><br><span class="line">   ....:     <span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">   ....:     <span class="string">&#x27;key2&#x27;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">   ....:     <span class="string">&#x27;v1&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">   ....:     <span class="string">&#x27;v2&#x27;</span>: [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">2.5</span>, -<span class="number">0.5</span>, <span class="number">4.0</span>, -<span class="number">1.2</span>, <span class="number">0.2</span>, -<span class="number">1.7</span>]</span><br><span class="line">   ....: &#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: y, X = patsy.dmatrices(<span class="string">&#x27;v2 ~ key1&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: X</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">  Intercept  key1[T.b]</span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;Intercept&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line">    <span class="string">&#x27;key1&#x27;</span> (column <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你从模型中忽略截距，每个分类值的列都会包括在设计矩阵的模型中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">54</span>]: y, X = patsy.dmatrices(<span class="string">&#x27;v2 ~ key1 + 0&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: X</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">  key1[a]  key1[b]</span><br><span class="line">        <span class="number">1</span>        <span class="number">0</span></span><br><span class="line">        <span class="number">1</span>        <span class="number">0</span></span><br><span class="line">        <span class="number">0</span>        <span class="number">1</span></span><br><span class="line">        <span class="number">0</span>        <span class="number">1</span></span><br><span class="line">        <span class="number">1</span>        <span class="number">0</span></span><br><span class="line">        <span class="number">0</span>        <span class="number">1</span></span><br><span class="line">        <span class="number">1</span>        <span class="number">0</span></span><br><span class="line">        <span class="number">0</span>        <span class="number">1</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;key1&#x27;</span> (columns <span class="number">0</span>:<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用C函数，数值列可以截取为分类量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: y, X = patsy.dmatrices(<span class="string">&#x27;v2 ~ C(key2)&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: X</span><br><span class="line">Out[<span class="number">57</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">  Intercept  C(key2)[T<span class="number">.1</span>]</span><br><span class="line">          <span class="number">1</span>             <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>             <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>             <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>             <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>             <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>             <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>             <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>             <span class="number">0</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;Intercept&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line">    <span class="string">&#x27;C(key2)&#x27;</span> (column <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当你在模型中使用多个分类名，事情就会变复杂，因为会包括key1:key2形式的相交部分，它可以用在方差（ANOVA）模型分析中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">58</span>]: data[<span class="string">&#x27;key2&#x27;</span>] = data[<span class="string">&#x27;key2&#x27;</span>].<span class="built_in">map</span>(&#123;<span class="number">0</span>: <span class="string">&#x27;zero&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;one&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: data</span><br><span class="line">Out[<span class="number">59</span>]: </span><br><span class="line">  key1  key2  v1   v2</span><br><span class="line"><span class="number">0</span>    a  zero   <span class="number">1</span> -<span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    a   one   <span class="number">2</span>  <span class="number">0.0</span></span><br><span class="line"><span class="number">2</span>    b  zero   <span class="number">3</span>  <span class="number">2.5</span></span><br><span class="line"><span class="number">3</span>    b   one   <span class="number">4</span> -<span class="number">0.5</span></span><br><span class="line"><span class="number">4</span>    a  zero   <span class="number">5</span>  <span class="number">4.0</span></span><br><span class="line"><span class="number">5</span>    b   one   <span class="number">6</span> -<span class="number">1.2</span></span><br><span class="line"><span class="number">6</span>    a  zero   <span class="number">7</span>  <span class="number">0.2</span></span><br><span class="line"><span class="number">7</span>    b  zero   <span class="number">8</span> -<span class="number">1.7</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: y, X = patsy.dmatrices(<span class="string">&#x27;v2 ~ key1 + key2&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: X</span><br><span class="line">Out[<span class="number">61</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">8</span>, <span class="number">3</span>)</span><br><span class="line">  Intercept  key1[T.b]  key2[T.zero]</span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span>             <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span>             <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span>             <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span>             <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span>             <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span>             <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span>             <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span>             <span class="number">1</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;Intercept&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line">    <span class="string">&#x27;key1&#x27;</span> (column <span class="number">1</span>)</span><br><span class="line">    <span class="string">&#x27;key2&#x27;</span> (column <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: y, X = patsy.dmatrices(<span class="string">&#x27;v2 ~ key1 + key2 + key1:key2&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: X</span><br><span class="line">Out[<span class="number">63</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">8</span>, <span class="number">4</span>)</span><br><span class="line">  Intercept  key1[T.b]  key2[T.zero]</span><br><span class="line">key1[T.b]:key2[T.zero]</span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span>             <span class="number">1</span>                       <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span>             <span class="number">0</span>                       <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span>             <span class="number">1</span>                       <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span>             <span class="number">0</span>                       <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span>             <span class="number">1</span>                       <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span>             <span class="number">0</span>                       <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span>             <span class="number">1</span>                       <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span>             <span class="number">1</span>                       <span class="number">1</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;Intercept&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line">    <span class="string">&#x27;key1&#x27;</span> (column <span class="number">1</span>)</span><br><span class="line">    <span class="string">&#x27;key2&#x27;</span> (column <span class="number">2</span>)</span><br><span class="line">    <span class="string">&#x27;key1:key2&#x27;</span> (column <span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Patsy提供转换分类数据的其它方法，包括以特定顺序转换。请参阅线上文档。</p>
<h1 id="statsmodels介绍">13.3 statsmodels介绍</h1>
<p>statsmodels是Python进行拟合多种统计模型、进行统计试验和数据探索可视化的库。Statsmodels包含许多经典的统计方法，但没有贝叶斯方法和机器学习模型。</p>
<p>statsmodels包含的模型有：</p>
<ul>
<li>线性模型，广义线性模型和健壮线性模型</li>
<li>线性混合效应模型</li>
<li>方差（ANOVA）方法分析</li>
<li>时间序列过程和状态空间模型</li>
<li>广义矩估计</li>
</ul>
<p>下面，我会使用一些基本的statsmodels工具，探索Patsy公式和pandasDataFrame对象如何使用模型接口。</p>
<h2 id="估计线性模型">估计线性模型</h2>
<p>statsmodels有多种线性回归模型，包括从基本（比如普通最小二乘）到复杂（比如迭代加权最小二乘法）的。</p>
<p>statsmodels的线性模型有两种不同的接口：基于数组和基于公式。它们可以通过API模块引入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">import</span> statsmodels.formula.api <span class="keyword">as</span> smf</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了展示它们的使用方法，我们从一些随机数据生成一个线性模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dnorm</span>(<span class="params">mean, variance, size=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(size, <span class="built_in">int</span>):</span><br><span class="line">        size = size,</span><br><span class="line">    <span class="keyword">return</span> mean + np.sqrt(variance) * np.random.randn(*size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># For reproducibility</span></span><br><span class="line">np.random.seed(<span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line">N = <span class="number">100</span></span><br><span class="line">X = np.c_[dnorm(<span class="number">0</span>, <span class="number">0.4</span>, size=N),</span><br><span class="line">          dnorm(<span class="number">0</span>, <span class="number">0.6</span>, size=N),</span><br><span class="line">          dnorm(<span class="number">0</span>, <span class="number">0.2</span>, size=N)]</span><br><span class="line">eps = dnorm(<span class="number">0</span>, <span class="number">0.1</span>, size=N)</span><br><span class="line">beta = [<span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.5</span>]</span><br><span class="line"></span><br><span class="line">y = np.dot(X, beta) + eps</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，我使用了“真实”模型和可知参数beta。此时，dnorm可用来生成正态分布数据，带有特定均值和方差。现在有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">66</span>]: X[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">66</span>]: </span><br><span class="line">array([[-<span class="number">0.1295</span>, -<span class="number">1.2128</span>,  <span class="number">0.5042</span>],</span><br><span class="line">       [ <span class="number">0.3029</span>, -<span class="number">0.4357</span>, -<span class="number">0.2542</span>],</span><br><span class="line">       [-<span class="number">0.3285</span>, -<span class="number">0.0253</span>,  <span class="number">0.1384</span>],</span><br><span class="line">       [-<span class="number">0.3515</span>, -<span class="number">0.7196</span>, -<span class="number">0.2582</span>],</span><br><span class="line">       [ <span class="number">1.2433</span>, -<span class="number">0.3738</span>, -<span class="number">0.5226</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: y[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">67</span>]: array([ <span class="number">0.4279</span>, -<span class="number">0.6735</span>, -<span class="number">0.0909</span>, -<span class="number">0.4895</span>,-<span class="number">0.1289</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>像之前Patsy看到的，线性模型通常要拟合一个截距。sm.add_constant函数可以添加一个截距的列到现存的矩阵：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">68</span>]: X_model = sm.add_constant(X)</span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: X_model[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">69</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>    , -<span class="number">0.1295</span>, -<span class="number">1.2128</span>,  <span class="number">0.5042</span>],</span><br><span class="line">       [ <span class="number">1.</span>    ,  <span class="number">0.3029</span>, -<span class="number">0.4357</span>, -<span class="number">0.2542</span>],</span><br><span class="line">       [ <span class="number">1.</span>    , -<span class="number">0.3285</span>, -<span class="number">0.0253</span>,  <span class="number">0.1384</span>],</span><br><span class="line">       [ <span class="number">1.</span>    , -<span class="number">0.3515</span>, -<span class="number">0.7196</span>, -<span class="number">0.2582</span>],</span><br><span class="line">       [ <span class="number">1.</span>    ,  <span class="number">1.2433</span>, -<span class="number">0.3738</span>, -<span class="number">0.5226</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>sm.OLS类可以拟合一个普通最小二乘回归：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">70</span>]: model = sm.OLS(y, X)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个模型的fit方法返回了一个回归结果对象，它包含估计的模型参数和其它内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">71</span>]: results = model.fit()</span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: results.params</span><br><span class="line">Out[<span class="number">72</span>]: array([ <span class="number">0.1783</span>,  <span class="number">0.223</span> ,  <span class="number">0.501</span> ])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对结果使用summary方法可以打印模型的详细诊断结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">73</span>]: <span class="built_in">print</span>(results.summary())</span><br><span class="line">OLS Regression Results                            </span><br><span class="line">==============================================================================</span><br><span class="line">Dep. Variable:                      y   R-squared:                       <span class="number">0.430</span></span><br><span class="line">Model:                            OLS   Adj. R-squared:                  <span class="number">0.413</span></span><br><span class="line">Method:                 Least Squares   F-statistic:                     <span class="number">24.42</span></span><br><span class="line">Date:                Mon, <span class="number">25</span> Sep <span class="number">2017</span>   Prob (F-statistic):           <span class="number">7.44e-12</span></span><br><span class="line">Time:                        <span class="number">14</span>:06:<span class="number">15</span>   Log-Likelihood:                -<span class="number">34.305</span></span><br><span class="line">No. Observations:                 <span class="number">100</span>   AIC:                             <span class="number">74.61</span></span><br><span class="line">Df Residuals:                      <span class="number">97</span>   BIC:                             <span class="number">82.42</span></span><br><span class="line">Df Model:                           <span class="number">3</span>                                         </span><br><span class="line">Covariance <span class="type">Type</span>:            nonrobust                                         </span><br><span class="line">==============================================================================</span><br><span class="line">                 coef    std err          t      P&gt;|t|      [<span class="number">0.025</span>      <span class="number">0.975</span>]</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">x1             <span class="number">0.1783</span>      <span class="number">0.053</span>      <span class="number">3.364</span>      <span class="number">0.001</span>       <span class="number">0.073</span>       <span class="number">0.283</span></span><br><span class="line">x2             <span class="number">0.2230</span>      <span class="number">0.046</span>      <span class="number">4.818</span>      <span class="number">0.000</span>       <span class="number">0.131</span>       <span class="number">0.315</span></span><br><span class="line">x3             <span class="number">0.5010</span>      <span class="number">0.080</span>      <span class="number">6.237</span>      <span class="number">0.000</span>       <span class="number">0.342</span>       <span class="number">0.660</span></span><br><span class="line">==============================================================================</span><br><span class="line">Omnibus:                        <span class="number">4.662</span>   Durbin-Watson:                   <span class="number">2.201</span></span><br><span class="line">Prob(Omnibus):                  <span class="number">0.097</span>   Jarque-Bera (JB):                <span class="number">4.098</span></span><br><span class="line">Skew:                           <span class="number">0.481</span>   Prob(JB):                        <span class="number">0.129</span></span><br><span class="line">Kurtosis:                       <span class="number">3.243</span>   Cond. No.</span><br><span class="line"><span class="number">1.74</span></span><br><span class="line">==============================================================================</span><br><span class="line">Warnings:</span><br><span class="line">[<span class="number">1</span>] Standard Errors assume that the covariance matrix of the errors <span class="keyword">is</span> correctly </span><br><span class="line">specified.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的参数名为通用名x1, x2等等。假设所有的模型参数都在一个DataFrame中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: data = pd.DataFrame(X, columns=[<span class="string">&#x27;col0&#x27;</span>, <span class="string">&#x27;col1&#x27;</span>, <span class="string">&#x27;col2&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: data[<span class="string">&#x27;y&#x27;</span>] = y</span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: data[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">76</span>]: </span><br><span class="line">       col0      col1      col2         y</span><br><span class="line"><span class="number">0</span> -<span class="number">0.129468</span> -<span class="number">1.212753</span>  <span class="number">0.504225</span>  <span class="number">0.427863</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.302910</span> -<span class="number">0.435742</span> -<span class="number">0.254180</span> -<span class="number">0.673480</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.328522</span> -<span class="number">0.025302</span>  <span class="number">0.138351</span> -<span class="number">0.090878</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.351475</span> -<span class="number">0.719605</span> -<span class="number">0.258215</span> -<span class="number">0.489494</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1.243269</span> -<span class="number">0.373799</span> -<span class="number">0.522629</span> -<span class="number">0.128941</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，我们使用statsmodels的公式API和Patsy的公式字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">77</span>]: results = smf.ols(<span class="string">&#x27;y ~ col0 + col1 + col2&#x27;</span>, data=data).fit()</span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: results.params</span><br><span class="line">Out[<span class="number">78</span>]: </span><br><span class="line">Intercept    <span class="number">0.033559</span></span><br><span class="line">col0         <span class="number">0.176149</span></span><br><span class="line">col1         <span class="number">0.224826</span></span><br><span class="line">col2         <span class="number">0.514808</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: results.tvalues</span><br><span class="line">Out[<span class="number">79</span>]: </span><br><span class="line">Intercept    <span class="number">0.952188</span></span><br><span class="line">col0         <span class="number">3.319754</span></span><br><span class="line">col1         <span class="number">4.850730</span></span><br><span class="line">col2         <span class="number">6.303971</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>观察下statsmodels是如何返回Series结果的，附带有DataFrame的列名。当使用公式和pandas对象时，我们不需要使用add_constant。</p>
<p>给出一个样本外数据，你可以根据估计的模型参数计算预测值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">80</span>]: results.predict(data[:<span class="number">5</span>])</span><br><span class="line">Out[<span class="number">80</span>]: </span><br><span class="line"><span class="number">0</span>   -<span class="number">0.002327</span></span><br><span class="line"><span class="number">1</span>   -<span class="number">0.141904</span></span><br><span class="line"><span class="number">2</span>    <span class="number">0.041226</span></span><br><span class="line"><span class="number">3</span>   -<span class="number">0.323070</span></span><br><span class="line"><span class="number">4</span>   -<span class="number">0.100535</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>statsmodels的线性模型结果还有其它的分析、诊断和可视化工具。除了普通最小二乘模型，还有其它的线性模型。</p>
<h2 id="估计时间序列过程">估计时间序列过程</h2>
<p>statsmodels的另一模型类是进行时间序列分析，包括自回归过程、卡尔曼滤波和其它态空间模型，和多元自回归模型。</p>
<p>用自回归结构和噪声来模拟一些时间序列数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init_x = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">values = [init_x, init_x]</span><br><span class="line">N = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">b0 = <span class="number">0.8</span></span><br><span class="line">b1 = -<span class="number">0.4</span></span><br><span class="line">noise = dnorm(<span class="number">0</span>, <span class="number">0.1</span>, N)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    new_x = values[-<span class="number">1</span>] * b0 + values[-<span class="number">2</span>] * b1 + noise[i]</span><br><span class="line">    values.append(new_x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个数据有AR(2)结构（两个延迟），参数是0.8和-0.4。拟合AR模型时，你可能不知道滞后项的个数，因此可以用较多的滞后量来拟合这个模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">82</span>]: MAXLAGS = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: model = sm.tsa.AR(values)</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: results = model.fit(MAXLAGS)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果中的估计参数首先是截距，其次是前两个参数的估计值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">85</span>]: results.params</span><br><span class="line">Out[<span class="number">85</span>]: array([-<span class="number">0.0062</span>,  <span class="number">0.7845</span>, -<span class="number">0.4085</span>, -<span class="number">0.0136</span>,  <span class="number">0.015</span> ,  <span class="number">0.0143</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更多的细节以及如何解释结果超出了本书的范围，可以通过statsmodels文档学习更多。</p>
<h1 id="scikit-learn介绍">13.4 scikit-learn介绍</h1>
<p>scikit-learn是一个广泛使用、用途多样的Python机器学习库。它包含多种标准监督和非监督机器学习方法和模型选择和评估、数据转换、数据加载和模型持久化工具。这些模型可以用于分类、聚合、预测和其它任务。</p>
<p>机器学习方面的学习和应用scikit-learn和TensorFlow解决实际问题的线上和纸质资料很多。本节中，我会简要介绍scikit-learn API的风格。</p>
<p>写作此书的时候，scikit-learn并没有和pandas深度结合，但是有些第三方包在开发中。尽管如此，pandas非常适合在模型拟合前处理数据集。</p>
<p>举个例子，我用一个Kaggle竞赛的经典数据集，关于泰坦尼克号乘客的生还率。我们用pandas加载测试和训练数据集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">86</span>]: train = pd.read_csv(<span class="string">&#x27;datasets/titanic/train.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: test = pd.read_csv(<span class="string">&#x27;datasets/titanic/test.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: train[:<span class="number">4</span>]</span><br><span class="line">Out[<span class="number">88</span>]: </span><br><span class="line">   PassengerId  Survived  Pclass  \</span><br><span class="line"><span class="number">0</span>            <span class="number">1</span>         <span class="number">0</span>       <span class="number">3</span>   </span><br><span class="line"><span class="number">1</span>            <span class="number">2</span>         <span class="number">1</span>       <span class="number">1</span>   </span><br><span class="line"><span class="number">2</span>            <span class="number">3</span>         <span class="number">1</span>       <span class="number">3</span>   </span><br><span class="line"><span class="number">3</span>            <span class="number">4</span>         <span class="number">1</span>       <span class="number">1</span>   </span><br><span class="line">                                                Name     Sex   Age  SibSp  \</span><br><span class="line"><span class="number">0</span>                            Braund, Mr. Owen Harris    male  <span class="number">22.0</span>      <span class="number">1</span>   </span><br><span class="line"><span class="number">1</span>  Cumings, Mrs. John Bradley (Florence Briggs Th...  female  <span class="number">38.0</span>      <span class="number">1</span>   </span><br><span class="line"><span class="number">2</span>                             Heikkinen, Miss. Laina  female  <span class="number">26.0</span>      <span class="number">0</span>   </span><br><span class="line"><span class="number">3</span>       Futrelle, Mrs. Jacques Heath (Lily May Peel)  female  <span class="number">35.0</span>      <span class="number">1</span>   </span><br><span class="line">   Parch            Ticket     Fare Cabin Embarked  </span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>         A/<span class="number">5</span> <span class="number">21171</span>   <span class="number">7.2500</span>   NaN        S  </span><br><span class="line"><span class="number">1</span>      <span class="number">0</span>          PC <span class="number">17599</span>  <span class="number">71.2833</span>   C85        C  </span><br><span class="line"><span class="number">2</span>      <span class="number">0</span>  STON/O2. <span class="number">3101282</span>   <span class="number">7.9250</span>   NaN        S  </span><br><span class="line"><span class="number">3</span>      <span class="number">0</span>            <span class="number">113803</span>  <span class="number">53.1000</span>  C123        S</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>statsmodels和scikit-learn通常不能接收缺失数据，因此我们要查看列是否包含缺失值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">89</span>]: train.isnull().<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">89</span>]: </span><br><span class="line">PassengerId      <span class="number">0</span></span><br><span class="line">Survived         <span class="number">0</span></span><br><span class="line">Pclass           <span class="number">0</span></span><br><span class="line">Name             <span class="number">0</span></span><br><span class="line">Sex              <span class="number">0</span></span><br><span class="line">Age            <span class="number">177</span></span><br><span class="line">SibSp            <span class="number">0</span></span><br><span class="line">Parch            <span class="number">0</span></span><br><span class="line">Ticket           <span class="number">0</span></span><br><span class="line">Fare             <span class="number">0</span></span><br><span class="line">Cabin          <span class="number">687</span></span><br><span class="line">Embarked         <span class="number">2</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: test.isnull().<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">90</span>]: </span><br><span class="line">PassengerId      <span class="number">0</span></span><br><span class="line">Pclass           <span class="number">0</span></span><br><span class="line">Name             <span class="number">0</span></span><br><span class="line">Sex              <span class="number">0</span></span><br><span class="line">Age             <span class="number">86</span></span><br><span class="line">SibSp            <span class="number">0</span></span><br><span class="line">Parch            <span class="number">0</span></span><br><span class="line">Ticket           <span class="number">0</span></span><br><span class="line">Fare             <span class="number">1</span></span><br><span class="line">Cabin          <span class="number">327</span></span><br><span class="line">Embarked         <span class="number">0</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在统计和机器学习的例子中，根据数据中的特征，一个典型的任务是预测乘客能否生还。模型现在训练数据集中拟合，然后用样本外测试数据集评估。</p>
<p>我想用年龄作为预测值，但是它包含缺失值。缺失数据补全的方法有多种，我用的是一种简单方法，用训练数据集的中位数补全两个表的空值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">91</span>]: impute_value = train[<span class="string">&#x27;Age&#x27;</span>].median()</span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: train[<span class="string">&#x27;Age&#x27;</span>] = train[<span class="string">&#x27;Age&#x27;</span>].fillna(impute_value)</span><br><span class="line"></span><br><span class="line">In [<span class="number">93</span>]: test[<span class="string">&#x27;Age&#x27;</span>] = test[<span class="string">&#x27;Age&#x27;</span>].fillna(impute_value)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在我们需要指定模型。我增加了一个列IsFemale，作为“Sex”列的编码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">94</span>]: train[<span class="string">&#x27;IsFemale&#x27;</span>] = (train[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;female&#x27;</span>).astype(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">95</span>]: test[<span class="string">&#x27;IsFemale&#x27;</span>] = (test[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;female&#x27;</span>).astype(<span class="built_in">int</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，我们确定一些模型变量，并创建NumPy数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">96</span>]: predictors = [<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;IsFemale&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: X_train = train[predictors].values</span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: X_test = test[predictors].values</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: y_train = train[<span class="string">&#x27;Survived&#x27;</span>].values</span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: X_train[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">100</span>]: </span><br><span class="line">array([[  <span class="number">3.</span>,   <span class="number">0.</span>,  <span class="number">22.</span>],</span><br><span class="line">       [  <span class="number">1.</span>,   <span class="number">1.</span>,  <span class="number">38.</span>],</span><br><span class="line">       [  <span class="number">3.</span>,   <span class="number">1.</span>,  <span class="number">26.</span>],</span><br><span class="line">       [  <span class="number">1.</span>,   <span class="number">1.</span>,  <span class="number">35.</span>],</span><br><span class="line">       [  <span class="number">3.</span>,   <span class="number">0.</span>,  <span class="number">35.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">101</span>]: y_train[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">101</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我不能保证这是一个好模型，但它的特征都符合。我们用scikit-learn的LogisticRegression模型，创建一个模型实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">102</span>]: <span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: model = LogisticRegression()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与statsmodels类似，我们可以用模型的fit方法，将它拟合到训练数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">104</span>]: model.fit(X_train, y_train)</span><br><span class="line">Out[<span class="number">104</span>]: </span><br><span class="line">LogisticRegression(C=<span class="number">1.0</span>, class_weight=<span class="literal">None</span>, dual=<span class="literal">False</span>, fit_intercept=<span class="literal">True</span>,</span><br><span class="line">          intercept_scaling=<span class="number">1</span>, max_iter=<span class="number">100</span>, multi_class=<span class="string">&#x27;ovr&#x27;</span>, n_jobs=<span class="number">1</span>,</span><br><span class="line">          penalty=<span class="string">&#x27;l2&#x27;</span>, random_state=<span class="literal">None</span>, solver=<span class="string">&#x27;liblinear&#x27;</span>, tol=<span class="number">0.0001</span>,</span><br><span class="line">          verbose=<span class="number">0</span>, warm_start=<span class="literal">False</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，我们可以用model.predict，对测试数据进行预测：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">105</span>]: y_predict = model.predict(X_test)</span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: y_predict[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">106</span>]: array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你有测试数据集的真是值，你可以计算准确率或其它错误度量值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(y_true == y_predict).mean()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在实际中，模型训练经常有许多额外的复杂因素。许多模型有可以调节的参数，有些方法（比如交叉验证）可以用来进行参数调节，避免对训练数据过拟合。这通常可以提高预测性或对新数据的健壮性。</p>
<p>交叉验证通过分割训练数据来模拟样本外预测。基于模型的精度得分（比如均方差），可以对模型参数进行网格搜索。有些模型，如logistic回归，有内置的交叉验证的估计类。例如，logisticregressioncv类可以用一个参数指定网格搜索对模型的正则化参数C的粒度：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">107</span>]: <span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegressionCV</span><br><span class="line"></span><br><span class="line">In [<span class="number">108</span>]: model_cv = LogisticRegressionCV(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: model_cv.fit(X_train, y_train)</span><br><span class="line">Out[<span class="number">109</span>]: </span><br><span class="line">LogisticRegressionCV(Cs=<span class="number">10</span>, class_weight=<span class="literal">None</span>, cv=<span class="literal">None</span>, dual=<span class="literal">False</span>,</span><br><span class="line">           fit_intercept=<span class="literal">True</span>, intercept_scaling=<span class="number">1.0</span>, max_iter=<span class="number">100</span>,</span><br><span class="line">           multi_class=<span class="string">&#x27;ovr&#x27;</span>, n_jobs=<span class="number">1</span>, penalty=<span class="string">&#x27;l2&#x27;</span>, random_state=<span class="literal">None</span>,</span><br><span class="line">           refit=<span class="literal">True</span>, scoring=<span class="literal">None</span>, solver=<span class="string">&#x27;lbfgs&#x27;</span>, tol=<span class="number">0.0001</span>, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要手动进行交叉验证，你可以使用cross_val_score帮助函数，它可以处理数据分割。例如，要交叉验证我们的带有四个不重叠训练数据的模型，可以这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">110</span>]: <span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: model = LogisticRegression(C=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">112</span>]: scores = cross_val_score(model, X_train, y_train, cv=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">113</span>]: scores</span><br><span class="line">Out[<span class="number">113</span>]: array([ <span class="number">0.7723</span>,  <span class="number">0.8027</span>,  <span class="number">0.7703</span>,  <span class="number">0.7883</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认的评分指标取决于模型本身，但是可以明确指定一个评分。交叉验证过的模型需要更长时间来训练，但会有更高的模型性能。</p>
<h1 id="继续学习">13.5 继续学习</h1>
<p>我只是介绍了一些Python建模库的表面内容，现在有越来越多的框架用于各种统计和机器学习，它们都是用Python或Python用户界面实现的。</p>
<p>这本书的重点是数据规整，有其它的书是关注建模和数据科学工具的。其中优秀的有：</p>
<ul>
<li>Andreas Mueller and Sarah Guido (O’Reilly)的 《Introduction to Machine Learning with Python》</li>
<li>Jake VanderPlas (O’Reilly)的 《Python Data Science Handbook》</li>
<li>Joel Grus (O’Reilly) 的 《Data Science from Scratch: First Principles》</li>
<li>Sebastian Raschka (Packt Publishing) 的《Python Machine Learning》</li>
<li>Aurélien Géron (O’Reilly) 的《Hands-On Machine Learning with Scikit-Learn and TensorFlow》</li>
</ul>
<p>虽然书是学习的好资源，但是随着底层开源软件的发展，书的内容会过时。最好是不断熟悉各种统计和机器学习框架的文档，学习最新的功能和API。</p>
]]></content>
      <categories>
        <category>Python 数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>第10章 数据聚合与分组运算</title>
    <url>/2019/04/09/%E7%AC%AC10%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%81%9A%E5%90%88%E4%B8%8E%E5%88%86%E7%BB%84%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>对数据集进行分组并对各组应用一个函数（无论是聚合还是转换），通常是数据分析工作中的重要环节。在将数据集加载、融合、准备好之后，通常就是计算分组统计或生成透视表。pandas提供了一个灵活高效的gruopby功能，它使你能以一种自然的方式对数据集进行切片、切块、摘要等操作。<span id="more"></span></p>
<p>关系型数据库和SQL（Structured Query Language，结构化查询语言）能够如此流行的原因之一就是其能够方便地对数据进行连接、过滤、转换和聚合。但是，像SQL这样的查询语言所能执行的分组运算的种类很有限。在本章中你将会看到，由于Python和pandas强大的表达能力，我们可以执行复杂得多的分组运算（利用任何可以接受pandas对象或NumPy数组的函数）。在本章中，你将会学到：</p>
<ul>
<li>使用一个或多个键（形式可以是函数、数组或DataFrame列名）分割pandas对象。</li>
<li>计算分组的概述统计，比如数量、平均值或标准差，或是用户定义的函数。</li>
<li>应用组内转换或其他运算，如规格化、线性回归、排名或选取子集等。</li>
<li>计算透视表或交叉表。</li>
<li>执行分位数分析以及其它统计分组分析。</li>
</ul>
<blockquote>
<p>笔记：对时间序列数据的聚合（groupby的特殊用法之一）也称作重采样（resampling），本书将在第11章中单独对其进行讲解。</p>
</blockquote>
<h1 id="groupby机制">10.1 GroupBy机制</h1>
<p>Hadley Wickham（许多热门R语言包的作者）创造了一个用于表示分组运算的术语"split-apply-combine"（拆分－应用－合并）。第一个阶段，pandas对象（无论是Series、DataFrame还是其他的）中的数据会根据你所提供的一个或多个键被拆分（split）为多组。拆分操作是在对象的特定轴上执行的。例如，DataFrame可以在其行（axis=0）或列（axis=1）上进行分组。然后，将一个函数应用（apply）到各个分组并产生一个新值。最后，所有这些函数的执行结果会被合并（combine）到最终的结果对象中。结果对象的形式一般取决于数据上所执行的操作。图10-1大致说明了一个简单的分组聚合过程。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-e5c671e09ecf94be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图10-1 分组聚合演示" /><figcaption aria-hidden="true">图10-1 分组聚合演示</figcaption>
</figure>
<p>分组键可以有多种形式，且类型不必相同：</p>
<ul>
<li>列表或数组，其长度与待分组的轴一样。</li>
<li>表示DataFrame某个列名的值。</li>
<li>字典或Series，给出待分组轴上的值与分组名之间的对应关系。</li>
<li>函数，用于处理轴索引或索引中的各个标签。</li>
</ul>
<p>注意，后三种都只是快捷方式而已，其最终目的仍然是产生一组用于拆分对象的值。如果觉得这些东西看起来很抽象，不用担心，我将在本章中给出大量有关于此的示例。首先来看看下面这个非常简单的表格型数据集（以DataFrame的形式）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span> : [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>],</span><br><span class="line">   ....:                    <span class="string">&#x27;key2&#x27;</span> : [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">   ....:                    <span class="string">&#x27;data1&#x27;</span> : np.random.randn(<span class="number">5</span>),</span><br><span class="line">   ....:                    <span class="string">&#x27;data2&#x27;</span> : np.random.randn(<span class="number">5</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: df</span><br><span class="line">Out[<span class="number">11</span>]: </span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">1.393406</span>    a  one</span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span>    a  two</span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span>  <span class="number">0.769023</span>    b  two</span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span>    a  one</span><br></pre></td></tr></table></figure>
<p>假设你想要按key1进行分组，并计算data1列的平均值。实现该功能的方式有很多，而我们这里要用的是：访问data1，并根据key1调用groupby：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: grouped = df[<span class="string">&#x27;data1&#x27;</span>].groupby(df[<span class="string">&#x27;key1&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: grouped</span><br><span class="line">Out[<span class="number">13</span>]: &lt;pandas.core.groupby.SeriesGroupBy <span class="built_in">object</span> at <span class="number">0x7faa31537390</span>&gt;</span><br></pre></td></tr></table></figure>
<p>变量grouped是一个GroupBy对象。它实际上还没有进行任何计算，只是含有一些有关分组键df['key1']的中间数据而已。换句话说，该对象已经有了接下来对各分组执行运算所需的一切信息。例如，我们可以调用GroupBy的mean方法来计算分组平均值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">14</span>]: grouped.mean()</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">key1</span><br><span class="line">a    <span class="number">0.746672</span></span><br><span class="line">b   -<span class="number">0.537585</span></span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure>
<p>稍后我将详细讲解.mean()的调用过程。这里最重要的是，数据（Series）根据分组键进行了聚合，产生了一个新的Series，其索引为key1列中的唯一值。之所以结果中索引的名称为key1，是因为原始DataFrame的列df['key1']就叫这个名字。</p>
<p>如果我们一次传入多个数组的列表，就会得到不同的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: means = df[<span class="string">&#x27;data1&#x27;</span>].groupby([df[<span class="string">&#x27;key1&#x27;</span>], df[<span class="string">&#x27;key2&#x27;</span>]]).mean()</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: means</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">key1  key2</span><br><span class="line">a     one     <span class="number">0.880536</span></span><br><span class="line">      two     <span class="number">0.478943</span></span><br><span class="line">b     one    -<span class="number">0.519439</span></span><br><span class="line">      two    -<span class="number">0.555730</span></span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure>
<p>这里，我通过两个键对数据进行了分组，得到的Series具有一个层次化索引（由唯一的键对组成）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: means.unstack()</span><br><span class="line">Out[<span class="number">17</span>]: </span><br><span class="line">key2       one       two</span><br><span class="line">key1                    </span><br><span class="line">a     <span class="number">0.880536</span>  <span class="number">0.478943</span></span><br><span class="line">b    -<span class="number">0.519439</span> -<span class="number">0.555730</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，分组键均为Series。实际上，分组键可以是任何长度适当的数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: states = np.array([<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: years = np.array([<span class="number">2005</span>, <span class="number">2005</span>, <span class="number">2006</span>, <span class="number">2005</span>, <span class="number">2006</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: df[<span class="string">&#x27;data1&#x27;</span>].groupby([states, years]).mean()</span><br><span class="line">Out[<span class="number">20</span>]: </span><br><span class="line">California  <span class="number">2005</span>    <span class="number">0.478943</span></span><br><span class="line">            <span class="number">2006</span>   -<span class="number">0.519439</span></span><br><span class="line">Ohio        <span class="number">2005</span>   -<span class="number">0.380219</span></span><br><span class="line">            <span class="number">2006</span>    <span class="number">1.965781</span></span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure>
<p>通常，分组信息就位于相同的要处理DataFrame中。这里，你还可以将列名（可以是字符串、数字或其他Python对象）用作分组键：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: df.groupby(<span class="string">&#x27;key1&#x27;</span>).mean()</span><br><span class="line">Out[<span class="number">21</span>]: </span><br><span class="line">         data1     data2</span><br><span class="line">key1</span><br><span class="line">a     <span class="number">0.746672</span>  <span class="number">0.910916</span></span><br><span class="line">b    -<span class="number">0.537585</span>  <span class="number">0.525384</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>]).mean()</span><br><span class="line">Out[<span class="number">22</span>]: </span><br><span class="line">              data1     data2</span><br><span class="line">key1 key2                    </span><br><span class="line">a    one   <span class="number">0.880536</span>  <span class="number">1.319920</span></span><br><span class="line">     two   <span class="number">0.478943</span>  <span class="number">0.092908</span></span><br><span class="line">b    one  -<span class="number">0.519439</span>  <span class="number">0.281746</span></span><br><span class="line">     two  -<span class="number">0.555730</span>  <span class="number">0.769023</span></span><br></pre></td></tr></table></figure>
<p>你可能已经注意到了，第一个例子在执行df.groupby('key1').mean()时，结果中没有key2列。这是因为df['key2']不是数值数据（俗称“麻烦列”），所以被从结果中排除了。默认情况下，所有数值列都会被聚合，虽然有时可能会被过滤为一个子集，稍后就会碰到。</p>
<p>无论你准备拿groupby做什么，都有可能会用到GroupBy的size方法，它可以返回一个含有分组大小的Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">23</span>]: df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>]).size()</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">key1  key2</span><br><span class="line">a     one     <span class="number">2</span></span><br><span class="line">      two     <span class="number">1</span></span><br><span class="line">b     one     <span class="number">1</span></span><br><span class="line">      two     <span class="number">1</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>注意，任何分组关键词中的缺失值，都会被从结果中除去。</p>
<h2 id="对分组进行迭代">对分组进行迭代</h2>
<p>GroupBy对象支持迭代，可以产生一组二元元组（由分组名和数据块组成）。看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: <span class="keyword">for</span> name, group <span class="keyword">in</span> df.groupby(<span class="string">&#x27;key1&#x27;</span>):</span><br><span class="line">   ....:     <span class="built_in">print</span>(name)</span><br><span class="line">   ....:     <span class="built_in">print</span>(group)</span><br><span class="line">   ....:</span><br><span class="line">a</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">1.393406</span>    a  one</span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span>    a  two</span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span>    a  one</span><br><span class="line">b</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span>  <span class="number">0.769023</span>    b  two</span><br></pre></td></tr></table></figure>
<p>对于多重键的情况，元组的第一个元素将会是由键值组成的元组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: <span class="keyword">for</span> (k1, k2), group <span class="keyword">in</span> df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>]):</span><br><span class="line">   ....:     <span class="built_in">print</span>((k1, k2))</span><br><span class="line">   ....:     <span class="built_in">print</span>(group)</span><br><span class="line">   ....:</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">1.393406</span>    a  one</span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span>    a  one</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span>    a  two</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">     data1     data2 key1 key2</span><br><span class="line"><span class="number">3</span> -<span class="number">0.55573</span>  <span class="number">0.769023</span>    b  two</span><br></pre></td></tr></table></figure>
<p>当然，你可以对这些数据片段做任何操作。有一个你可能会觉得有用的运算：将这些数据片段做成一个字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">26</span>]: pieces = <span class="built_in">dict</span>(<span class="built_in">list</span>(df.groupby(<span class="string">&#x27;key1&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: pieces[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">27</span>]: </span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span>  <span class="number">0.769023</span>    b  two</span><br></pre></td></tr></table></figure>
<p>groupby默认是在axis=0上进行分组的，通过设置也可以在其他任何轴上进行分组。拿上面例子中的df来说，我们可以根据dtype对列进行分组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">28</span>]: df.dtypes</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">data1    float64</span><br><span class="line">data2    float64</span><br><span class="line">key1      <span class="built_in">object</span></span><br><span class="line">key2      <span class="built_in">object</span></span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: grouped = df.groupby(df.dtypes, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>可以如下打印分组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">30</span>]: <span class="keyword">for</span> dtype, group <span class="keyword">in</span> grouped:</span><br><span class="line">   ....:     <span class="built_in">print</span>(dtype)</span><br><span class="line">   ....:     <span class="built_in">print</span>(group)</span><br><span class="line">   ....:</span><br><span class="line">float64</span><br><span class="line">      data1     data2</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">1.393406</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span>  <span class="number">0.769023</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span></span><br><span class="line"><span class="built_in">object</span></span><br><span class="line">  key1 key2</span><br><span class="line"><span class="number">0</span>    a  one</span><br><span class="line"><span class="number">1</span>    a  two</span><br><span class="line"><span class="number">2</span>    b  one</span><br><span class="line"><span class="number">3</span>    b  two</span><br><span class="line"><span class="number">4</span>    a  one</span><br></pre></td></tr></table></figure>
<h2 id="选取一列或列的子集">选取一列或列的子集</h2>
<p>对于由DataFrame产生的GroupBy对象，如果用一个（单个字符串）或一组（字符串数组）列名对其进行索引，就能实现选取部分列进行聚合的目的。也就是说：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.groupby(<span class="string">&#x27;key1&#x27;</span>)[<span class="string">&#x27;data1&#x27;</span>]</span><br><span class="line">df.groupby(<span class="string">&#x27;key1&#x27;</span>)[[<span class="string">&#x27;data2&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<p>是以下代码的语法糖：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;data1&#x27;</span>].groupby(df[<span class="string">&#x27;key1&#x27;</span>])</span><br><span class="line">df[[<span class="string">&#x27;data2&#x27;</span>]].groupby(df[<span class="string">&#x27;key1&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>尤其对于大数据集，很可能只需要对部分列进行聚合。例如，在前面那个数据集中，如果只需计算data2列的平均值并以DataFrame形式得到结果，可以这样写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">31</span>]: df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])[[<span class="string">&#x27;data2&#x27;</span>]].mean()</span><br><span class="line">Out[<span class="number">31</span>]: </span><br><span class="line">              data2</span><br><span class="line">key1 key2          </span><br><span class="line">a    one   <span class="number">1.319920</span></span><br><span class="line">     two   <span class="number">0.092908</span></span><br><span class="line">b    one   <span class="number">0.281746</span></span><br><span class="line">     two   <span class="number">0.769023</span></span><br></pre></td></tr></table></figure>
<p>这种索引操作所返回的对象是一个已分组的DataFrame（如果传入的是列表或数组）或已分组的Series（如果传入的是标量形式的单个列名）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">32</span>]: s_grouped = df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])[<span class="string">&#x27;data2&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: s_grouped</span><br><span class="line">Out[<span class="number">33</span>]: &lt;pandas.core.groupby.SeriesGroupBy <span class="built_in">object</span> at <span class="number">0x7faa30c78da0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: s_grouped.mean()</span><br><span class="line">Out[<span class="number">34</span>]: </span><br><span class="line">key1  key2</span><br><span class="line">a     one     <span class="number">1.319920</span></span><br><span class="line">      two     <span class="number">0.092908</span></span><br><span class="line">b     one     <span class="number">0.281746</span></span><br><span class="line">      two     <span class="number">0.769023</span></span><br><span class="line">Name: data2, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="通过字典或series进行分组">通过字典或Series进行分组</h2>
<p>除数组以外，分组信息还可以其他形式存在。来看另一个示例DataFrame：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">35</span>]: people = pd.DataFrame(np.random.randn(<span class="number">5</span>, <span class="number">5</span>),</span><br><span class="line">   ....:                       columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>],</span><br><span class="line">   ....:                       index=[<span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Wes&#x27;</span>, <span class="string">&#x27;Jim&#x27;</span>, <span class="string">&#x27;Travis&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: people.iloc[<span class="number">2</span>:<span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>]] = np.nan <span class="comment"># Add a few NA values</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: people</span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">               a         b         c         d         e</span><br><span class="line">Joe     <span class="number">1.007189</span> -<span class="number">1.296221</span>  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line">Steve   <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span></span><br><span class="line">Wes    -<span class="number">0.539741</span>       NaN       NaN -<span class="number">1.021228</span> -<span class="number">0.577087</span></span><br><span class="line">Jim     <span class="number">0.124121</span>  <span class="number">0.302614</span>  <span class="number">0.523772</span>  <span class="number">0.000940</span>  <span class="number">1.343810</span></span><br><span class="line">Travis -<span class="number">0.713544</span> -<span class="number">0.831154</span> -<span class="number">2.370232</span> -<span class="number">1.860761</span> -<span class="number">0.860757</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，假设已知列的分组关系，并希望根据分组计算列的和：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">38</span>]: mapping = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">   ....:            <span class="string">&#x27;d&#x27;</span>: <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;e&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;f&#x27;</span> : <span class="string">&#x27;orange&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，你可以将这个字典传给groupby，来构造数组，但我们可以直接传递字典（我包含了键“f”来强调，存在未使用的分组键是可以的）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">39</span>]: by_column = people.groupby(mapping, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: by_column.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">            blue       red</span><br><span class="line">Joe     <span class="number">0.503905</span>  <span class="number">1.063885</span></span><br><span class="line">Steve   <span class="number">1.297183</span> -<span class="number">1.553778</span></span><br><span class="line">Wes    -<span class="number">1.021228</span> -<span class="number">1.116829</span></span><br><span class="line">Jim     <span class="number">0.524712</span>  <span class="number">1.770545</span></span><br><span class="line">Travis -<span class="number">4.230992</span> -<span class="number">2.405455</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Series也有同样的功能，它可以被看做一个固定大小的映射：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: map_series = pd.Series(mapping)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: map_series</span><br><span class="line">Out[<span class="number">42</span>]: </span><br><span class="line">a       red</span><br><span class="line">b       red</span><br><span class="line">c      blue</span><br><span class="line">d      blue</span><br><span class="line">e       red</span><br><span class="line">f    orange</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: people.groupby(map_series, axis=<span class="number">1</span>).count()</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">        blue  red</span><br><span class="line">Joe        <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">Steve      <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">Wes        <span class="number">1</span>    <span class="number">2</span></span><br><span class="line">Jim        <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">Travis     <span class="number">2</span>    <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="通过函数进行分组">通过函数进行分组</h2>
<p>比起使用字典或Series，使用Python函数是一种更原生的方法定义分组映射。任何被当做分组键的函数都会在各个索引值上被调用一次，其返回值就会被用作分组名称。具体点说，以上一小节的示例DataFrame为例，其索引值为人的名字。你可以计算一个字符串长度的数组，更简单的方法是传入len函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">44</span>]: people.groupby(<span class="built_in">len</span>).<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">44</span>]: </span><br><span class="line">          a         b         c         d         e</span><br><span class="line"><span class="number">3</span>  <span class="number">0.591569</span> -<span class="number">0.993608</span>  <span class="number">0.798764</span> -<span class="number">0.791374</span>  <span class="number">2.119639</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span></span><br><span class="line"><span class="number">6</span> -<span class="number">0.713544</span> -<span class="number">0.831154</span> -<span class="number">2.370232</span> -<span class="number">1.860761</span> -<span class="number">0.860757</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将函数跟数组、列表、字典、Series混合使用也不是问题，因为任何东西在内部都会被转换为数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">45</span>]: key_list = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: people.groupby([<span class="built_in">len</span>, key_list]).<span class="built_in">min</span>()</span><br><span class="line">Out[<span class="number">46</span>]: </span><br><span class="line">              a         b         c         d         e</span><br><span class="line"><span class="number">3</span> one -<span class="number">0.539741</span> -<span class="number">1.296221</span>  <span class="number">0.274992</span> -<span class="number">1.021228</span> -<span class="number">0.577087</span></span><br><span class="line">  two  <span class="number">0.124121</span>  <span class="number">0.302614</span>  <span class="number">0.523772</span>  <span class="number">0.000940</span>  <span class="number">1.343810</span></span><br><span class="line"><span class="number">5</span> one  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span></span><br><span class="line"><span class="number">6</span> two -<span class="number">0.713544</span> -<span class="number">0.831154</span> -<span class="number">2.370232</span> -<span class="number">1.860761</span> -<span class="number">0.860757</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="根据索引级别分组">根据索引级别分组</h2>
<p>层次化索引数据集最方便的地方就在于它能够根据轴索引的一个级别进行聚合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">47</span>]: columns = pd.MultiIndex.from_arrays([[<span class="string">&#x27;US&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>],</span><br><span class="line">   ....:                                     [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>]],</span><br><span class="line">   ....:                                     names=[<span class="string">&#x27;cty&#x27;</span>, <span class="string">&#x27;tenor&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: hier_df = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">5</span>), columns=columns)</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: hier_df</span><br><span class="line">Out[<span class="number">49</span>]: </span><br><span class="line">cty          US                            JP          </span><br><span class="line">tenor         <span class="number">1</span>         <span class="number">3</span>         <span class="number">5</span>         <span class="number">1</span>         <span class="number">3</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0.560145</span> -<span class="number">1.265934</span>  <span class="number">0.119827</span> -<span class="number">1.063512</span>  <span class="number">0.332883</span></span><br><span class="line"><span class="number">1</span>     -<span class="number">2.359419</span> -<span class="number">0.199543</span> -<span class="number">1.541996</span> -<span class="number">0.970736</span> -<span class="number">1.307030</span></span><br><span class="line"><span class="number">2</span>      <span class="number">0.286350</span>  <span class="number">0.377984</span> -<span class="number">0.753887</span>  <span class="number">0.331286</span>  <span class="number">1.349742</span></span><br><span class="line"><span class="number">3</span>      <span class="number">0.069877</span>  <span class="number">0.246674</span> -<span class="number">0.011862</span>  <span class="number">1.004812</span>  <span class="number">1.327195</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要根据级别分组，使用level关键字传递级别序号或名字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">50</span>]: hier_df.groupby(level=<span class="string">&#x27;cty&#x27;</span>, axis=<span class="number">1</span>).count()</span><br><span class="line">Out[<span class="number">50</span>]: </span><br><span class="line">cty  JP  US</span><br><span class="line"><span class="number">0</span>     <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">1</span>     <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">2</span>     <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">3</span>     <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="数据聚合">10.2 数据聚合</h1>
<p>聚合指的是任何能够从数组产生标量值的数据转换过程。之前的例子已经用过一些，比如mean、count、min以及sum等。你可能想知道在GroupBy对象上调用mean()时究竟发生了什么。许多常见的聚合运算（如表10-1所示）都有进行优化。然而，除了这些方法，你还可以使用其它的。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-ba8de524e08b1b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表10-1 经过优化的groupby方法" /><figcaption aria-hidden="true">表10-1 经过优化的groupby方法</figcaption>
</figure>
<p>你可以使用自己发明的聚合运算，还可以调用分组对象上已经定义好的任何方法。例如，quantile可以计算Series或DataFrame列的样本分位数。</p>
<p>虽然quantile并没有明确地实现于GroupBy，但它是一个Series方法，所以这里是能用的。实际上，GroupBy会高效地对Series进行切片，然后对各片调用piece.quantile(0.9)，最后将这些结果组装成最终结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">51</span>]: df</span><br><span class="line">Out[<span class="number">51</span>]: </span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">1.393406</span>    a  one</span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span>    a  two</span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span>  <span class="number">0.769023</span>    b  two</span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span>    a  one</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: grouped = df.groupby(<span class="string">&#x27;key1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: grouped[<span class="string">&#x27;data1&#x27;</span>].quantile(<span class="number">0.9</span>)</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">key1</span><br><span class="line">a    <span class="number">1.668413</span></span><br><span class="line">b   -<span class="number">0.523068</span></span><br><span class="line">Name: data1, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果要使用你自己的聚合函数，只需将其传入aggregate或agg方法即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">54</span>]: <span class="function"><span class="keyword">def</span> <span class="title">peak_to_peak</span>(<span class="params">arr</span>):</span></span><br><span class="line">   ....:     <span class="keyword">return</span> arr.<span class="built_in">max</span>() - arr.<span class="built_in">min</span>()</span><br><span class="line">In [<span class="number">55</span>]: grouped.agg(peak_to_peak)</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">         data1     data2</span><br><span class="line">key1                    </span><br><span class="line">a     <span class="number">2.170488</span>  <span class="number">1.300498</span></span><br><span class="line">b     <span class="number">0.036292</span>  <span class="number">0.487276</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可能注意到注意，有些方法（如describe）也是可以用在这里的，即使严格来讲，它们并非聚合运算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: grouped.describe()</span><br><span class="line">Out[<span class="number">56</span>]: </span><br><span class="line">     data1                                                              \</span><br><span class="line">     count      mean       std       <span class="built_in">min</span>       <span class="number">25</span>%       <span class="number">50</span>%       <span class="number">75</span>%   </span><br><span class="line">key1                                                                     </span><br><span class="line">a      <span class="number">3.0</span>  <span class="number">0.746672</span>  <span class="number">1.109736</span> -<span class="number">0.204708</span>  <span class="number">0.137118</span>  <span class="number">0.478943</span>  <span class="number">1.222362</span>   </span><br><span class="line">b      <span class="number">2.0</span> -<span class="number">0.537585</span>  <span class="number">0.025662</span> -<span class="number">0.555730</span> -<span class="number">0.546657</span> -<span class="number">0.537585</span> -<span class="number">0.528512</span>   </span><br><span class="line">               data2                                                    \</span><br><span class="line"><span class="built_in">max</span> count      mean       std       <span class="built_in">min</span>       <span class="number">25</span>%       <span class="number">50</span>%   </span><br><span class="line">key1                                                                     </span><br><span class="line">a     <span class="number">1.965781</span>   <span class="number">3.0</span>  <span class="number">0.910916</span>  <span class="number">0.712217</span>  <span class="number">0.092908</span>  <span class="number">0.669671</span>  <span class="number">1.246435</span>   </span><br><span class="line">b    -<span class="number">0.519439</span>   <span class="number">2.0</span>  <span class="number">0.525384</span>  <span class="number">0.344556</span>  <span class="number">0.281746</span>  <span class="number">0.403565</span>  <span class="number">0.525384</span>   </span><br><span class="line">                          </span><br><span class="line">           <span class="number">75</span>%       <span class="built_in">max</span>  </span><br><span class="line">key1                      </span><br><span class="line">a     <span class="number">1.319920</span>  <span class="number">1.393406</span>  </span><br><span class="line">b     <span class="number">0.647203</span>  <span class="number">0.769023</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在后面的10.3节，我将详细说明这到底是怎么回事。</p>
<blockquote>
<p>笔记：自定义聚合函数要比表10-1中那些经过优化的函数慢得多。这是因为在构造中间分组数据块时存在非常大的开销（函数调用、数据重排等）。</p>
</blockquote>
<h2 id="面向列的多函数应用">面向列的多函数应用</h2>
<p>回到前面小费的例子。使用read_csv导入数据之后，我们添加了一个小费百分比的列tip_pct：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">57</span>]: tips = pd.read_csv(<span class="string">&#x27;examples/tips.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add tip percentage of total bill</span></span><br><span class="line">In [<span class="number">58</span>]: tips[<span class="string">&#x27;tip_pct&#x27;</span>] = tips[<span class="string">&#x27;tip&#x27;</span>] / tips[<span class="string">&#x27;total_bill&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: tips[:<span class="number">6</span>]</span><br><span class="line">Out[<span class="number">59</span>]: </span><br><span class="line">   total_bill   tip smoker  day    time  size   tip_pct</span><br><span class="line"><span class="number">0</span>       <span class="number">16.99</span>  <span class="number">1.01</span>     No  Sun  Dinner     <span class="number">2</span>  <span class="number">0.059447</span></span><br><span class="line"><span class="number">1</span>       <span class="number">10.34</span>  <span class="number">1.66</span>     No  Sun  Dinner     <span class="number">3</span>  <span class="number">0.160542</span></span><br><span class="line"><span class="number">2</span>       <span class="number">21.01</span>  <span class="number">3.50</span>     No  Sun  Dinner     <span class="number">3</span>  <span class="number">0.166587</span></span><br><span class="line"><span class="number">3</span>       <span class="number">23.68</span>  <span class="number">3.31</span>     No  Sun  Dinner     <span class="number">2</span>  <span class="number">0.139780</span></span><br><span class="line"><span class="number">4</span>       <span class="number">24.59</span>  <span class="number">3.61</span>     No  Sun  Dinner     <span class="number">4</span>  <span class="number">0.146808</span></span><br><span class="line"><span class="number">5</span>       <span class="number">25.29</span>  <span class="number">4.71</span>     No  Sun  Dinner     <span class="number">4</span>  <span class="number">0.186240</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你已经看到，对Series或DataFrame列的聚合运算其实就是使用aggregate（使用自定义函数）或调用诸如mean、std之类的方法。然而，你可能希望对不同的列使用不同的聚合函数，或一次应用多个函数。其实这也好办，我将通过一些示例来进行讲解。首先，我根据天和smoker对tips进行分组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">60</span>]: grouped = tips.groupby([<span class="string">&#x27;day&#x27;</span>, <span class="string">&#x27;smoker&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，对于表10-1中的那些描述统计，可以将函数名以字符串的形式传入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">61</span>]: grouped_pct = grouped[<span class="string">&#x27;tip_pct&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: grouped_pct.agg(<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">Out[<span class="number">62</span>]: </span><br><span class="line">day   smoker</span><br><span class="line">Fri   No        <span class="number">0.151650</span></span><br><span class="line">      Yes       <span class="number">0.174783</span></span><br><span class="line">Sat   No        <span class="number">0.158048</span></span><br><span class="line">      Yes       <span class="number">0.147906</span></span><br><span class="line">Sun   No        <span class="number">0.160113</span></span><br><span class="line">      Yes       <span class="number">0.187250</span></span><br><span class="line">Thur  No        <span class="number">0.160298</span></span><br><span class="line">      Yes       <span class="number">0.163863</span></span><br><span class="line">Name: tip_pct, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果传入一组函数或函数名，得到的DataFrame的列就会以相应的函数命名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">63</span>]: grouped_pct.agg([<span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;std&#x27;</span>, peak_to_peak])</span><br><span class="line">Out[<span class="number">63</span>]: </span><br><span class="line">                 mean       std  peak_to_peak</span><br><span class="line">day  smoker                                  </span><br><span class="line">Fri  No      <span class="number">0.151650</span>  <span class="number">0.028123</span>      <span class="number">0.067349</span></span><br><span class="line">     Yes     <span class="number">0.174783</span>  <span class="number">0.051293</span>      <span class="number">0.159925</span></span><br><span class="line">Sat  No      <span class="number">0.158048</span>  <span class="number">0.039767</span>      <span class="number">0.235193</span></span><br><span class="line">     Yes     <span class="number">0.147906</span>  <span class="number">0.061375</span>      <span class="number">0.290095</span></span><br><span class="line">Sun  No      <span class="number">0.160113</span>  <span class="number">0.042347</span>      <span class="number">0.193226</span></span><br><span class="line">     Yes     <span class="number">0.187250</span>  <span class="number">0.154134</span>      <span class="number">0.644685</span></span><br><span class="line">Thur No      <span class="number">0.160298</span>  <span class="number">0.038774</span>      <span class="number">0.193350</span></span><br><span class="line">     Yes     <span class="number">0.163863</span>  <span class="number">0.039389</span>      <span class="number">0.151240</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，我们传递了一组聚合函数进行聚合，独立对数据分组进行评估。</p>
<p>你并非一定要接受GroupBy自动给出的那些列名，特别是lambda函数，它们的名称是'<lambda>'，这样的辨识度就很低了（通过函数的__name__属性看看就知道了）。因此，如果传入的是一个由(name,function)元组组成的列表，则各元组的第一个元素就会被用作DataFrame的列名（可以将这种二元元组列表看做一个有序映射）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">64</span>]: grouped_pct.agg([(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>), (<span class="string">&#x27;bar&#x27;</span>, np.std)])</span><br><span class="line">Out[<span class="number">64</span>]: </span><br><span class="line">                  foo       bar</span><br><span class="line">day  smoker                    </span><br><span class="line">Fri  No      <span class="number">0.151650</span>  <span class="number">0.028123</span></span><br><span class="line">     Yes     <span class="number">0.174783</span>  <span class="number">0.051293</span></span><br><span class="line">Sat  No      <span class="number">0.158048</span>  <span class="number">0.039767</span></span><br><span class="line">     Yes     <span class="number">0.147906</span>  <span class="number">0.061375</span></span><br><span class="line">Sun  No      <span class="number">0.160113</span>  <span class="number">0.042347</span></span><br><span class="line">     Yes     <span class="number">0.187250</span>  <span class="number">0.154134</span></span><br><span class="line">Thur No      <span class="number">0.160298</span>  <span class="number">0.038774</span></span><br><span class="line">     Yes     <span class="number">0.163863</span>  <span class="number">0.039389</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于DataFrame，你还有更多选择，你可以定义一组应用于全部列的一组函数，或不同的列应用不同的函数。假设我们想要对tip_pct和total_bill列计算三个统计信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">65</span>]: functions = [<span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;max&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: result = grouped[<span class="string">&#x27;tip_pct&#x27;</span>, <span class="string">&#x27;total_bill&#x27;</span>].agg(functions)</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: result</span><br><span class="line">Out[<span class="number">67</span>]: </span><br><span class="line">            tip_pct                     total_bill                  </span><br><span class="line">              count      mean       <span class="built_in">max</span>      count       mean    <span class="built_in">max</span></span><br><span class="line">day  smoker                                                         </span><br><span class="line">Fri  No           <span class="number">4</span>  <span class="number">0.151650</span>  <span class="number">0.187735</span>          <span class="number">4</span>  <span class="number">18.420000</span>  <span class="number">22.75</span></span><br><span class="line">     Yes         <span class="number">15</span>  <span class="number">0.174783</span>  <span class="number">0.263480</span>         <span class="number">15</span>  <span class="number">16.813333</span>  <span class="number">40.17</span></span><br><span class="line">Sat  No          <span class="number">45</span>  <span class="number">0.158048</span>  <span class="number">0.291990</span>         <span class="number">45</span>  <span class="number">19.661778</span>  <span class="number">48.33</span></span><br><span class="line">     Yes         <span class="number">42</span>  <span class="number">0.147906</span>  <span class="number">0.325733</span>         <span class="number">42</span>  <span class="number">21.276667</span>  <span class="number">50.81</span></span><br><span class="line">Sun  No          <span class="number">57</span>  <span class="number">0.160113</span>  <span class="number">0.252672</span>         <span class="number">57</span>  <span class="number">20.506667</span>  <span class="number">48.17</span></span><br><span class="line">     Yes         <span class="number">19</span>  <span class="number">0.187250</span>  <span class="number">0.710345</span>         <span class="number">19</span>  <span class="number">24.120000</span>  <span class="number">45.35</span></span><br><span class="line">Thur No          <span class="number">45</span>  <span class="number">0.160298</span>  <span class="number">0.266312</span>         <span class="number">45</span>  <span class="number">17.113111</span>  <span class="number">41.19</span></span><br><span class="line">     Yes         <span class="number">17</span>  <span class="number">0.163863</span>  <span class="number">0.241255</span>         <span class="number">17</span>  <span class="number">19.190588</span>  <span class="number">43.11</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如你所见，结果DataFrame拥有层次化的列，这相当于分别对各列进行聚合，然后用concat将结果组装到一起，使用列名用作keys参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">68</span>]: result[<span class="string">&#x27;tip_pct&#x27;</span>]</span><br><span class="line">Out[<span class="number">68</span>]: </span><br><span class="line">             count      mean       <span class="built_in">max</span></span><br><span class="line">day  smoker                           </span><br><span class="line">Fri  No          <span class="number">4</span>  <span class="number">0.151650</span>  <span class="number">0.187735</span></span><br><span class="line">     Yes        <span class="number">15</span>  <span class="number">0.174783</span>  <span class="number">0.263480</span></span><br><span class="line">Sat  No         <span class="number">45</span>  <span class="number">0.158048</span>  <span class="number">0.291990</span></span><br><span class="line">     Yes        <span class="number">42</span>  <span class="number">0.147906</span>  <span class="number">0.325733</span></span><br><span class="line">Sun  No         <span class="number">57</span>  <span class="number">0.160113</span>  <span class="number">0.252672</span></span><br><span class="line">     Yes        <span class="number">19</span>  <span class="number">0.187250</span>  <span class="number">0.710345</span></span><br><span class="line">Thur No         <span class="number">45</span>  <span class="number">0.160298</span>  <span class="number">0.266312</span></span><br><span class="line">     Yes        <span class="number">17</span>  <span class="number">0.163863</span>  <span class="number">0.241255</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>跟前面一样，这里也可以传入带有自定义名称的一组元组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">69</span>]: ftuples = [(<span class="string">&#x27;Durchschnitt&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>),(<span class="string">&#x27;Abweichung&#x27;</span>, np.var)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: grouped[<span class="string">&#x27;tip_pct&#x27;</span>, <span class="string">&#x27;total_bill&#x27;</span>].agg(ftuples)</span><br><span class="line">Out[<span class="number">70</span>]: </span><br><span class="line">                 tip_pct              total_bill            </span><br><span class="line">            Durchschnitt Abweichung Durchschnitt  Abweichung</span><br><span class="line">day  smoker                                                 </span><br><span class="line">Fri  No         <span class="number">0.151650</span>   <span class="number">0.000791</span>    <span class="number">18.420000</span>   <span class="number">25.596333</span></span><br><span class="line">     Yes        <span class="number">0.174783</span>   <span class="number">0.002631</span>    <span class="number">16.813333</span>   <span class="number">82.562438</span></span><br><span class="line">Sat  No         <span class="number">0.158048</span>   <span class="number">0.001581</span>    <span class="number">19.661778</span>   <span class="number">79.908965</span></span><br><span class="line">     Yes        <span class="number">0.147906</span>   <span class="number">0.003767</span>    <span class="number">21.276667</span>  <span class="number">101.387535</span></span><br><span class="line">Sun  No         <span class="number">0.160113</span>   <span class="number">0.001793</span>    <span class="number">20.506667</span>   <span class="number">66.099980</span></span><br><span class="line">     Yes        <span class="number">0.187250</span>   <span class="number">0.023757</span>    <span class="number">24.120000</span>  <span class="number">109.046044</span></span><br><span class="line">Thur No         <span class="number">0.160298</span>   <span class="number">0.001503</span>    <span class="number">17.113111</span>   <span class="number">59.625081</span></span><br><span class="line">     Yes        <span class="number">0.163863</span>   <span class="number">0.001551</span>    <span class="number">19.190588</span>   <span class="number">69.808518</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，假设你想要对一个列或不同的列应用不同的函数。具体的办法是向agg传入一个从列名映射到函数的字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">71</span>]: grouped.agg(&#123;<span class="string">&#x27;tip&#x27;</span> : np.<span class="built_in">max</span>, <span class="string">&#x27;size&#x27;</span> : <span class="string">&#x27;sum&#x27;</span>&#125;)</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line">               tip  size</span><br><span class="line">day  smoker             </span><br><span class="line">Fri  No       <span class="number">3.50</span>     <span class="number">9</span></span><br><span class="line">     Yes      <span class="number">4.73</span>    <span class="number">31</span></span><br><span class="line">Sat  No       <span class="number">9.00</span>   <span class="number">115</span></span><br><span class="line">     Yes     <span class="number">10.00</span>   <span class="number">104</span></span><br><span class="line">Sun  No       <span class="number">6.00</span>   <span class="number">167</span></span><br><span class="line">     Yes      <span class="number">6.50</span>    <span class="number">49</span></span><br><span class="line">Thur No       <span class="number">6.70</span>   <span class="number">112</span></span><br><span class="line">     Yes      <span class="number">5.00</span>    <span class="number">40</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: grouped.agg(&#123;<span class="string">&#x27;tip_pct&#x27;</span> : [<span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;std&#x27;</span>],</span><br><span class="line">   ....:              <span class="string">&#x27;size&#x27;</span> : <span class="string">&#x27;sum&#x27;</span>&#125;)</span><br><span class="line">Out[<span class="number">72</span>]: </span><br><span class="line">              tip_pct                               size</span><br><span class="line">                  <span class="built_in">min</span>       <span class="built_in">max</span>      mean       std  <span class="built_in">sum</span></span><br><span class="line">day  smoker                                             </span><br><span class="line">Fri  No      <span class="number">0.120385</span>  <span class="number">0.187735</span>  <span class="number">0.151650</span>  <span class="number">0.028123</span>    <span class="number">9</span></span><br><span class="line">     Yes     <span class="number">0.103555</span>  <span class="number">0.263480</span>  <span class="number">0.174783</span>  <span class="number">0.051293</span>   <span class="number">31</span></span><br><span class="line">Sat  No      <span class="number">0.056797</span>  <span class="number">0.291990</span>  <span class="number">0.158048</span>  <span class="number">0.039767</span>  <span class="number">115</span></span><br><span class="line">     Yes     <span class="number">0.035638</span>  <span class="number">0.325733</span>  <span class="number">0.147906</span>  <span class="number">0.061375</span>  <span class="number">104</span></span><br><span class="line">Sun  No      <span class="number">0.059447</span>  <span class="number">0.252672</span>  <span class="number">0.160113</span>  <span class="number">0.042347</span>  <span class="number">167</span></span><br><span class="line">     Yes     <span class="number">0.065660</span>  <span class="number">0.710345</span>  <span class="number">0.187250</span>  <span class="number">0.154134</span>   <span class="number">49</span></span><br><span class="line">Thur No      <span class="number">0.072961</span>  <span class="number">0.266312</span>  <span class="number">0.160298</span>  <span class="number">0.038774</span>  <span class="number">112</span></span><br><span class="line">     Yes     <span class="number">0.090014</span>  <span class="number">0.241255</span>  <span class="number">0.163863</span>  <span class="number">0.039389</span>   <span class="number">40</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>只有将多个函数应用到至少一列时，DataFrame才会拥有层次化的列。</p>
<h2 id="以没有行索引的形式返回聚合数据">以“没有行索引”的形式返回聚合数据</h2>
<p>到目前为止，所有示例中的聚合数据都有由唯一的分组键组成的索引（可能还是层次化的）。由于并不总是需要如此，所以你可以向groupby传入as_index=False以禁用该功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">73</span>]: tips.groupby([<span class="string">&#x27;day&#x27;</span>, <span class="string">&#x27;smoker&#x27;</span>], as_index=<span class="literal">False</span>).mean()</span><br><span class="line">Out[<span class="number">73</span>]: </span><br><span class="line">    day smoker  total_bill       tip      size   tip_pct</span><br><span class="line"><span class="number">0</span>   Fri     No   <span class="number">18.420000</span>  <span class="number">2.812500</span>  <span class="number">2.250000</span>  <span class="number">0.151650</span></span><br><span class="line"><span class="number">1</span>   Fri    Yes   <span class="number">16.813333</span>  <span class="number">2.714000</span>  <span class="number">2.066667</span>  <span class="number">0.174783</span></span><br><span class="line"><span class="number">2</span>   Sat     No   <span class="number">19.661778</span>  <span class="number">3.102889</span>  <span class="number">2.555556</span>  <span class="number">0.158048</span></span><br><span class="line"><span class="number">3</span>   Sat    Yes   <span class="number">21.276667</span>  <span class="number">2.875476</span>  <span class="number">2.476190</span>  <span class="number">0.147906</span></span><br><span class="line"><span class="number">4</span>   Sun     No   <span class="number">20.506667</span>  <span class="number">3.167895</span>  <span class="number">2.929825</span>  <span class="number">0.160113</span></span><br><span class="line"><span class="number">5</span>   Sun    Yes   <span class="number">24.120000</span>  <span class="number">3.516842</span>  <span class="number">2.578947</span>  <span class="number">0.187250</span></span><br><span class="line"><span class="number">6</span>  Thur     No   <span class="number">17.113111</span>  <span class="number">2.673778</span>  <span class="number">2.488889</span>  <span class="number">0.160298</span></span><br><span class="line"><span class="number">7</span>  Thur    Yes   <span class="number">19.190588</span>  <span class="number">3.030000</span>  <span class="number">2.352941</span>  <span class="number">0.163863</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然，对结果调用reset_index也能得到这种形式的结果。使用as_index=False方法可以避免一些不必要的计算。</p>
<h1 id="apply一般性的拆分应用合并">10.3 apply：一般性的“拆分－应用－合并”</h1>
<p>最通用的GroupBy方法是apply，本节剩余部分将重点讲解它。如图10-2所示，apply会将待处理的对象拆分成多个片段，然后对各片段调用传入的函数，最后尝试将各片段组合到一起。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-7e8bb217f599b4ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图10-2 分组聚合示例" /><figcaption aria-hidden="true">图10-2 分组聚合示例</figcaption>
</figure>
<p>回到之前那个小费数据集，假设你想要根据分组选出最高的5个tip_pct值。首先，编写一个选取指定列具有最大值的行的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">df, n=<span class="number">5</span>, column=<span class="string">&#x27;tip_pct&#x27;</span></span>):</span></span><br><span class="line">   ....:     <span class="keyword">return</span> df.sort_values(by=column)[-n:]</span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: top(tips, n=<span class="number">6</span>)</span><br><span class="line">Out[<span class="number">75</span>]: </span><br><span class="line">     total_bill   tip smoker  day    time  size   tip_pct</span><br><span class="line"><span class="number">109</span>       <span class="number">14.31</span>  <span class="number">4.00</span>    Yes  Sat  Dinner     <span class="number">2</span>  <span class="number">0.279525</span></span><br><span class="line"><span class="number">183</span>       <span class="number">23.17</span>  <span class="number">6.50</span>    Yes  Sun  Dinner     <span class="number">4</span>  <span class="number">0.280535</span></span><br><span class="line"><span class="number">232</span>       <span class="number">11.61</span>  <span class="number">3.39</span>     No  Sat  Dinner     <span class="number">2</span>  <span class="number">0.291990</span></span><br><span class="line"><span class="number">67</span>         <span class="number">3.07</span>  <span class="number">1.00</span>    Yes  Sat  Dinner     <span class="number">1</span>  <span class="number">0.325733</span></span><br><span class="line"><span class="number">178</span>        <span class="number">9.60</span>  <span class="number">4.00</span>    Yes  Sun  Dinner     <span class="number">2</span>  <span class="number">0.416667</span></span><br><span class="line"><span class="number">172</span>        <span class="number">7.25</span>  <span class="number">5.15</span>    Yes  Sun  Dinner     <span class="number">2</span>  <span class="number">0.710345</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，如果对smoker分组并用该函数调用apply，就会得到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: tips.groupby(<span class="string">&#x27;smoker&#x27;</span>).apply(top)</span><br><span class="line">Out[<span class="number">76</span>]: </span><br><span class="line">            total_bill   tip smoker   day    time  size   tip_pct</span><br><span class="line">smoker                                                           </span><br><span class="line">No     <span class="number">88</span>        <span class="number">24.71</span>  <span class="number">5.85</span>     No  Thur   Lunch     <span class="number">2</span>  <span class="number">0.236746</span></span><br><span class="line">       <span class="number">185</span>       <span class="number">20.69</span>  <span class="number">5.00</span>     No   Sun  Dinner     <span class="number">5</span>  <span class="number">0.241663</span></span><br><span class="line">       <span class="number">51</span>        <span class="number">10.29</span>  <span class="number">2.60</span>     No   Sun  Dinner     <span class="number">2</span>  <span class="number">0.252672</span></span><br><span class="line">       <span class="number">149</span>        <span class="number">7.51</span>  <span class="number">2.00</span>     No  Thur   Lunch     <span class="number">2</span>  <span class="number">0.266312</span></span><br><span class="line">       <span class="number">232</span>       <span class="number">11.61</span>  <span class="number">3.39</span>     No   Sat  Dinner     <span class="number">2</span>  <span class="number">0.291990</span></span><br><span class="line">Yes    <span class="number">109</span>       <span class="number">14.31</span>  <span class="number">4.00</span>    Yes   Sat  Dinner     <span class="number">2</span>  <span class="number">0.279525</span></span><br><span class="line">       <span class="number">183</span>       <span class="number">23.17</span>  <span class="number">6.50</span>    Yes   Sun  Dinner     <span class="number">4</span>  <span class="number">0.280535</span></span><br><span class="line">       <span class="number">67</span>         <span class="number">3.07</span>  <span class="number">1.00</span>    Yes   Sat  Dinner     <span class="number">1</span>  <span class="number">0.325733</span></span><br><span class="line">       <span class="number">178</span>        <span class="number">9.60</span>  <span class="number">4.00</span>    Yes   Sun  Dinner     <span class="number">2</span>  <span class="number">0.416667</span></span><br><span class="line">       <span class="number">172</span>        <span class="number">7.25</span>  <span class="number">5.15</span>    Yes   Sun  Dinner     <span class="number">2</span>  <span class="number">0.710345</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里发生了什么？top函数在DataFrame的各个片段上调用，然后结果由pandas.concat组装到一起，并以分组名称进行了标记。于是，最终结果就有了一个层次化索引，其内层索引值来自原DataFrame。</p>
<p>如果传给apply的函数能够接受其他参数或关键字，则可以将这些内容放在函数名后面一并传入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">77</span>]: tips.groupby([<span class="string">&#x27;smoker&#x27;</span>, <span class="string">&#x27;day&#x27;</span>]).apply(top, n=<span class="number">1</span>, column=<span class="string">&#x27;total_bill&#x27;</span>)</span><br><span class="line">Out[<span class="number">77</span>]: </span><br><span class="line">                 total_bill    tip smoker   day    time  size   tip_pct</span><br><span class="line">smoker day                                                             </span><br><span class="line">No     Fri  <span class="number">94</span>        <span class="number">22.75</span>   <span class="number">3.25</span>     No   Fri  Dinner     <span class="number">2</span>  <span class="number">0.142857</span></span><br><span class="line">       Sat  <span class="number">212</span>       <span class="number">48.33</span>   <span class="number">9.00</span>     No   Sat  Dinner     <span class="number">4</span>  <span class="number">0.186220</span></span><br><span class="line">       Sun  <span class="number">156</span>       <span class="number">48.17</span>   <span class="number">5.00</span>     No   Sun  Dinner     <span class="number">6</span>  <span class="number">0.103799</span></span><br><span class="line">       Thur <span class="number">142</span>       <span class="number">41.19</span>   <span class="number">5.00</span>     No  Thur   Lunch     <span class="number">5</span>  <span class="number">0.121389</span></span><br><span class="line">Yes    Fri  <span class="number">95</span>        <span class="number">40.17</span>   <span class="number">4.73</span>    Yes   Fri  Dinner     <span class="number">4</span>  <span class="number">0.117750</span></span><br><span class="line">       Sat  <span class="number">170</span>       <span class="number">50.81</span>  <span class="number">10.00</span>    Yes   Sat  Dinner     <span class="number">3</span>  <span class="number">0.196812</span></span><br><span class="line">       Sun  <span class="number">182</span>       <span class="number">45.35</span>   <span class="number">3.50</span>    Yes   Sun  Dinner     <span class="number">3</span>  <span class="number">0.077178</span></span><br><span class="line">       Thur <span class="number">197</span>       <span class="number">43.11</span>   <span class="number">5.00</span>    Yes  Thur   Lunch     <span class="number">4</span>  <span class="number">0.115982</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：除这些基本用法之外，能否充分发挥apply的威力很大程度上取决于你的创造力。传入的那个函数能做什么全由你说了算，它只需返回一个pandas对象或标量值即可。本章后续部分的示例主要用于讲解如何利用groupby解决各种各样的问题。</p>
</blockquote>
<p>可能你已经想起来了，之前我在GroupBy对象上调用过describe：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">78</span>]: result = tips.groupby(<span class="string">&#x27;smoker&#x27;</span>)[<span class="string">&#x27;tip_pct&#x27;</span>].describe()</span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: result</span><br><span class="line">Out[<span class="number">79</span>]: </span><br><span class="line">        count      mean       std       <span class="built_in">min</span>       <span class="number">25</span>%       <span class="number">50</span>%       <span class="number">75</span>%  \</span><br><span class="line">smoker                                                                      </span><br><span class="line">No      <span class="number">151.0</span>  <span class="number">0.159328</span>  <span class="number">0.039910</span>  <span class="number">0.056797</span>  <span class="number">0.136906</span>  <span class="number">0.155625</span>  <span class="number">0.185014</span>   </span><br><span class="line">Yes      <span class="number">93.0</span>  <span class="number">0.163196</span>  <span class="number">0.085119</span>  <span class="number">0.035638</span>  <span class="number">0.106771</span>  <span class="number">0.153846</span>  <span class="number">0.195059</span>   </span><br><span class="line">             <span class="built_in">max</span>  </span><br><span class="line">smoker</span><br><span class="line"></span><br><span class="line">No      <span class="number">0.291990</span>  </span><br><span class="line">Yes     <span class="number">0.710345</span>  </span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: result.unstack(<span class="string">&#x27;smoker&#x27;</span>)</span><br><span class="line">Out[<span class="number">80</span>]: </span><br><span class="line">       smoker</span><br><span class="line">count  No        <span class="number">151.000000</span></span><br><span class="line">       Yes        <span class="number">93.000000</span></span><br><span class="line">mean   No          <span class="number">0.159328</span></span><br><span class="line">       Yes         <span class="number">0.163196</span></span><br><span class="line">std    No          <span class="number">0.039910</span></span><br><span class="line">       Yes         <span class="number">0.085119</span></span><br><span class="line"><span class="built_in">min</span>    No          <span class="number">0.056797</span></span><br><span class="line">       Yes         <span class="number">0.035638</span></span><br><span class="line"><span class="number">25</span>%    No          <span class="number">0.136906</span></span><br><span class="line">       Yes         <span class="number">0.106771</span></span><br><span class="line"><span class="number">50</span>%    No          <span class="number">0.155625</span></span><br><span class="line">       Yes         <span class="number">0.153846</span></span><br><span class="line"><span class="number">75</span>%    No          <span class="number">0.185014</span></span><br><span class="line">       Yes         <span class="number">0.195059</span></span><br><span class="line"><span class="built_in">max</span>    No          <span class="number">0.291990</span></span><br><span class="line">       Yes         <span class="number">0.710345</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在GroupBy中，当你调用诸如describe之类的方法时，实际上只是应用了下面两条代码的快捷方式而已：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x: x.describe()</span><br><span class="line">grouped.apply(f)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="禁止分组键">禁止分组键</h2>
<p>从上面的例子中可以看出，分组键会跟原始对象的索引共同构成结果对象中的层次化索引。将group_keys=False传入groupby即可禁止该效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">81</span>]: tips.groupby(<span class="string">&#x27;smoker&#x27;</span>, group_keys=<span class="literal">False</span>).apply(top)</span><br><span class="line">Out[<span class="number">81</span>]: </span><br><span class="line">     total_bill   tip smoker   day    time  size   tip_pct</span><br><span class="line"><span class="number">88</span>        <span class="number">24.71</span>  <span class="number">5.85</span>     No  Thur   Lunch     <span class="number">2</span>  <span class="number">0.236746</span></span><br><span class="line"><span class="number">185</span>       <span class="number">20.69</span>  <span class="number">5.00</span>     No   Sun  Dinner     <span class="number">5</span>  <span class="number">0.241663</span></span><br><span class="line"><span class="number">51</span>        <span class="number">10.29</span>  <span class="number">2.60</span>     No   Sun  Dinner     <span class="number">2</span>  <span class="number">0.252672</span></span><br><span class="line"><span class="number">149</span>        <span class="number">7.51</span>  <span class="number">2.00</span>     No  Thur   Lunch     <span class="number">2</span>  <span class="number">0.266312</span></span><br><span class="line"><span class="number">232</span>       <span class="number">11.61</span>  <span class="number">3.39</span>     No   Sat  Dinner     <span class="number">2</span>  <span class="number">0.291990</span></span><br><span class="line"><span class="number">109</span>       <span class="number">14.31</span>  <span class="number">4.00</span>    Yes   Sat  Dinner     <span class="number">2</span>  <span class="number">0.279525</span></span><br><span class="line"><span class="number">183</span>       <span class="number">23.17</span>  <span class="number">6.50</span>    Yes   Sun  Dinner     <span class="number">4</span>  <span class="number">0.280535</span></span><br><span class="line"><span class="number">67</span>         <span class="number">3.07</span>  <span class="number">1.00</span>    Yes   Sat  Dinner     <span class="number">1</span>  <span class="number">0.325733</span></span><br><span class="line"><span class="number">178</span>        <span class="number">9.60</span>  <span class="number">4.00</span>    Yes   Sun  Dinner     <span class="number">2</span>  <span class="number">0.416667</span></span><br><span class="line"><span class="number">172</span>        <span class="number">7.25</span>  <span class="number">5.15</span>    Yes   Sun  Dinner     <span class="number">2</span>  <span class="number">0.710345</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="分位数和桶分析">分位数和桶分析</h2>
<p>我曾在第8章中讲过，pandas有一些能根据指定面元或样本分位数将数据拆分成多块的工具（比如cut和qcut）。将这些函数跟groupby结合起来，就能非常轻松地实现对数据集的桶（bucket）或分位数（quantile）分析了。以下面这个简单的随机数据集为例，我们利用cut将其装入长度相等的桶中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">82</span>]: frame = pd.DataFrame(&#123;<span class="string">&#x27;data1&#x27;</span>: np.random.randn(<span class="number">1000</span>),</span><br><span class="line">   ....:                       <span class="string">&#x27;data2&#x27;</span>: np.random.randn(<span class="number">1000</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: quartiles = pd.cut(frame.data1, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: quartiles[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">84</span>]: </span><br><span class="line"><span class="number">0</span>     (-<span class="number">1.23</span>, <span class="number">0.489</span>]</span><br><span class="line"><span class="number">1</span>    (-<span class="number">2.956</span>, -<span class="number">1.23</span>]</span><br><span class="line"><span class="number">2</span>     (-<span class="number">1.23</span>, <span class="number">0.489</span>]</span><br><span class="line"><span class="number">3</span>     (<span class="number">0.489</span>, <span class="number">2.208</span>]</span><br><span class="line"><span class="number">4</span>     (-<span class="number">1.23</span>, <span class="number">0.489</span>]</span><br><span class="line"><span class="number">5</span>     (<span class="number">0.489</span>, <span class="number">2.208</span>]</span><br><span class="line"><span class="number">6</span>     (-<span class="number">1.23</span>, <span class="number">0.489</span>]</span><br><span class="line"><span class="number">7</span>     (-<span class="number">1.23</span>, <span class="number">0.489</span>]</span><br><span class="line"><span class="number">8</span>     (<span class="number">0.489</span>, <span class="number">2.208</span>]</span><br><span class="line"><span class="number">9</span>     (<span class="number">0.489</span>, <span class="number">2.208</span>]</span><br><span class="line">Name: data1, dtype: category</span><br><span class="line">Categories (<span class="number">4</span>, interval[float64]): [(-<span class="number">2.956</span>, -<span class="number">1.23</span>] &lt; (-<span class="number">1.23</span>, <span class="number">0.489</span>] &lt; (<span class="number">0.489</span>, <span class="number">2.</span></span><br><span class="line"><span class="number">208</span>] &lt; (<span class="number">2.208</span>, <span class="number">3.928</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由cut返回的Categorical对象可直接传递到groupby。因此，我们可以像下面这样对data2列做一些统计计算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">85</span>]: <span class="function"><span class="keyword">def</span> <span class="title">get_stats</span>(<span class="params">group</span>):</span></span><br><span class="line">   ....:     <span class="keyword">return</span> &#123;<span class="string">&#x27;min&#x27;</span>: group.<span class="built_in">min</span>(), <span class="string">&#x27;max&#x27;</span>: group.<span class="built_in">max</span>(),</span><br><span class="line">   ....:             <span class="string">&#x27;count&#x27;</span>: group.count(), <span class="string">&#x27;mean&#x27;</span>: group.mean()&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: grouped = frame.data2.groupby(quartiles)</span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: grouped.apply(get_stats).unstack()</span><br><span class="line">Out[<span class="number">87</span>]: </span><br><span class="line">                 count       <span class="built_in">max</span>      mean       <span class="built_in">min</span></span><br><span class="line">data1                                               </span><br><span class="line">(-<span class="number">2.956</span>, -<span class="number">1.23</span>]   <span class="number">95.0</span>  <span class="number">1.670835</span> -<span class="number">0.039521</span> -<span class="number">3.399312</span></span><br><span class="line">(-<span class="number">1.23</span>, <span class="number">0.489</span>]   <span class="number">598.0</span>  <span class="number">3.260383</span> -<span class="number">0.002051</span> -<span class="number">2.989741</span></span><br><span class="line">(<span class="number">0.489</span>, <span class="number">2.208</span>]   <span class="number">297.0</span>  <span class="number">2.954439</span>  <span class="number">0.081822</span> -<span class="number">3.745356</span></span><br><span class="line">(<span class="number">2.208</span>, <span class="number">3.928</span>]    <span class="number">10.0</span>  <span class="number">1.765640</span>  <span class="number">0.024750</span> -<span class="number">1.929776</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这些都是长度相等的桶。要根据样本分位数得到大小相等的桶，使用qcut即可。传入labels=False即可只获取分位数的编号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Return quantile numbers</span></span><br><span class="line">In [<span class="number">88</span>]: grouping = pd.qcut(frame.data1, <span class="number">10</span>, labels=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: grouped = frame.data2.groupby(grouping)</span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: grouped.apply(get_stats).unstack()</span><br><span class="line">Out[<span class="number">90</span>]: </span><br><span class="line">       count       <span class="built_in">max</span>      mean       <span class="built_in">min</span></span><br><span class="line">data1                                     </span><br><span class="line"><span class="number">0</span>      <span class="number">100.0</span>  <span class="number">1.670835</span> -<span class="number">0.049902</span> -<span class="number">3.399312</span></span><br><span class="line"><span class="number">1</span>      <span class="number">100.0</span>  <span class="number">2.628441</span>  <span class="number">0.030989</span> -<span class="number">1.950098</span></span><br><span class="line"><span class="number">2</span>      <span class="number">100.0</span>  <span class="number">2.527939</span> -<span class="number">0.067179</span> -<span class="number">2.925113</span></span><br><span class="line"><span class="number">3</span>      <span class="number">100.0</span>  <span class="number">3.260383</span>  <span class="number">0.065713</span> -<span class="number">2.315555</span></span><br><span class="line"><span class="number">4</span>      <span class="number">100.0</span>  <span class="number">2.074345</span> -<span class="number">0.111653</span> -<span class="number">2.047939</span></span><br><span class="line"><span class="number">5</span>      <span class="number">100.0</span>  <span class="number">2.184810</span>  <span class="number">0.052130</span> -<span class="number">2.989741</span></span><br><span class="line"><span class="number">6</span>      <span class="number">100.0</span>  <span class="number">2.458842</span> -<span class="number">0.021489</span> -<span class="number">2.223506</span></span><br><span class="line"><span class="number">7</span>      <span class="number">100.0</span>  <span class="number">2.954439</span> -<span class="number">0.026459</span> -<span class="number">3.056990</span></span><br><span class="line"><span class="number">8</span>      <span class="number">100.0</span>  <span class="number">2.735527</span>  <span class="number">0.103406</span> -<span class="number">3.745356</span></span><br><span class="line"><span class="number">9</span>      <span class="number">100.0</span>  <span class="number">2.377020</span>  <span class="number">0.220122</span> -<span class="number">2.064111</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们会在第12章详细讲解pandas的Categorical类型。</p>
<h2 id="示例用特定于分组的值填充缺失值">示例：用特定于分组的值填充缺失值</h2>
<p>对于缺失数据的清理工作，有时你会用dropna将其替换掉，而有时则可能会希望用一个固定值或由数据集本身所衍生出来的值去填充NA值。这时就得使用fillna这个工具了。在下面这个例子中，我用平均值去填充NA值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">91</span>]: s = pd.Series(np.random.randn(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: s[::<span class="number">2</span>] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="number">93</span>]: s</span><br><span class="line">Out[<span class="number">93</span>]: </span><br><span class="line"><span class="number">0</span>         NaN</span><br><span class="line"><span class="number">1</span>   -<span class="number">0.125921</span></span><br><span class="line"><span class="number">2</span>         NaN</span><br><span class="line"><span class="number">3</span>   -<span class="number">0.884475</span></span><br><span class="line"><span class="number">4</span>         NaN</span><br><span class="line"><span class="number">5</span>    <span class="number">0.227290</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: s.fillna(s.mean())</span><br><span class="line">Out[<span class="number">94</span>]: </span><br><span class="line"><span class="number">0</span>   -<span class="number">0.261035</span></span><br><span class="line"><span class="number">1</span>   -<span class="number">0.125921</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">0.261035</span></span><br><span class="line"><span class="number">3</span>   -<span class="number">0.884475</span></span><br><span class="line"><span class="number">4</span>   -<span class="number">0.261035</span></span><br><span class="line"><span class="number">5</span>    <span class="number">0.227290</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设你需要对不同的分组填充不同的值。一种方法是将数据分组，并使用apply和一个能够对各数据块调用fillna的函数即可。下面是一些有关美国几个州的示例数据，这些州又被分为东部和西部：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">95</span>]: states = [<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Vermont&#x27;</span>, <span class="string">&#x27;Florida&#x27;</span>,</span><br><span class="line">   ....:           <span class="string">&#x27;Oregon&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;Idaho&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">96</span>]: group_key = [<span class="string">&#x27;East&#x27;</span>] * <span class="number">4</span> + [<span class="string">&#x27;West&#x27;</span>] * <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: data = pd.Series(np.random.randn(<span class="number">8</span>), index=states)</span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: data</span><br><span class="line">Out[<span class="number">98</span>]: </span><br><span class="line">Ohio          <span class="number">0.922264</span></span><br><span class="line">New York     -<span class="number">2.153545</span></span><br><span class="line">Vermont      -<span class="number">0.365757</span></span><br><span class="line">Florida      -<span class="number">0.375842</span></span><br><span class="line">Oregon        <span class="number">0.329939</span></span><br><span class="line">Nevada        <span class="number">0.981994</span></span><br><span class="line">California    <span class="number">1.105913</span></span><br><span class="line">Idaho        -<span class="number">1.613716</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>['East'] * 4产生了一个列表，包括了['East']中元素的四个拷贝。将这些列表串联起来。</p>
<p>将一些值设为缺失：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">99</span>]: data[[<span class="string">&#x27;Vermont&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Idaho&#x27;</span>]] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: data</span><br><span class="line">Out[<span class="number">100</span>]: </span><br><span class="line">Ohio          <span class="number">0.922264</span></span><br><span class="line">New York     -<span class="number">2.153545</span></span><br><span class="line">Vermont            NaN</span><br><span class="line">Florida      -<span class="number">0.375842</span></span><br><span class="line">Oregon        <span class="number">0.329939</span></span><br><span class="line">Nevada             NaN</span><br><span class="line">California    <span class="number">1.105913</span></span><br><span class="line">Idaho              NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">101</span>]: data.groupby(group_key).mean()</span><br><span class="line">Out[<span class="number">101</span>]: </span><br><span class="line">East   -<span class="number">0.535707</span></span><br><span class="line">West    <span class="number">0.717926</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以用分组平均值去填充NA值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">102</span>]: fill_mean = <span class="keyword">lambda</span> g: g.fillna(g.mean())</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: data.groupby(group_key).apply(fill_mean)</span><br><span class="line">Out[<span class="number">103</span>]: </span><br><span class="line">Ohio          <span class="number">0.922264</span></span><br><span class="line">New York     -<span class="number">2.153545</span></span><br><span class="line">Vermont      -<span class="number">0.535707</span></span><br><span class="line">Florida      -<span class="number">0.375842</span></span><br><span class="line">Oregon        <span class="number">0.329939</span></span><br><span class="line">Nevada        <span class="number">0.717926</span></span><br><span class="line">California    <span class="number">1.105913</span></span><br><span class="line">Idaho         <span class="number">0.717926</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外，也可以在代码中预定义各组的填充值。由于分组具有一个name属性，所以我们可以拿来用一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">104</span>]: fill_values = &#123;<span class="string">&#x27;East&#x27;</span>: <span class="number">0.5</span>, <span class="string">&#x27;West&#x27;</span>: -<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: fill_func = <span class="keyword">lambda</span> g: g.fillna(fill_values[g.name])</span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: data.groupby(group_key).apply(fill_func)</span><br><span class="line">Out[<span class="number">106</span>]: </span><br><span class="line">Ohio          <span class="number">0.922264</span></span><br><span class="line">New York     -<span class="number">2.153545</span></span><br><span class="line">Vermont       <span class="number">0.500000</span></span><br><span class="line">Florida      -<span class="number">0.375842</span></span><br><span class="line">Oregon        <span class="number">0.329939</span></span><br><span class="line">Nevada       -<span class="number">1.000000</span></span><br><span class="line">California    <span class="number">1.105913</span></span><br><span class="line">Idaho        -<span class="number">1.000000</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="示例随机采样和排列">示例：随机采样和排列</h2>
<p>假设你想要从一个大数据集中随机抽取（进行替换或不替换）样本以进行蒙特卡罗模拟（Monte Carlo simulation）或其他分析工作。“抽取”的方式有很多，这里使用的方法是对Series使用sample方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hearts, Spades, Clubs, Diamonds</span></span><br><span class="line">suits = [<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">card_val = (<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)) + [<span class="number">10</span>] * <span class="number">3</span>) * <span class="number">4</span></span><br><span class="line">base_names = [<span class="string">&#x27;A&#x27;</span>] + <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>)) + [<span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>]</span><br><span class="line">cards = []</span><br><span class="line"><span class="keyword">for</span> suit <span class="keyword">in</span> [<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]:</span><br><span class="line">    cards.extend(<span class="built_in">str</span>(num) + suit <span class="keyword">for</span> num <span class="keyword">in</span> base_names)</span><br><span class="line"></span><br><span class="line">deck = pd.Series(card_val, index=cards)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在我有了一个长度为52的Series，其索引包括牌名，值则是21点或其他游戏中用于计分的点数（为了简单起见，我当A的点数为1）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">108</span>]: deck[:<span class="number">13</span>]</span><br><span class="line">Out[<span class="number">108</span>]: </span><br><span class="line">AH      <span class="number">1</span></span><br><span class="line">2H      <span class="number">2</span></span><br><span class="line">3H      <span class="number">3</span></span><br><span class="line">4H      <span class="number">4</span></span><br><span class="line">5H      <span class="number">5</span></span><br><span class="line">6H      <span class="number">6</span></span><br><span class="line">7H      <span class="number">7</span></span><br><span class="line">8H      <span class="number">8</span></span><br><span class="line">9H      <span class="number">9</span></span><br><span class="line">10H    <span class="number">10</span></span><br><span class="line">JH     <span class="number">10</span></span><br><span class="line">KH     <span class="number">10</span></span><br><span class="line">QH     <span class="number">10</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，根据我上面所讲的，从整副牌中抽出5张，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">109</span>]: <span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">deck, n=<span class="number">5</span></span>):</span></span><br><span class="line">   .....:     <span class="keyword">return</span> deck.sample(n)</span><br><span class="line"></span><br><span class="line">In [<span class="number">110</span>]: draw(deck)</span><br><span class="line">Out[<span class="number">110</span>]: </span><br><span class="line">AD     <span class="number">1</span></span><br><span class="line">8C     <span class="number">8</span></span><br><span class="line">5H     <span class="number">5</span></span><br><span class="line">KC    <span class="number">10</span></span><br><span class="line">2C     <span class="number">2</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设你想要从每种花色中随机抽取两张牌。由于花色是牌名的最后一个字符，所以我们可以据此进行分组，并使用apply：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">111</span>]: get_suit = <span class="keyword">lambda</span> card: card[-<span class="number">1</span>] <span class="comment"># last letter is suit</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">112</span>]: deck.groupby(get_suit).apply(draw, n=<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">112</span>]: </span><br><span class="line">C  2C     <span class="number">2</span></span><br><span class="line">   3C     <span class="number">3</span></span><br><span class="line">D  KD    <span class="number">10</span></span><br><span class="line">   8D     <span class="number">8</span></span><br><span class="line">H  KH    <span class="number">10</span></span><br><span class="line">   3H     <span class="number">3</span></span><br><span class="line">S  2S     <span class="number">2</span></span><br><span class="line">   4S     <span class="number">4</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或者，也可以这样写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">113</span>]: deck.groupby(get_suit, group_keys=<span class="literal">False</span>).apply(draw, n=<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">113</span>]: </span><br><span class="line">KC    <span class="number">10</span></span><br><span class="line">JC    <span class="number">10</span></span><br><span class="line">AD     <span class="number">1</span></span><br><span class="line">5D     <span class="number">5</span></span><br><span class="line">5H     <span class="number">5</span></span><br><span class="line">6H     <span class="number">6</span></span><br><span class="line">7S     <span class="number">7</span></span><br><span class="line">KS    <span class="number">10</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="示例分组加权平均数和相关系数">示例：分组加权平均数和相关系数</h2>
<p>根据groupby的“拆分－应用－合并”范式，可以进行DataFrame的列与列之间或两个Series之间的运算（比如分组加权平均）。以下面这个数据集为例，它含有分组键、值以及一些权重值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">114</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;category&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">   .....:                                 <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">   .....:                    <span class="string">&#x27;data&#x27;</span>: np.random.randn(<span class="number">8</span>),</span><br><span class="line">   .....:                    <span class="string">&#x27;weights&#x27;</span>: np.random.rand(<span class="number">8</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">115</span>]: df</span><br><span class="line">Out[<span class="number">115</span>]: </span><br><span class="line">  category      data   weights</span><br><span class="line"><span class="number">0</span>        a  <span class="number">1.561587</span>  <span class="number">0.957515</span></span><br><span class="line"><span class="number">1</span>        a  <span class="number">1.219984</span>  <span class="number">0.347267</span></span><br><span class="line"><span class="number">2</span>        a -<span class="number">0.482239</span>  <span class="number">0.581362</span></span><br><span class="line"><span class="number">3</span>        a  <span class="number">0.315667</span>  <span class="number">0.217091</span></span><br><span class="line"><span class="number">4</span>        b -<span class="number">0.047852</span>  <span class="number">0.894406</span></span><br><span class="line"><span class="number">5</span>        b -<span class="number">0.454145</span>  <span class="number">0.918564</span></span><br><span class="line"><span class="number">6</span>        b -<span class="number">0.556774</span>  <span class="number">0.277825</span></span><br><span class="line"><span class="number">7</span>        b  <span class="number">0.253321</span>  <span class="number">0.955905</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后可以利用category计算分组加权平均数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">116</span>]: grouped = df.groupby(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">117</span>]: get_wavg = <span class="keyword">lambda</span> g: np.average(g[<span class="string">&#x27;data&#x27;</span>], weights=g[<span class="string">&#x27;weights&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: grouped.apply(get_wavg)</span><br><span class="line">Out[<span class="number">118</span>]:</span><br><span class="line">category</span><br><span class="line">a    <span class="number">0.811643</span></span><br><span class="line">b   -<span class="number">0.122262</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另一个例子，考虑一个来自Yahoo!Finance的数据集，其中含有几只股票和标准普尔500指数（符号SPX）的收盘价：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">119</span>]: close_px = pd.read_csv(<span class="string">&#x27;examples/stock_px_2.csv&#x27;</span>, parse_dates=<span class="literal">True</span>,</span><br><span class="line">   .....:                        index_col=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: close_px.info()</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">DatetimeIndex</span>:</span> <span class="number">2214</span> entries, <span class="number">2003</span>-01-02 to <span class="number">2011</span>-<span class="number">10</span>-<span class="number">14</span></span><br><span class="line">Data columns (total <span class="number">4</span> columns):</span><br><span class="line">AAPL    <span class="number">2214</span> non-null float64</span><br><span class="line">MSFT    <span class="number">2214</span> non-null float64</span><br><span class="line">XOM     <span class="number">2214</span> non-null float64</span><br><span class="line">SPX     <span class="number">2214</span> non-null float64</span><br><span class="line">dtypes: float64(<span class="number">4</span>)</span><br><span class="line">memory usage: <span class="number">86.5</span> KB</span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: close_px[-<span class="number">4</span>:]</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line">              AAPL   MSFT    XOM      SPX</span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">11</span>  <span class="number">400.29</span>  <span class="number">27.00</span>  <span class="number">76.27</span>  <span class="number">1195.54</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">12</span>  <span class="number">402.19</span>  <span class="number">26.96</span>  <span class="number">77.16</span>  <span class="number">1207.25</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">13</span>  <span class="number">408.43</span>  <span class="number">27.18</span>  <span class="number">76.37</span>  <span class="number">1203.66</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">14</span>  <span class="number">422.00</span>  <span class="number">27.27</span>  <span class="number">78.11</span>  <span class="number">1224.58</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>来做一个比较有趣的任务：计算一个由日收益率（通过百分数变化计算）与SPX之间的年度相关系数组成的DataFrame。下面是一个实现办法，我们先创建一个函数，用它计算每列和SPX列的成对相关系数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">122</span>]: spx_corr = <span class="keyword">lambda</span> x: x.corrwith(x[<span class="string">&#x27;SPX&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来，我们使用pct_change计算close_px的百分比变化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">123</span>]: rets = close_px.pct_change().dropna()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后，我们用年对百分比变化进行分组，可以用一个一行的函数，从每行的标签返回每个datetime标签的year属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">124</span>]: get_year = <span class="keyword">lambda</span> x: x.year</span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: by_year = rets.groupby(get_year)</span><br><span class="line"></span><br><span class="line">In [<span class="number">126</span>]: by_year.apply(spx_corr)</span><br><span class="line">Out[<span class="number">126</span>]: </span><br><span class="line">          AAPL      MSFT       XOM  SPX</span><br><span class="line"><span class="number">2003</span>  <span class="number">0.541124</span>  <span class="number">0.745174</span>  <span class="number">0.661265</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2004</span>  <span class="number">0.374283</span>  <span class="number">0.588531</span>  <span class="number">0.557742</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2005</span>  <span class="number">0.467540</span>  <span class="number">0.562374</span>  <span class="number">0.631010</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2006</span>  <span class="number">0.428267</span>  <span class="number">0.406126</span>  <span class="number">0.518514</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2007</span>  <span class="number">0.508118</span>  <span class="number">0.658770</span>  <span class="number">0.786264</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2008</span>  <span class="number">0.681434</span>  <span class="number">0.804626</span>  <span class="number">0.828303</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2009</span>  <span class="number">0.707103</span>  <span class="number">0.654902</span>  <span class="number">0.797921</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2010</span>  <span class="number">0.710105</span>  <span class="number">0.730118</span>  <span class="number">0.839057</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2011</span>  <span class="number">0.691931</span>  <span class="number">0.800996</span>  <span class="number">0.859975</span>  <span class="number">1.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然，你还可以计算列与列之间的相关系数。这里，我们计算Apple和Microsoft的年相关系数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">127</span>]: by_year.apply(<span class="keyword">lambda</span> g: g[<span class="string">&#x27;AAPL&#x27;</span>].corr(g[<span class="string">&#x27;MSFT&#x27;</span>]))</span><br><span class="line">Out[<span class="number">127</span>]: </span><br><span class="line"><span class="number">2003</span>    <span class="number">0.480868</span></span><br><span class="line"><span class="number">2004</span>    <span class="number">0.259024</span></span><br><span class="line"><span class="number">2005</span>    <span class="number">0.300093</span></span><br><span class="line"><span class="number">2006</span>    <span class="number">0.161735</span></span><br><span class="line"><span class="number">2007</span>    <span class="number">0.417738</span></span><br><span class="line"><span class="number">2008</span>    <span class="number">0.611901</span></span><br><span class="line"><span class="number">2009</span>    <span class="number">0.432738</span></span><br><span class="line"><span class="number">2010</span>    <span class="number">0.571946</span></span><br><span class="line"><span class="number">2011</span>    <span class="number">0.581987</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="示例组级别的线性回归">示例：组级别的线性回归</h2>
<p>顺着上一个例子继续，你可以用groupby执行更为复杂的分组统计分析，只要函数返回的是pandas对象或标量值即可。例如，我可以定义下面这个regress函数（利用statsmodels计量经济学库）对各数据块执行普通最小二乘法（Ordinary Least Squares，OLS）回归：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">regress</span>(<span class="params">data, yvar, xvars</span>):</span></span><br><span class="line">    Y = data[yvar]</span><br><span class="line">    X = data[xvars]</span><br><span class="line">    X[<span class="string">&#x27;intercept&#x27;</span>] = <span class="number">1.</span></span><br><span class="line">    result = sm.OLS(Y, X).fit()</span><br><span class="line">    <span class="keyword">return</span> result.params</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，为了按年计算AAPL对SPX收益率的线性回归，执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">129</span>]: by_year.apply(regress, <span class="string">&#x27;AAPL&#x27;</span>, [<span class="string">&#x27;SPX&#x27;</span>])</span><br><span class="line">Out[<span class="number">129</span>]: </span><br><span class="line">           SPX  intercept</span><br><span class="line"><span class="number">2003</span>  <span class="number">1.195406</span>   <span class="number">0.000710</span></span><br><span class="line"><span class="number">2004</span>  <span class="number">1.363463</span>   <span class="number">0.004201</span></span><br><span class="line"><span class="number">2005</span>  <span class="number">1.766415</span>   <span class="number">0.003246</span></span><br><span class="line"><span class="number">2006</span>  <span class="number">1.645496</span>   <span class="number">0.000080</span></span><br><span class="line"><span class="number">2007</span>  <span class="number">1.198761</span>   <span class="number">0.003438</span></span><br><span class="line"><span class="number">2008</span>  <span class="number">0.968016</span>  -<span class="number">0.001110</span></span><br><span class="line"><span class="number">2009</span>  <span class="number">0.879103</span>   <span class="number">0.002954</span></span><br><span class="line"><span class="number">2010</span>  <span class="number">1.052608</span>   <span class="number">0.001261</span></span><br><span class="line"><span class="number">2011</span>  <span class="number">0.806605</span>   <span class="number">0.001514</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="透视表和交叉表">10.4 透视表和交叉表</h1>
<p>透视表（pivot table）是各种电子表格程序和其他数据分析软件中一种常见的数据汇总工具。它根据一个或多个键对数据进行聚合，并根据行和列上的分组键将数据分配到各个矩形区域中。在Python和pandas中，可以通过本章所介绍的groupby功能以及（能够利用层次化索引的）重塑运算制作透视表。DataFrame有一个pivot_table方法，此外还有一个顶级的pandas.pivot_table函数。除能为groupby提供便利之外，pivot_table还可以添加分项小计，也叫做margins。</p>
<p>回到小费数据集，假设我想要根据day和smoker计算分组平均数（pivot_table的默认聚合类型），并将day和smoker放到行上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">130</span>]: tips.pivot_table(index=[<span class="string">&#x27;day&#x27;</span>, <span class="string">&#x27;smoker&#x27;</span>])</span><br><span class="line">Out[<span class="number">130</span>]: </span><br><span class="line">                 size       tip   tip_pct  total_bill</span><br><span class="line">day  smoker                                          </span><br><span class="line">Fri  No      <span class="number">2.250000</span>  <span class="number">2.812500</span>  <span class="number">0.151650</span>   <span class="number">18.420000</span></span><br><span class="line">     Yes     <span class="number">2.066667</span>  <span class="number">2.714000</span>  <span class="number">0.174783</span>   <span class="number">16.813333</span></span><br><span class="line">Sat  No      <span class="number">2.555556</span>  <span class="number">3.102889</span>  <span class="number">0.158048</span>   <span class="number">19.661778</span></span><br><span class="line">     Yes     <span class="number">2.476190</span>  <span class="number">2.875476</span>  <span class="number">0.147906</span>   <span class="number">21.276667</span></span><br><span class="line">Sun  No      <span class="number">2.929825</span>  <span class="number">3.167895</span>  <span class="number">0.160113</span>   <span class="number">20.506667</span></span><br><span class="line">     Yes     <span class="number">2.578947</span>  <span class="number">3.516842</span>  <span class="number">0.187250</span>   <span class="number">24.120000</span></span><br><span class="line">Thur No      <span class="number">2.488889</span>  <span class="number">2.673778</span>  <span class="number">0.160298</span>   <span class="number">17.113111</span></span><br><span class="line">     Yes     <span class="number">2.352941</span>  <span class="number">3.030000</span>  <span class="number">0.163863</span>   <span class="number">19.190588</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以用groupby直接来做。现在，假设我们只想聚合tip_pct和size，而且想根据time进行分组。我将smoker放到列上，把day放到行上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">131</span>]: tips.pivot_table([<span class="string">&#x27;tip_pct&#x27;</span>, <span class="string">&#x27;size&#x27;</span>], index=[<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;day&#x27;</span>],</span><br><span class="line">   .....:                  columns=<span class="string">&#x27;smoker&#x27;</span>)</span><br><span class="line">Out[<span class="number">131</span>]: </span><br><span class="line">                 size             tip_pct          </span><br><span class="line">smoker             No       Yes        No       Yes</span><br><span class="line">time   day                                         </span><br><span class="line">Dinner Fri   <span class="number">2.000000</span>  <span class="number">2.222222</span>  <span class="number">0.139622</span>  <span class="number">0.165347</span></span><br><span class="line">       Sat   <span class="number">2.555556</span>  <span class="number">2.476190</span>  <span class="number">0.158048</span>  <span class="number">0.147906</span></span><br><span class="line">       Sun   <span class="number">2.929825</span>  <span class="number">2.578947</span>  <span class="number">0.160113</span>  <span class="number">0.187250</span></span><br><span class="line">       Thur  <span class="number">2.000000</span>       NaN  <span class="number">0.159744</span>       NaN</span><br><span class="line">Lunch  Fri   <span class="number">3.000000</span>  <span class="number">1.833333</span>  <span class="number">0.187735</span>  <span class="number">0.188937</span></span><br><span class="line">       Thur  <span class="number">2.500000</span>  <span class="number">2.352941</span>  <span class="number">0.160311</span>  <span class="number">0.163863</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还可以对这个表作进一步的处理，传入margins=True添加分项小计。这将会添加标签为All的行和列，其值对应于单个等级中所有数据的分组统计：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">132</span>]: tips.pivot_table([<span class="string">&#x27;tip_pct&#x27;</span>, <span class="string">&#x27;size&#x27;</span>], index=[<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;day&#x27;</span>],</span><br><span class="line">   .....:                  columns=<span class="string">&#x27;smoker&#x27;</span>, margins=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">132</span>]: </span><br><span class="line">                 size                       tip_pct                    </span><br><span class="line">smoker             No       Yes       All        No       Yes       All</span><br><span class="line">time   day                                                             </span><br><span class="line">Dinner Fri   <span class="number">2.000000</span>  <span class="number">2.222222</span>  <span class="number">2.166667</span>  <span class="number">0.139622</span>  <span class="number">0.165347</span>  <span class="number">0.158916</span></span><br><span class="line">       Sat   <span class="number">2.555556</span>  <span class="number">2.476190</span>  <span class="number">2.517241</span>  <span class="number">0.158048</span>  <span class="number">0.147906</span>  <span class="number">0.153152</span></span><br><span class="line">       Sun   <span class="number">2.929825</span>  <span class="number">2.578947</span>  <span class="number">2.842105</span>  <span class="number">0.160113</span>  <span class="number">0.187250</span>  <span class="number">0.166897</span></span><br><span class="line">       Thur  <span class="number">2.000000</span>       NaN  <span class="number">2.000000</span>  <span class="number">0.159744</span>       NaN  <span class="number">0.159744</span></span><br><span class="line">Lunch  Fri   <span class="number">3.000000</span>  <span class="number">1.833333</span>  <span class="number">2.000000</span>  <span class="number">0.187735</span>  <span class="number">0.188937</span>  <span class="number">0.188765</span></span><br><span class="line">       Thur  <span class="number">2.500000</span>  <span class="number">2.352941</span>  <span class="number">2.459016</span>  <span class="number">0.160311</span>  <span class="number">0.163863</span>  <span class="number">0.161301</span></span><br><span class="line">All          <span class="number">2.668874</span>  <span class="number">2.408602</span>  <span class="number">2.569672</span>  <span class="number">0.159328</span>  <span class="number">0.163196</span>  <span class="number">0.160803</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，All值为平均数：不单独考虑烟民与非烟民（All列），不单独考虑行分组两个级别中的任何单项（All行）。</p>
<p>要使用其他的聚合函数，将其传给aggfunc即可。例如，使用count或len可以得到有关分组大小的交叉表（计数或频率）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">133</span>]: tips.pivot_table(<span class="string">&#x27;tip_pct&#x27;</span>, index=[<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;smoker&#x27;</span>], columns=<span class="string">&#x27;day&#x27;</span>,</span><br><span class="line">   .....:                  aggfunc=<span class="built_in">len</span>, margins=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">133</span>]: </span><br><span class="line">day             Fri   Sat   Sun  Thur    All</span><br><span class="line">time   smoker                               </span><br><span class="line">Dinner No       <span class="number">3.0</span>  <span class="number">45.0</span>  <span class="number">57.0</span>   <span class="number">1.0</span>  <span class="number">106.0</span></span><br><span class="line">       Yes      <span class="number">9.0</span>  <span class="number">42.0</span>  <span class="number">19.0</span>   NaN   <span class="number">70.0</span></span><br><span class="line">Lunch  No       <span class="number">1.0</span>   NaN   NaN  <span class="number">44.0</span>   <span class="number">45.0</span></span><br><span class="line">       Yes      <span class="number">6.0</span>   NaN   NaN  <span class="number">17.0</span>   <span class="number">23.0</span></span><br><span class="line">All            <span class="number">19.0</span>  <span class="number">87.0</span>  <span class="number">76.0</span>  <span class="number">62.0</span>  <span class="number">244.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果存在空的组合（也就是NA），你可能会希望设置一个fill_value：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">134</span>]: tips.pivot_table(<span class="string">&#x27;tip_pct&#x27;</span>, index=[<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;size&#x27;</span>, <span class="string">&#x27;smoker&#x27;</span>],</span><br><span class="line">   .....:                  columns=<span class="string">&#x27;day&#x27;</span>, aggfunc=<span class="string">&#x27;mean&#x27;</span>, fill_value=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">134</span>]: </span><br><span class="line">day                      Fri       Sat       Sun      Thur</span><br><span class="line">time   size smoker                                        </span><br><span class="line">Dinner <span class="number">1</span>    No      <span class="number">0.000000</span>  <span class="number">0.137931</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line">            Yes     <span class="number">0.000000</span>  <span class="number">0.325733</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line">       <span class="number">2</span>    No      <span class="number">0.139622</span>  <span class="number">0.162705</span>  <span class="number">0.168859</span>  <span class="number">0.159744</span></span><br><span class="line">            Yes     <span class="number">0.171297</span>  <span class="number">0.148668</span>  <span class="number">0.207893</span>  <span class="number">0.000000</span></span><br><span class="line">       <span class="number">3</span>    No      <span class="number">0.000000</span>  <span class="number">0.154661</span>  <span class="number">0.152663</span>  <span class="number">0.000000</span></span><br><span class="line">            Yes     <span class="number">0.000000</span>  <span class="number">0.144995</span>  <span class="number">0.152660</span>  <span class="number">0.000000</span></span><br><span class="line">       <span class="number">4</span>    No      <span class="number">0.000000</span>  <span class="number">0.150096</span>  <span class="number">0.148143</span>  <span class="number">0.000000</span></span><br><span class="line">            Yes     <span class="number">0.117750</span>  <span class="number">0.124515</span>  <span class="number">0.193370</span>  <span class="number">0.000000</span></span><br><span class="line">       <span class="number">5</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.206928</span>  <span class="number">0.000000</span></span><br><span class="line">Yes     <span class="number">0.000000</span>  <span class="number">0.106572</span>  <span class="number">0.065660</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="meta">... </span>                     ...       ...       ...       ...</span><br><span class="line">Lunch  <span class="number">1</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.181728</span></span><br><span class="line">            Yes     <span class="number">0.223776</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line">       <span class="number">2</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.166005</span></span><br><span class="line">            Yes     <span class="number">0.181969</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.158843</span></span><br><span class="line">       <span class="number">3</span>    No      <span class="number">0.187735</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.084246</span></span><br><span class="line">            Yes     <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.204952</span></span><br><span class="line">       <span class="number">4</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.138919</span></span><br><span class="line">            Yes     <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.155410</span></span><br><span class="line">       <span class="number">5</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.121389</span></span><br><span class="line">       <span class="number">6</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.173706</span></span><br><span class="line">[<span class="number">21</span> rows x <span class="number">4</span> columns]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>pivot_table的参数说明请参见表10-2。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-c9e01844c4803a42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表10-2 pivot_table的选项" /><figcaption aria-hidden="true">表10-2 pivot_table的选项</figcaption>
</figure>
<h2 id="交叉表crosstab">交叉表：crosstab</h2>
<p>交叉表（cross-tabulation，简称crosstab）是一种用于计算分组频率的特殊透视表。看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">138</span>]: data</span><br><span class="line">Out[<span class="number">138</span>]:</span><br><span class="line">   Sample Nationality    Handedness</span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>         USA  Right-handed</span><br><span class="line"><span class="number">1</span>       <span class="number">2</span>       Japan   Left-handed</span><br><span class="line"><span class="number">2</span>       <span class="number">3</span>         USA  Right-handed</span><br><span class="line"><span class="number">3</span>       <span class="number">4</span>       Japan  Right-handed</span><br><span class="line"><span class="number">4</span>       <span class="number">5</span>       Japan   Left-handed</span><br><span class="line"><span class="number">5</span>       <span class="number">6</span>       Japan  Right-handed</span><br><span class="line"><span class="number">6</span>       <span class="number">7</span>         USA  Right-handed</span><br><span class="line"><span class="number">7</span>       <span class="number">8</span>         USA   Left-handed</span><br><span class="line"><span class="number">8</span>       <span class="number">9</span>       Japan  Right-handed</span><br><span class="line"><span class="number">9</span>      <span class="number">10</span>         USA  Right-handed</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>作为调查分析的一部分，我们可能想要根据国籍和用手习惯对这段数据进行统计汇总。虽然可以用pivot_table实现该功能，但是pandas.crosstab函数会更方便：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">139</span>]: pd.crosstab(data.Nationality, data.Handedness, margins=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">139</span>]: </span><br><span class="line">Handedness   Left-handed  Right-handed  All</span><br><span class="line">Nationality</span><br><span class="line">Japan                  <span class="number">2</span>             <span class="number">3</span>    <span class="number">5</span></span><br><span class="line">USA                    <span class="number">1</span>             <span class="number">4</span>    <span class="number">5</span></span><br><span class="line">All                    <span class="number">3</span>             <span class="number">7</span>   <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>crosstab的前两个参数可以是数组或Series，或是数组列表。就像小费数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">140</span>]: pd.crosstab([tips.time, tips.day], tips.smoker, margins=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">140</span>]: </span><br><span class="line">smoker        No  Yes  All</span><br><span class="line">time   day                </span><br><span class="line">Dinner Fri     <span class="number">3</span>    <span class="number">9</span>   <span class="number">12</span></span><br><span class="line">       Sat    <span class="number">45</span>   <span class="number">42</span>   <span class="number">87</span></span><br><span class="line">       Sun    <span class="number">57</span>   <span class="number">19</span>   <span class="number">76</span></span><br><span class="line">       Thur    <span class="number">1</span>    <span class="number">0</span>    <span class="number">1</span></span><br><span class="line">Lunch  Fri     <span class="number">1</span>    <span class="number">6</span>    <span class="number">7</span></span><br><span class="line">       Thur   <span class="number">44</span>   <span class="number">17</span>   <span class="number">61</span></span><br><span class="line">All          <span class="number">151</span>   <span class="number">93</span>  <span class="number">244</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="总结">10.5 总结</h1>
<p>掌握pandas数据分组工具既有助于数据清理，也有助于建模或统计分析工作。在第14章，我们会看几个例子，对真实数据使用groupby。</p>
<p>在下一章，我们将关注时间序列数据。</p>
]]></content>
      <categories>
        <category>Python 数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>第11章 时间序列</title>
    <url>/2019/04/09/%E7%AC%AC11%E7%AB%A0-%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>时间序列（time series）数据是一种重要的结构化数据形式，应用于多个领域，包括金融学、经济学、生态学、神经科学、物理学等。在多个时间点观察或测量到的任何事物都可以形成一段时间序列。<span id="more"></span>很多时间序列是固定频率的，也就是说，数据点是根据某种规律定期出现的（比如每15秒、每5分钟、每月出现一次）。时间序列也可以是不定期的，没有固定的时间单位或单位之间的偏移量。时间序列数据的意义取决于具体的应用场景，主要有以下几种：</p>
<ul>
<li>时间戳（timestamp），特定的时刻。</li>
<li>固定时期（period），如2007年1月或2010年全年。</li>
<li>时间间隔（interval），由起始和结束时间戳表示。时期（period）可以被看做间隔（interval）的特例。</li>
<li>实验或过程时间，每个时间点都是相对于特定起始时间的一个度量。例如，从放入烤箱时起，每秒钟饼干的直径。</li>
</ul>
<p>本章主要讲解前3种时间序列。许多技术都可用于处理实验型时间序列，其索引可能是一个整数或浮点数（表示从实验开始算起已经过去的时间）。最简单也最常见的时间序列都是用时间戳进行索引的。</p>
<blockquote>
<p>提示：pandas也支持基于timedeltas的指数，它可以有效代表实验或经过的时间。这本书不涉及timedelta指数，但你可以学习pandas的文档（http://pandas.pydata.org/）。</p>
</blockquote>
<p>pandas提供了许多内置的时间序列处理工具和数据算法。因此，你可以高效处理非常大的时间序列，轻松地进行切片/切块、聚合、对定期/不定期的时间序列进行重采样等。有些工具特别适合金融和经济应用，你当然也可以用它们来分析服务器日志数据。</p>
<h1 id="日期和时间数据类型及工具">11.1 日期和时间数据类型及工具</h1>
<p>Python标准库包含用于日期（date）和时间（time）数据的数据类型，而且还有日历方面的功能。我们主要会用到datetime、time以及calendar模块。datetime.datetime（也可以简写为datetime）是用得最多的数据类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: <span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: now = datetime.now()</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: now</span><br><span class="line">Out[<span class="number">12</span>]: datetime.datetime(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">25</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">52</span>, <span class="number">72973</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: now.year, now.month, now.day</span><br><span class="line">Out[<span class="number">13</span>]: (<span class="number">2017</span>, <span class="number">9</span>, <span class="number">25</span>)</span><br></pre></td></tr></table></figure>
<p>datetime以毫秒形式存储日期和时间。timedelta表示两个datetime对象之间的时间差：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">14</span>]: delta = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>) - datetime(<span class="number">2008</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">8</span>, <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: delta</span><br><span class="line">Out[<span class="number">15</span>]: datetime.timedelta(<span class="number">926</span>, <span class="number">56700</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: delta.days</span><br><span class="line">Out[<span class="number">16</span>]: <span class="number">926</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: delta.seconds</span><br><span class="line">Out[<span class="number">17</span>]: <span class="number">56700</span></span><br></pre></td></tr></table></figure>
<p>可以给datetime对象加上（或减去）一个或多个timedelta，这样会产生一个新对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: <span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: start = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: start + timedelta(<span class="number">12</span>)</span><br><span class="line">Out[<span class="number">20</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">19</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: start - <span class="number">2</span> * timedelta(<span class="number">12</span>)</span><br><span class="line">Out[<span class="number">21</span>]: datetime.datetime(<span class="number">2010</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>datetime模块中的数据类型参见表10-1。虽然本章主要讲的是pandas数据类型和高级时间序列处理，但你肯定会在Python的其他地方遇到有关datetime的数据类型。</p>
<p>表11-1 datetime模块中的数据类型</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-4af261a305a70aeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>tzinfo 存储时区信息的基本类型</p>
<h2 id="字符串和datetime的相互转换">字符串和datetime的相互转换</h2>
<p>利用str或strftime方法（传入一个格式化字符串），datetime对象和pandas的Timestamp对象（稍后就会介绍）可以被格式化为字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">22</span>]: stamp = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: <span class="built_in">str</span>(stamp)</span><br><span class="line">Out[<span class="number">23</span>]: <span class="string">&#x27;2011-01-03 00:00:00&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: stamp.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">Out[<span class="number">24</span>]: <span class="string">&#x27;2011-01-03&#x27;</span></span><br></pre></td></tr></table></figure>
<p>表11-2列出了全部的格式化编码。</p>
<p>表11-2 datetime格式定义（兼容ISO C89）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-50c751823754df58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-de0181e1f6b45eaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>datetime.strptime可以用这些格式化编码将字符串转换为日期：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: value = <span class="string">&#x27;2011-01-03&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: datetime.strptime(value, <span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">Out[<span class="number">26</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: datestrs = [<span class="string">&#x27;7/6/2011&#x27;</span>, <span class="string">&#x27;8/6/2011&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: [datetime.strptime(x, <span class="string">&#x27;%m/%d/%Y&#x27;</span>) <span class="keyword">for</span> x <span class="keyword">in</span> datestrs]</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">[datetime.datetime(<span class="number">2011</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line"> datetime.datetime(<span class="number">2011</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>)]</span><br></pre></td></tr></table></figure>
<p>datetime.strptime是通过已知格式进行日期解析的最佳方式。但是每次都要编写格式定义是很麻烦的事情，尤其是对于一些常见的日期格式。这种情况下，你可以用dateutil这个第三方包中的parser.parse方法（pandas中已经自动安装好了）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">29</span>]: <span class="keyword">from</span> dateutil.parser <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: parse(<span class="string">&#x27;2011-01-03&#x27;</span>)</span><br><span class="line">Out[<span class="number">30</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>dateutil可以解析几乎所有人类能够理解的日期表示形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">31</span>]: parse(<span class="string">&#x27;Jan 31, 1997 10:45 PM&#x27;</span>)</span><br><span class="line">Out[<span class="number">31</span>]: datetime.datetime(<span class="number">1997</span>, <span class="number">1</span>, <span class="number">31</span>, <span class="number">22</span>, <span class="number">45</span>)</span><br></pre></td></tr></table></figure>
<p>在国际通用的格式中，日出现在月的前面很普遍，传入dayfirst=True即可解决这个问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">32</span>]: parse(<span class="string">&#x27;6/12/2011&#x27;</span>, dayfirst=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">32</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>pandas通常是用于处理成组日期的，不管这些日期是DataFrame的轴索引还是列。to_datetime方法可以解析多种不同的日期表示形式。对标准日期格式（如ISO8601）的解析非常快：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">33</span>]: datestrs = [<span class="string">&#x27;2011-07-06 12:00:00&#x27;</span>, <span class="string">&#x27;2011-08-06 00:00:00&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: pd.to_datetime(datestrs)</span><br><span class="line">Out[<span class="number">34</span>]: DatetimeIndex([<span class="string">&#x27;2011-07-06 12:00:00&#x27;</span>, <span class="string">&#x27;2011-08-06 00:00:00&#x27;</span>], dtype=<span class="string">&#x27;dat</span></span><br><span class="line"><span class="string">etime64[ns]&#x27;</span>, freq=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>它还可以处理缺失值（None、空字符串等）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">35</span>]: idx = pd.to_datetime(datestrs + [<span class="literal">None</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: idx</span><br><span class="line">Out[<span class="number">36</span>]: DatetimeIndex([<span class="string">&#x27;2011-07-06 12:00:00&#x27;</span>, <span class="string">&#x27;2011-08-06 00:00:00&#x27;</span>, <span class="string">&#x27;NaT&#x27;</span>], dty</span><br><span class="line">pe=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: idx[<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">37</span>]: NaT</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: pd.isnull(idx)</span><br><span class="line">Out[<span class="number">38</span>]: array([<span class="literal">False</span>, <span class="literal">False</span>,  <span class="literal">True</span>], dtype=<span class="built_in">bool</span>)</span><br></pre></td></tr></table></figure>
<p>NaT（Not a Time）是pandas中时间戳数据的null值。</p>
<blockquote>
<p>注意：dateutil.parser是一个实用但不完美的工具。比如说，它会把一些原本不是日期的字符串认作是日期（比如"42"会被解析为2042年的今天）。</p>
</blockquote>
<p>datetime对象还有一些特定于当前环境（位于不同国家或使用不同语言的系统）的格式化选项。例如，德语或法语系统所用的月份简写就与英语系统所用的不同。表11-3进行了总结。</p>
<p>表11-3 特定于当前环境的日期格式</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-cf0119398273e2b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<h1 id="时间序列基础">11.2 时间序列基础</h1>
<p>pandas最基本的时间序列类型就是以时间戳（通常以Python字符串或datatime对象表示）为索引的Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">39</span>]: <span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: dates = [datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">2</span>), datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line">   ....:          datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>), datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">8</span>),</span><br><span class="line">   ....:          datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">10</span>), datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">12</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: ts = pd.Series(np.random.randn(<span class="number">6</span>), index=dates)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: ts</span><br><span class="line">Out[<span class="number">42</span>]: </span><br><span class="line"><span class="number">2011</span>-01-02   -<span class="number">0.204708</span></span><br><span class="line"><span class="number">2011</span>-01-05    <span class="number">0.478943</span></span><br><span class="line"><span class="number">2011</span>-01-07   -<span class="number">0.519439</span></span><br><span class="line"><span class="number">2011</span>-01-08   -<span class="number">0.555730</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">10</span>    <span class="number">1.965781</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">12</span>    <span class="number">1.393406</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>这些datetime对象实际上是被放在一个DatetimeIndex中的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">43</span>]: ts.index</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2011-01-02&#x27;</span>, <span class="string">&#x27;2011-01-05&#x27;</span>, <span class="string">&#x27;2011-01-07&#x27;</span>, <span class="string">&#x27;2011-01-08&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2011-01-10&#x27;</span>, <span class="string">&#x27;2011-01-12&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>跟其他Series一样，不同索引的时间序列之间的算术运算会自动按日期对齐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">44</span>]: ts + ts[::<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">44</span>]: </span><br><span class="line"><span class="number">2011</span>-01-02   -<span class="number">0.409415</span></span><br><span class="line"><span class="number">2011</span>-01-05         NaN</span><br><span class="line"><span class="number">2011</span>-01-07   -<span class="number">1.038877</span></span><br><span class="line"><span class="number">2011</span>-01-08         NaN</span><br><span class="line"><span class="number">2011</span>-01-<span class="number">10</span>    <span class="number">3.931561</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">12</span>         NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>ts[::2] 是每隔两个取一个。</p>
<p>pandas用NumPy的datetime64数据类型以纳秒形式存储时间戳：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">45</span>]: ts.index.dtype</span><br><span class="line">Out[<span class="number">45</span>]: dtype(<span class="string">&#x27;&lt;M8[ns]&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>DatetimeIndex中的各个标量值是pandas的Timestamp对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">46</span>]: stamp = ts.index[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: stamp</span><br><span class="line">Out[<span class="number">47</span>]: Timestamp(<span class="string">&#x27;2011-01-02 00:00:00&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>只要有需要，TimeStamp可以随时自动转换为datetime对象。此外，它还可以存储频率信息（如果有的话），且知道如何执行时区转换以及其他操作。稍后将对此进行详细讲解。</p>
<h2 id="索引选取子集构造">索引、选取、子集构造</h2>
<p>当你根据标签索引选取数据时，时间序列和其它的pandas.Series很像：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">48</span>]: stamp = ts.index[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: ts[stamp]</span><br><span class="line">Out[<span class="number">49</span>]: -<span class="number">0.51943871505673811</span></span><br></pre></td></tr></table></figure>
<p>还有一种更为方便的用法：传入一个可以被解释为日期的字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">50</span>]: ts[<span class="string">&#x27;1/10/2011&#x27;</span>]</span><br><span class="line">Out[<span class="number">50</span>]: <span class="number">1.9657805725027142</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: ts[<span class="string">&#x27;20110110&#x27;</span>]</span><br><span class="line">Out[<span class="number">51</span>]: <span class="number">1.9657805725027142</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于较长的时间序列，只需传入“年”或“年月”即可轻松选取数据的切片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">52</span>]: longer_ts = pd.Series(np.random.randn(<span class="number">1000</span>),</span><br><span class="line">   ....:                       index=pd.date_range(<span class="string">&#x27;1/1/2000&#x27;</span>, periods=<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: longer_ts</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line"><span class="number">2000</span>-01-01    <span class="number">0.092908</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">0.281746</span></span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">0.769023</span></span><br><span class="line"><span class="number">2000</span>-01-04    <span class="number">1.246435</span></span><br><span class="line"><span class="number">2000</span>-01-05    <span class="number">1.007189</span></span><br><span class="line"><span class="number">2000</span>-01-06   -<span class="number">1.296221</span></span><br><span class="line"><span class="number">2000</span>-01-07    <span class="number">0.274992</span></span><br><span class="line"><span class="number">2000</span>-01-08    <span class="number">0.228913</span></span><br><span class="line"><span class="number">2000</span>-01-09    <span class="number">1.352917</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>    <span class="number">0.886429</span></span><br><span class="line">                ...   </span><br><span class="line"><span class="number">2002</span>-09-<span class="number">17</span>   -<span class="number">0.139298</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">18</span>   -<span class="number">1.159926</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">19</span>    <span class="number">0.618965</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">20</span>    <span class="number">1.373890</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">21</span>   -<span class="number">0.983505</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">22</span>    <span class="number">0.930944</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">23</span>   -<span class="number">0.811676</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">24</span>   -<span class="number">1.830156</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">25</span>   -<span class="number">0.138730</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">26</span>    <span class="number">0.334088</span></span><br><span class="line">Freq: D, Length: <span class="number">1000</span>, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: longer_ts[<span class="string">&#x27;2001&#x27;</span>]</span><br><span class="line">Out[<span class="number">54</span>]: </span><br><span class="line"><span class="number">2001</span>-01-01    <span class="number">1.599534</span></span><br><span class="line"><span class="number">2001</span>-01-02    <span class="number">0.474071</span></span><br><span class="line"><span class="number">2001</span>-01-03    <span class="number">0.151326</span></span><br><span class="line"><span class="number">2001</span>-01-04   -<span class="number">0.542173</span></span><br><span class="line"><span class="number">2001</span>-01-05   -<span class="number">0.475496</span></span><br><span class="line"><span class="number">2001</span>-01-06    <span class="number">0.106403</span></span><br><span class="line"><span class="number">2001</span>-01-07   -<span class="number">1.308228</span></span><br><span class="line"><span class="number">2001</span>-01-08    <span class="number">2.173185</span></span><br><span class="line"><span class="number">2001</span>-01-09    <span class="number">0.564561</span></span><br><span class="line"><span class="number">2001</span>-01-<span class="number">10</span>   -<span class="number">0.190481</span></span><br><span class="line">                ...   </span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">22</span>    <span class="number">0.000369</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">23</span>    <span class="number">0.900885</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">24</span>   -<span class="number">0.454869</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">25</span>   -<span class="number">0.864547</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">26</span>    <span class="number">1.129120</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">27</span>    <span class="number">0.057874</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">28</span>   -<span class="number">0.433739</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">29</span>    <span class="number">0.092698</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">30</span>   -<span class="number">1.397820</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">31</span>    <span class="number">1.457823</span></span><br><span class="line">Freq: D, Length: <span class="number">365</span>, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，字符串“2001”被解释成年，并根据它选取时间区间。指定月也同样奏效：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">55</span>]: longer_ts[<span class="string">&#x27;2001-05&#x27;</span>]</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line"><span class="number">2001</span>-05-01   -<span class="number">0.622547</span></span><br><span class="line"><span class="number">2001</span>-05-02    <span class="number">0.936289</span></span><br><span class="line"><span class="number">2001</span>-05-03    <span class="number">0.750018</span></span><br><span class="line"><span class="number">2001</span>-05-04   -<span class="number">0.056715</span></span><br><span class="line"><span class="number">2001</span>-05-05    <span class="number">2.300675</span></span><br><span class="line"><span class="number">2001</span>-05-06    <span class="number">0.569497</span></span><br><span class="line"><span class="number">2001</span>-05-07    <span class="number">1.489410</span></span><br><span class="line"><span class="number">2001</span>-05-08    <span class="number">1.264250</span></span><br><span class="line"><span class="number">2001</span>-05-09   -<span class="number">0.761837</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">10</span>   -<span class="number">0.331617</span></span><br><span class="line">                ...   </span><br><span class="line"><span class="number">2001</span>-05-<span class="number">22</span>    <span class="number">0.503699</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">23</span>   -<span class="number">1.387874</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">24</span>    <span class="number">0.204851</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">25</span>    <span class="number">0.603705</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">26</span>    <span class="number">0.545680</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">27</span>    <span class="number">0.235477</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">28</span>    <span class="number">0.111835</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">29</span>   -<span class="number">1.251504</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">30</span>   -<span class="number">2.949343</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">31</span>    <span class="number">0.634634</span></span><br><span class="line">Freq: D, Length: <span class="number">31</span>, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>datetime对象也可以进行切片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: ts[datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>):]</span><br><span class="line">Out[<span class="number">56</span>]: </span><br><span class="line"><span class="number">2011</span>-01-07   -<span class="number">0.519439</span></span><br><span class="line"><span class="number">2011</span>-01-08   -<span class="number">0.555730</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">10</span>    <span class="number">1.965781</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">12</span>    <span class="number">1.393406</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于大部分时间序列数据都是按照时间先后排序的，因此你也可以用不存在于该时间序列中的时间戳对其进行切片（即范围查询）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">57</span>]: ts</span><br><span class="line">Out[<span class="number">57</span>]: </span><br><span class="line"><span class="number">2011</span>-01-02   -<span class="number">0.204708</span></span><br><span class="line"><span class="number">2011</span>-01-05    <span class="number">0.478943</span></span><br><span class="line"><span class="number">2011</span>-01-07   -<span class="number">0.519439</span></span><br><span class="line"><span class="number">2011</span>-01-08   -<span class="number">0.555730</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">10</span>    <span class="number">1.965781</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">12</span>    <span class="number">1.393406</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: ts[<span class="string">&#x27;1/6/2011&#x27;</span>:<span class="string">&#x27;1/11/2011&#x27;</span>]</span><br><span class="line">Out[<span class="number">58</span>]: </span><br><span class="line"><span class="number">2011</span>-01-07   -<span class="number">0.519439</span></span><br><span class="line"><span class="number">2011</span>-01-08   -<span class="number">0.555730</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">10</span>    <span class="number">1.965781</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>跟之前一样，你可以传入字符串日期、datetime或Timestamp。注意，这样切片所产生的是原时间序列的视图，跟NumPy数组的切片运算是一样的。</p>
<p>这意味着，没有数据被复制，对切片进行修改会反映到原始数据上。</p>
<p>此外，还有一个等价的实例方法也可以截取两个日期之间TimeSeries：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">59</span>]: ts.truncate(after=<span class="string">&#x27;1/9/2011&#x27;</span>)</span><br><span class="line">Out[<span class="number">59</span>]: </span><br><span class="line"><span class="number">2011</span>-01-02   -<span class="number">0.204708</span></span><br><span class="line"><span class="number">2011</span>-01-05    <span class="number">0.478943</span></span><br><span class="line"><span class="number">2011</span>-01-07   -<span class="number">0.519439</span></span><br><span class="line"><span class="number">2011</span>-01-08   -<span class="number">0.555730</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>面这些操作对DataFrame也有效。例如，对DataFrame的行进行索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">60</span>]: dates = pd.date_range(<span class="string">&#x27;1/1/2000&#x27;</span>, periods=<span class="number">100</span>, freq=<span class="string">&#x27;W-WED&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: long_df = pd.DataFrame(np.random.randn(<span class="number">100</span>, <span class="number">4</span>),</span><br><span class="line">   ....:                        index=dates,</span><br><span class="line">   ....:                        columns=[<span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>,</span><br><span class="line">   ....:                                 <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: long_df.loc[<span class="string">&#x27;5-2001&#x27;</span>]</span><br><span class="line">Out[<span class="number">62</span>]: </span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2001</span>-05-02 -<span class="number">0.006045</span>  <span class="number">0.490094</span> -<span class="number">0.277186</span> -<span class="number">0.707213</span></span><br><span class="line"><span class="number">2001</span>-05-09 -<span class="number">0.560107</span>  <span class="number">2.735527</span>  <span class="number">0.927335</span>  <span class="number">1.513906</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">16</span>  <span class="number">0.538600</span>  <span class="number">1.273768</span>  <span class="number">0.667876</span> -<span class="number">0.969206</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">23</span>  <span class="number">1.676091</span> -<span class="number">0.817649</span>  <span class="number">0.050188</span>  <span class="number">1.951312</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">30</span>  <span class="number">3.260383</span>  <span class="number">0.963301</span>  <span class="number">1.201206</span> -<span class="number">1.852001</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="带有重复索引的时间序列">带有重复索引的时间序列</h2>
<p>在某些应用场景中，可能会存在多个观测数据落在同一个时间点上的情况。下面就是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">63</span>]: dates = pd.DatetimeIndex([<span class="string">&#x27;1/1/2000&#x27;</span>, <span class="string">&#x27;1/2/2000&#x27;</span>, <span class="string">&#x27;1/2/2000&#x27;</span>,</span><br><span class="line">   ....:                           <span class="string">&#x27;1/2/2000&#x27;</span>, <span class="string">&#x27;1/3/2000&#x27;</span>])</span><br><span class="line">In [<span class="number">64</span>]: dup_ts = pd.Series(np.arange(<span class="number">5</span>), index=dates)</span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: dup_ts</span><br><span class="line">Out[<span class="number">65</span>]: </span><br><span class="line"><span class="number">2000</span>-01-01    <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">1</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">2</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">3</span></span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">4</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过检查索引的is_unique属性，我们就可以知道它是不是唯一的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">66</span>]: dup_ts.index.is_unique</span><br><span class="line">Out[<span class="number">66</span>]: <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对这个时间序列进行索引，要么产生标量值，要么产生切片，具体要看所选的时间点是否重复：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">67</span>]: dup_ts[<span class="string">&#x27;1/3/2000&#x27;</span>]  <span class="comment"># not duplicated</span></span><br><span class="line">Out[<span class="number">67</span>]: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: dup_ts[<span class="string">&#x27;1/2/2000&#x27;</span>]  <span class="comment"># duplicated</span></span><br><span class="line">Out[<span class="number">68</span>]: </span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">1</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">2</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设你想要对具有非唯一时间戳的数据进行聚合。一个办法是使用groupby，并传入level=0：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">69</span>]: grouped = dup_ts.groupby(level=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: grouped.mean()</span><br><span class="line">Out[<span class="number">70</span>]: </span><br><span class="line"><span class="number">2000</span>-01-01    <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">2</span></span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">4</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: grouped.count()</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line"><span class="number">2000</span>-01-01    <span class="number">1</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">3</span></span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">1</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="日期的范围频率以及移动">11.3 日期的范围、频率以及移动</h1>
<p>pandas中的原生时间序列一般被认为是不规则的，也就是说，它们没有固定的频率。对于大部分应用程序而言，这是无所谓的。但是，它常常需要以某种相对固定的频率进行分析，比如每日、每月、每15分钟等（这样自然会在时间序列中引入缺失值）。幸运的是，pandas有一整套标准时间序列频率以及用于重采样、频率推断、生成固定频率日期范围的工具。例如，我们可以将之前那个时间序列转换为一个具有固定频率（每日）的时间序列，只需调用resample即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">72</span>]: ts</span><br><span class="line">Out[<span class="number">72</span>]: </span><br><span class="line"><span class="number">2011</span>-01-02   -<span class="number">0.204708</span></span><br><span class="line"><span class="number">2011</span>-01-05    <span class="number">0.478943</span></span><br><span class="line"><span class="number">2011</span>-01-07   -<span class="number">0.519439</span></span><br><span class="line"><span class="number">2011</span>-01-08   -<span class="number">0.555730</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">10</span>    <span class="number">1.965781</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">12</span>    <span class="number">1.393406</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">73</span>]: resampler = ts.resample(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>字符串“D”是每天的意思。</p>
<p>频率的转换（或重采样）是一个比较大的主题，稍后将专门用一节来进行讨论（11.6小节）。这里，我将告诉你如何使用基本的频率和它的倍数。</p>
<h2 id="生成日期范围">生成日期范围</h2>
<p>虽然我之前用的时候没有明说，但你可能已经猜到pandas.date_range可用于根据指定的频率生成指定长度的DatetimeIndex：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: index = pd.date_range(<span class="string">&#x27;2012-04-01&#x27;</span>, <span class="string">&#x27;2012-06-01&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: index</span><br><span class="line">Out[<span class="number">75</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-04-01&#x27;</span>, <span class="string">&#x27;2012-04-02&#x27;</span>, <span class="string">&#x27;2012-04-03&#x27;</span>, <span class="string">&#x27;2012-04-04&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-05&#x27;</span>, <span class="string">&#x27;2012-04-06&#x27;</span>, <span class="string">&#x27;2012-04-07&#x27;</span>, <span class="string">&#x27;2012-04-08&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-09&#x27;</span>, <span class="string">&#x27;2012-04-10&#x27;</span>, <span class="string">&#x27;2012-04-11&#x27;</span>, <span class="string">&#x27;2012-04-12&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-13&#x27;</span>, <span class="string">&#x27;2012-04-14&#x27;</span>, <span class="string">&#x27;2012-04-15&#x27;</span>, <span class="string">&#x27;2012-04-16&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-17&#x27;</span>, <span class="string">&#x27;2012-04-18&#x27;</span>, <span class="string">&#x27;2012-04-19&#x27;</span>, <span class="string">&#x27;2012-04-20&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-21&#x27;</span>, <span class="string">&#x27;2012-04-22&#x27;</span>, <span class="string">&#x27;2012-04-23&#x27;</span>, <span class="string">&#x27;2012-04-24&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-25&#x27;</span>, <span class="string">&#x27;2012-04-26&#x27;</span>, <span class="string">&#x27;2012-04-27&#x27;</span>, <span class="string">&#x27;2012-04-28&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-29&#x27;</span>, <span class="string">&#x27;2012-04-30&#x27;</span>, <span class="string">&#x27;2012-05-01&#x27;</span>, <span class="string">&#x27;2012-05-02&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-03&#x27;</span>, <span class="string">&#x27;2012-05-04&#x27;</span>, <span class="string">&#x27;2012-05-05&#x27;</span>, <span class="string">&#x27;2012-05-06&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-07&#x27;</span>, <span class="string">&#x27;2012-05-08&#x27;</span>, <span class="string">&#x27;2012-05-09&#x27;</span>, <span class="string">&#x27;2012-05-10&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-11&#x27;</span>, <span class="string">&#x27;2012-05-12&#x27;</span>, <span class="string">&#x27;2012-05-13&#x27;</span>, <span class="string">&#x27;2012-05-14&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-15&#x27;</span>, <span class="string">&#x27;2012-05-16&#x27;</span>, <span class="string">&#x27;2012-05-17&#x27;</span>, <span class="string">&#x27;2012-05-18&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-19&#x27;</span>, <span class="string">&#x27;2012-05-20&#x27;</span>, <span class="string">&#x27;2012-05-21&#x27;</span>, <span class="string">&#x27;2012-05-22&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-23&#x27;</span>, <span class="string">&#x27;2012-05-24&#x27;</span>, <span class="string">&#x27;2012-05-25&#x27;</span>, <span class="string">&#x27;2012-05-26&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-27&#x27;</span>, <span class="string">&#x27;2012-05-28&#x27;</span>, <span class="string">&#x27;2012-05-29&#x27;</span>, <span class="string">&#x27;2012-05-30&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-31&#x27;</span>, <span class="string">&#x27;2012-06-01&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认情况下，date_range会产生按天计算的时间点。如果只传入起始或结束日期，那就还得传入一个表示一段时间的数字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: pd.date_range(start=<span class="string">&#x27;2012-04-01&#x27;</span>, periods=<span class="number">20</span>)</span><br><span class="line">Out[<span class="number">76</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-04-01&#x27;</span>, <span class="string">&#x27;2012-04-02&#x27;</span>, <span class="string">&#x27;2012-04-03&#x27;</span>, <span class="string">&#x27;2012-04-04&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-05&#x27;</span>, <span class="string">&#x27;2012-04-06&#x27;</span>, <span class="string">&#x27;2012-04-07&#x27;</span>, <span class="string">&#x27;2012-04-08&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-09&#x27;</span>, <span class="string">&#x27;2012-04-10&#x27;</span>, <span class="string">&#x27;2012-04-11&#x27;</span>, <span class="string">&#x27;2012-04-12&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-13&#x27;</span>, <span class="string">&#x27;2012-04-14&#x27;</span>, <span class="string">&#x27;2012-04-15&#x27;</span>, <span class="string">&#x27;2012-04-16&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-17&#x27;</span>, <span class="string">&#x27;2012-04-18&#x27;</span>, <span class="string">&#x27;2012-04-19&#x27;</span>, <span class="string">&#x27;2012-04-20&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: pd.date_range(end=<span class="string">&#x27;2012-06-01&#x27;</span>, periods=<span class="number">20</span>)</span><br><span class="line">Out[<span class="number">77</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-05-13&#x27;</span>, <span class="string">&#x27;2012-05-14&#x27;</span>, <span class="string">&#x27;2012-05-15&#x27;</span>, <span class="string">&#x27;2012-05-16&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-17&#x27;</span>, <span class="string">&#x27;2012-05-18&#x27;</span>, <span class="string">&#x27;2012-05-19&#x27;</span>, <span class="string">&#x27;2012-05-20&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-21&#x27;</span>, <span class="string">&#x27;2012-05-22&#x27;</span>, <span class="string">&#x27;2012-05-23&#x27;</span>, <span class="string">&#x27;2012-05-24&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-25&#x27;</span>, <span class="string">&#x27;2012-05-26&#x27;</span>, <span class="string">&#x27;2012-05-27&#x27;</span>,<span class="string">&#x27;2012-05-28&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-29&#x27;</span>, <span class="string">&#x27;2012-05-30&#x27;</span>, <span class="string">&#x27;2012-05-31&#x27;</span>, <span class="string">&#x27;2012-06-01&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>起始和结束日期定义了日期索引的严格边界。例如，如果你想要生成一个由每月最后一个工作日组成的日期索引，可以传入"BM"频率（表示business end of month，表11-4是频率列表），这样就只会包含时间间隔内（或刚好在边界上的）符合频率要求的日期：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">78</span>]: pd.date_range(<span class="string">&#x27;2000-01-01&#x27;</span>, <span class="string">&#x27;2000-12-01&#x27;</span>, freq=<span class="string">&#x27;BM&#x27;</span>)</span><br><span class="line">Out[<span class="number">78</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2000-01-31&#x27;</span>, <span class="string">&#x27;2000-02-29&#x27;</span>, <span class="string">&#x27;2000-03-31&#x27;</span>, <span class="string">&#x27;2000-04-28&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-05-31&#x27;</span>, <span class="string">&#x27;2000-06-30&#x27;</span>, <span class="string">&#x27;2000-07-31&#x27;</span>, <span class="string">&#x27;2000-08-31&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-09-29&#x27;</span>, <span class="string">&#x27;2000-10-31&#x27;</span>, <span class="string">&#x27;2000-11-30&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;BM&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表11-4 基本的时间序列频率（不完整）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-c8614ddbd10793ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-8da46ba96544b071.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-3ca410609195edc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>date_range默认会保留起始和结束时间戳的时间信息（如果有的话）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">79</span>]: pd.date_range(<span class="string">&#x27;2012-05-02 12:56:31&#x27;</span>, periods=<span class="number">5</span>)</span><br><span class="line">Out[<span class="number">79</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-05-02 12:56:31&#x27;</span>, <span class="string">&#x27;2012-05-03 12:56:31&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-04 12:56:31&#x27;</span>, <span class="string">&#x27;2012-05-05 12:56:31&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-06 12:56:31&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有时，虽然起始和结束日期带有时间信息，但你希望产生一组被规范化（normalize）到午夜的时间戳。normalize选项即可实现该功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">80</span>]: pd.date_range(<span class="string">&#x27;2012-05-02 12:56:31&#x27;</span>, periods=<span class="number">5</span>, normalize=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">80</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-05-02&#x27;</span>, <span class="string">&#x27;2012-05-03&#x27;</span>, <span class="string">&#x27;2012-05-04&#x27;</span>, <span class="string">&#x27;2012-05-05&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-06&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="频率和日期偏移量">频率和日期偏移量</h2>
<p>pandas中的频率是由一个基础频率（base frequency）和一个乘数组成的。基础频率通常以一个字符串别名表示，比如"M"表示每月，"H"表示每小时。对于每个基础频率，都有一个被称为日期偏移量（date offset）的对象与之对应。例如，按小时计算的频率可以用Hour类表示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">81</span>]: <span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Hour, Minute</span><br><span class="line"></span><br><span class="line">In [<span class="number">82</span>]: hour = Hour()</span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: hour</span><br><span class="line">Out[<span class="number">83</span>]: &lt;Hour&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传入一个整数即可定义偏移量的倍数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">84</span>]: four_hours = Hour(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">85</span>]: four_hours</span><br><span class="line">Out[<span class="number">85</span>]: &lt;<span class="number">4</span> * Hours&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一般来说，无需明确创建这样的对象，只需使用诸如"H"或"4H"这样的字符串别名即可。在基础频率前面放上一个整数即可创建倍数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">86</span>]: pd.date_range(<span class="string">&#x27;2000-01-01&#x27;</span>, <span class="string">&#x27;2000-01-03 23:59&#x27;</span>, freq=<span class="string">&#x27;4h&#x27;</span>)</span><br><span class="line">Out[<span class="number">86</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2000-01-01 00:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 04:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-01 08:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 12:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-01 16:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 20:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-02 00:00:00&#x27;</span>, <span class="string">&#x27;2000-01-02 04:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-02 08:00:00&#x27;</span>, <span class="string">&#x27;2000-01-02 12:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-02 16:00:00&#x27;</span>, <span class="string">&#x27;2000-01-02 20:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-03 00:00:00&#x27;</span>, <span class="string">&#x27;2000-01-03 04:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-03 08:00:00&#x27;</span>, <span class="string">&#x27;2000-01-03 12:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-03 16:00:00&#x27;</span>, <span class="string">&#x27;2000-01-03 20:00:00&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;4H&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>大部分偏移量对象都可通过加法进行连接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">87</span>]: Hour(<span class="number">2</span>) + Minute(<span class="number">30</span>)</span><br><span class="line">Out[<span class="number">87</span>]: &lt;<span class="number">150</span> * Minutes&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同理，你也可以传入频率字符串（如"2h30min"），这种字符串可以被高效地解析为等效的表达式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">88</span>]: pd.date_range(<span class="string">&#x27;2000-01-01&#x27;</span>, periods=<span class="number">10</span>, freq=<span class="string">&#x27;1h30min&#x27;</span>)</span><br><span class="line">Out[<span class="number">88</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2000-01-01 00:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 01:30:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-01 03:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 04:30:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-01 06:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 07:30:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-01 09:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 10:30:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-01 12:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 13:30:00&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;90T&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有些频率所描述的时间点并不是均匀分隔的。例如，"M"（日历月末）和"BM"（每月最后一个工作日）就取决于每月的天数，对于后者，还要考虑月末是不是周末。由于没有更好的术语，我将这些称为锚点偏移量（anchored offset）。</p>
<p>表11-4列出了pandas中的频率代码和日期偏移量类。</p>
<blockquote>
<p>笔记：用户可以根据实际需求自定义一些频率类以便提供pandas所没有的日期逻辑，但具体的细节超出了本书的范围。</p>
</blockquote>
<p>表11-4 时间序列的基础频率</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-ff139312cd972204.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-adfa57a998c0296e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-d09e577a10d0e6eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<h2 id="wom日期">WOM日期</h2>
<p>WOM（Week Of Month）是一种非常实用的频率类，它以WOM开头。它使你能获得诸如“每月第3个星期五”之类的日期：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">89</span>]: rng = pd.date_range(<span class="string">&#x27;2012-01-01&#x27;</span>, <span class="string">&#x27;2012-09-01&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: <span class="built_in">list</span>(rng)</span><br><span class="line">Out[<span class="number">90</span>]: </span><br><span class="line">[Timestamp(<span class="string">&#x27;2012-01-20 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>),</span><br><span class="line"> Timestamp(<span class="string">&#x27;2012-02-17 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>),</span><br><span class="line"> Timestamp(<span class="string">&#x27;2012-03-16 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>),</span><br><span class="line"> Timestamp(<span class="string">&#x27;2012-04-20 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>),</span><br><span class="line"> Timestamp(<span class="string">&#x27;2012-05-18 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>),</span><br><span class="line"> Timestamp(<span class="string">&#x27;2012-06-15 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>),</span><br><span class="line"> Timestamp(<span class="string">&#x27;2012-07-20 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>),</span><br><span class="line"> Timestamp(<span class="string">&#x27;2012-08-17 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="移动超前和滞后数据">移动（超前和滞后）数据</h2>
<p>移动（shifting）指的是沿着时间轴将数据前移或后移。Series和DataFrame都有一个shift方法用于执行单纯的前移或后移操作，保持索引不变：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">91</span>]: ts = pd.Series(np.random.randn(<span class="number">4</span>),</span><br><span class="line">   ....:                index=pd.date_range(<span class="string">&#x27;1/1/2000&#x27;</span>, periods=<span class="number">4</span>, freq=<span class="string">&#x27;M&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: ts</span><br><span class="line">Out[<span class="number">92</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.066748</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>    <span class="number">0.838639</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>   -<span class="number">0.117388</span></span><br><span class="line"><span class="number">2000</span>-04-<span class="number">30</span>   -<span class="number">0.517795</span></span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">93</span>]: ts.shift(<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">93</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>         NaN</span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>         NaN</span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>   -<span class="number">0.066748</span></span><br><span class="line"><span class="number">2000</span>-04-<span class="number">30</span>    <span class="number">0.838639</span></span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: ts.shift(-<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">94</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.117388</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>   -<span class="number">0.517795</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>         NaN</span><br><span class="line"><span class="number">2000</span>-04-<span class="number">30</span>         NaN</span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当我们这样进行移动时，就会在时间序列的前面或后面产生缺失数据。</p>
<p>shift通常用于计算一个时间序列或多个时间序列（如DataFrame的列）中的百分比变化。可以这样表达：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts / ts.shift(<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于单纯的移位操作不会修改索引，所以部分数据会被丢弃。因此，如果频率已知，则可以将其传给shift以便实现对时间戳进行位移而不是对数据进行简单位移：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">95</span>]: ts.shift(<span class="number">2</span>, freq=<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">Out[<span class="number">95</span>]: </span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>   -<span class="number">0.066748</span></span><br><span class="line"><span class="number">2000</span>-04-<span class="number">30</span>    <span class="number">0.838639</span></span><br><span class="line"><span class="number">2000</span>-05-<span class="number">31</span>   -<span class="number">0.117388</span></span><br><span class="line"><span class="number">2000</span>-06-<span class="number">30</span>   -<span class="number">0.517795</span></span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里还可以使用其他频率，于是你就能非常灵活地对数据进行超前和滞后处理了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">96</span>]: ts.shift(<span class="number">3</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">Out[<span class="number">96</span>]: </span><br><span class="line"><span class="number">2000</span>-02-03   -<span class="number">0.066748</span></span><br><span class="line"><span class="number">2000</span>-03-03    <span class="number">0.838639</span></span><br><span class="line"><span class="number">2000</span>-04-03   -<span class="number">0.117388</span></span><br><span class="line"><span class="number">2000</span>-05-03   -<span class="number">0.517795</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: ts.shift(<span class="number">1</span>, freq=<span class="string">&#x27;90T&#x27;</span>)</span><br><span class="line">Out[<span class="number">97</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span> 01:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.066748</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span> 01:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.838639</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span> 01:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.117388</span></span><br><span class="line"><span class="number">2000</span>-04-<span class="number">30</span> 01:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.517795</span></span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="通过偏移量对日期进行位移">通过偏移量对日期进行位移</h2>
<p>pandas的日期偏移量还可以用在datetime或Timestamp对象上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">98</span>]: <span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Day, MonthEnd</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: now = datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: now + <span class="number">3</span> * Day()</span><br><span class="line">Out[<span class="number">100</span>]: Timestamp(<span class="string">&#x27;2011-11-20 00:00:00&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果加的是锚点偏移量（比如MonthEnd），第一次增量会将原日期向前滚动到符合频率规则的下一个日期：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">101</span>]: now + MonthEnd()</span><br><span class="line">Out[<span class="number">101</span>]: Timestamp(<span class="string">&#x27;2011-11-30 00:00:00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">102</span>]: now + MonthEnd(<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">102</span>]: Timestamp(<span class="string">&#x27;2011-12-31 00:00:00&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过锚点偏移量的rollforward和rollback方法，可明确地将日期向前或向后“滚动”：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">103</span>]: offset = MonthEnd()</span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: offset.rollforward(now)</span><br><span class="line">Out[<span class="number">104</span>]: Timestamp(<span class="string">&#x27;2011-11-30 00:00:00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: offset.rollback(now)</span><br><span class="line">Out[<span class="number">105</span>]: Timestamp(<span class="string">&#x27;2011-10-31 00:00:00&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>日期偏移量还有一个巧妙的用法，即结合groupby使用这两个“滚动”方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">106</span>]: ts = pd.Series(np.random.randn(<span class="number">20</span>),</span><br><span class="line">   .....:                index=pd.date_range(<span class="string">&#x27;1/15/2000&#x27;</span>, periods=<span class="number">20</span>, freq=<span class="string">&#x27;4d&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: ts</span><br><span class="line">Out[<span class="number">107</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">15</span>   -<span class="number">0.116696</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">19</span>    <span class="number">2.389645</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">23</span>   -<span class="number">0.932454</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">27</span>   -<span class="number">0.229331</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">1.140330</span></span><br><span class="line"><span class="number">2000</span>-02-04    <span class="number">0.439920</span></span><br><span class="line"><span class="number">2000</span>-02-08   -<span class="number">0.823758</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">12</span>   -<span class="number">0.520930</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">16</span>    <span class="number">0.350282</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">20</span>    <span class="number">0.204395</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">24</span>    <span class="number">0.133445</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">28</span>    <span class="number">0.327905</span></span><br><span class="line"><span class="number">2000</span>-03-03    <span class="number">0.072153</span></span><br><span class="line"><span class="number">2000</span>-03-07    <span class="number">0.131678</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">11</span>   -<span class="number">1.297459</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">15</span>    <span class="number">0.997747</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">19</span>    <span class="number">0.870955</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">23</span>   -<span class="number">0.991253</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">27</span>    <span class="number">0.151699</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>    <span class="number">1.266151</span></span><br><span class="line">Freq: 4D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">108</span>]: ts.groupby(offset.rollforward).mean()</span><br><span class="line">Out[<span class="number">108</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.005833</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>    <span class="number">0.015894</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>    <span class="number">0.150209</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然，更简单、更快速地实现该功能的办法是使用resample（11.6小节将对此进行详细介绍）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">109</span>]: ts.resample(<span class="string">&#x27;M&#x27;</span>).mean()</span><br><span class="line">Out[<span class="number">109</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.005833</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>    <span class="number">0.015894</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>    <span class="number">0.150209</span></span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="时区处理">11.4 时区处理</h1>
<p>时间序列处理工作中最让人不爽的就是对时区的处理。许多人都选择以协调世界时（UTC，它是格林尼治标准时间（Greenwich Mean Time）的接替者，目前已经是国际标准了）来处理时间序列。时区是以UTC偏移量的形式表示的。例如，夏令时期间，纽约比UTC慢4小时，而在全年其他时间则比UTC慢5小时。</p>
<p>在Python中，时区信息来自第三方库pytz，它使Python可以使用Olson数据库（汇编了世界时区信息）。这对历史数据非常重要，这是因为由于各地政府的各种突发奇想，夏令时转变日期（甚至UTC偏移量）已经发生过多次改变了。就拿美国来说，DST转变时间自1900年以来就改变过多次！</p>
<p>有关pytz库的更多信息，请查阅其文档。就本书而言，由于pandas包装了pytz的功能，因此你可以不用记忆其API，只要记得时区的名称即可。时区名可以在shell中看到，也可以通过文档查看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">110</span>]: <span class="keyword">import</span> pytz</span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: pytz.common_timezones[-<span class="number">5</span>:]</span><br><span class="line">Out[<span class="number">111</span>]: [<span class="string">&#x27;US/Eastern&#x27;</span>, <span class="string">&#x27;US/Hawaii&#x27;</span>, <span class="string">&#x27;US/Mountain&#x27;</span>, <span class="string">&#x27;US/Pacific&#x27;</span>, <span class="string">&#x27;UTC&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要从pytz中获取时区对象，使用pytz.timezone即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">112</span>]: tz = pytz.timezone(<span class="string">&#x27;America/New_York&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">113</span>]: tz</span><br><span class="line">Out[<span class="number">113</span>]: &lt;DstTzInfo <span class="string">&#x27;America/New_York&#x27;</span> LMT-<span class="number">1</span> day, <span class="number">19</span>:04:<span class="number">00</span> STD&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>pandas中的方法既可以接受时区名也可以接受这些对象。</p>
<h1 id="时区本地化和转换">时区本地化和转换</h1>
<p>默认情况下，pandas中的时间序列是单纯（naive）的时区。看看下面这个时间序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">114</span>]: rng = pd.date_range(<span class="string">&#x27;3/9/2012 9:30&#x27;</span>, periods=<span class="number">6</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">115</span>]: ts = pd.Series(np.random.randn(<span class="built_in">len</span>(rng)), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: ts</span><br><span class="line">Out[<span class="number">116</span>]: </span><br><span class="line"><span class="number">2012</span>-03-09 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.202469</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">10</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.050718</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">11</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.639869</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">12</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.597594</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">13</span> 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.797246</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">14</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.472879</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其索引的tz字段为None：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">117</span>]: <span class="built_in">print</span>(ts.index.tz)</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以用时区集生成日期范围：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">118</span>]: pd.date_range(<span class="string">&#x27;3/9/2012 9:30&#x27;</span>, periods=<span class="number">10</span>, freq=<span class="string">&#x27;D&#x27;</span>, tz=<span class="string">&#x27;UTC&#x27;</span>)</span><br><span class="line">Out[<span class="number">118</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-03-09 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-10 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-11 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-12 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-13 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-14 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-15 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-16 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-17 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-18 09:30:00+00:00&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns, UTC]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从单纯到本地化的转换是通过tz_localize方法处理的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">119</span>]: ts</span><br><span class="line">Out[<span class="number">119</span>]: </span><br><span class="line"><span class="number">2012</span>-03-09 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.202469</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">10</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.050718</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">11</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.639869</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">12</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.597594</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">13</span> 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.797246</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">14</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.472879</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: ts_utc = ts.tz_localize(<span class="string">&#x27;UTC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: ts_utc</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line"><span class="number">2012</span>-03-09 09:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>   -<span class="number">0.202469</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">10</span> 09:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.050718</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">11</span> 09:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.639869</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">12</span> 09:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.597594</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">13</span> 09:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>   -<span class="number">0.797246</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">14</span> 09:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.472879</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: ts_utc.index</span><br><span class="line">Out[<span class="number">122</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-03-09 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-10 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-11 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-12 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-13 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-14 09:30:00+00:00&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns, UTC]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一旦时间序列被本地化到某个特定时区，就可以用tz_convert将其转换到别的时区了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">123</span>]: ts_utc.tz_convert(<span class="string">&#x27;America/New_York&#x27;</span>)</span><br><span class="line">Out[<span class="number">123</span>]: </span><br><span class="line"><span class="number">2012</span>-03-09 04:<span class="number">30</span>:<span class="number">00</span>-05:<span class="number">00</span>   -<span class="number">0.202469</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">10</span> 04:<span class="number">30</span>:<span class="number">00</span>-05:<span class="number">00</span>    <span class="number">0.050718</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">11</span> 05:<span class="number">30</span>:<span class="number">00</span>-04:<span class="number">00</span>    <span class="number">0.639869</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">12</span> 05:<span class="number">30</span>:<span class="number">00</span>-04:<span class="number">00</span>    <span class="number">0.597594</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">13</span> 05:<span class="number">30</span>:<span class="number">00</span>-04:<span class="number">00</span>   -<span class="number">0.797246</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">14</span> 05:<span class="number">30</span>:<span class="number">00</span>-04:<span class="number">00</span>    <span class="number">0.472879</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于上面这种时间序列（它跨越了美国东部时区的夏令时转变期），我们可以将其本地化到EST，然后转换为UTC或柏林时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">124</span>]: ts_eastern = ts.tz_localize(<span class="string">&#x27;America/New_York&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: ts_eastern.tz_convert(<span class="string">&#x27;UTC&#x27;</span>)</span><br><span class="line">Out[<span class="number">125</span>]: </span><br><span class="line"><span class="number">2012</span>-03-09 <span class="number">14</span>:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>   -<span class="number">0.202469</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">10</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.050718</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">11</span> <span class="number">13</span>:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.639869</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">12</span> <span class="number">13</span>:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.597594</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">13</span> <span class="number">13</span>:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>   -<span class="number">0.797246</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">14</span> <span class="number">13</span>:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.472879</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">126</span>]: ts_eastern.tz_convert(<span class="string">&#x27;Europe/Berlin&#x27;</span>)</span><br><span class="line">Out[<span class="number">126</span>]: </span><br><span class="line"><span class="number">2012</span>-03-09 <span class="number">15</span>:<span class="number">30</span>:<span class="number">00</span>+01:<span class="number">00</span>   -<span class="number">0.202469</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">10</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">00</span>+01:<span class="number">00</span>    <span class="number">0.050718</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">11</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">00</span>+01:<span class="number">00</span>    <span class="number">0.639869</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">12</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">00</span>+01:<span class="number">00</span>    <span class="number">0.597594</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">13</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">00</span>+01:<span class="number">00</span>   -<span class="number">0.797246</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">14</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">00</span>+01:<span class="number">00</span>    <span class="number">0.472879</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>tz_localize和tz_convert也是DatetimeIndex的实例方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">127</span>]: ts.index.tz_localize(<span class="string">&#x27;Asia/Shanghai&#x27;</span>)</span><br><span class="line">Out[<span class="number">127</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-03-09 09:30:00+08:00&#x27;</span>, <span class="string">&#x27;2012-03-10 09:30:00+08:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-11 09:30:00+08:00&#x27;</span>, <span class="string">&#x27;2012-03-12 09:30:00+08:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-13 09:30:00+08:00&#x27;</span>, <span class="string">&#x27;2012-03-14 09:30:00+08:00&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns, Asia/Shanghai]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：对单纯时间戳的本地化操作还会检查夏令时转变期附近容易混淆或不存在的时间。</p>
</blockquote>
<h2 id="操作时区意识型timestamp对象">操作时区意识型Timestamp对象</h2>
<p>跟时间序列和日期范围差不多，独立的Timestamp对象也能被从单纯型（naive）本地化为时区意识型（time zone-aware），并从一个时区转换到另一个时区：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">128</span>]: stamp = pd.Timestamp(<span class="string">&#x27;2011-03-12 04:00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: stamp_utc = stamp.tz_localize(<span class="string">&#x27;utc&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">130</span>]: stamp_utc.tz_convert(<span class="string">&#x27;America/New_York&#x27;</span>)</span><br><span class="line">Out[<span class="number">130</span>]: Timestamp(<span class="string">&#x27;2011-03-11 23:00:00-0500&#x27;</span>, tz=<span class="string">&#x27;America/New_York&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在创建Timestamp时，还可以传入一个时区信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">131</span>]: stamp_moscow = pd.Timestamp(<span class="string">&#x27;2011-03-12 04:00&#x27;</span>, tz=<span class="string">&#x27;Europe/Moscow&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">132</span>]: stamp_moscow</span><br><span class="line">Out[<span class="number">132</span>]: Timestamp(<span class="string">&#x27;2011-03-12 04:00:00+0300&#x27;</span>, tz=<span class="string">&#x27;Europe/Moscow&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>时区意识型Timestamp对象在内部保存了一个UTC时间戳值（自UNIX纪元（1970年1月1日）算起的纳秒数）。这个UTC值在时区转换过程中是不会发生变化的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">133</span>]: stamp_utc.value</span><br><span class="line">Out[<span class="number">133</span>]: <span class="number">1299902400000000000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">134</span>]: stamp_utc.tz_convert(<span class="string">&#x27;America/New_York&#x27;</span>).value</span><br><span class="line">Out[<span class="number">134</span>]: <span class="number">1299902400000000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当使用pandas的DateOffset对象执行时间算术运算时，运算过程会自动关注是否存在夏令时转变期。这里，我们创建了在DST转变之前的时间戳。首先，来看夏令时转变前的30分钟：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">135</span>]: <span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Hour</span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: stamp = pd.Timestamp(<span class="string">&#x27;2012-03-12 01:30&#x27;</span>, tz=<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">137</span>]: stamp</span><br><span class="line">Out[<span class="number">137</span>]: Timestamp(<span class="string">&#x27;2012-03-12 01:30:00-0400&#x27;</span>, tz=<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">138</span>]: stamp + Hour()</span><br><span class="line">Out[<span class="number">138</span>]: Timestamp(<span class="string">&#x27;2012-03-12 02:30:00-0400&#x27;</span>, tz=<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，夏令时转变前90分钟：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">139</span>]: stamp = pd.Timestamp(<span class="string">&#x27;2012-11-04 00:30&#x27;</span>, tz=<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">140</span>]: stamp</span><br><span class="line">Out[<span class="number">140</span>]: Timestamp(<span class="string">&#x27;2012-11-04 00:30:00-0400&#x27;</span>, tz=<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">141</span>]: stamp + <span class="number">2</span> * Hour()</span><br><span class="line">Out[<span class="number">141</span>]: Timestamp(<span class="string">&#x27;2012-11-04 01:30:00-0500&#x27;</span>, tz=<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="不同时区之间的运算">不同时区之间的运算</h2>
<p>如果两个时间序列的时区不同，在将它们合并到一起时，最终结果就会是UTC。由于时间戳其实是以UTC存储的，所以这是一个很简单的运算，并不需要发生任何转换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">142</span>]: rng = pd.date_range(<span class="string">&#x27;3/7/2012 9:30&#x27;</span>, periods=<span class="number">10</span>, freq=<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">143</span>]: ts = pd.Series(np.random.randn(<span class="built_in">len</span>(rng)), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">144</span>]: ts</span><br><span class="line">Out[<span class="number">144</span>]: </span><br><span class="line"><span class="number">2012</span>-03-07 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.522356</span></span><br><span class="line"><span class="number">2012</span>-03-08 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.546348</span></span><br><span class="line"><span class="number">2012</span>-03-09 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.733537</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">12</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">1.302736</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">13</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.022199</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">14</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.364287</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">15</span> 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.922839</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">16</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.312656</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">19</span> 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">1.128497</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">20</span> 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.333488</span></span><br><span class="line">Freq: B, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">145</span>]: ts1 = ts[:<span class="number">7</span>].tz_localize(<span class="string">&#x27;Europe/London&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">146</span>]: ts2 = ts1[<span class="number">2</span>:].tz_convert(<span class="string">&#x27;Europe/Moscow&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">147</span>]: result = ts1 + ts2</span><br><span class="line"></span><br><span class="line">In [<span class="number">148</span>]: result.index</span><br><span class="line">Out[<span class="number">148</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-03-07 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-08 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-09 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-12 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-13 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-14 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-15 09:30:00+00:00&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns, UTC]&#x27;</span>, freq=<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="时期及其算术运算">11.5 时期及其算术运算</h1>
<p>时期（period）表示的是时间区间，比如数日、数月、数季、数年等。Period类所表示的就是这种数据类型，其构造函数需要用到一个字符串或整数，以及表11-4中的频率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">149</span>]: p = pd.Period(<span class="number">2007</span>, freq=<span class="string">&#x27;A-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">150</span>]: p</span><br><span class="line">Out[<span class="number">150</span>]: Period(<span class="string">&#x27;2007&#x27;</span>, <span class="string">&#x27;A-DEC&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，这个Period对象表示的是从2007年1月1日到2007年12月31日之间的整段时间。只需对Period对象加上或减去一个整数即可达到根据其频率进行位移的效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">151</span>]: p + <span class="number">5</span></span><br><span class="line">Out[<span class="number">151</span>]: Period(<span class="string">&#x27;2012&#x27;</span>, <span class="string">&#x27;A-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">152</span>]: p - <span class="number">2</span></span><br><span class="line">Out[<span class="number">152</span>]: Period(<span class="string">&#x27;2005&#x27;</span>, <span class="string">&#x27;A-DEC&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果两个Period对象拥有相同的频率，则它们的差就是它们之间的单位数量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">153</span>]: pd.Period(<span class="string">&#x27;2014&#x27;</span>, freq=<span class="string">&#x27;A-DEC&#x27;</span>) - p</span><br><span class="line">Out[<span class="number">153</span>]: <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>period_range函数可用于创建规则的时期范围：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">154</span>]: rng = pd.period_range(<span class="string">&#x27;2000-01-01&#x27;</span>, <span class="string">&#x27;2000-06-30&#x27;</span>, freq=<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">155</span>]: rng</span><br><span class="line">Out[<span class="number">155</span>]: PeriodIndex([<span class="string">&#x27;2000-01&#x27;</span>, <span class="string">&#x27;2000-02&#x27;</span>, <span class="string">&#x27;2000-03&#x27;</span>, <span class="string">&#x27;2000-04&#x27;</span>, <span class="string">&#x27;2000-05&#x27;</span>, <span class="string">&#x27;20</span></span><br><span class="line"><span class="string">00-06&#x27;</span>], dtype=<span class="string">&#x27;period[M]&#x27;</span>, freq=<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>PeriodIndex类保存了一组Period，它可以在任何pandas数据结构中被用作轴索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">156</span>]: pd.Series(np.random.randn(<span class="number">6</span>), index=rng)</span><br><span class="line">Out[<span class="number">156</span>]: </span><br><span class="line"><span class="number">2000</span>-01   -<span class="number">0.514551</span></span><br><span class="line"><span class="number">2000</span>-02   -<span class="number">0.559782</span></span><br><span class="line"><span class="number">2000</span>-03   -<span class="number">0.783408</span></span><br><span class="line"><span class="number">2000</span>-04   -<span class="number">1.797685</span></span><br><span class="line"><span class="number">2000</span>-05   -<span class="number">0.172670</span></span><br><span class="line"><span class="number">2000</span>-06    <span class="number">0.680215</span></span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你有一个字符串数组，你也可以使用PeriodIndex类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">157</span>]: values = [<span class="string">&#x27;2001Q3&#x27;</span>, <span class="string">&#x27;2002Q2&#x27;</span>, <span class="string">&#x27;2003Q1&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">158</span>]: index = pd.PeriodIndex(values, freq=<span class="string">&#x27;Q-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">159</span>]: index</span><br><span class="line">Out[<span class="number">159</span>]: PeriodIndex([<span class="string">&#x27;2001Q3&#x27;</span>, <span class="string">&#x27;2002Q2&#x27;</span>, <span class="string">&#x27;2003Q1&#x27;</span>], dtype=<span class="string">&#x27;period[Q-DEC]&#x27;</span>, freq</span><br><span class="line">=<span class="string">&#x27;Q-DEC&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="时期的频率转换">时期的频率转换</h2>
<p>Period和PeriodIndex对象都可以通过其asfreq方法被转换成别的频率。假设我们有一个年度时期，希望将其转换为当年年初或年末的一个月度时期。该任务非常简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">160</span>]: p = pd.Period(<span class="string">&#x27;2007&#x27;</span>, freq=<span class="string">&#x27;A-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">161</span>]: p</span><br><span class="line">Out[<span class="number">161</span>]: Period(<span class="string">&#x27;2007&#x27;</span>, <span class="string">&#x27;A-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">162</span>]: p.asfreq(<span class="string">&#x27;M&#x27;</span>, how=<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">Out[<span class="number">162</span>]: Period(<span class="string">&#x27;2007-01&#x27;</span>, <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">163</span>]: p.asfreq(<span class="string">&#x27;M&#x27;</span>, how=<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">Out[<span class="number">163</span>]: Period(<span class="string">&#x27;2007-12&#x27;</span>, <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可以将Period('2007','A-DEC')看做一个被划分为多个月度时期的时间段中的游标。图11-1对此进行了说明。对于一个不以12月结束的财政年度，月度子时期的归属情况就不一样了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">164</span>]: p = pd.Period(<span class="string">&#x27;2007&#x27;</span>, freq=<span class="string">&#x27;A-JUN&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">165</span>]: p</span><br><span class="line">Out[<span class="number">165</span>]: Period(<span class="string">&#x27;2007&#x27;</span>, <span class="string">&#x27;A-JUN&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">166</span>]: p.asfreq(<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">Out[<span class="number">166</span>]: Period(<span class="string">&#x27;2006-07&#x27;</span>, <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">167</span>]: p.asfreq(<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">Out[<span class="number">167</span>]: Period(<span class="string">&#x27;2007-06&#x27;</span>, <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-d201200d0e65676f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11-1 Period频率转换示例" /><figcaption aria-hidden="true">图11-1 Period频率转换示例</figcaption>
</figure>
<p>在将高频率转换为低频率时，超时期（superperiod）是由子时期（subperiod）所属的位置决定的。例如，在A-JUN频率中，月份“2007年8月”实际上是属于周期“2008年”的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">168</span>]: p = pd.Period(<span class="string">&#x27;Aug-2007&#x27;</span>, <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">169</span>]: p.asfreq(<span class="string">&#x27;A-JUN&#x27;</span>)</span><br><span class="line">Out[<span class="number">169</span>]: Period(<span class="string">&#x27;2008&#x27;</span>, <span class="string">&#x27;A-JUN&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>完整的PeriodIndex或TimeSeries的频率转换方式也是如此：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">170</span>]: rng = pd.period_range(<span class="string">&#x27;2006&#x27;</span>, <span class="string">&#x27;2009&#x27;</span>, freq=<span class="string">&#x27;A-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">171</span>]: ts = pd.Series(np.random.randn(<span class="built_in">len</span>(rng)), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">172</span>]: ts</span><br><span class="line">Out[<span class="number">172</span>]: </span><br><span class="line"><span class="number">2006</span>    <span class="number">1.607578</span></span><br><span class="line"><span class="number">2007</span>    <span class="number">0.200381</span></span><br><span class="line"><span class="number">2008</span>   -<span class="number">0.834068</span></span><br><span class="line"><span class="number">2009</span>   -<span class="number">0.302988</span></span><br><span class="line">Freq: A-DEC, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">173</span>]: ts.asfreq(<span class="string">&#x27;M&#x27;</span>, how=<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">Out[<span class="number">173</span>]: </span><br><span class="line"><span class="number">2006</span>-01    <span class="number">1.607578</span></span><br><span class="line"><span class="number">2007</span>-01    <span class="number">0.200381</span></span><br><span class="line"><span class="number">2008</span>-01   -<span class="number">0.834068</span></span><br><span class="line"><span class="number">2009</span>-01   -<span class="number">0.302988</span></span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，根据年度时期的第一个月，每年的时期被取代为每月的时期。如果我们想要每年的最后一个工作日，我们可以使用“B”频率，并指明想要该时期的末尾：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">174</span>]: ts.asfreq(<span class="string">&#x27;B&#x27;</span>, how=<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Out[<span class="number">174</span>]: </span><br><span class="line"><span class="number">2006</span>-<span class="number">12</span>-<span class="number">29</span>    <span class="number">1.607578</span></span><br><span class="line"><span class="number">2007</span>-<span class="number">12</span>-<span class="number">31</span>    <span class="number">0.200381</span></span><br><span class="line"><span class="number">2008</span>-<span class="number">12</span>-<span class="number">31</span>   -<span class="number">0.834068</span></span><br><span class="line"><span class="number">2009</span>-<span class="number">12</span>-<span class="number">31</span>   -<span class="number">0.302988</span></span><br><span class="line">Freq: B, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="按季度计算的时期频率">按季度计算的时期频率</h2>
<p>季度型数据在会计、金融等领域中很常见。许多季度型数据都会涉及“财年末”的概念，通常是一年12个月中某月的最后一个日历日或工作日。就这一点来说，时期"2012Q4"根据财年末的不同会有不同的含义。pandas支持12种可能的季度型频率，即Q-JAN到Q-DEC：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">175</span>]: p = pd.Period(<span class="string">&#x27;2012Q4&#x27;</span>, freq=<span class="string">&#x27;Q-JAN&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">176</span>]: p</span><br><span class="line">Out[<span class="number">176</span>]: Period(<span class="string">&#x27;2012Q4&#x27;</span>, <span class="string">&#x27;Q-JAN&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在以1月结束的财年中，2012Q4是从11月到1月（将其转换为日型频率就明白了）。图11-2对此进行了说明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">177</span>]: p.asfreq(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">Out[<span class="number">177</span>]: Period(<span class="string">&#x27;2011-11-01&#x27;</span>, <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">178</span>]: p.asfreq(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">Out[<span class="number">178</span>]: Period(<span class="string">&#x27;2012-01-31&#x27;</span>, <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-e2e1d52c9766f6ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11.2 不同季度型频率之间的转换" /><figcaption aria-hidden="true">图11.2 不同季度型频率之间的转换</figcaption>
</figure>
<p>因此，Period之间的算术运算会非常简单。例如，要获取该季度倒数第二个工作日下午4点的时间戳，你可以这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">179</span>]: p4pm = (p.asfreq(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;e&#x27;</span>) - <span class="number">1</span>).asfreq(<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;s&#x27;</span>) + <span class="number">16</span> * <span class="number">60</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">180</span>]: p4pm</span><br><span class="line">Out[<span class="number">180</span>]: Period(<span class="string">&#x27;2012-01-30 16:00&#x27;</span>, <span class="string">&#x27;T&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">181</span>]: p4pm.to_timestamp()</span><br><span class="line">Out[<span class="number">181</span>]: Timestamp(<span class="string">&#x27;2012-01-30 16:00:00&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>period_range可用于生成季度型范围。季度型范围的算术运算也跟上面是一样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">182</span>]: rng = pd.period_range(<span class="string">&#x27;2011Q3&#x27;</span>, <span class="string">&#x27;2012Q4&#x27;</span>, freq=<span class="string">&#x27;Q-JAN&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">183</span>]: ts = pd.Series(np.arange(<span class="built_in">len</span>(rng)), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">184</span>]: ts</span><br><span class="line">Out[<span class="number">184</span>]: </span><br><span class="line">2011Q3    <span class="number">0</span></span><br><span class="line">2011Q4    <span class="number">1</span></span><br><span class="line">2012Q1    <span class="number">2</span></span><br><span class="line">2012Q2    <span class="number">3</span></span><br><span class="line">2012Q3    <span class="number">4</span></span><br><span class="line">2012Q4    <span class="number">5</span></span><br><span class="line">Freq: Q-JAN, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">185</span>]: new_rng = (rng.asfreq(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;e&#x27;</span>) - <span class="number">1</span>).asfreq(<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;s&#x27;</span>) + <span class="number">16</span> * <span class="number">60</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">186</span>]: ts.index = new_rng.to_timestamp()</span><br><span class="line"></span><br><span class="line">In [<span class="number">187</span>]: ts</span><br><span class="line">Out[<span class="number">187</span>]:</span><br><span class="line"><span class="number">2010</span>-<span class="number">10</span>-<span class="number">28</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">0</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">28</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">1</span></span><br><span class="line"><span class="number">2011</span>-04-<span class="number">28</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">2</span></span><br><span class="line"><span class="number">2011</span>-07-<span class="number">28</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">3</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">28</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">4</span></span><br><span class="line"><span class="number">2012</span>-01-<span class="number">30</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">5</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="将timestamp转换为period及其反向过程">将Timestamp转换为Period（及其反向过程）</h2>
<p>通过使用to_period方法，可以将由时间戳索引的Series和DataFrame对象转换为以时期索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">188</span>]: rng = pd.date_range(<span class="string">&#x27;2000-01-01&#x27;</span>, periods=<span class="number">3</span>, freq=<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">189</span>]: ts = pd.Series(np.random.randn(<span class="number">3</span>), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">190</span>]: ts</span><br><span class="line">Out[<span class="number">190</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>    <span class="number">1.663261</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>   -<span class="number">0.996206</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>    <span class="number">1.521760</span></span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">191</span>]: pts = ts.to_period()</span><br><span class="line"></span><br><span class="line">In [<span class="number">192</span>]: pts</span><br><span class="line">Out[<span class="number">192</span>]: </span><br><span class="line"><span class="number">2000</span>-01    <span class="number">1.663261</span></span><br><span class="line"><span class="number">2000</span>-02   -<span class="number">0.996206</span></span><br><span class="line"><span class="number">2000</span>-03    <span class="number">1.521760</span></span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于时期指的是非重叠时间区间，因此对于给定的频率，一个时间戳只能属于一个时期。新PeriodIndex的频率默认是从时间戳推断而来的，你也可以指定任何别的频率。结果中允许存在重复时期：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">193</span>]: rng = pd.date_range(<span class="string">&#x27;1/29/2000&#x27;</span>, periods=<span class="number">6</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">194</span>]: ts2 = pd.Series(np.random.randn(<span class="number">6</span>), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">195</span>]: ts2</span><br><span class="line">Out[<span class="number">195</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">29</span>    <span class="number">0.244175</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">30</span>    <span class="number">0.423331</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.654040</span></span><br><span class="line"><span class="number">2000</span>-02-01    <span class="number">2.089154</span></span><br><span class="line"><span class="number">2000</span>-02-02   -<span class="number">0.060220</span></span><br><span class="line"><span class="number">2000</span>-02-03   -<span class="number">0.167933</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">196</span>]: ts2.to_period(<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">Out[<span class="number">196</span>]: </span><br><span class="line"><span class="number">2000</span>-01    <span class="number">0.244175</span></span><br><span class="line"><span class="number">2000</span>-01    <span class="number">0.423331</span></span><br><span class="line"><span class="number">2000</span>-01   -<span class="number">0.654040</span></span><br><span class="line"><span class="number">2000</span>-02    <span class="number">2.089154</span></span><br><span class="line"><span class="number">2000</span>-02   -<span class="number">0.060220</span></span><br><span class="line"><span class="number">2000</span>-02   -<span class="number">0.167933</span></span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要转换回时间戳，使用to_timestamp即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">197</span>]: pts = ts2.to_period()</span><br><span class="line"></span><br><span class="line">In [<span class="number">198</span>]: pts</span><br><span class="line">Out[<span class="number">198</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">29</span>    <span class="number">0.244175</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">30</span>    <span class="number">0.423331</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.654040</span></span><br><span class="line"><span class="number">2000</span>-02-01    <span class="number">2.089154</span></span><br><span class="line"><span class="number">2000</span>-02-02   -<span class="number">0.060220</span></span><br><span class="line"><span class="number">2000</span>-02-03   -<span class="number">0.167933</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">199</span>]: pts.to_timestamp(how=<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">Out[<span class="number">199</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">29</span>    <span class="number">0.244175</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">30</span>    <span class="number">0.423331</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.654040</span></span><br><span class="line"><span class="number">2000</span>-02-01    <span class="number">2.089154</span></span><br><span class="line"><span class="number">2000</span>-02-02   -<span class="number">0.060220</span></span><br><span class="line"><span class="number">2000</span>-02-03   -<span class="number">0.167933</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="通过数组创建periodindex">通过数组创建PeriodIndex</h2>
<p>固定频率的数据集通常会将时间信息分开存放在多个列中。例如，在下面这个宏观经济数据集中，年度和季度就分别存放在不同的列中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">200</span>]: data = pd.read_csv(<span class="string">&#x27;examples/macrodata.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">201</span>]: data.head(<span class="number">5</span>)</span><br><span class="line">Out[<span class="number">201</span>]: </span><br><span class="line">     year  quarter   realgdp  realcons  realinv  realgovt  realdpi    cpi  \</span><br><span class="line"><span class="number">0</span>  <span class="number">1959.0</span>      <span class="number">1.0</span>  <span class="number">2710.349</span>    <span class="number">1707.4</span>  <span class="number">286.898</span>   <span class="number">470.045</span>   <span class="number">1886.9</span>  <span class="number">28.98</span>   </span><br><span class="line"><span class="number">1</span>  <span class="number">1959.0</span>      <span class="number">2.0</span>  <span class="number">2778.801</span>    <span class="number">1733.7</span>  <span class="number">310.859</span>   <span class="number">481.301</span>   <span class="number">1919.7</span>  <span class="number">29.15</span>   </span><br><span class="line"><span class="number">2</span>  <span class="number">1959.0</span>      <span class="number">3.0</span>  <span class="number">2775.488</span>    <span class="number">1751.8</span>  <span class="number">289.226</span>   <span class="number">491.260</span>   <span class="number">1916.4</span>  <span class="number">29.35</span>   </span><br><span class="line"><span class="number">3</span>  <span class="number">1959.0</span>      <span class="number">4.0</span>  <span class="number">2785.204</span>    <span class="number">1753.7</span>  <span class="number">299.356</span>   <span class="number">484.052</span>   <span class="number">1931.3</span>  <span class="number">29.37</span>   </span><br><span class="line"><span class="number">4</span>  <span class="number">1960.0</span>      <span class="number">1.0</span>  <span class="number">2847.699</span>    <span class="number">1770.5</span>  <span class="number">331.722</span>   <span class="number">462.199</span>   <span class="number">1955.5</span>  <span class="number">29.54</span>   </span><br><span class="line">      m1  tbilrate  unemp      pop  infl  realint  </span><br><span class="line"><span class="number">0</span>  <span class="number">139.7</span>      <span class="number">2.82</span>    <span class="number">5.8</span>  <span class="number">177.146</span>  <span class="number">0.00</span>     <span class="number">0.00</span>  </span><br><span class="line"><span class="number">1</span>  <span class="number">141.7</span>      <span class="number">3.08</span>    <span class="number">5.1</span>  <span class="number">177.830</span>  <span class="number">2.34</span>     <span class="number">0.74</span>  </span><br><span class="line"><span class="number">2</span>  <span class="number">140.5</span>      <span class="number">3.82</span>    <span class="number">5.3</span>  <span class="number">178.657</span>  <span class="number">2.74</span>     <span class="number">1.09</span>  </span><br><span class="line"><span class="number">3</span>  <span class="number">140.0</span>      <span class="number">4.33</span>    <span class="number">5.6</span>  <span class="number">179.386</span>  <span class="number">0.27</span>     <span class="number">4.06</span>  </span><br><span class="line"><span class="number">4</span>  <span class="number">139.6</span>      <span class="number">3.50</span>    <span class="number">5.2</span>  <span class="number">180.007</span>  <span class="number">2.31</span>     <span class="number">1.19</span>  </span><br><span class="line"></span><br><span class="line">In [<span class="number">202</span>]: data.year</span><br><span class="line">Out[<span class="number">202</span>]: </span><br><span class="line"><span class="number">0</span>      <span class="number">1959.0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">1959.0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">1959.0</span></span><br><span class="line"><span class="number">3</span>      <span class="number">1959.0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">1960.0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">1960.0</span></span><br><span class="line"><span class="number">6</span>      <span class="number">1960.0</span></span><br><span class="line"><span class="number">7</span>      <span class="number">1960.0</span></span><br><span class="line"><span class="number">8</span>      <span class="number">1961.0</span></span><br><span class="line"><span class="number">9</span>      <span class="number">1961.0</span></span><br><span class="line">        ...  </span><br><span class="line"><span class="number">193</span>    <span class="number">2007.0</span></span><br><span class="line"><span class="number">194</span>    <span class="number">2007.0</span></span><br><span class="line"><span class="number">195</span>    <span class="number">2007.0</span></span><br><span class="line"><span class="number">196</span>    <span class="number">2008.0</span></span><br><span class="line"><span class="number">197</span>    <span class="number">2008.0</span></span><br><span class="line"><span class="number">198</span>    <span class="number">2008.0</span></span><br><span class="line"><span class="number">199</span>    <span class="number">2008.0</span></span><br><span class="line"><span class="number">200</span>    <span class="number">2009.0</span></span><br><span class="line"><span class="number">201</span>    <span class="number">2009.0</span></span><br><span class="line"><span class="number">202</span>    <span class="number">2009.0</span></span><br><span class="line">Name: year, Length: <span class="number">203</span>, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">203</span>]: data.quarter</span><br><span class="line">Out[<span class="number">203</span>]: </span><br><span class="line"><span class="number">0</span>      <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">2.0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">3.0</span></span><br><span class="line"><span class="number">3</span>      <span class="number">4.0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">1.0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">2.0</span></span><br><span class="line"><span class="number">6</span>      <span class="number">3.0</span></span><br><span class="line"><span class="number">7</span>      <span class="number">4.0</span></span><br><span class="line"><span class="number">8</span>      <span class="number">1.0</span></span><br><span class="line"><span class="number">9</span>      <span class="number">2.0</span></span><br><span class="line">      ... </span><br><span class="line"><span class="number">193</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">194</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">195</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">196</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">197</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">198</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">199</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">200</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">201</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">202</span>    <span class="number">3.0</span></span><br><span class="line">Name: quarter, Length: <span class="number">203</span>, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过将这些数组以及一个频率传入PeriodIndex，就可以将它们合并成DataFrame的一个索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">204</span>]: index = pd.PeriodIndex(year=data.year, quarter=data.quarter,</span><br><span class="line">   .....:                        freq=<span class="string">&#x27;Q-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">205</span>]: index</span><br><span class="line">Out[<span class="number">205</span>]: </span><br><span class="line">PeriodIndex([<span class="string">&#x27;1959Q1&#x27;</span>, <span class="string">&#x27;1959Q2&#x27;</span>, <span class="string">&#x27;1959Q3&#x27;</span>, <span class="string">&#x27;1959Q4&#x27;</span>, <span class="string">&#x27;1960Q1&#x27;</span>, <span class="string">&#x27;1960Q2&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;1960Q3&#x27;</span>, <span class="string">&#x27;1960Q4&#x27;</span>, <span class="string">&#x27;1961Q1&#x27;</span>, <span class="string">&#x27;1961Q2&#x27;</span>,</span><br><span class="line">             ...</span><br><span class="line">             <span class="string">&#x27;2007Q2&#x27;</span>, <span class="string">&#x27;2007Q3&#x27;</span>, <span class="string">&#x27;2007Q4&#x27;</span>, <span class="string">&#x27;2008Q1&#x27;</span>, <span class="string">&#x27;2008Q2&#x27;</span>, <span class="string">&#x27;2008Q3&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;2008Q4&#x27;</span>, <span class="string">&#x27;2009Q1&#x27;</span>, <span class="string">&#x27;2009Q2&#x27;</span>, <span class="string">&#x27;2009Q3&#x27;</span>],</span><br><span class="line">            dtype=<span class="string">&#x27;period[Q-DEC]&#x27;</span>, length=<span class="number">203</span>, freq=<span class="string">&#x27;Q-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">206</span>]: data.index = index</span><br><span class="line"></span><br><span class="line">In [<span class="number">207</span>]: data.infl</span><br><span class="line">Out[<span class="number">207</span>]: </span><br><span class="line">1959Q1    <span class="number">0.00</span></span><br><span class="line">1959Q2    <span class="number">2.34</span></span><br><span class="line">1959Q3    <span class="number">2.74</span></span><br><span class="line">1959Q4    <span class="number">0.27</span></span><br><span class="line">1960Q1    <span class="number">2.31</span></span><br><span class="line">1960Q2    <span class="number">0.14</span></span><br><span class="line">1960Q3    <span class="number">2.70</span></span><br><span class="line">1960Q4    <span class="number">1.21</span></span><br><span class="line">1961Q1   -<span class="number">0.40</span></span><br><span class="line">1961Q2    <span class="number">1.47</span></span><br><span class="line">          ... </span><br><span class="line">2007Q2    <span class="number">2.75</span></span><br><span class="line">2007Q3    <span class="number">3.45</span></span><br><span class="line">2007Q4    <span class="number">6.38</span></span><br><span class="line">2008Q1    <span class="number">2.82</span></span><br><span class="line">2008Q2    <span class="number">8.53</span></span><br><span class="line">2008Q3   -<span class="number">3.16</span></span><br><span class="line">2008Q4   -<span class="number">8.79</span></span><br><span class="line">2009Q1    <span class="number">0.94</span></span><br><span class="line">2009Q2    <span class="number">3.37</span></span><br><span class="line">2009Q3    <span class="number">3.56</span></span><br><span class="line">Freq: Q-DEC, Name: infl, Length: <span class="number">203</span>, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="重采样及频率转换">11.6 重采样及频率转换</h1>
<p>重采样（resampling）指的是将时间序列从一个频率转换到另一个频率的处理过程。将高频率数据聚合到低频率称为降采样（downsampling），而将低频率数据转换到高频率则称为升采样（upsampling）。并不是所有的重采样都能被划分到这两个大类中。例如，将W-WED（每周三）转换为W-FRI既不是降采样也不是升采样。</p>
<p>pandas对象都带有一个resample方法，它是各种频率转换工作的主力函数。resample有一个类似于groupby的API，调用resample可以分组数据，然后会调用一个聚合函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">208</span>]: rng = pd.date_range(<span class="string">&#x27;2000-01-01&#x27;</span>, periods=<span class="number">100</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">209</span>]: ts = pd.Series(np.random.randn(<span class="built_in">len</span>(rng)), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">210</span>]: ts</span><br><span class="line">Out[<span class="number">210</span>]: </span><br><span class="line"><span class="number">2000</span>-01-01    <span class="number">0.631634</span></span><br><span class="line"><span class="number">2000</span>-01-02   -<span class="number">1.594313</span></span><br><span class="line"><span class="number">2000</span>-01-03   -<span class="number">1.519937</span></span><br><span class="line"><span class="number">2000</span>-01-04    <span class="number">1.108752</span></span><br><span class="line"><span class="number">2000</span>-01-05    <span class="number">1.255853</span></span><br><span class="line"><span class="number">2000</span>-01-06   -<span class="number">0.024330</span></span><br><span class="line"><span class="number">2000</span>-01-07   -<span class="number">2.047939</span></span><br><span class="line"><span class="number">2000</span>-01-08   -<span class="number">0.272657</span></span><br><span class="line"><span class="number">2000</span>-01-09   -<span class="number">1.692615</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>    <span class="number">1.423830</span></span><br><span class="line">                ...   </span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>   -<span class="number">0.007852</span></span><br><span class="line"><span class="number">2000</span>-04-01   -<span class="number">1.638806</span></span><br><span class="line"><span class="number">2000</span>-04-02    <span class="number">1.401227</span></span><br><span class="line"><span class="number">2000</span>-04-03    <span class="number">1.758539</span></span><br><span class="line"><span class="number">2000</span>-04-04    <span class="number">0.628932</span></span><br><span class="line"><span class="number">2000</span>-04-05   -<span class="number">0.423776</span></span><br><span class="line"><span class="number">2000</span>-04-06    <span class="number">0.789740</span></span><br><span class="line"><span class="number">2000</span>-04-07    <span class="number">0.937568</span></span><br><span class="line"><span class="number">2000</span>-04-08   -<span class="number">2.253294</span></span><br><span class="line"><span class="number">2000</span>-04-09   -<span class="number">1.772919</span></span><br><span class="line">Freq: D, Length: <span class="number">100</span>, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">211</span>]: ts.resample(<span class="string">&#x27;M&#x27;</span>).mean()</span><br><span class="line">Out[<span class="number">211</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.165893</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>    <span class="number">0.078606</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>    <span class="number">0.223811</span></span><br><span class="line"><span class="number">2000</span>-04-<span class="number">30</span>   -<span class="number">0.063643</span></span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">212</span>]: ts.resample(<span class="string">&#x27;M&#x27;</span>, kind=<span class="string">&#x27;period&#x27;</span>).mean()</span><br><span class="line">Out[<span class="number">212</span>]: </span><br><span class="line"><span class="number">2000</span>-01   -<span class="number">0.165893</span></span><br><span class="line"><span class="number">2000</span>-02    <span class="number">0.078606</span></span><br><span class="line"><span class="number">2000</span>-03    <span class="number">0.223811</span></span><br><span class="line"><span class="number">2000</span>-04   -<span class="number">0.063643</span></span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>resample是一个灵活高效的方法，可用于处理非常大的时间序列。我将通过一系列的示例说明其用法。表11-5总结它的一些选项。</p>
<p>表11-5 resample方法的参数 <img src="https://upload-images.jianshu.io/upload_images/7178691-b40a57086c904e83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<h2 id="降采样">降采样</h2>
<p>将数据聚合到规律的低频率是一件非常普通的时间序列处理任务。待聚合的数据不必拥有固定的频率，期望的频率会自动定义聚合的面元边界，这些面元用于将时间序列拆分为多个片段。例如，要转换到月度频率（'M'或'BM'），数据需要被划分到多个单月时间段中。各时间段都是半开放的。一个数据点只能属于一个时间段，所有时间段的并集必须能组成整个时间帧。在用resample对数据进行降采样时，需要考虑两样东西：</p>
<ul>
<li>各区间哪边是闭合的。</li>
<li>如何标记各个聚合面元，用区间的开头还是末尾。</li>
</ul>
<p>为了说明，我们来看一些“1分钟”数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">213</span>]: rng = pd.date_range(<span class="string">&#x27;2000-01-01&#x27;</span>, periods=<span class="number">12</span>, freq=<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">214</span>]: ts = pd.Series(np.arange(<span class="number">12</span>), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">215</span>]: ts</span><br><span class="line">Out[<span class="number">215</span>]: </span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:01:<span class="number">00</span>     <span class="number">1</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:02:<span class="number">00</span>     <span class="number">2</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:03:<span class="number">00</span>     <span class="number">3</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:04:<span class="number">00</span>     <span class="number">4</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:05:<span class="number">00</span>     <span class="number">5</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:06:<span class="number">00</span>     <span class="number">6</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:07:<span class="number">00</span>     <span class="number">7</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:08:<span class="number">00</span>     <span class="number">8</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:09:<span class="number">00</span>     <span class="number">9</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>    <span class="number">10</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">11</span>:<span class="number">00</span>    <span class="number">11</span></span><br><span class="line">Freq: T, dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设你想要通过求和的方式将这些数据聚合到“5分钟”块中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">216</span>]: ts.resample(<span class="string">&#x27;5min&#x27;</span>, closed=<span class="string">&#x27;right&#x27;</span>).<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">216</span>]: </span><br><span class="line"><span class="number">1999</span>-<span class="number">12</span>-<span class="number">31</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">00</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">15</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:05:<span class="number">00</span>    <span class="number">40</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>    <span class="number">11</span></span><br><span class="line">Freq: 5T, dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传入的频率将会以“5分钟”的增量定义面元边界。默认情况下，面元的右边界是包含的，因此00:00到00:05的区间中是包含00:05的。传入closed='left'会让区间以左边界闭合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">217</span>]: ts.resample(<span class="string">&#x27;5min&#x27;</span>, closed=<span class="string">&#x27;right&#x27;</span>).<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">217</span>]: </span><br><span class="line"><span class="number">1999</span>-<span class="number">12</span>-<span class="number">31</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">00</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">15</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:05:<span class="number">00</span>    <span class="number">40</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>    <span class="number">11</span></span><br><span class="line">Freq: 5T, dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如你所见，最终的时间序列是以各面元右边界的时间戳进行标记的。传入label='right'即可用面元的邮编界对其进行标记：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">218</span>]: ts.resample(<span class="string">&#x27;5min&#x27;</span>, closed=<span class="string">&#x27;right&#x27;</span>, label=<span class="string">&#x27;right&#x27;</span>).<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">218</span>]: </span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:05:<span class="number">00</span>    <span class="number">15</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>    <span class="number">40</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">15</span>:<span class="number">00</span>    <span class="number">11</span></span><br><span class="line">Freq: 5T, dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>图11-3说明了“1分钟”数据被转换为“5分钟”数据的处理过程。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-7a77f47844f2ee8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11-3 各种closed、label约定的“5分钟”重采样演示" /><figcaption aria-hidden="true">图11-3 各种closed、label约定的“5分钟”重采样演示</figcaption>
</figure>
<p>最后，你可能希望对结果索引做一些位移，比如从右边界减去一秒以便更容易明白该时间戳到底表示的是哪个区间。只需通过loffset设置一个字符串或日期偏移量即可实现这个目的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">219</span>]: ts.resample(<span class="string">&#x27;5min&#x27;</span>, closed=<span class="string">&#x27;right&#x27;</span>,</span><br><span class="line">   .....:             label=<span class="string">&#x27;right&#x27;</span>, loffset=<span class="string">&#x27;-1s&#x27;</span>).<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">219</span>]: </span><br><span class="line"><span class="number">1999</span>-<span class="number">12</span>-<span class="number">31</span> <span class="number">23</span>:<span class="number">59</span>:<span class="number">59</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:04:<span class="number">59</span>    <span class="number">15</span></span><br><span class="line">In [<span class="number">219</span>]: ts.resample(<span class="string">&#x27;5min&#x27;</span>, closed=<span class="string">&#x27;right&#x27;</span>,</span><br><span class="line">   .....:             label=<span class="string">&#x27;right&#x27;</span>, loffset=<span class="string">&#x27;-1s&#x27;</span>).<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">219</span>]: </span><br><span class="line"><span class="number">1999</span>-<span class="number">12</span>-<span class="number">31</span> <span class="number">23</span>:<span class="number">59</span>:<span class="number">59</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:04:<span class="number">59</span>    <span class="number">15</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此外，也可以通过调用结果对象的shift方法来实现该目的，这样就不需要设置loffset了。</p>
<h2 id="ohlc重采样">OHLC重采样</h2>
<p>金融领域中有一种无所不在的时间序列聚合方式，即计算各面元的四个值：第一个值（open，开盘）、最后一个值（close，收盘）、最大值（high，最高）以及最小值（low，最低）。传入how='ohlc'即可得到一个含有这四种聚合值的DataFrame。整个过程很高效，只需一次扫描即可计算出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">220</span>]: ts.resample(<span class="string">&#x27;5min&#x27;</span>).ohlc()</span><br><span class="line">Out[<span class="number">220</span>]: </span><br><span class="line">                     <span class="built_in">open</span>  high  low  close</span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>     <span class="number">0</span>     <span class="number">4</span>    <span class="number">0</span>      <span class="number">4</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:05:<span class="number">00</span>     <span class="number">5</span>     <span class="number">9</span>    <span class="number">5</span>      <span class="number">9</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>    <span class="number">10</span>    <span class="number">11</span>   <span class="number">10</span>     <span class="number">11</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="升采样和插值">升采样和插值</h2>
<p>在将数据从低频率转换到高频率时，就不需要聚合了。我们来看一个带有一些周型数据的DataFrame：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">221</span>]: frame = pd.DataFrame(np.random.randn(<span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line">   .....:                      index=pd.date_range(<span class="string">&#x27;1/1/2000&#x27;</span>, periods=<span class="number">2</span>,</span><br><span class="line">   .....:                                          freq=<span class="string">&#x27;W-WED&#x27;</span>),</span><br><span class="line">   .....:                      columns=[<span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">222</span>]: frame</span><br><span class="line">Out[<span class="number">222</span>]: </span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2000</span>-01-05 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">12</span> -<span class="number">0.046662</span>  <span class="number">0.927238</span>  <span class="number">0.482284</span> -<span class="number">0.867130</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当你对这个数据进行聚合，每组只有一个值，这样就会引入缺失值。我们使用asfreq方法转换成高频，不经过聚合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">223</span>]: df_daily = frame.resample(<span class="string">&#x27;D&#x27;</span>).asfreq()</span><br><span class="line"></span><br><span class="line">In [<span class="number">224</span>]: df_daily</span><br><span class="line">Out[<span class="number">224</span>]: </span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2000</span>-01-05 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-06       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-07       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-08       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-09       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-<span class="number">11</span>       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-<span class="number">12</span> -<span class="number">0.046662</span>  <span class="number">0.927238</span>  <span class="number">0.482284</span> -<span class="number">0.867130</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设你想要用前面的周型值填充“非星期三”。resampling的填充和插值方式跟fillna和reindex的一样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">225</span>]: frame.resample(<span class="string">&#x27;D&#x27;</span>).ffill()</span><br><span class="line">Out[<span class="number">225</span>]: </span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2000</span>-01-05 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-06 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-07 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-08 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-09 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span> -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">11</span> -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">12</span> -<span class="number">0.046662</span>  <span class="number">0.927238</span>  <span class="number">0.482284</span> -<span class="number">0.867130</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同样，这里也可以只填充指定的时期数（目的是限制前面的观测值的持续使用距离）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">226</span>]: frame.resample(<span class="string">&#x27;D&#x27;</span>).ffill(limit=<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">226</span>]:</span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2000</span>-01-05 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-06 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-07 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-08       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-09       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-<span class="number">11</span>       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-<span class="number">12</span> -<span class="number">0.046662</span>  <span class="number">0.927238</span>  <span class="number">0.482284</span> -<span class="number">0.867130</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，新的日期索引完全没必要跟旧的重叠：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">227</span>]: frame.resample(<span class="string">&#x27;W-THU&#x27;</span>).ffill()</span><br><span class="line">Out[<span class="number">227</span>]: </span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2000</span>-01-06 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">13</span> -<span class="number">0.046662</span>  <span class="number">0.927238</span>  <span class="number">0.482284</span> -<span class="number">0.867130</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="通过时期进行重采样">通过时期进行重采样</h2>
<p>对那些使用时期索引的数据进行重采样与时间戳很像：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">228</span>]: frame = pd.DataFrame(np.random.randn(<span class="number">24</span>, <span class="number">4</span>),</span><br><span class="line">   .....:                      index=pd.period_range(<span class="string">&#x27;1-2000&#x27;</span>, <span class="string">&#x27;12-2001&#x27;</span>,</span><br><span class="line">   .....:                                            freq=<span class="string">&#x27;M&#x27;</span>),</span><br><span class="line">   .....:                      columns=[<span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">229</span>]: frame[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">229</span>]: </span><br><span class="line">         Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2000</span>-01  <span class="number">0.493841</span> -<span class="number">0.155434</span>  <span class="number">1.397286</span>  <span class="number">1.507055</span></span><br><span class="line"><span class="number">2000</span>-02 -<span class="number">1.179442</span>  <span class="number">0.443171</span>  <span class="number">1.395676</span> -<span class="number">0.529658</span></span><br><span class="line"><span class="number">2000</span>-03  <span class="number">0.787358</span>  <span class="number">0.248845</span>  <span class="number">0.743239</span>  <span class="number">1.267746</span></span><br><span class="line"><span class="number">2000</span>-04  <span class="number">1.302395</span> -<span class="number">0.272154</span> -<span class="number">0.051532</span> -<span class="number">0.467740</span></span><br><span class="line"><span class="number">2000</span>-05 -<span class="number">1.040816</span>  <span class="number">0.426419</span>  <span class="number">0.312945</span> -<span class="number">1.115689</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">230</span>]: annual_frame = frame.resample(<span class="string">&#x27;A-DEC&#x27;</span>).mean()</span><br><span class="line"></span><br><span class="line">In [<span class="number">231</span>]: annual_frame</span><br><span class="line">Out[<span class="number">231</span>]: </span><br><span class="line">      Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2000</span>  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line"><span class="number">2001</span>  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>升采样要稍微麻烦一些，因为你必须决定在新频率中各区间的哪端用于放置原来的值，就像asfreq方法那样。convention参数默认为'start'，也可设置为'end'：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Q-DEC: Quarterly, year ending in December</span></span><br><span class="line">In [<span class="number">232</span>]: annual_frame.resample(<span class="string">&#x27;Q-DEC&#x27;</span>).ffill()</span><br><span class="line">Out[<span class="number">232</span>]: </span><br><span class="line">        Colorado     Texas  New York      Ohio</span><br><span class="line">2000Q1  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2000Q2  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2000Q3  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2000Q4  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q1  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line">2001Q2  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line">2001Q3  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line">2001Q4  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">233</span>]: annual_frame.resample(<span class="string">&#x27;Q-DEC&#x27;</span>, convention=<span class="string">&#x27;end&#x27;</span>).ffill()</span><br><span class="line">Out[<span class="number">233</span>]: </span><br><span class="line">        Colorado     Texas  New York      Ohio</span><br><span class="line">2000Q4  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q1  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q2  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q3  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q4  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于时期指的是时间区间，所以升采样和降采样的规则就比较严格：</p>
<ul>
<li>在降采样中，目标频率必须是源频率的子时期（subperiod）。</li>
<li>在升采样中，目标频率必须是源频率的超时期（superperiod）。</li>
</ul>
<p>如果不满足这些条件，就会引发异常。这主要影响的是按季、年、周计算的频率。例如，由Q-MAR定义的时间区间只能升采样为A-MAR、A-JUN、A-SEP、A-DEC等：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">234</span>]: annual_frame.resample(<span class="string">&#x27;Q-MAR&#x27;</span>).ffill()</span><br><span class="line">Out[<span class="number">234</span>]: </span><br><span class="line">        Colorado     Texas  New York      Ohio</span><br><span class="line">2000Q4  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q1  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q2  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q3  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q4  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line">2002Q1  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line">2002Q2  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line">2002Q3  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="移动窗口函数">11.7 移动窗口函数</h1>
<p>在移动窗口（可以带有指数衰减权数）上计算的各种统计函数也是一类常见于时间序列的数组变换。这样可以圆滑噪音数据或断裂数据。我将它们称为移动窗口函数（moving window function），其中还包括那些窗口不定长的函数（如指数加权移动平均）。跟其他统计函数一样，移动窗口函数也会自动排除缺失值。</p>
<p>开始之前，我们加载一些时间序列数据，将其重采样为工作日频率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">235</span>]: close_px_all = pd.read_csv(<span class="string">&#x27;examples/stock_px_2.csv&#x27;</span>,</span><br><span class="line">   .....:                            parse_dates=<span class="literal">True</span>, index_col=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">236</span>]: close_px = close_px_all[[<span class="string">&#x27;AAPL&#x27;</span>, <span class="string">&#x27;MSFT&#x27;</span>, <span class="string">&#x27;XOM&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">237</span>]: close_px = close_px.resample(<span class="string">&#x27;B&#x27;</span>).ffill()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在引入rolling运算符，它与resample和groupby很像。可以在TimeSeries或DataFrame以及一个window（表示期数，见图11-4）上调用它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">238</span>]: close_px.AAPL.plot()</span><br><span class="line">Out[<span class="number">238</span>]: &lt;matplotlib.axes._subplots.AxesSubplot at <span class="number">0x7f2f2570cf98</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">239</span>]: close_px.AAPL.rolling(<span class="number">250</span>).mean().plot()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-3327483eab730b09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11-4 苹果公司股价的250日均线" /><figcaption aria-hidden="true">图11-4 苹果公司股价的250日均线</figcaption>
</figure>
<p>表达式rolling(250)与groupby很像，但不是对其进行分组，而是创建一个按照250天分组的滑动窗口对象。然后，我们就得到了苹果公司股价的250天的移动窗口。</p>
<p>默认情况下，rolling函数需要窗口中所有的值为非NA值。可以修改该行为以解决缺失数据的问题。其实，在时间序列开始处尚不足窗口期的那些数据就是个特例（见图11-5）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">241</span>]: appl_std250 = close_px.AAPL.rolling(<span class="number">250</span>, min_periods=<span class="number">10</span>).std()</span><br><span class="line"></span><br><span class="line">In [<span class="number">242</span>]: appl_std250[<span class="number">5</span>:<span class="number">12</span>]</span><br><span class="line">Out[<span class="number">242</span>]: </span><br><span class="line"><span class="number">2003</span>-01-09         NaN</span><br><span class="line"><span class="number">2003</span>-01-<span class="number">10</span>         NaN</span><br><span class="line"><span class="number">2003</span>-01-<span class="number">13</span>         NaN</span><br><span class="line"><span class="number">2003</span>-01-<span class="number">14</span>         NaN</span><br><span class="line"><span class="number">2003</span>-01-<span class="number">15</span>    <span class="number">0.077496</span></span><br><span class="line"><span class="number">2003</span>-01-<span class="number">16</span>    <span class="number">0.074760</span></span><br><span class="line"><span class="number">2003</span>-01-<span class="number">17</span>    <span class="number">0.112368</span></span><br><span class="line">Freq: B, Name: AAPL, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">243</span>]: appl_std250.plot()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-15f565bed1ccad09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11-5 苹果公司250日每日回报标准差" /><figcaption aria-hidden="true">图11-5 苹果公司250日每日回报标准差</figcaption>
</figure>
<p>要计算扩展窗口平均（expanding window mean），可以使用expanding而不是rolling。“扩展”意味着，从时间序列的起始处开始窗口，增加窗口直到它超过所有的序列。apple_std250时间序列的扩展窗口平均如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">244</span>]: expanding_mean = appl_std250.expanding().mean()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对DataFrame调用rolling_mean（以及与之类似的函数）会将转换应用到所有的列上（见图11-6）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">246</span>]: close_px.rolling(<span class="number">60</span>).mean().plot(logy=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-979f748052b2279f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11-6 各股价60日均线（对数Y轴）" /><figcaption aria-hidden="true">图11-6 各股价60日均线（对数Y轴）</figcaption>
</figure>
<p>rolling函数也可以接受一个指定固定大小时间补偿字符串，而不是一组时期。这样可以方便处理不规律的时间序列。这些字符串也可以传递给resample。例如，我们可以计算20天的滚动均值，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">247</span>]: close_px.rolling(<span class="string">&#x27;20D&#x27;</span>).mean()</span><br><span class="line">Out[<span class="number">247</span>]:</span><br><span class="line">                  AAPL       MSFT        XOM</span><br><span class="line"><span class="number">2003</span>-01-02    <span class="number">7.400000</span>  <span class="number">21.110000</span>  <span class="number">29.220000</span></span><br><span class="line"><span class="number">2003</span>-01-03    <span class="number">7.425000</span>  <span class="number">21.125000</span>  <span class="number">29.230000</span></span><br><span class="line"><span class="number">2003</span>-01-06    <span class="number">7.433333</span>  <span class="number">21.256667</span>  <span class="number">29.473333</span></span><br><span class="line"><span class="number">2003</span>-01-07    <span class="number">7.432500</span>  <span class="number">21.425000</span>  <span class="number">29.342500</span></span><br><span class="line"><span class="number">2003</span>-01-08    <span class="number">7.402000</span>  <span class="number">21.402000</span>  <span class="number">29.240000</span></span><br><span class="line"><span class="number">2003</span>-01-09    <span class="number">7.391667</span>  <span class="number">21.490000</span>  <span class="number">29.273333</span></span><br><span class="line"><span class="number">2003</span>-01-<span class="number">10</span>    <span class="number">7.387143</span>  <span class="number">21.558571</span>  <span class="number">29.238571</span></span><br><span class="line"><span class="number">2003</span>-01-<span class="number">13</span>    <span class="number">7.378750</span>  <span class="number">21.633750</span>  <span class="number">29.197500</span></span><br><span class="line"><span class="number">2003</span>-01-<span class="number">14</span>    <span class="number">7.370000</span>  <span class="number">21.717778</span>  <span class="number">29.194444</span></span><br><span class="line"><span class="number">2003</span>-01-<span class="number">15</span>    <span class="number">7.355000</span>  <span class="number">21.757000</span>  <span class="number">29.152000</span></span><br><span class="line"><span class="meta">... </span>               ...        ...        ...</span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-03  <span class="number">398.002143</span>  <span class="number">25.890714</span>  <span class="number">72.413571</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-04  <span class="number">396.802143</span>  <span class="number">25.807857</span>  <span class="number">72.427143</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-05  <span class="number">395.751429</span>  <span class="number">25.729286</span>  <span class="number">72.422857</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-06  <span class="number">394.099286</span>  <span class="number">25.673571</span>  <span class="number">72.375714</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-07  <span class="number">392.479333</span>  <span class="number">25.712000</span>  <span class="number">72.454667</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">10</span>  <span class="number">389.351429</span>  <span class="number">25.602143</span>  <span class="number">72.527857</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">11</span>  <span class="number">388.505000</span>  <span class="number">25.674286</span>  <span class="number">72.835000</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">12</span>  <span class="number">388.531429</span>  <span class="number">25.810000</span>  <span class="number">73.400714</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">13</span>  <span class="number">388.826429</span>  <span class="number">25.961429</span>  <span class="number">73.905000</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">14</span>  <span class="number">391.038000</span>  <span class="number">26.048667</span>  <span class="number">74.185333</span></span><br><span class="line">[<span class="number">2292</span> rows x <span class="number">3</span> columns]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="指数加权函数">指数加权函数</h2>
<p>另一种使用固定大小窗口及相等权数观测值的办法是，定义一个衰减因子（decay factor）常量，以便使近期的观测值拥有更大的权数。衰减因子的定义方式有很多，比较流行的是使用时间间隔（span），它可以使结果兼容于窗口大小等于时间间隔的简单移动窗口（simple moving window）函数。</p>
<p>由于指数加权统计会赋予近期的观测值更大的权数，因此相对于等权统计，它能“适应”更快的变化。</p>
<p>除了rolling和expanding，pandas还有ewm运算符。下面这个例子对比了苹果公司股价的30日移动平均和span=30的指数加权移动平均（如图11-7所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">249</span>]: aapl_px = close_px.AAPL[<span class="string">&#x27;2006&#x27;</span>:<span class="string">&#x27;2007&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">250</span>]: ma60 = aapl_px.rolling(<span class="number">30</span>, min_periods=<span class="number">20</span>).mean()</span><br><span class="line"></span><br><span class="line">In [<span class="number">251</span>]: ewma60 = aapl_px.ewm(span=<span class="number">30</span>).mean()</span><br><span class="line"></span><br><span class="line">In [<span class="number">252</span>]: ma60.plot(style=<span class="string">&#x27;k--&#x27;</span>, label=<span class="string">&#x27;Simple MA&#x27;</span>)</span><br><span class="line">Out[<span class="number">252</span>]: &lt;matplotlib.axes._subplots.AxesSubplot at <span class="number">0x7f2f252161d0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">253</span>]: ewma60.plot(style=<span class="string">&#x27;k-&#x27;</span>, label=<span class="string">&#x27;EW MA&#x27;</span>)</span><br><span class="line">Out[<span class="number">253</span>]: &lt;matplotlib.axes._subplots.AxesSubplot at <span class="number">0x7f2f252161d0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">254</span>]: plt.legend()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-dae48defe3749fad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11-7 简单移动平均与指数加权移动平均" /><figcaption aria-hidden="true">图11-7 简单移动平均与指数加权移动平均</figcaption>
</figure>
<h2 id="二元移动窗口函数">二元移动窗口函数</h2>
<p>有些统计运算（如相关系数和协方差）需要在两个时间序列上执行。例如，金融分析师常常对某只股票对某个参考指数（如标准普尔500指数）的相关系数感兴趣。要进行说明，我们先计算我们感兴趣的时间序列的百分数变化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">256</span>]: spx_px = close_px_all[<span class="string">&#x27;SPX&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">257</span>]: spx_rets = spx_px.pct_change()</span><br><span class="line"></span><br><span class="line">In [<span class="number">258</span>]: returns = close_px.pct_change()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调用rolling之后，corr聚合函数开始计算与spx_rets滚动相关系数（结果见图11-8）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">259</span>]: corr = returns.AAPL.rolling(<span class="number">125</span>, min_periods=<span class="number">100</span>).corr(spx_rets)</span><br><span class="line"></span><br><span class="line">In [<span class="number">260</span>]: corr.plot()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-e81e0f602b4db0ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11-8 AAPL 6个月的回报与标准普尔500指数的相关系数" /><figcaption aria-hidden="true">图11-8 AAPL 6个月的回报与标准普尔500指数的相关系数</figcaption>
</figure>
<p>假设你想要一次性计算多只股票与标准普尔500指数的相关系数。虽然编写一个循环并新建一个DataFrame不是什么难事，但比较啰嗦。其实，只需传入一个TimeSeries和一个DataFrame，rolling_corr就会自动计算TimeSeries（本例中就是spx_rets）与DataFrame各列的相关系数。结果如图11-9所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">262</span>]: corr = returns.rolling(<span class="number">125</span>, min_periods=<span class="number">100</span>).corr(spx_rets)</span><br><span class="line"></span><br><span class="line">In [<span class="number">263</span>]: corr.plot()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-0a54a028a62b9b50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11-9 3只股票6个月的回报与标准普尔500指数的相关系数" /><figcaption aria-hidden="true">图11-9 3只股票6个月的回报与标准普尔500指数的相关系数</figcaption>
</figure>
<h2 id="用户定义的移动窗口函数">用户定义的移动窗口函数</h2>
<p>rolling_apply函数使你能够在移动窗口上应用自己设计的数组函数。唯一要求的就是：该函数要能从数组的各个片段中产生单个值（即约简）。比如说，当我们用rolling(...).quantile(q)计算样本分位数时，可能对样本中特定值的百分等级感兴趣。scipy.stats.percentileofscore函数就能达到这个目的（结果见图11-10）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">265</span>]: <span class="keyword">from</span> scipy.stats <span class="keyword">import</span> percentileofscore</span><br><span class="line"></span><br><span class="line">In [<span class="number">266</span>]: score_at_2percent = <span class="keyword">lambda</span> x: percentileofscore(x, <span class="number">0.02</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">267</span>]: result = returns.AAPL.rolling(<span class="number">250</span>).apply(score_at_2percent)</span><br><span class="line"></span><br><span class="line">In [<span class="number">268</span>]: result.plot()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-af49e84a90c23c1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11-10 AAPL 2%回报率的百分等级（一年窗口期）" /><figcaption aria-hidden="true">图11-10 AAPL 2%回报率的百分等级（一年窗口期）</figcaption>
</figure>
<p>如果你没安装SciPy，可以使用conda或pip安装。</p>
<h1 id="总结">11.8 总结</h1>
<p>与前面章节接触的数据相比，时间序列数据要求不同类型的分析和数据转换工具。</p>
<p>在接下来的章节中，我们将学习一些高级的pandas方法和如何开始使用建模库statsmodels和scikit-learn。</p>
]]></content>
      <categories>
        <category>Python 数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>附录A NumPy高级应用</title>
    <url>/2019/04/09/%E9%99%84%E5%BD%95A-NumPy%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>在这篇附录中，我会深入NumPy库的数组计算。这会包括ndarray更内部的细节，和更高级的数组操作和算法。</p>
<p>本章包括了一些杂乱的章节，不需要仔细研究。<span id="more"></span></p>
<h1 id="a.1-ndarray对象的内部机理">A.1 ndarray对象的内部机理</h1>
<p>NumPy的ndarray提供了一种将同质数据块（可以是连续或跨越）解释为多维数组对象的方式。正如你之前所看到的那样，数据类型（dtype）决定了数据的解释方式，比如浮点数、整数、布尔值等。</p>
<p>ndarray如此强大的部分原因是所有数组对象都是数据块的一个跨度视图（strided view）。你可能想知道数组视图arr[::2,::-1]不复制任何数据的原因是什么。简单地说，ndarray不只是一块内存和一个dtype，它还有跨度信息，这使得数组能以各种步幅（step size）在内存中移动。更准确地讲，ndarray内部由以下内容组成：</p>
<ul>
<li>一个指向数据（内存或内存映射文件中的一块数据）的指针。</li>
<li>数据类型或dtype，描述在数组中的固定大小值的格子。</li>
<li>一个表示数组形状（shape）的元组。</li>
<li>一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要“跨过”的字节数。</li>
</ul>
<p>图A-1简单地说明了ndarray的内部结构。</p>
<figure>
<img src="https://upload-images.jianshu.io/upload_images/7178691-43452f2f413e5094.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图A-1 Numpy的ndarray对象" /><figcaption aria-hidden="true">图A-1 Numpy的ndarray对象</figcaption>
</figure>
<p>例如，一个10×5的数组，其形状为(10,5)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: np.ones((<span class="number">10</span>, <span class="number">5</span>)).shape</span><br><span class="line">Out[<span class="number">10</span>]: (<span class="number">10</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>一个典型的（C顺序，稍后将详细讲解）3×4×5的float64（8个字节）数组，其跨度为(160,40,8) —— 知道跨度是非常有用的，通常，跨度在一个轴上越大，沿这个轴进行计算的开销就越大：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: np.ones((<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), dtype=np.float64).strides</span><br><span class="line">Out[<span class="number">11</span>]: (<span class="number">160</span>, <span class="number">40</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<p>虽然NumPy用户很少会对数组的跨度信息感兴趣，但它们却是构建非复制式数组视图的重要因素。跨度甚至可以是负数，这样会使数组在内存中后向移动，比如在切片obj[::-1]或obj[:,::-1]中就是这样的。</p>
<h2 id="numpy数据类型体系">NumPy数据类型体系</h2>
<p>你可能偶尔需要检查数组中所包含的是否是整数、浮点数、字符串或Python对象。因为浮点数的种类很多（从float16到float128），判断dtype是否属于某个大类的工作非常繁琐。幸运的是，dtype都有一个超类（比如np.integer和np.floating），它们可以跟np.issubdtype函数结合使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: ints = np.ones(<span class="number">10</span>, dtype=np.uint16)</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: floats = np.ones(<span class="number">10</span>, dtype=np.float32)</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: np.issubdtype(ints.dtype, np.integer)</span><br><span class="line">Out[<span class="number">14</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: np.issubdtype(floats.dtype, np.floating)</span><br><span class="line">Out[<span class="number">15</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>调用dtype的mro方法即可查看其所有的父类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">16</span>]: np.float64.mro()</span><br><span class="line">Out[<span class="number">16</span>]:</span><br><span class="line">[numpy.float64,</span><br><span class="line"> numpy.floating,</span><br><span class="line"> numpy.inexact,</span><br><span class="line"> numpy.number,</span><br><span class="line"> numpy.generic,</span><br><span class="line"> <span class="built_in">float</span>,</span><br><span class="line"> <span class="built_in">object</span>]</span><br></pre></td></tr></table></figure>
<p>然后得到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: np.issubdtype(ints.dtype, np.number)</span><br><span class="line">Out[<span class="number">17</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>大部分NumPy用户完全不需要了解这些知识，但是这些知识偶尔还是能派上用场的。图A-2说明了dtype体系以及父子类关系。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-b8996bf943a06ab9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图A-2 NumPy的dtype体系" /><figcaption aria-hidden="true">图A-2 NumPy的dtype体系</figcaption>
</figure>
<h1 id="a.2-高级数组操作">A.2 高级数组操作</h1>
<p>除花式索引、切片、布尔条件取子集等操作之外，数组的操作方式还有很多。虽然pandas中的高级函数可以处理数据分析工作中的许多重型任务，但有时你还是需要编写一些在现有库中找不到的数据算法。</p>
<h2 id="数组重塑">数组重塑</h2>
<p>多数情况下，你可以无需复制任何数据，就将数组从一个形状转换为另一个形状。只需向数组的实例方法reshape传入一个表示新形状的元组即可实现该目的。例如，假设有一个一维数组，我们希望将其重新排列为一个矩阵（结果见图A-3）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: arr = np.arange(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: arr</span><br><span class="line">Out[<span class="number">19</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: arr.reshape((<span class="number">4</span>, <span class="number">2</span>))</span><br><span class="line">Out[<span class="number">20</span>]: </span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>]])</span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-95bbca6d8d04e4c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图A-3 按C顺序（按行）和按Fortran顺序（按列）进行重塑" /><figcaption aria-hidden="true">图A-3 按C顺序（按行）和按Fortran顺序（按列）进行重塑</figcaption>
</figure>
<p>多维数组也能被重塑：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: arr.reshape((<span class="number">4</span>, <span class="number">2</span>)).reshape((<span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line">Out[<span class="number">21</span>]: </span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])</span><br></pre></td></tr></table></figure>
<p>作为参数的形状的其中一维可以是－1，它表示该维度的大小由数据本身推断而来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">22</span>]: arr = np.arange(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: arr.reshape((<span class="number">5</span>, -<span class="number">1</span>))</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]])</span><br></pre></td></tr></table></figure>
<p>与reshape将一维数组转换为多维数组的运算过程相反的运算通常称为扁平化（flattening）或散开（raveling）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">27</span>]: arr = np.arange(<span class="number">15</span>).reshape((<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: arr</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: arr.ravel()</span><br><span class="line">Out[<span class="number">29</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>])</span><br></pre></td></tr></table></figure>
<p>如果结果中的值与原始数组相同，ravel不会产生源数据的副本。flatten方法的行为类似于ravel，只不过它总是返回数据的副本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">30</span>]: arr.flatten()</span><br><span class="line">Out[<span class="number">30</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>])</span><br></pre></td></tr></table></figure>
<p>数组可以被重塑或散开为别的顺序。这对NumPy新手来说是一个比较微妙的问题，所以在下一小节中我们将专门讲解这个问题。</p>
<h2 id="c和fortran顺序">C和Fortran顺序</h2>
<p>NumPy允许你更为灵活地控制数据在内存中的布局。默认情况下，NumPy数组是按行优先顺序创建的。在空间方面，这就意味着，对于一个二维数组，每行中的数据项是被存放在相邻内存位置上的。另一种顺序是列优先顺序，它意味着每列中的数据项是被存放在相邻内存位置上的。</p>
<p>由于一些历史原因，行和列优先顺序又分别称为C和Fortran顺序。在FORTRAN 77中，矩阵全都是列优先的。</p>
<p>像reshape和reval这样的函数，都可以接受一个表示数组数据存放顺序的order参数。一般可以是'C'或'F'（还有'A'和'K'等不常用的选项，具体请参考NumPy的文档）。图A-3对此进行了说明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">31</span>]: arr = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: arr</span><br><span class="line">Out[<span class="number">32</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: arr.ravel()</span><br><span class="line">Out[<span class="number">33</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: arr.ravel(<span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">Out[<span class="number">34</span>]: array([ <span class="number">0</span>,  <span class="number">4</span>,  <span class="number">8</span>,  <span class="number">1</span>,  <span class="number">5</span>,  <span class="number">9</span>,  <span class="number">2</span>,  <span class="number">6</span>, <span class="number">10</span>,  <span class="number">3</span>,  <span class="number">7</span>, <span class="number">11</span>])</span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-f486e7c41d7e0eec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图A-3 按C（行优先）或Fortran（列优先）顺序进行重塑" /><figcaption aria-hidden="true">图A-3 按C（行优先）或Fortran（列优先）顺序进行重塑</figcaption>
</figure>
<p>二维或更高维数组的重塑过程比较令人费解（见图A-3）。C和Fortran顺序的关键区别就是维度的行进顺序：</p>
<ul>
<li>C/行优先顺序：先经过更高的维度（例如，轴1会先于轴0被处理）。</li>
<li>Fortran/列优先顺序：后经过更高的维度（例如，轴0会先于轴1被处理）。</li>
</ul>
<h2 id="数组的合并和拆分">数组的合并和拆分</h2>
<p>numpy.concatenate可以按指定轴将一个由数组组成的序列（如元组、列表等）连接到一起：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">35</span>]: arr1 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: arr2 = np.array([[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: np.concatenate([arr1, arr2], axis=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>],</span><br><span class="line">       [ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: np.concatenate([arr1, arr2], axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">38</span>]: </span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br></pre></td></tr></table></figure>
<p>对于常见的连接操作，NumPy提供了一些比较方便的方法（如vstack和hstack）。因此，上面的运算还可以表达为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">39</span>]: np.vstack((arr1, arr2))</span><br><span class="line">Out[<span class="number">39</span>]: </span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>],</span><br><span class="line">       [ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: np.hstack((arr1, arr2))</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">[ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br></pre></td></tr></table></figure>
<p>与此相反，split用于将一个数组沿指定轴拆分为多个数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: arr = np.random.randn(<span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: arr</span><br><span class="line">Out[<span class="number">42</span>]: </span><br><span class="line">array([[-<span class="number">0.2047</span>,  <span class="number">0.4789</span>],</span><br><span class="line">       [-<span class="number">0.5194</span>, -<span class="number">0.5557</span>],</span><br><span class="line">       [ <span class="number">1.9658</span>,  <span class="number">1.3934</span>],</span><br><span class="line">       [ <span class="number">0.0929</span>,  <span class="number">0.2817</span>],</span><br><span class="line">       [ <span class="number">0.769</span> ,  <span class="number">1.2464</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: first, second, third = np.split(arr, [<span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: first</span><br><span class="line">Out[<span class="number">44</span>]: array([[-<span class="number">0.2047</span>,  <span class="number">0.4789</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: second</span><br><span class="line">Out[<span class="number">45</span>]: </span><br><span class="line">array([[-<span class="number">0.5194</span>, -<span class="number">0.5557</span>],</span><br><span class="line">       [ <span class="number">1.9658</span>,  <span class="number">1.3934</span>]])</span><br><span class="line">In [<span class="number">46</span>]: third</span><br><span class="line">Out[<span class="number">46</span>]: </span><br><span class="line">array([[ <span class="number">0.0929</span>,  <span class="number">0.2817</span>],</span><br><span class="line">       [ <span class="number">0.769</span> ,  <span class="number">1.2464</span>]])</span><br></pre></td></tr></table></figure>
<p>传入到np.split的值[1,3]指示在哪个索引处分割数组。</p>
<p>表A-1中列出了所有关于数组连接和拆分的函数，其中有些是专门为了方便常见的连接运算而提供的。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-c597246722a6bb01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表A-1 数组连接函数" /><figcaption aria-hidden="true">表A-1 数组连接函数</figcaption>
</figure>
<h2 id="堆叠辅助类r_和c_">堆叠辅助类：r_和c_</h2>
<p>NumPy命名空间中有两个特殊的对象——r_和c_，它们可以使数组的堆叠操作更为简洁：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">47</span>]: arr = np.arange(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: arr1 = arr.reshape((<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: arr2 = np.random.randn(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: np.r_[arr1, arr2]</span><br><span class="line">Out[<span class="number">50</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>    ,  <span class="number">1.</span>    ],</span><br><span class="line">       [ <span class="number">2.</span>    ,  <span class="number">3.</span>    ],</span><br><span class="line">       [ <span class="number">4.</span>    ,  <span class="number">5.</span>    ],</span><br><span class="line">       [ <span class="number">1.0072</span>, -<span class="number">1.2962</span>],</span><br><span class="line">       [ <span class="number">0.275</span> ,  <span class="number">0.2289</span>],</span><br><span class="line">       [ <span class="number">1.3529</span>,  <span class="number">0.8864</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: np.c_[np.r_[arr1, arr2], arr]</span><br><span class="line">Out[<span class="number">51</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>    ,  <span class="number">1.</span>    ,  <span class="number">0.</span>    ],</span><br><span class="line">       [ <span class="number">2.</span>    ,  <span class="number">3.</span>    ,  <span class="number">1.</span>    ],</span><br><span class="line">       [ <span class="number">4.</span>    ,  <span class="number">5.</span>    ,  <span class="number">2.</span>    ],</span><br><span class="line">       [ <span class="number">1.0072</span>, -<span class="number">1.2962</span>,  <span class="number">3.</span>    ],</span><br><span class="line">       [ <span class="number">0.275</span> ,  <span class="number">0.2289</span>,  <span class="number">4.</span>    ],</span><br><span class="line">       [ <span class="number">1.3529</span>,  <span class="number">0.8864</span>,  <span class="number">5.</span>    ]])</span><br></pre></td></tr></table></figure>
<p>它还可以将切片转换成数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">52</span>]: np.c_[<span class="number">1</span>:<span class="number">6</span>, -<span class="number">10</span>:-<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">52</span>]: </span><br><span class="line">array([[  <span class="number">1</span>, -<span class="number">10</span>],</span><br><span class="line">       [  <span class="number">2</span>,  -<span class="number">9</span>],</span><br><span class="line">       [  <span class="number">3</span>,  -<span class="number">8</span>],</span><br><span class="line">       [  <span class="number">4</span>,  -<span class="number">7</span>],</span><br><span class="line">       [  <span class="number">5</span>,  -<span class="number">6</span>]])</span><br></pre></td></tr></table></figure>
<p>r_和c_的具体功能请参考其文档。</p>
<h2 id="元素的重复操作tile和repeat">元素的重复操作：tile和repeat</h2>
<p>对数组进行重复以产生更大数组的工具主要是repeat和tile这两个函数。repeat会将数组中的各个元素重复一定次数，从而产生一个更大的数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">53</span>]: arr = np.arange(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: arr</span><br><span class="line">Out[<span class="number">54</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: arr.repeat(<span class="number">3</span>)</span><br><span class="line">Out[<span class="number">55</span>]: array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：跟其他流行的数组编程语言（如MATLAB）不同，NumPy中很少需要对数组进行重复（replicate）。这主要是因为广播（broadcasting，我们将在下一节中讲解该技术）能更好地满足该需求。</p>
</blockquote>
<p>默认情况下，如果传入的是一个整数，则各元素就都会重复那么多次。如果传入的是一组整数，则各元素就可以重复不同的次数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: arr.repeat([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">Out[<span class="number">56</span>]: array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于多维数组，还可以让它们的元素沿指定轴重复：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">57</span>]: arr = np.random.randn(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: arr</span><br><span class="line">Out[<span class="number">58</span>]: </span><br><span class="line">array([[-<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: arr.repeat(<span class="number">2</span>, axis=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">59</span>]: </span><br><span class="line">array([[-<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [-<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，如果没有设置轴向，则数组会被扁平化，这可能不会是你想要的结果。同样，在对多维进行重复时，也可以传入一组整数，这样就会使各切片重复不同的次数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">60</span>]: arr.repeat([<span class="number">2</span>, <span class="number">3</span>], axis=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">60</span>]: </span><br><span class="line">array([[-<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [-<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: arr.repeat([<span class="number">2</span>, <span class="number">3</span>], axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">61</span>]: </span><br><span class="line">array([[-<span class="number">2.0016</span>, -<span class="number">2.0016</span>, -<span class="number">0.3718</span>, -<span class="number">0.3718</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">1.669</span> ,  <span class="number">1.669</span> , -<span class="number">0.4386</span>, -<span class="number">0.4386</span>, -<span class="number">0.4386</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>tile的功能是沿指定轴向堆叠数组的副本。你可以形象地将其想象成“铺瓷砖”：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">62</span>]: arr</span><br><span class="line">Out[<span class="number">62</span>]: </span><br><span class="line">array([[-<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: np.tile(arr, <span class="number">2</span>)</span><br><span class="line">Out[<span class="number">63</span>]: </span><br><span class="line">array([[-<span class="number">2.0016</span>, -<span class="number">0.3718</span>, -<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>,  <span class="number">1.669</span> , -<span class="number">0.4386</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二个参数是瓷砖的数量。对于标量，瓷砖是水平铺设的，而不是垂直铺设。它可以是一个表示“铺设”布局的元组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">64</span>]: arr</span><br><span class="line">Out[<span class="number">64</span>]: </span><br><span class="line">array([[-<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: np.tile(arr, (<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">Out[<span class="number">65</span>]: </span><br><span class="line">array([[-<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>],</span><br><span class="line">       [-<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: np.tile(arr, (<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line">Out[<span class="number">66</span>]: </span><br><span class="line">array([[-<span class="number">2.0016</span>, -<span class="number">0.3718</span>, -<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>,  <span class="number">1.669</span> , -<span class="number">0.4386</span>],</span><br><span class="line">       [-<span class="number">2.0016</span>, -<span class="number">0.3718</span>, -<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>,  <span class="number">1.669</span> , -<span class="number">0.4386</span>],</span><br><span class="line">       [-<span class="number">2.0016</span>, -<span class="number">0.3718</span>, -<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>,  <span class="number">1.669</span> , -<span class="number">0.4386</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="花式索引的等价函数take和put">花式索引的等价函数：take和put</h2>
<p>在第4章中我们讲过，获取和设置数组子集的一个办法是通过整数数组使用花式索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">67</span>]: arr = np.arange(<span class="number">10</span>) * <span class="number">100</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: inds = [<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: arr[inds]</span><br><span class="line">Out[<span class="number">69</span>]: array([<span class="number">700</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">600</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ndarray还有其它方法用于获取单个轴向上的选区：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">70</span>]: arr.take(inds)</span><br><span class="line">Out[<span class="number">70</span>]: array([<span class="number">700</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">600</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: arr.put(inds, <span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: arr</span><br><span class="line">Out[<span class="number">72</span>]: array([  <span class="number">0</span>,  <span class="number">42</span>,  <span class="number">42</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>,  <span class="number">42</span>,  <span class="number">42</span>,<span class="number">800</span>, <span class="number">900</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">73</span>]: arr.put(inds, [<span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">74</span>]: arr</span><br><span class="line">Out[<span class="number">74</span>]: array([  <span class="number">0</span>,  <span class="number">41</span>,  <span class="number">42</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>,  <span class="number">43</span>,  <span class="number">40</span>, <span class="number">800</span>, <span class="number">900</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要在其它轴上使用take，只需传入axis关键字即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">75</span>]: inds = [<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: arr = np.random.randn(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: arr</span><br><span class="line">Out[<span class="number">77</span>]: </span><br><span class="line">array([[-<span class="number">0.5397</span>,  <span class="number">0.477</span> ,  <span class="number">3.2489</span>, -<span class="number">1.0212</span>],</span><br><span class="line">       [-<span class="number">0.5771</span>,  <span class="number">0.1241</span>,  <span class="number">0.3026</span>,  <span class="number">0.5238</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: arr.take(inds, axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">78</span>]: </span><br><span class="line">array([[ <span class="number">3.2489</span>, -<span class="number">0.5397</span>,  <span class="number">3.2489</span>,  <span class="number">0.477</span> ],</span><br><span class="line">       [ <span class="number">0.3026</span>, -<span class="number">0.5771</span>,  <span class="number">0.3026</span>,  <span class="number">0.1241</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>put不接受axis参数，它只会在数组的扁平化版本（一维，C顺序）上进行索引。因此，在需要用其他轴向的索引设置元素时，最好还是使用花式索引。</p>
<h1 id="a.3-广播">A.3 广播</h1>
<p>广播（broadcasting）指的是不同形状的数组之间的算术运算的执行方式。它是一种非常强大的功能，但也容易令人误解，即使是经验丰富的老手也是如此。将标量值跟数组合并时就会发生最简单的广播：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">79</span>]: arr = np.arange(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: arr</span><br><span class="line">Out[<span class="number">80</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: arr * <span class="number">4</span></span><br><span class="line">Out[<span class="number">81</span>]: array([ <span class="number">0</span>,  <span class="number">4</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">16</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里我们说：在这个乘法运算中，标量值4被广播到了其他所有的元素上。</p>
<p>看一个例子，我们可以通过减去列平均值的方式对数组的每一列进行距平化处理。这个问题解决起来非常简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">82</span>]: arr = np.random.randn(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: arr.mean(<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">83</span>]: array([-<span class="number">0.3928</span>, -<span class="number">0.3824</span>, -<span class="number">0.8768</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: demeaned = arr - arr.mean(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">85</span>]: demeaned</span><br><span class="line">Out[<span class="number">85</span>]: </span><br><span class="line">array([[ <span class="number">0.3937</span>,  <span class="number">1.7263</span>,  <span class="number">0.1633</span>],</span><br><span class="line">       [-<span class="number">0.4384</span>, -<span class="number">1.9878</span>, -<span class="number">0.9839</span>],</span><br><span class="line">       [-<span class="number">0.468</span> ,  <span class="number">0.9426</span>, -<span class="number">0.3891</span>],</span><br><span class="line">       [ <span class="number">0.5126</span>, -<span class="number">0.6811</span>,  <span class="number">1.2097</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: demeaned.mean(<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">86</span>]: array([-<span class="number">0.</span>,  <span class="number">0.</span>, -<span class="number">0.</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>图A-4形象地展示了该过程。用广播的方式对行进行距平化处理会稍微麻烦一些。幸运的是，只要遵循一定的规则，低维度的值是可以被广播到数组的任意维度的（比如对二维数组各列减去行平均值）。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-6aaf022ab88452a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图A-4 一维数组在轴0上的广播" /><figcaption aria-hidden="true">图A-4 一维数组在轴0上的广播</figcaption>
</figure>
<p>于是就得到了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-fcaba8455960862a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>虽然我是一名经验丰富的NumPy老手，但经常还是得停下来画张图并想想广播的原则。再来看一下最后那个例子，假设你希望对各行减去那个平均值。由于arr.mean(0)的长度为3，所以它可以在0轴向上进行广播：因为arr的后缘维度是3，所以它们是兼容的。根据该原则，要在1轴向上做减法（即各行减去行平均值），较小的那个数组的形状必须是(4,1)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">87</span>]: arr</span><br><span class="line">Out[<span class="number">87</span>]: </span><br><span class="line">array([[ <span class="number">0.0009</span>,  <span class="number">1.3438</span>, -<span class="number">0.7135</span>],</span><br><span class="line">       [-<span class="number">0.8312</span>, -<span class="number">2.3702</span>, -<span class="number">1.8608</span>],</span><br><span class="line">       [-<span class="number">0.8608</span>,  <span class="number">0.5601</span>, -<span class="number">1.2659</span>],</span><br><span class="line">       [ <span class="number">0.1198</span>, -<span class="number">1.0635</span>,  <span class="number">0.3329</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: row_means = arr.mean(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: row_means.shape</span><br><span class="line">Out[<span class="number">89</span>]: (<span class="number">4</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: row_means.reshape((<span class="number">4</span>, <span class="number">1</span>))</span><br><span class="line">Out[<span class="number">90</span>]: </span><br><span class="line">array([[ <span class="number">0.2104</span>],</span><br><span class="line">       [-<span class="number">1.6874</span>],</span><br><span class="line">       [-<span class="number">0.5222</span>],</span><br><span class="line">       [-<span class="number">0.2036</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">91</span>]: demeaned = arr - row_means.reshape((<span class="number">4</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: demeaned.mean(<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">92</span>]: array([ <span class="number">0.</span>, -<span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>图A-5说明了该运算的过程。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-9b0310d6773c3d38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图A-5 二维数组在轴1上的广播" /><figcaption aria-hidden="true">图A-5 二维数组在轴1上的广播</figcaption>
</figure>
<p>图A-6展示了另外一种情况，这次是在一个三维数组上沿0轴向加上一个二维数组。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-965eb28b60046cd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图A-6 三维数组在轴0上的广播" /><figcaption aria-hidden="true">图A-6 三维数组在轴0上的广播</figcaption>
</figure>
<h2 id="沿其它轴向广播">沿其它轴向广播</h2>
<p>高维度数组的广播似乎更难以理解，而实际上它也是遵循广播原则的。如果不然，你就会得到下面这样一个错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">93</span>]: arr - arr.mean(<span class="number">1</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">93</span>-7b87b85a20b2&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> arr - arr.mean(<span class="number">1</span>)</span><br><span class="line">ValueError: operands could <span class="keyword">not</span> be broadcast together <span class="keyword">with</span> shapes (<span class="number">4</span>,<span class="number">3</span>) (<span class="number">4</span>,)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>人们经常需要通过算术运算过程将较低维度的数组在除0轴以外的其他轴向上广播。根据广播的原则，较小数组的“广播维”必须为1。在上面那个行距平化的例子中，这就意味着要将行平均值的形状变成(4,1)而不是(4,)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">94</span>]: arr - arr.mean(<span class="number">1</span>).reshape((<span class="number">4</span>, <span class="number">1</span>))</span><br><span class="line">Out[<span class="number">94</span>]: </span><br><span class="line">array([[-<span class="number">0.2095</span>,  <span class="number">1.1334</span>, -<span class="number">0.9239</span>],</span><br><span class="line">       [ <span class="number">0.8562</span>, -<span class="number">0.6828</span>, -<span class="number">0.1734</span>],</span><br><span class="line">       [-<span class="number">0.3386</span>,  <span class="number">1.0823</span>, -<span class="number">0.7438</span>],</span><br><span class="line">       [ <span class="number">0.3234</span>, -<span class="number">0.8599</span>,  <span class="number">0.5365</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于三维的情况，在三维中的任何一维上广播其实也就是将数据重塑为兼容的形状而已。图A-7说明了要在三维数组各维度上广播的形状需求。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-b40936aab8e757d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图A-7：能在该三维数组上广播的二维数组的形状" /><figcaption aria-hidden="true">图A-7：能在该三维数组上广播的二维数组的形状</figcaption>
</figure>
<p>于是就有了一个非常普遍的问题（尤其是在通用算法中），即专门为了广播而添加一个长度为1的新轴。虽然reshape是一个办法，但插入轴需要构造一个表示新形状的元组。这是一个很郁闷的过程。因此，NumPy数组提供了一种通过索引机制插入轴的特殊语法。下面这段代码通过特殊的np.newaxis属性以及“全”切片来插入新轴：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">95</span>]: arr = np.zeros((<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">96</span>]: arr_3d = arr[:, np.newaxis, :]</span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: arr_3d.shape</span><br><span class="line">Out[<span class="number">97</span>]: (<span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: arr_1d = np.random.normal(size=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: arr_1d[:, np.newaxis]</span><br><span class="line">Out[<span class="number">99</span>]: </span><br><span class="line">array([[-<span class="number">2.3594</span>],</span><br><span class="line">       [-<span class="number">0.1995</span>],</span><br><span class="line">       [-<span class="number">1.542</span> ]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: arr_1d[np.newaxis, :]</span><br><span class="line">Out[<span class="number">100</span>]: array([[-<span class="number">2.3594</span>, -<span class="number">0.1995</span>, -<span class="number">1.542</span> ]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此，如果我们有一个三维数组，并希望对轴2进行距平化，那么只需要编写下面这样的代码就可以了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">101</span>]: arr = np.random.randn(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">102</span>]: depth_means = arr.mean(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: depth_means</span><br><span class="line">Out[<span class="number">103</span>]: </span><br><span class="line">array([[-<span class="number">0.4735</span>,  <span class="number">0.3971</span>, -<span class="number">0.0228</span>,  <span class="number">0.2001</span>],</span><br><span class="line">       [-<span class="number">0.3521</span>, -<span class="number">0.281</span> , -<span class="number">0.071</span> , -<span class="number">0.1586</span>],</span><br><span class="line">       [ <span class="number">0.6245</span>,  <span class="number">0.6047</span>,  <span class="number">0.4396</span>, -<span class="number">0.2846</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: depth_means.shape</span><br><span class="line">Out[<span class="number">104</span>]: (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: demeaned = arr - depth_means[:, :, np.newaxis]</span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: demeaned.mean(<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">106</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>, -<span class="number">0.</span>, -<span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>, -<span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>, -<span class="number">0.</span>, -<span class="number">0.</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有些读者可能会想，在对指定轴进行距平化时，有没有一种既通用又不牺牲性能的方法呢？实际上是有的，但需要一些索引方面的技巧：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demean_axis</span>(<span class="params">arr, axis=<span class="number">0</span></span>):</span></span><br><span class="line">    means = arr.mean(axis)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This generalizes things like [:, :, np.newaxis] to N dimensions</span></span><br><span class="line">    indexer = [<span class="built_in">slice</span>(<span class="literal">None</span>)] * arr.ndim</span><br><span class="line">    indexer[axis] = np.newaxis</span><br><span class="line">    <span class="keyword">return</span> arr - means[indexer]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="通过广播设置数组的值">通过广播设置数组的值</h2>
<p>算术运算所遵循的广播原则同样也适用于通过索引机制设置数组值的操作。对于最简单的情况，我们可以这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">107</span>]: arr = np.zeros((<span class="number">4</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">108</span>]: arr[:] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: arr</span><br><span class="line">Out[<span class="number">109</span>]: </span><br><span class="line">array([[ <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>],</span><br><span class="line">       [ <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>],</span><br><span class="line">       [ <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>],</span><br><span class="line">       [ <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是，假设我们想要用一个一维数组来设置目标数组的各列，只要保证形状兼容就可以了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">110</span>]: col = np.array([<span class="number">1.28</span>, -<span class="number">0.42</span>, <span class="number">0.44</span>, <span class="number">1.6</span>])</span><br><span class="line">In [<span class="number">111</span>]: arr[:] = col[:, np.newaxis]</span><br><span class="line"></span><br><span class="line">In [<span class="number">112</span>]: arr</span><br><span class="line">Out[<span class="number">112</span>]: </span><br><span class="line">array([[ <span class="number">1.28</span>,  <span class="number">1.28</span>,  <span class="number">1.28</span>],</span><br><span class="line">       [-<span class="number">0.42</span>, -<span class="number">0.42</span>, -<span class="number">0.42</span>],</span><br><span class="line">       [ <span class="number">0.44</span>,  <span class="number">0.44</span>,  <span class="number">0.44</span>],</span><br><span class="line">       [ <span class="number">1.6</span> ,  <span class="number">1.6</span> ,  <span class="number">1.6</span> ]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">113</span>]: arr[:<span class="number">2</span>] = [[-<span class="number">1.37</span>], [<span class="number">0.509</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: arr</span><br><span class="line">Out[<span class="number">114</span>]: </span><br><span class="line">array([[-<span class="number">1.37</span> , -<span class="number">1.37</span> , -<span class="number">1.37</span> ],</span><br><span class="line">       [ <span class="number">0.509</span>,  <span class="number">0.509</span>,  <span class="number">0.509</span>],</span><br><span class="line">       [ <span class="number">0.44</span> ,  <span class="number">0.44</span> ,  <span class="number">0.44</span> ],</span><br><span class="line">       [ <span class="number">1.6</span>  ,  <span class="number">1.6</span>  ,  <span class="number">1.6</span>  ]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="a.4-ufunc高级应用">A.4 ufunc高级应用</h1>
<p>虽然许多NumPy用户只会用到通用函数所提供的快速的元素级运算，但通用函数实际上还有一些高级用法能使我们丢开循环而编写出更为简洁的代码。</p>
<h2 id="ufunc实例方法">ufunc实例方法</h2>
<p>NumPy的各个二元ufunc都有一些用于执行特定矢量化运算的特殊方法。表A-2汇总了这些方法，下面我将通过几个具体的例子对它们进行说明。</p>
<p>reduce接受一个数组参数，并通过一系列的二元运算对其值进行聚合（可指明轴向）。例如，我们可以用np.add.reduce对数组中各个元素进行求和：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">115</span>]: arr = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: np.add.reduce(arr)</span><br><span class="line">Out[<span class="number">116</span>]: <span class="number">45</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">117</span>]: arr.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">117</span>]: <span class="number">45</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>起始值取决于ufunc（对于add的情况，就是0）。如果设置了轴号，约简运算就会沿该轴向执行。这就使你能用一种比较简洁的方式得到某些问题的答案。在下面这个例子中，我们用np.logical_and检查数组各行中的值是否是有序的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">118</span>]: np.random.seed(<span class="number">12346</span>)  <span class="comment"># for reproducibility</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: arr = np.random.randn(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: arr[::<span class="number">2</span>].sort(<span class="number">1</span>) <span class="comment"># sort a few rows</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: arr[:, :-<span class="number">1</span>] &lt; arr[:, <span class="number">1</span>:]</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line">array([[ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>],</span><br><span class="line">       [<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">       [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>],</span><br><span class="line">       [ <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>],</span><br><span class="line">       [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>]], dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: np.logical_and.reduce(arr[:, :-<span class="number">1</span>] &lt; arr[:, <span class="number">1</span>:], axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">122</span>]: array([ <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>], dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，logical_and.reduce跟all方法是等价的。</p>
<p>ccumulate跟reduce的关系就像cumsum跟sum的关系那样。它产生一个跟原数组大小相同的中间“累计”值数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">123</span>]: arr = np.arange(<span class="number">15</span>).reshape((<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: np.add.accumulate(arr, axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">124</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">3</span>,  <span class="number">6</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">5</span>, <span class="number">11</span>, <span class="number">18</span>, <span class="number">26</span>, <span class="number">35</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">21</span>, <span class="number">33</span>, <span class="number">46</span>, <span class="number">60</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>outer用于计算两个数组的叉积：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">125</span>]: arr = np.arange(<span class="number">3</span>).repeat([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">126</span>]: arr</span><br><span class="line">Out[<span class="number">126</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">127</span>]: np.multiply.outer(arr, np.arange(<span class="number">5</span>))</span><br><span class="line">Out[<span class="number">127</span>]: </span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>outer输出结果的维度是两个输入数据的维度之和：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">128</span>]: x, y = np.random.randn(<span class="number">3</span>, <span class="number">4</span>), np.random.randn(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: result = np.subtract.outer(x, y)</span><br><span class="line"></span><br><span class="line">In [<span class="number">130</span>]: result.shape</span><br><span class="line">Out[<span class="number">130</span>]: (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后一个方法reduceat用于计算“局部约简”，其实就是一个对数据各切片进行聚合的groupby运算。它接受一组用于指示如何对值进行拆分和聚合的“面元边界”：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">131</span>]: arr = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">132</span>]: np.add.reduceat(arr, [<span class="number">0</span>, <span class="number">5</span>, <span class="number">8</span>])</span><br><span class="line">Out[<span class="number">132</span>]: array([<span class="number">10</span>, <span class="number">18</span>, <span class="number">17</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最终结果是在arr[0:5]、arr[5:8]以及arr[8:]上执行的约简。跟其他方法一样，这里也可以传入一个axis参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">133</span>]: arr = np.multiply.outer(np.arange(<span class="number">4</span>), np.arange(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">134</span>]: arr</span><br><span class="line">Out[<span class="number">134</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">       [ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">0</span>,  <span class="number">2</span>,  <span class="number">4</span>,  <span class="number">6</span>,  <span class="number">8</span>],</span><br><span class="line">       [ <span class="number">0</span>,  <span class="number">3</span>,  <span class="number">6</span>,  <span class="number">9</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">135</span>]: np.add.reduceat(arr, [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>], axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">135</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">       [ <span class="number">1</span>,  <span class="number">5</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">2</span>, <span class="number">10</span>,  <span class="number">8</span>],</span><br><span class="line">       [ <span class="number">3</span>, <span class="number">15</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表A-2总结了部分的ufunc方法。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-c997bd45000f7b72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表A ufunc方法" /><figcaption aria-hidden="true">表A ufunc方法</figcaption>
</figure>
<h2 id="编写新的ufunc">编写新的ufunc</h2>
<p>有多种方法可以让你编写自己的NumPy ufuncs。最常见的是使用NumPy C API，但它超越了本书的范围。在本节，我们讲纯粹的Python ufunc。</p>
<p>numpy.frompyfunc接受一个Python函数以及两个分别表示输入输出参数数量的参数。例如，下面是一个能够实现元素级加法的简单函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">136</span>]: <span class="function"><span class="keyword">def</span> <span class="title">add_elements</span>(<span class="params">x, y</span>):</span></span><br><span class="line">   .....:     <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">In [<span class="number">137</span>]: add_them = np.frompyfunc(add_elements, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">138</span>]: add_them(np.arange(<span class="number">8</span>), np.arange(<span class="number">8</span>))</span><br><span class="line">Out[<span class="number">138</span>]: array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>], dtype=<span class="built_in">object</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用frompyfunc创建的函数总是返回Python对象数组，这一点很不方便。幸运的是，还有另一个办法，即numpy.vectorize。虽然没有frompyfunc那么强大，但可以让你指定输出类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">139</span>]: add_them = np.vectorize(add_elements, otypes=[np.float64])</span><br><span class="line"></span><br><span class="line">In [<span class="number">140</span>]: add_them(np.arange(<span class="number">8</span>), np.arange(<span class="number">8</span>))</span><br><span class="line">Out[<span class="number">140</span>]: array([  <span class="number">0.</span>,   <span class="number">2.</span>,   <span class="number">4.</span>,   <span class="number">6.</span>,   <span class="number">8.</span>,  <span class="number">10.</span>,  <span class="number">12.</span>,  <span class="number">14.</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然这两个函数提供了一种创建ufunc型函数的手段，但它们非常慢，因为它们在计算每个元素时都要执行一次Python函数调用，这就会比NumPy自带的基于C的ufunc慢很多：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">141</span>]: arr = np.random.randn(<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">142</span>]: %timeit add_them(arr, arr)</span><br><span class="line"><span class="number">4.12</span> ms +- <span class="number">182</span> us per loop (mean +- std. dev. of <span class="number">7</span> runs, <span class="number">100</span> loops each)</span><br><span class="line"></span><br><span class="line">In [<span class="number">143</span>]: %timeit np.add(arr, arr)</span><br><span class="line"><span class="number">6.89</span> us +- <span class="number">504</span> ns per loop (mean +- std. dev. of <span class="number">7</span> runs, <span class="number">100000</span> loops each)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>本章的后面，我会介绍使用Numba（http://numba.pydata.org/），创建快速Python ufuncs。</p>
<h1 id="a.5-结构化和记录式数组">A.5 结构化和记录式数组</h1>
<p>你可能已经注意到了，到目前为止我们所讨论的ndarray都是一种同质数据容器，也就是说，在它所表示的内存块中，各元素占用的字节数相同（具体根据dtype而定）。从表面上看，它似乎不能用于表示异质或表格型的数据。结构化数组是一种特殊的ndarray，其中的各个元素可以被看做C语言中的结构体（struct，这就是“结构化”的由来）或SQL表中带有多个命名字段的行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">144</span>]: dtype = [(<span class="string">&#x27;x&#x27;</span>, np.float64), (<span class="string">&#x27;y&#x27;</span>, np.int32)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">145</span>]: sarr = np.array([(<span class="number">1.5</span>, <span class="number">6</span>), (np.pi, -<span class="number">2</span>)], dtype=dtype)</span><br><span class="line"></span><br><span class="line">In [<span class="number">146</span>]: sarr</span><br><span class="line">Out[<span class="number">146</span>]: </span><br><span class="line">array([( <span class="number">1.5</span>   ,  <span class="number">6</span>), ( <span class="number">3.1416</span>, -<span class="number">2</span>)],</span><br><span class="line">      dtype=[(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;&lt;f8&#x27;</span>), (<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;&lt;i4&#x27;</span>)])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>定义结构化dtype（请参考NumPy的在线文档）的方式有很多。最典型的办法是元组列表，各元组的格式为(field_name,field_data_type)。这样，数组的元素就成了元组式的对象，该对象中各个元素可以像字典那样进行访问：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">147</span>]: sarr[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">147</span>]: ( <span class="number">1.5</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">148</span>]: sarr[<span class="number">0</span>][<span class="string">&#x27;y&#x27;</span>]</span><br><span class="line">Out[<span class="number">148</span>]: <span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>字段名保存在dtype.names属性中。在访问结构化数组的某个字段时，返回的是该数据的视图，所以不会发生数据复制：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">149</span>]: sarr[<span class="string">&#x27;x&#x27;</span>]</span><br><span class="line">Out[<span class="number">149</span>]: array([ <span class="number">1.5</span>   ,  <span class="number">3.1416</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="嵌套dtype和多维字段">嵌套dtype和多维字段</h2>
<p>在定义结构化dtype时，你可以再设置一个形状（可以是一个整数，也可以是一个元组）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">150</span>]: dtype = [(<span class="string">&#x27;x&#x27;</span>, np.int64, <span class="number">3</span>), (<span class="string">&#x27;y&#x27;</span>, np.int32)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">151</span>]: arr = np.zeros(<span class="number">4</span>, dtype=dtype)</span><br><span class="line"></span><br><span class="line">In [<span class="number">152</span>]: arr</span><br><span class="line">Out[<span class="number">152</span>]: </span><br><span class="line">array([([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], <span class="number">0</span>), ([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], <span class="number">0</span>), ([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], <span class="number">0</span>), ([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], <span class="number">0</span>)],</span><br><span class="line">      dtype=[(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;&lt;i8&#x27;</span>, (<span class="number">3</span>,)), (<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;&lt;i4&#x27;</span>)])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这种情况下，各个记录的x字段所表示的是一个长度为3的数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">153</span>]: arr[<span class="number">0</span>][<span class="string">&#x27;x&#x27;</span>]</span><br><span class="line">Out[<span class="number">153</span>]: array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样，访问arr['x']即可得到一个二维数组，而不是前面那个例子中的一维数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">154</span>]: arr[<span class="string">&#x27;x&#x27;</span>]</span><br><span class="line">Out[<span class="number">154</span>]: </span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这就使你能用单个数组的内存块存放复杂的嵌套结构。你还可以嵌套dtype，作出更复杂的结构。下面是一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">155</span>]: dtype = [(<span class="string">&#x27;x&#x27;</span>, [(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;f8&#x27;</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>)]), (<span class="string">&#x27;y&#x27;</span>, np.int32)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">156</span>]: data = np.array([((<span class="number">1</span>, <span class="number">2</span>), <span class="number">5</span>), ((<span class="number">3</span>, <span class="number">4</span>), <span class="number">6</span>)], dtype=dtype)</span><br><span class="line"></span><br><span class="line">In [<span class="number">157</span>]: data[<span class="string">&#x27;x&#x27;</span>]</span><br><span class="line">Out[<span class="number">157</span>]: </span><br><span class="line">array([( <span class="number">1.</span>,  <span class="number">2.</span>), ( <span class="number">3.</span>,  <span class="number">4.</span>)],</span><br><span class="line">      dtype=[(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;&lt;f8&#x27;</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;&lt;f4&#x27;</span>)])</span><br><span class="line"></span><br><span class="line">In [<span class="number">158</span>]: data[<span class="string">&#x27;y&#x27;</span>]</span><br><span class="line">Out[<span class="number">158</span>]: array([<span class="number">5</span>, <span class="number">6</span>], dtype=int32)</span><br><span class="line"></span><br><span class="line">In [<span class="number">159</span>]: data[<span class="string">&#x27;x&#x27;</span>][<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">Out[<span class="number">159</span>]: array([ <span class="number">1.</span>,  <span class="number">3.</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>pandas的DataFrame并不直接支持该功能，但它的分层索引机制跟这个差不多。</p>
<h2 id="为什么要用结构化数组">为什么要用结构化数组</h2>
<p>跟pandas的DataFrame相比，NumPy的结构化数组是一种相对较低级的工具。它可以将单个内存块解释为带有任意复杂嵌套列的表格型结构。由于数组中的每个元素在内存中都被表示为固定的字节数，所以结构化数组能够提供非常快速高效的磁盘数据读写（包括内存映像）、网络传输等功能。</p>
<p>结构化数组的另一个常见用法是，将数据文件写成定长记录字节流，这是C和C++代码中常见的数据序列化手段（业界许多历史系统中都能找得到）。只要知道文件的格式（记录的大小、元素的顺序、字节数以及数据类型等），就可以用np.fromfile将数据读入内存。这种用法超出了本书的范围，知道这点就可以了。</p>
<h1 id="a.6-更多有关排序的话题">A.6 更多有关排序的话题</h1>
<p>跟Python内置的列表一样，ndarray的sort实例方法也是就地排序。也就是说，数组内容的重新排列是不会产生新数组的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">160</span>]: arr = np.random.randn(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">161</span>]: arr.sort()</span><br><span class="line"></span><br><span class="line">In [<span class="number">162</span>]: arr</span><br><span class="line">Out[<span class="number">162</span>]: array([-<span class="number">1.082</span> ,  <span class="number">0.3759</span>,  <span class="number">0.8014</span>,  <span class="number">1.1397</span>,  <span class="number">1.2888</span>,  <span class="number">1.8413</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在对数组进行就地排序时要注意一点，如果目标数组只是一个视图，则原始数组将会被修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">163</span>]: arr = np.random.randn(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">164</span>]: arr</span><br><span class="line">Out[<span class="number">164</span>]: </span><br><span class="line">array([[-<span class="number">0.3318</span>, -<span class="number">1.4711</span>,  <span class="number">0.8705</span>, -<span class="number">0.0847</span>, -<span class="number">1.1329</span>],</span><br><span class="line">       [-<span class="number">1.0111</span>, -<span class="number">0.3436</span>,  <span class="number">2.1714</span>,  <span class="number">0.1234</span>, -<span class="number">0.0189</span>],</span><br><span class="line">       [ <span class="number">0.1773</span>,  <span class="number">0.7424</span>,  <span class="number">0.8548</span>,  <span class="number">1.038</span> , -<span class="number">0.329</span> ]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">165</span>]: arr[:, <span class="number">0</span>].sort()  <span class="comment"># Sort first column values in-place</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">166</span>]: arr</span><br><span class="line">Out[<span class="number">166</span>]: </span><br><span class="line">array([[-<span class="number">1.0111</span>, -<span class="number">1.4711</span>,  <span class="number">0.8705</span>, -<span class="number">0.0847</span>, -<span class="number">1.1329</span>],</span><br><span class="line">       [-<span class="number">0.3318</span>, -<span class="number">0.3436</span>,  <span class="number">2.1714</span>,  <span class="number">0.1234</span>, -<span class="number">0.0189</span>],</span><br><span class="line">       [ <span class="number">0.1773</span>,  <span class="number">0.7424</span>,  <span class="number">0.8548</span>,  <span class="number">1.038</span> , -<span class="number">0.329</span> ]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>相反，numpy.sort会为原数组创建一个已排序副本。另外，它所接受的参数（比如kind）跟ndarray.sort一样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">167</span>]: arr = np.random.randn(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">168</span>]: arr</span><br><span class="line">Out[<span class="number">168</span>]: array([-<span class="number">1.1181</span>, -<span class="number">0.2415</span>, -<span class="number">2.0051</span>,  <span class="number">0.7379</span>, -<span class="number">1.0614</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">169</span>]: np.sort(arr)</span><br><span class="line">Out[<span class="number">169</span>]: array([-<span class="number">2.0051</span>, -<span class="number">1.1181</span>, -<span class="number">1.0614</span>, -<span class="number">0.2415</span>,  <span class="number">0.7379</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">170</span>]: arr</span><br><span class="line">Out[<span class="number">170</span>]: array([-<span class="number">1.1181</span>, -<span class="number">0.2415</span>, -<span class="number">2.0051</span>,  <span class="number">0.7379</span>, -<span class="number">1.0614</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这两个排序方法都可以接受一个axis参数，以便沿指定轴向对各块数据进行单独排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">171</span>]: arr = np.random.randn(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">172</span>]: arr</span><br><span class="line">Out[<span class="number">172</span>]: </span><br><span class="line">array([[ <span class="number">0.5955</span>, -<span class="number">0.2682</span>,  <span class="number">1.3389</span>, -<span class="number">0.1872</span>,  <span class="number">0.9111</span>],</span><br><span class="line">       [-<span class="number">0.3215</span>,  <span class="number">1.0054</span>, -<span class="number">0.5168</span>,  <span class="number">1.1925</span>, -<span class="number">0.1989</span>],</span><br><span class="line">       [ <span class="number">0.3969</span>, -<span class="number">1.7638</span>,  <span class="number">0.6071</span>, -<span class="number">0.2222</span>, -<span class="number">0.2171</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">173</span>]: arr.sort(axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">174</span>]: arr</span><br><span class="line">Out[<span class="number">174</span>]: </span><br><span class="line">array([[-<span class="number">0.2682</span>, -<span class="number">0.1872</span>,  <span class="number">0.5955</span>,  <span class="number">0.9111</span>,  <span class="number">1.3389</span>],</span><br><span class="line">       [-<span class="number">0.5168</span>, -<span class="number">0.3215</span>, -<span class="number">0.1989</span>,  <span class="number">1.0054</span>,  <span class="number">1.1925</span>],</span><br><span class="line">       [-<span class="number">1.7638</span>, -<span class="number">0.2222</span>, -<span class="number">0.2171</span>,  <span class="number">0.3969</span>,  <span class="number">0.6071</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可能注意到了，这两个排序方法都不可以被设置为降序。其实这也无所谓，因为数组切片会产生视图（也就是说，不会产生副本，也不需要任何其他的计算工作）。许多Python用户都很熟悉一个有关列表的小技巧：values[::-1]可以返回一个反序的列表。对ndarray也是如此：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">175</span>]: arr[:, ::-<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">175</span>]: </span><br><span class="line">array([[ <span class="number">1.3389</span>,  <span class="number">0.9111</span>,  <span class="number">0.5955</span>, -<span class="number">0.1872</span>, -<span class="number">0.2682</span>],</span><br><span class="line">       [ <span class="number">1.1925</span>,  <span class="number">1.0054</span>, -<span class="number">0.1989</span>, -<span class="number">0.3215</span>, -<span class="number">0.5168</span>],</span><br><span class="line">       [ <span class="number">0.6071</span>,  <span class="number">0.3969</span>, -<span class="number">0.2171</span>, -<span class="number">0.2222</span>, -<span class="number">1.7638</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="间接排序argsort和lexsort">间接排序：argsort和lexsort</h2>
<p>在数据分析工作中，常常需要根据一个或多个键对数据集进行排序。例如，一个有关学生信息的数据表可能需要以姓和名进行排序（先姓后名）。这就是间接排序的一个例子，如果你阅读过有关pandas的章节，那就已经见过不少高级例子了。给定一个或多个键，你就可以得到一个由整数组成的索引数组（我亲切地称之为索引器），其中的索引值说明了数据在新顺序下的位置。argsort和numpy.lexsort就是实现该功能的两个主要方法。下面是一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">176</span>]: values = np.array([<span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">177</span>]: indexer = values.argsort()</span><br><span class="line"></span><br><span class="line">In [<span class="number">178</span>]: indexer</span><br><span class="line">Out[<span class="number">178</span>]: array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">179</span>]: values[indexer]</span><br><span class="line">Out[<span class="number">179</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一个更复杂的例子，下面这段代码根据数组的第一行对其进行排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">180</span>]: arr = np.random.randn(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">181</span>]: arr[<span class="number">0</span>] = values</span><br><span class="line"></span><br><span class="line">In [<span class="number">182</span>]: arr</span><br><span class="line">Out[<span class="number">182</span>]: </span><br><span class="line">array([[ <span class="number">5.</span>    ,  <span class="number">0.</span>    ,  <span class="number">1.</span>    ,  <span class="number">3.</span>    ,  <span class="number">2.</span>    ],</span><br><span class="line">       [-<span class="number">0.3636</span>, -<span class="number">0.1378</span>,  <span class="number">2.1777</span>, -<span class="number">0.4728</span>,  <span class="number">0.8356</span>],</span><br><span class="line">       [-<span class="number">0.2089</span>,  <span class="number">0.2316</span>,  <span class="number">0.728</span> , -<span class="number">1.3918</span>,  <span class="number">1.9956</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">183</span>]: arr[:, arr[<span class="number">0</span>].argsort()]</span><br><span class="line">Out[<span class="number">183</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>    ,  <span class="number">1.</span>    ,  <span class="number">2.</span>    ,  <span class="number">3.</span>    ,  <span class="number">5.</span>    ],</span><br><span class="line">       [-<span class="number">0.1378</span>,  <span class="number">2.1777</span>,  <span class="number">0.8356</span>, -<span class="number">0.4728</span>, -<span class="number">0.3636</span>],</span><br><span class="line">       [ <span class="number">0.2316</span>,  <span class="number">0.728</span> ,  <span class="number">1.9956</span>, -<span class="number">1.3918</span>, -<span class="number">0.2089</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>lexsort跟argsort差不多，只不过它可以一次性对多个键数组执行间接排序（字典序）。假设我们想对一些以姓和名标识的数据进行排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">184</span>]: first_name = np.array([<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Jane&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Bill&#x27;</span>, <span class="string">&#x27;Barbara&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">185</span>]: last_name = np.array([<span class="string">&#x27;Jones&#x27;</span>, <span class="string">&#x27;Arnold&#x27;</span>, <span class="string">&#x27;Arnold&#x27;</span>, <span class="string">&#x27;Jones&#x27;</span>, <span class="string">&#x27;Walters&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">186</span>]: sorter = np.lexsort((first_name, last_name))</span><br><span class="line"></span><br><span class="line">In [<span class="number">187</span>]: sorter</span><br><span class="line">Out[<span class="number">187</span>]: array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">188</span>]: <span class="built_in">zip</span>(last_name[sorter], first_name[sorter])</span><br><span class="line">Out[<span class="number">188</span>]: &lt;<span class="built_in">zip</span> at <span class="number">0x7fa203eda1c8</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>刚开始使用lexsort的时候可能会比较容易头晕，这是因为键的应用顺序是从最后一个传入的算起的。不难看出，last_name是先于first_name被应用的。</p>
<blockquote>
<p>笔记：Series和DataFrame的sort_index以及Series的order方法就是通过这些函数的变体（它们还必须考虑缺失值）实现的。</p>
</blockquote>
<h2 id="其他排序算法">其他排序算法</h2>
<p>稳定的（stable）排序算法会保持等价元素的相对位置。对于相对位置具有实际意义的那些间接排序而言，这一点非常重要：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">189</span>]: values = np.array([<span class="string">&#x27;2:first&#x27;</span>, <span class="string">&#x27;2:second&#x27;</span>, <span class="string">&#x27;1:first&#x27;</span>, <span class="string">&#x27;1:second&#x27;</span>,</span><br><span class="line">.....:                    <span class="string">&#x27;1:third&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">190</span>]: key = np.array([<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">191</span>]: indexer = key.argsort(kind=<span class="string">&#x27;mergesort&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">192</span>]: indexer</span><br><span class="line">Out[<span class="number">192</span>]: array([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">193</span>]: values.take(indexer)</span><br><span class="line">Out[<span class="number">193</span>]: </span><br><span class="line">array([<span class="string">&#x27;1:first&#x27;</span>, <span class="string">&#x27;1:second&#x27;</span>, <span class="string">&#x27;1:third&#x27;</span>, <span class="string">&#x27;2:first&#x27;</span>, <span class="string">&#x27;2:second&#x27;</span>],</span><br><span class="line">      dtype=<span class="string">&#x27;&lt;U8&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>mergesort（合并排序）是唯一的稳定排序，它保证有O(n log n)的性能（空间复杂度），但是其平均性能比默认的quicksort（快速排序）要差。表A-3列出了可用的排序算法及其相关的性能指标。大部分用户完全不需要知道这些东西，但了解一下总是好的。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-970f54f58b6b3356.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表A-3 数组排序算法" /><figcaption aria-hidden="true">表A-3 数组排序算法</figcaption>
</figure>
<h2 id="部分排序数组">部分排序数组</h2>
<p>排序的目的之一可能是确定数组中最大或最小的元素。NumPy有两个优化方法，numpy.partition和np.argpartition，可以在第k个最小元素划分的数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">194</span>]: np.random.seed(<span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">195</span>]: arr = np.random.randn(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">196</span>]: arr</span><br><span class="line">Out[<span class="number">196</span>]: </span><br><span class="line">array([-<span class="number">0.2047</span>,  <span class="number">0.4789</span>, -<span class="number">0.5194</span>, -<span class="number">0.5557</span>,  <span class="number">1.9658</span>,  <span class="number">1.3934</span>,  <span class="number">0.0929</span>,</span><br><span class="line">        <span class="number">0.2817</span>,  <span class="number">0.769</span> ,  <span class="number">1.2464</span>,  <span class="number">1.0072</span>, -<span class="number">1.2962</span>,  <span class="number">0.275</span> ,  <span class="number">0.2289</span>,</span><br><span class="line">        <span class="number">1.3529</span>,  <span class="number">0.8864</span>, -<span class="number">2.0016</span>, -<span class="number">0.3718</span>,  <span class="number">1.669</span> , -<span class="number">0.4386</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">197</span>]: np.partition(arr, <span class="number">3</span>)</span><br><span class="line">Out[<span class="number">197</span>]: </span><br><span class="line">array([-<span class="number">2.0016</span>, -<span class="number">1.2962</span>, -<span class="number">0.5557</span>, -<span class="number">0.5194</span>, -<span class="number">0.3718</span>, -<span class="number">0.4386</span>, -<span class="number">0.2047</span>,</span><br><span class="line">        <span class="number">0.2817</span>,  <span class="number">0.769</span> ,  <span class="number">0.4789</span>,  <span class="number">1.0072</span>,  <span class="number">0.0929</span>,  <span class="number">0.275</span> ,  <span class="number">0.2289</span>,</span><br><span class="line">        <span class="number">1.3529</span>,  <span class="number">0.8864</span>,  <span class="number">1.3934</span>,  <span class="number">1.9658</span>,  <span class="number">1.669</span> ,  <span class="number">1.2464</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当你调用partition(arr, 3)，结果中的头三个元素是最小的三个，没有特定的顺序。numpy.argpartition与numpy.argsort相似，会返回索引，重排数据为等价的顺序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">198</span>]: indices = np.argpartition(arr, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">199</span>]: indices</span><br><span class="line">Out[<span class="number">199</span>]: </span><br><span class="line">array([<span class="number">16</span>, <span class="number">11</span>,  <span class="number">3</span>,  <span class="number">2</span>, <span class="number">17</span>, <span class="number">19</span>,  <span class="number">0</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">1</span>, <span class="number">10</span>,  <span class="number">6</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>,  <span class="number">5</span>,</span><br><span class="line">        <span class="number">4</span>, <span class="number">18</span>,  <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">200</span>]: arr.take(indices)</span><br><span class="line">Out[<span class="number">200</span>]: </span><br><span class="line">array([-<span class="number">2.0016</span>, -<span class="number">1.2962</span>, -<span class="number">0.5557</span>, -<span class="number">0.5194</span>, -<span class="number">0.3718</span>, -<span class="number">0.4386</span>, -<span class="number">0.2047</span>,</span><br><span class="line">        <span class="number">0.2817</span>,  <span class="number">0.769</span> ,  <span class="number">0.4789</span>,  <span class="number">1.0072</span>,  <span class="number">0.0929</span>,  <span class="number">0.275</span> ,  <span class="number">0.2289</span>,</span><br><span class="line">        <span class="number">1.3529</span>,  <span class="number">0.8864</span>,  <span class="number">1.3934</span>,  <span class="number">1.9658</span>,  <span class="number">1.669</span> ,  <span class="number">1.2464</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="numpy.searchsorted在有序数组中查找元素">numpy.searchsorted：在有序数组中查找元素</h2>
<p>searchsorted是一个在有序数组上执行二分查找的数组方法，只要将值插入到它返回的那个位置就能维持数组的有序性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">201</span>]: arr = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">15</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">202</span>]: arr.searchsorted(<span class="number">9</span>)</span><br><span class="line">Out[<span class="number">202</span>]: <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可以传入一组值就能得到一组索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">203</span>]: arr.searchsorted([<span class="number">0</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">16</span>])</span><br><span class="line">Out[<span class="number">203</span>]: array([<span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上面的结果中可以看出，对于元素0，searchsorted会返回0。这是因为其默认行为是返回相等值组的左侧索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">204</span>]: arr = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">205</span>]: arr.searchsorted([<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">Out[<span class="number">205</span>]: array([<span class="number">0</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">206</span>]: arr.searchsorted([<span class="number">0</span>, <span class="number">1</span>], side=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line">Out[<span class="number">206</span>]: array([<span class="number">3</span>, <span class="number">7</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再来看searchsorted的另一个用法，假设我们有一个数据数组（其中的值在0到10000之间），还有一个表示“面元边界”的数组，我们希望用它将数据数组拆分开：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">207</span>]: data = np.floor(np.random.uniform(<span class="number">0</span>, <span class="number">10000</span>, size=<span class="number">50</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">208</span>]: bins = np.array([<span class="number">0</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">5000</span>, <span class="number">10000</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">209</span>]: data</span><br><span class="line">Out[<span class="number">209</span>]: </span><br><span class="line">array([ <span class="number">9940.</span>,  <span class="number">6768.</span>,  <span class="number">7908.</span>,  <span class="number">1709.</span>,   <span class="number">268.</span>,  <span class="number">8003.</span>, <span class="number">9037.</span>,   <span class="number">246.</span>,</span><br><span class="line">        <span class="number">4917.</span>,  <span class="number">5262.</span>,  <span class="number">5963.</span>,   <span class="number">519.</span>,  <span class="number">8950.</span>,  <span class="number">7282.</span>,  <span class="number">8183.</span>,  <span class="number">5002.</span>,</span><br><span class="line">        <span class="number">8101.</span>,   <span class="number">959.</span>,  <span class="number">2189.</span>,  <span class="number">2587.</span>,  <span class="number">4681.</span>,  <span class="number">4593.</span>,  <span class="number">7095.</span>,  <span class="number">1780.</span>,</span><br><span class="line">        <span class="number">5314.</span>,  <span class="number">1677.</span>,  <span class="number">7688.</span>,  <span class="number">9281.</span>,  <span class="number">6094.</span>,  <span class="number">1501.</span>,  <span class="number">4896.</span>,  <span class="number">3773.</span>,</span><br><span class="line">        <span class="number">8486.</span>,  <span class="number">9110.</span>,  <span class="number">3838.</span>,  <span class="number">3154.</span>,  <span class="number">5683.</span>,  <span class="number">1878.</span>,  <span class="number">1258.</span>,  <span class="number">6875.</span>,</span><br><span class="line">        <span class="number">7996.</span>,  <span class="number">5735.</span>,  <span class="number">9732.</span>,  <span class="number">6340.</span>,  <span class="number">8884.</span>,  <span class="number">4954.</span>,  <span class="number">3516.</span>,  <span class="number">7142.</span>,</span><br><span class="line">        <span class="number">5039.</span>,  <span class="number">2256.</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，为了得到各数据点所属区间的编号（其中1表示面元[0,100)），我们可以直接使用searchsorted：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">210</span>]: labels = bins.searchsorted(data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">211</span>]: labels</span><br><span class="line">Out[<span class="number">211</span>]: </span><br><span class="line">array([<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">       <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>,</span><br><span class="line">       <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过pandas的groupby使用该结果即可非常轻松地对原数据集进行拆分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">212</span>]: pd.Series(data).groupby(labels).mean()</span><br><span class="line">Out[<span class="number">212</span>]: </span><br><span class="line"><span class="number">2</span>     <span class="number">498.000000</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3064.277778</span></span><br><span class="line"><span class="number">4</span>    <span class="number">7389.035714</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="a.7-用numba编写快速numpy函数">A.7 用Numba编写快速NumPy函数</h1>
<p>Numba是一个开源项目，它可以利用CPUs、GPUs或其它硬件为类似NumPy的数据创建快速函数。它使用了LLVM项目（http://llvm.org/），将Python代码转换为机器代码。</p>
<p>为了介绍Numba，来考虑一个纯粹的Python函数，它使用for循环计算表达式(x - y).mean()：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mean_distance</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    nx = <span class="built_in">len</span>(x)</span><br><span class="line">    result = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nx):</span><br><span class="line">        result += x[i] - y[i]</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result / count</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个函数很慢：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">209</span>]: x = np.random.randn(<span class="number">10000000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">210</span>]: y = np.random.randn(<span class="number">10000000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">211</span>]: %timeit mean_distance(x, y)</span><br><span class="line"><span class="number">1</span> loop, best of <span class="number">3</span>: <span class="number">2</span> s per loop</span><br><span class="line"></span><br><span class="line">In [<span class="number">212</span>]: %timeit (x - y).mean()</span><br><span class="line"><span class="number">100</span> loops, best of <span class="number">3</span>: <span class="number">14.7</span> ms per loop</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>NumPy的版本要比它快过100倍。我们可以转换这个函数为编译的Numba函数，使用numba.jit函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">213</span>]: <span class="keyword">import</span> numba <span class="keyword">as</span> nb</span><br><span class="line"></span><br><span class="line">In [<span class="number">214</span>]: numba_mean_distance = nb.jit(mean_distance)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以写成装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@nb.jit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mean_distance</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    nx = <span class="built_in">len</span>(x)</span><br><span class="line">    result = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nx):</span><br><span class="line">        result += x[i] - y[i]</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result / count</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它要比矢量化的NumPy快：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">215</span>]: %timeit numba_mean_distance(x, y)</span><br><span class="line"><span class="number">100</span> loops, best of <span class="number">3</span>: <span class="number">10.3</span> ms per loop</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Numba不能编译Python代码，但它支持纯Python写的一个部分，可以编写数值算法。</p>
<p>Numba是一个深厚的库，支持多种硬件、编译模式和用户插件。它还可以编译NumPy Python API的一部分，而不用for循环。Numba也可以识别可以便以为机器编码的结构体，但是若调用CPython API，它就不知道如何编译。Numba的jit函数有一个选项，nopython=True，它限制了可以被转换为Python代码的代码，这些代码可以编译为LLVM，但没有任何Python C API调用。jit(nopython=True)有一个简短的别名numba.njit。</p>
<p>前面的例子，我们还可以这样写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> float64, njit</span><br><span class="line"></span><br><span class="line"><span class="meta">@njit(<span class="params">float64(<span class="params">float64[:], float64[:]</span>)</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mean_distance</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (x - y).mean()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我建议你学习Numba的线上文档（http://numba.pydata.org/）。下一节介绍一个创建自定义Numpy ufunc对象的例子。</p>
<h2 id="用numba创建自定义numpy.ufunc对象">用Numba创建自定义numpy.ufunc对象</h2>
<p>numba.vectorize创建了一个编译的NumPy ufunc，它与内置的ufunc很像。考虑一个numpy.add的Python例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> vectorize</span><br><span class="line"></span><br><span class="line"><span class="meta">@vectorize</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nb_add</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: x = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: nb_add(x, x)</span><br><span class="line">Out[<span class="number">14</span>]: array([  <span class="number">0.</span>,   <span class="number">2.</span>,   <span class="number">4.</span>,   <span class="number">6.</span>,   <span class="number">8.</span>,  <span class="number">10.</span>,  <span class="number">12.</span>,  <span class="number">14.</span>,  <span class="number">16.</span>,  <span class="number">18.</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: nb_add.accumulate(x, <span class="number">0</span>)</span><br><span class="line">Out[<span class="number">15</span>]: array([  <span class="number">0.</span>,   <span class="number">1.</span>,   <span class="number">3.</span>,   <span class="number">6.</span>,  <span class="number">10.</span>,  <span class="number">15.</span>,  <span class="number">21.</span>,  <span class="number">28.</span>,  <span class="number">36.</span>,  <span class="number">45.</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="a.8-高级数组输入输出">A.8 高级数组输入输出</h1>
<p>我在第4章中讲过，np.save和np.load可用于读写磁盘上以二进制格式存储的数组。其实还有一些工具可用于更为复杂的场景。尤其是内存映像（memory map），它使你能处理在内存中放不下的数据集。</p>
<h2 id="内存映像文件">内存映像文件</h2>
<p>内存映像文件是一种将磁盘上的非常大的二进制数据文件当做内存中的数组进行处理的方式。NumPy实现了一个类似于ndarray的memmap对象，它允许将大文件分成小段进行读写，而不是一次性将整个数组读入内存。另外，memmap也拥有跟普通数组一样的方法，因此，基本上只要是能用于ndarray的算法就也能用于memmap。</p>
<p>要创建一个内存映像，可以使用函数np.memmap并传入一个文件路径、数据类型、形状以及文件模式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">214</span>]: mmap = np.memmap(<span class="string">&#x27;mymmap&#x27;</span>, dtype=<span class="string">&#x27;float64&#x27;</span>, mode=<span class="string">&#x27;w+&#x27;</span>,</span><br><span class="line">   .....:                  shape=(<span class="number">10000</span>, <span class="number">10000</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">215</span>]: mmap</span><br><span class="line">Out[<span class="number">215</span>]: </span><br><span class="line">memmap([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>, ...,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>, ...,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>, ...,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        ..., </span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>, ...,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>, ...,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>, ...,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对memmap切片将会返回磁盘上的数据的视图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">216</span>]: section = mmap[:<span class="number">5</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果将数据赋值给这些视图：数据会先被缓存在内存中（就像是Python的文件对象），调用flush即可将其写入磁盘：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">217</span>]: section[:] = np.random.randn(<span class="number">5</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">218</span>]: mmap.flush()</span><br><span class="line"></span><br><span class="line">In [<span class="number">219</span>]: mmap</span><br><span class="line">Out[<span class="number">219</span>]: </span><br><span class="line">memmap([[ <span class="number">0.7584</span>, -<span class="number">0.6605</span>,  <span class="number">0.8626</span>, ...,  <span class="number">0.6046</span>, -<span class="number">0.6212</span>,  <span class="number">2.0542</span>],</span><br><span class="line">        [-<span class="number">1.2113</span>, -<span class="number">1.0375</span>,  <span class="number">0.7093</span>, ..., -<span class="number">1.4117</span>, -<span class="number">0.1719</span>, -<span class="number">0.8957</span>],</span><br><span class="line">        [-<span class="number">0.1419</span>, -<span class="number">0.3375</span>,  <span class="number">0.4329</span>, ...,  <span class="number">1.2914</span>, -<span class="number">0.752</span> , -<span class="number">0.44</span>  ],</span><br><span class="line">        ..., </span><br><span class="line">        [ <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    , ...,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ],</span><br><span class="line">        [ <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    , ...,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ],</span><br><span class="line">        [ <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    , ...,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">220</span>]: <span class="keyword">del</span> mmap</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>只要某个内存映像超出了作用域，它就会被垃圾回收器回收，之前对其所做的任何修改都会被写入磁盘。当打开一个已经存在的内存映像时，仍然需要指明数据类型和形状，因为磁盘上的那个文件只是一块二进制数据而已，没有任何元数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">221</span>]: mmap = np.memmap(<span class="string">&#x27;mymmap&#x27;</span>, dtype=<span class="string">&#x27;float64&#x27;</span>, shape=(<span class="number">10000</span>, <span class="number">10000</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">222</span>]: mmap</span><br><span class="line">Out[<span class="number">222</span>]: </span><br><span class="line">memmap([[ <span class="number">0.7584</span>, -<span class="number">0.6605</span>,  <span class="number">0.8626</span>, ...,  <span class="number">0.6046</span>, -<span class="number">0.6212</span>,  <span class="number">2.0542</span>],</span><br><span class="line">        [-<span class="number">1.2113</span>, -<span class="number">1.0375</span>,  <span class="number">0.7093</span>, ..., -<span class="number">1.4117</span>, -<span class="number">0.1719</span>, -<span class="number">0.8957</span>],</span><br><span class="line">        [-<span class="number">0.1419</span>, -<span class="number">0.3375</span>,  <span class="number">0.4329</span>, ...,  <span class="number">1.2914</span>, -<span class="number">0.752</span> , -<span class="number">0.44</span>  ],</span><br><span class="line">        ..., </span><br><span class="line">        [ <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    , ...,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ],</span><br><span class="line">        [ <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    , ...,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ],</span><br><span class="line">        [ <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    , ...,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>内存映像可以使用前面介绍的结构化或嵌套dtype。</p>
<h2 id="hdf5及其他数组存储方式">HDF5及其他数组存储方式</h2>
<p>PyTables和h5py这两个Python项目可以将NumPy的数组数据存储为高效且可压缩的HDF5格式（HDF意思是“层次化数据格式”）。你可以安全地将好几百GB甚至TB的数据存储为HDF5格式。要学习Python使用HDF5，请参考pandas线上文档。</p>
<h1 id="a.9-性能建议">A.9 性能建议</h1>
<p>使用NumPy的代码的性能一般都很不错，因为数组运算一般都比纯Python循环快得多。下面大致列出了一些需要注意的事项：</p>
<ul>
<li>将Python循环和条件逻辑转换为数组运算和布尔数组运算。</li>
<li>尽量使用广播。</li>
<li>避免复制数据，尽量使用数组视图（即切片）。</li>
<li>利用ufunc及其各种方法。</li>
</ul>
<p>如果单用NumPy无论如何都达不到所需的性能指标，就可以考虑一下用C、Fortran或Cython（等下会稍微介绍一下）来编写代码。我自己在工作中经常会用到Cython（http://cython.org），因为它不用花费我太多精力就能得到C语言那样的性能。</p>
<h2 id="连续内存的重要性">连续内存的重要性</h2>
<p>虽然这个话题有点超出本书的范围，但还是要提一下，因为在某些应用场景中，数组的内存布局可以对计算速度造成极大的影响。这是因为性能差别在一定程度上跟CPU的高速缓存（cache）体系有关。运算过程中访问连续内存块（例如，对以C顺序存储的数组的行求和）一般是最快的，因为内存子系统会将适当的内存块缓存到超高速的L1或L2CPU Cache中。此外，NumPy的C语言基础代码（某些）对连续存储的情况进行了优化处理，这样就能避免一些跨越式的内存访问。</p>
<p>一个数组的内存布局是连续的，就是说元素是以它们在数组中出现的顺序（即Fortran型（列优先）或C型（行优先））存储在内存中的。默认情况下，NumPy数组是以C型连续的方式创建的。列优先的数组（比如C型连续数组的转置）也被称为Fortran型连续。通过ndarray的flags属性即可查看这些信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">225</span>]: arr_c = np.ones((<span class="number">1000</span>, <span class="number">1000</span>), order=<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">226</span>]: arr_f = np.ones((<span class="number">1000</span>, <span class="number">1000</span>), order=<span class="string">&#x27;F&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">227</span>]: arr_c.flags</span><br><span class="line"></span><br><span class="line">Out[<span class="number">227</span>]: </span><br><span class="line">  C_CONTIGUOUS : <span class="literal">True</span></span><br><span class="line">  F_CONTIGUOUS : <span class="literal">False</span></span><br><span class="line">  OWNDATA : <span class="literal">True</span></span><br><span class="line">  WRITEABLE : <span class="literal">True</span></span><br><span class="line">  ALIGNED : <span class="literal">True</span></span><br><span class="line">  UPDATEIFCOPY : <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">228</span>]: arr_f.flags</span><br><span class="line">Out[<span class="number">228</span>]: </span><br><span class="line">  C_CONTIGUOUS : <span class="literal">False</span></span><br><span class="line">  F_CONTIGUOUS : <span class="literal">True</span></span><br><span class="line">  OWNDATA : <span class="literal">True</span></span><br><span class="line">  WRITEABLE : <span class="literal">True</span></span><br><span class="line">  ALIGNED : <span class="literal">True</span></span><br><span class="line">  UPDATEIFCOPY : <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">229</span>]: arr_f.flags.f_contiguous</span><br><span class="line">Out[<span class="number">229</span>]: <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中，对两个数组的行进行求和计算，理论上说，arr_c会比arr_f快，因为arr_c的行在内存中是连续的。我们可以在IPython中用%timeit来确认一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">230</span>]: %timeit arr_c.<span class="built_in">sum</span>(<span class="number">1</span>)</span><br><span class="line"><span class="number">784</span> us +- <span class="number">10.4</span> us per loop (mean +- std. dev. of <span class="number">7</span> runs, <span class="number">1000</span> loops each)</span><br><span class="line"></span><br><span class="line">In [<span class="number">231</span>]: %timeit arr_f.<span class="built_in">sum</span>(<span class="number">1</span>)</span><br><span class="line"><span class="number">934</span> us +- <span class="number">29</span> us per loop (mean +- std. dev. of <span class="number">7</span> runs, <span class="number">1000</span> loops each)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果想从NumPy中提升性能，这里就应该是下手的地方。如果数组的内存顺序不符合你的要求，使用copy并传入'C'或'F'即可解决该问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">232</span>]: arr_f.copy(<span class="string">&#x27;C&#x27;</span>).flags</span><br><span class="line">Out[<span class="number">232</span>]: </span><br><span class="line">  C_CONTIGUOUS : <span class="literal">True</span></span><br><span class="line">  F_CONTIGUOUS : <span class="literal">False</span></span><br><span class="line">  OWNDATA : <span class="literal">True</span></span><br><span class="line">  WRITEABLE : <span class="literal">True</span></span><br><span class="line">  ALIGNED : <span class="literal">True</span></span><br><span class="line">  UPDATEIFCOPY : <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，在构造数组的视图时，其结果不一定是连续的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">233</span>]: arr_c[:<span class="number">50</span>].flags.contiguous</span><br><span class="line">Out[<span class="number">233</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">234</span>]: arr_c[:, :<span class="number">50</span>].flags</span><br><span class="line">Out[<span class="number">234</span>]: </span><br><span class="line">  C_CONTIGUOUS : <span class="literal">False</span></span><br><span class="line">  F_CONTIGUOUS : <span class="literal">False</span></span><br><span class="line">  OWNDATA : <span class="literal">False</span></span><br><span class="line">  WRITEABLE : <span class="literal">True</span></span><br><span class="line">  ALIGNED : <span class="literal">True</span></span><br><span class="line">  UPDATEIFCOPY : <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python 数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>第14章 数据分析案例</title>
    <url>/2019/04/09/%E7%AC%AC14%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<p>本书正文的最后一章，我们来看一些真实世界的数据集。对于每个数据集，我们会用之前介绍的方法，从原始数据中提取有意义的内容。展示的方法适用于其它数据集，也包括你的。本章包含了一些各种各样的案例数据集，可以用来练习。<span id="more"></span></p>
<p>案例数据集可以在Github仓库找到，见第一章。</p>
<h1 id="来自bitly的usa.gov数据">14.1 来自Bitly的USA.gov数据</h1>
<p>2011年，URL缩短服务Bitly跟美国政府网站USA.gov合作，提供了一份从生成.gov或.mil短链接的用户那里收集来的匿名数据。在2011年，除实时数据之外，还可以下载文本文件形式的每小时快照。写作此书时（2017年），这项服务已经关闭，但我们保存一份数据用于本书的案例。</p>
<p>以每小时快照为例，文件中各行的格式为JSON（即JavaScript Object Notation，这是一种常用的Web数据格式）。例如，如果我们只读取某个文件中的第一行，那么所看到的结果应该是下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">5</span>]: path = <span class="string">&#x27;datasets/bitly_usagov/example.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: <span class="built_in">open</span>(path).readline()</span><br><span class="line">Out[<span class="number">6</span>]: <span class="string">&#x27;&#123; &quot;a&quot;: &quot;Mozilla\\/5.0 (Windows NT 6.1; WOW64) AppleWebKit\\/535.11</span></span><br><span class="line"><span class="string">(KHTML, like Gecko) Chrome\\/17.0.963.78 Safari\\/535.11&quot;, &quot;c&quot;: &quot;US&quot;, &quot;nk&quot;: 1,</span></span><br><span class="line"><span class="string">&quot;tz&quot;: &quot;America\\/New_York&quot;, &quot;gr&quot;: &quot;MA&quot;, &quot;g&quot;: &quot;A6qOVH&quot;, &quot;h&quot;: &quot;wfLQtf&quot;, &quot;l&quot;:</span></span><br><span class="line"><span class="string">&quot;orofrog&quot;, &quot;al&quot;: &quot;en-US,en;q=0.8&quot;, &quot;hh&quot;: &quot;1.usa.gov&quot;, &quot;r&quot;:</span></span><br><span class="line"><span class="string">&quot;http:\\/\\/www.facebook.com\\/l\\/7AQEFzjSi\\/1.usa.gov\\/wfLQtf&quot;, &quot;u&quot;:</span></span><br><span class="line"><span class="string">&quot;http:\\/\\/www.ncbi.nlm.nih.gov\\/pubmed\\/22415991&quot;, &quot;t&quot;: 1331923247, &quot;hc&quot;:</span></span><br><span class="line"><span class="string">1331822918, &quot;cy&quot;: &quot;Danvers&quot;, &quot;ll&quot;: [ 42.576698, -70.954903 ] &#125;\n&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Python有内置或第三方模块可以将JSON字符串转换成Python字典对象。这里，我将使用json模块及其loads函数逐行加载已经下载好的数据文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">path = <span class="string">&#x27;datasets/bitly_usagov/example.txt&#x27;</span></span><br><span class="line">records = [json.loads(line) <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(path)]</span><br></pre></td></tr></table></figure>
<p>现在，records对象就成为一组Python字典了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: records[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">18</span>]:</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko)</span></span><br><span class="line"><span class="string">Chrome/17.0.963.78 Safari/535.11&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;al&#x27;</span>: <span class="string">&#x27;en-US,en;q=0.8&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;US&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;cy&#x27;</span>: <span class="string">&#x27;Danvers&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;g&#x27;</span>: <span class="string">&#x27;A6qOVH&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;gr&#x27;</span>: <span class="string">&#x27;MA&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;h&#x27;</span>: <span class="string">&#x27;wfLQtf&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;hc&#x27;</span>: <span class="number">1331822918</span>,</span><br><span class="line"> <span class="string">&#x27;hh&#x27;</span>: <span class="string">&#x27;1.usa.gov&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;l&#x27;</span>: <span class="string">&#x27;orofrog&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ll&#x27;</span>: [<span class="number">42.576698</span>, -<span class="number">70.954903</span>],</span><br><span class="line"> <span class="string">&#x27;nk&#x27;</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="string">&#x27;r&#x27;</span>: <span class="string">&#x27;http://www.facebook.com/l/7AQEFzjSi/1.usa.gov/wfLQtf&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;t&#x27;</span>: <span class="number">1331923247</span>,</span><br><span class="line"> <span class="string">&#x27;tz&#x27;</span>: <span class="string">&#x27;America/New_York&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;u&#x27;</span>: <span class="string">&#x27;http://www.ncbi.nlm.nih.gov/pubmed/22415991&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用纯python代码对时区进行计数">用纯Python代码对时区进行计数</h2>
<p>假设我们想要知道该数据集中最常出现的是哪个时区（即tz字段），得到答案的办法有很多。首先，我们用列表推导式取出一组时区：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: time_zones = [rec[<span class="string">&#x27;tz&#x27;</span>] <span class="keyword">for</span> rec <span class="keyword">in</span> records]</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">KeyError                                  Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">12</span>-db4fbd348da9&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> time_zones = [rec[<span class="string">&#x27;tz&#x27;</span>] <span class="keyword">for</span> rec <span class="keyword">in</span> records]</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">12</span>-db4fbd348da9&gt; <span class="keyword">in</span> &lt;listcomp&gt;(<span class="number">.0</span>)</span><br><span class="line">----&gt; <span class="number">1</span> time_zones = [rec[<span class="string">&#x27;tz&#x27;</span>] <span class="keyword">for</span> rec <span class="keyword">in</span> records]</span><br><span class="line">KeyError: <span class="string">&#x27;tz&#x27;</span></span><br></pre></td></tr></table></figure>
<p>晕！原来并不是所有记录都有时区字段。这个好办，只需在列表推导式末尾加上一个if 'tz'in rec判断即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: time_zones = [rec[<span class="string">&#x27;tz&#x27;</span>] <span class="keyword">for</span> rec <span class="keyword">in</span> records <span class="keyword">if</span> <span class="string">&#x27;tz&#x27;</span> <span class="keyword">in</span> rec]</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: time_zones[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">[<span class="string">&#x27;America/New_York&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;America/Denver&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;America/New_York&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;America/Sao_Paulo&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;America/New_York&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;America/New_York&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Europe/Warsaw&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>只看前10个时区，我们发现有些是未知的（即空的）。虽然可以将它们过滤掉，但现在暂时先留着。接下来，为了对时区进行计数，这里介绍两个办法：一个较难（只使用标准Python库），另一个较简单（使用pandas）。计数的办法之一是在遍历时区的过程中将计数值保存在字典中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_counts</span>(<span class="params">sequence</span>):</span></span><br><span class="line">    counts = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> sequence:</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> counts:</span><br><span class="line">            counts[x] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            counts[x] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> counts</span><br></pre></td></tr></table></figure>
<p>如果使用Python标准库的更高级工具，那么你可能会将代码写得更简洁一些：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_counts2</span>(<span class="params">sequence</span>):</span></span><br><span class="line">    counts = defaultdict(<span class="built_in">int</span>) <span class="comment"># values will initialize to 0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> sequence:</span><br><span class="line">        counts[x] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> counts</span><br></pre></td></tr></table></figure>
<p>我将逻辑写到函数中是为了获得更高的复用性。要用它对时区进行处理，只需将time_zones传入即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: counts = get_counts(time_zones)</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: counts[<span class="string">&#x27;America/New_York&#x27;</span>]</span><br><span class="line">Out[<span class="number">18</span>]: <span class="number">1251</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: <span class="built_in">len</span>(time_zones)</span><br><span class="line">Out[<span class="number">19</span>]: <span class="number">3440</span></span><br></pre></td></tr></table></figure>
<p>如果想要得到前10位的时区及其计数值，我们需要用到一些有关字典的处理技巧：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">top_counts</span>(<span class="params">count_dict, n=<span class="number">10</span></span>):</span></span><br><span class="line">    value_key_pairs = [(count, tz) <span class="keyword">for</span> tz, count <span class="keyword">in</span> count_dict.items()]</span><br><span class="line">    value_key_pairs.sort()</span><br><span class="line">    <span class="keyword">return</span> value_key_pairs[-n:]</span><br></pre></td></tr></table></figure>
<p>然后有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: top_counts(counts)</span><br><span class="line">Out[<span class="number">21</span>]: </span><br><span class="line">[(<span class="number">33</span>, <span class="string">&#x27;America/Sao_Paulo&#x27;</span>),</span><br><span class="line"> (<span class="number">35</span>, <span class="string">&#x27;Europe/Madrid&#x27;</span>),</span><br><span class="line">(<span class="number">36</span>, <span class="string">&#x27;Pacific/Honolulu&#x27;</span>),</span><br><span class="line"> (<span class="number">37</span>, <span class="string">&#x27;Asia/Tokyo&#x27;</span>),</span><br><span class="line"> (<span class="number">74</span>, <span class="string">&#x27;Europe/London&#x27;</span>),</span><br><span class="line"> (<span class="number">191</span>, <span class="string">&#x27;America/Denver&#x27;</span>),</span><br><span class="line"> (<span class="number">382</span>, <span class="string">&#x27;America/Los_Angeles&#x27;</span>),</span><br><span class="line"> (<span class="number">400</span>, <span class="string">&#x27;America/Chicago&#x27;</span>),</span><br><span class="line"> (<span class="number">521</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line"> (<span class="number">1251</span>, <span class="string">&#x27;America/New_York&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<p>如果你搜索Python的标准库，你能找到collections.Counter类，它可以使这项工作更简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">22</span>]: <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: counts = Counter(time_zones)</span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: counts.most_common(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">24</span>]: </span><br><span class="line">[(<span class="string">&#x27;America/New_York&#x27;</span>, <span class="number">1251</span>),</span><br><span class="line"> (<span class="string">&#x27;&#x27;</span>, <span class="number">521</span>),</span><br><span class="line"> (<span class="string">&#x27;America/Chicago&#x27;</span>, <span class="number">400</span>),</span><br><span class="line"> (<span class="string">&#x27;America/Los_Angeles&#x27;</span>, <span class="number">382</span>),</span><br><span class="line"> (<span class="string">&#x27;America/Denver&#x27;</span>, <span class="number">191</span>),</span><br><span class="line"> (<span class="string">&#x27;Europe/London&#x27;</span>, <span class="number">74</span>),</span><br><span class="line"> (<span class="string">&#x27;Asia/Tokyo&#x27;</span>, <span class="number">37</span>),</span><br><span class="line"> (<span class="string">&#x27;Pacific/Honolulu&#x27;</span>, <span class="number">36</span>),</span><br><span class="line"> (<span class="string">&#x27;Europe/Madrid&#x27;</span>, <span class="number">35</span>),</span><br><span class="line"> (<span class="string">&#x27;America/Sao_Paulo&#x27;</span>, <span class="number">33</span>)]</span><br></pre></td></tr></table></figure>
<h2 id="用pandas对时区进行计数">用pandas对时区进行计数</h2>
<p>从原始记录的集合创建DateFrame，与将记录列表传递到pandas.DataFrame一样简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: frame = pd.DataFrame(records)</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: frame.info()</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">RangeIndex</span>:</span> <span class="number">3560</span> entries, <span class="number">0</span> to <span class="number">3559</span></span><br><span class="line">Data columns (total <span class="number">18</span> columns):</span><br><span class="line">_heartbeat_    <span class="number">120</span> non-null float64</span><br><span class="line">a              <span class="number">3440</span> non-null <span class="built_in">object</span></span><br><span class="line">al             <span class="number">3094</span> non-null <span class="built_in">object</span></span><br><span class="line">c              <span class="number">2919</span> non-null <span class="built_in">object</span></span><br><span class="line">cy             <span class="number">2919</span> non-null <span class="built_in">object</span></span><br><span class="line">g              <span class="number">3440</span> non-null <span class="built_in">object</span></span><br><span class="line">gr             <span class="number">2919</span> non-null <span class="built_in">object</span></span><br><span class="line">h              <span class="number">3440</span> non-null <span class="built_in">object</span></span><br><span class="line">hc             <span class="number">3440</span> non-null float64</span><br><span class="line">hh             <span class="number">3440</span> non-null <span class="built_in">object</span></span><br><span class="line">kw             <span class="number">93</span> non-null <span class="built_in">object</span></span><br><span class="line">l              <span class="number">3440</span> non-null <span class="built_in">object</span></span><br><span class="line">ll             <span class="number">2919</span> non-null <span class="built_in">object</span></span><br><span class="line">nk             <span class="number">3440</span> non-null float64</span><br><span class="line">r              <span class="number">3440</span> non-null <span class="built_in">object</span></span><br><span class="line">t              <span class="number">3440</span> non-null float64</span><br><span class="line">tz             <span class="number">3440</span> non-null <span class="built_in">object</span></span><br><span class="line">u              <span class="number">3440</span> non-null <span class="built_in">object</span></span><br><span class="line">dtypes: float64(<span class="number">4</span>), <span class="built_in">object</span>(<span class="number">14</span>)</span><br><span class="line">memory usage: <span class="number">500.7</span>+ KB</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: frame[<span class="string">&#x27;tz&#x27;</span>][:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line"><span class="number">0</span>     America/New_York</span><br><span class="line"><span class="number">1</span>       America/Denver</span><br><span class="line"><span class="number">2</span>     America/New_York</span><br><span class="line"><span class="number">3</span>    America/Sao_Paulo</span><br><span class="line"><span class="number">4</span>     America/New_York</span><br><span class="line"><span class="number">5</span>     America/New_York</span><br><span class="line"><span class="number">6</span>        Europe/Warsaw</span><br><span class="line"><span class="number">7</span>                     </span><br><span class="line"><span class="number">8</span>                     </span><br><span class="line"><span class="number">9</span>                     </span><br><span class="line">Name: tz, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>这里frame的输出形式是摘要视图（summary view），主要用于较大的DataFrame对象。我们然后可以对Series使用value_counts方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">29</span>]: tz_counts = frame[<span class="string">&#x27;tz&#x27;</span>].value_counts()</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: tz_counts[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">30</span>]: </span><br><span class="line">America/New_York       <span class="number">1251</span></span><br><span class="line">                        <span class="number">521</span></span><br><span class="line">America/Chicago         <span class="number">400</span></span><br><span class="line">America/Los_Angeles     <span class="number">382</span></span><br><span class="line">America/Denver          <span class="number">191</span></span><br><span class="line">Europe/London            <span class="number">74</span></span><br><span class="line">Asia/Tokyo               <span class="number">37</span></span><br><span class="line">Pacific/Honolulu         <span class="number">36</span></span><br><span class="line">Europe/Madrid            <span class="number">35</span></span><br><span class="line">America/Sao_Paulo        <span class="number">33</span></span><br><span class="line">Name: tz, dtype: int64</span><br></pre></td></tr></table></figure>
<p>我们可以用matplotlib可视化这个数据。为此，我们先给记录中未知或缺失的时区填上一个替代值。fillna函数可以替换缺失值（NA），而未知值（空字符串）则可以通过布尔型数组索引加以替换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">31</span>]: clean_tz = frame[<span class="string">&#x27;tz&#x27;</span>].fillna(<span class="string">&#x27;Missing&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: clean_tz[clean_tz == <span class="string">&#x27;&#x27;</span>] = <span class="string">&#x27;Unknown&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: tz_counts = clean_tz.value_counts()</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: tz_counts[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">34</span>]: </span><br><span class="line">America/New_York       <span class="number">1251</span></span><br><span class="line">Unknown                 <span class="number">521</span></span><br><span class="line">America/Chicago         <span class="number">400</span></span><br><span class="line">America/Los_Angeles     <span class="number">382</span></span><br><span class="line">America/Denver          <span class="number">191</span></span><br><span class="line">Missing                 <span class="number">120</span></span><br><span class="line">Europe/London            <span class="number">74</span></span><br><span class="line">Asia/Tokyo               <span class="number">37</span></span><br><span class="line">Pacific/Honolulu         <span class="number">36</span></span><br><span class="line">Europe/Madrid            <span class="number">35</span></span><br><span class="line">Name: tz, dtype: int64</span><br></pre></td></tr></table></figure>
<p>此时，我们可以用seaborn包创建水平柱状图（结果见图14-1）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">36</span>]: <span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: subset = tz_counts[:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: sns.barplot(y=subset.index, x=subset.values)</span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-aa267c1d399a78f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图14-1 usa.gov示例数据中最常出现的时区" /><figcaption aria-hidden="true">图14-1 usa.gov示例数据中最常出现的时区</figcaption>
</figure>
<p>a字段含有执行URL短缩操作的浏览器、设备、应用程序的相关信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">39</span>]: frame[<span class="string">&#x27;a&#x27;</span>][<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">39</span>]: <span class="string">&#x27;GoogleMaps/RochesterNY&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: frame[<span class="string">&#x27;a&#x27;</span>][<span class="number">50</span>]</span><br><span class="line">Out[<span class="number">40</span>]: <span class="string">&#x27;Mozilla/5.0 (Windows NT 5.1; rv:10.0.2)</span></span><br><span class="line"><span class="string">Gecko/20100101 Firefox/10.0.2&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: frame[<span class="string">&#x27;a&#x27;</span>][<span class="number">51</span>][:<span class="number">50</span>]  <span class="comment"># long line</span></span><br><span class="line">Out[<span class="number">41</span>]: <span class="string">&#x27;Mozilla/5.0 (Linux; U; Android 2.2.2; en-us; LG-P9&#x27;</span></span><br></pre></td></tr></table></figure>
<p>将这些"agent"字符串中的所有信息都解析出来是一件挺郁闷的工作。一种策略是将这种字符串的第一节（与浏览器大致对应）分离出来并得到另外一份用户行为摘要：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">42</span>]: results = pd.Series([x.split()[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> frame.a.dropna()])</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: results[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line"><span class="number">0</span>               Mozilla/<span class="number">5.0</span></span><br><span class="line"><span class="number">1</span>    GoogleMaps/RochesterNY</span><br><span class="line"><span class="number">2</span>               Mozilla/<span class="number">4.0</span></span><br><span class="line"><span class="number">3</span>               Mozilla/<span class="number">5.0</span></span><br><span class="line"><span class="number">4</span>               Mozilla/<span class="number">5.0</span></span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: results.value_counts()[:<span class="number">8</span>]</span><br><span class="line">Out[<span class="number">44</span>]: </span><br><span class="line">Mozilla/<span class="number">5.0</span>                 <span class="number">2594</span></span><br><span class="line">Mozilla/<span class="number">4.0</span>                  <span class="number">601</span></span><br><span class="line">GoogleMaps/RochesterNY       <span class="number">121</span></span><br><span class="line">Opera/<span class="number">9.80</span>                    <span class="number">34</span></span><br><span class="line">TEST_INTERNET_AGENT           <span class="number">24</span></span><br><span class="line">GoogleProducer                <span class="number">21</span></span><br><span class="line">Mozilla/<span class="number">6.0</span>                    <span class="number">5</span></span><br><span class="line">BlackBerry8520/<span class="number">5.0</span><span class="number">.0</span><span class="number">.681</span>       <span class="number">4</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，假设你想按Windows和非Windows用户对时区统计信息进行分解。为了简单起见，我们假定只要agent字符串中含有"Windows"就认为该用户为Windows用户。由于有的agent缺失，所以首先将它们从数据中移除：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">45</span>]: cframe = frame[frame.a.notnull()]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后计算出各行是否含有Windows的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">47</span>]: cframe[<span class="string">&#x27;os&#x27;</span>] = np.where(cframe[<span class="string">&#x27;a&#x27;</span>].<span class="built_in">str</span>.contains(<span class="string">&#x27;Windows&#x27;</span>),</span><br><span class="line">   ....:                         <span class="string">&#x27;Windows&#x27;</span>, <span class="string">&#x27;Not Windows&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: cframe[<span class="string">&#x27;os&#x27;</span>][:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">48</span>]: </span><br><span class="line"><span class="number">0</span>        Windows</span><br><span class="line"><span class="number">1</span>    Not Windows</span><br><span class="line"><span class="number">2</span>        Windows</span><br><span class="line"><span class="number">3</span>    Not Windows</span><br><span class="line"><span class="number">4</span>        Windows</span><br><span class="line">Name: os, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来就可以根据时区和新得到的操作系统列表对数据进行分组了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">49</span>]: by_tz_os = cframe.groupby([<span class="string">&#x27;tz&#x27;</span>, <span class="string">&#x27;os&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分组计数，类似于value_counts函数，可以用size来计算。并利用unstack对计数结果进行重塑：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">50</span>]: agg_counts = by_tz_os.size().unstack().fillna(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: agg_counts[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">51</span>]: </span><br><span class="line">os                              Not Windows  Windows</span><br><span class="line">tz                                                  </span><br><span class="line">                                      <span class="number">245.0</span>    <span class="number">276.0</span></span><br><span class="line">Africa/Cairo                            <span class="number">0.0</span>      <span class="number">3.0</span></span><br><span class="line">Africa/Casablanca                       <span class="number">0.0</span>      <span class="number">1.0</span></span><br><span class="line">Africa/Ceuta                            <span class="number">0.0</span>      <span class="number">2.0</span></span><br><span class="line">Africa/Johannesburg                     <span class="number">0.0</span>      <span class="number">1.0</span></span><br><span class="line">Africa/Lusaka                           <span class="number">0.0</span>      <span class="number">1.0</span></span><br><span class="line">America/Anchorage                       <span class="number">4.0</span>      <span class="number">1.0</span></span><br><span class="line">America/Argentina/Buenos_Aires          <span class="number">1.0</span>      <span class="number">0.0</span></span><br><span class="line">America/Argentina/Cordoba               <span class="number">0.0</span>      <span class="number">1.0</span></span><br><span class="line">America/Argentina/Mendoza               <span class="number">0.0</span>      <span class="number">1.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后，我们来选取最常出现的时区。为了达到这个目的，我根据agg_counts中的行数构造了一个间接索引数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Use to sort in ascending order</span></span><br><span class="line">In [<span class="number">52</span>]: indexer = agg_counts.<span class="built_in">sum</span>(<span class="number">1</span>).argsort()</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: indexer[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">tz</span><br><span class="line">                                  <span class="number">24</span></span><br><span class="line">Africa/Cairo                      <span class="number">20</span></span><br><span class="line">Africa/Casablanca                 <span class="number">21</span></span><br><span class="line">Africa/Ceuta                      <span class="number">92</span></span><br><span class="line">Africa/Johannesburg               <span class="number">87</span></span><br><span class="line">Africa/Lusaka                     <span class="number">53</span></span><br><span class="line">America/Anchorage                 <span class="number">54</span></span><br><span class="line">America/Argentina/Buenos_Aires    <span class="number">57</span></span><br><span class="line">America/Argentina/Cordoba         <span class="number">26</span></span><br><span class="line">America/Argentina/Mendoza         <span class="number">55</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我通过take按照这个顺序截取了最后10行最大值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">54</span>]: count_subset = agg_counts.take(indexer[-<span class="number">10</span>:])</span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: count_subset</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">os                   Not Windows  Windows</span><br><span class="line">tz                                       </span><br><span class="line">America/Sao_Paulo           <span class="number">13.0</span>     <span class="number">20.0</span></span><br><span class="line">Europe/Madrid               <span class="number">16.0</span>     <span class="number">19.0</span></span><br><span class="line">Pacific/Honolulu             <span class="number">0.0</span>     <span class="number">36.0</span></span><br><span class="line">Asia/Tokyo                   <span class="number">2.0</span>     <span class="number">35.0</span></span><br><span class="line">Europe/London               <span class="number">43.0</span>     <span class="number">31.0</span></span><br><span class="line">America/Denver             <span class="number">132.0</span>     <span class="number">59.0</span></span><br><span class="line">America/Los_Angeles        <span class="number">130.0</span>    <span class="number">252.0</span></span><br><span class="line">America/Chicago            <span class="number">115.0</span>    <span class="number">285.0</span></span><br><span class="line">                           <span class="number">245.0</span>    <span class="number">276.0</span></span><br><span class="line">America/New_York           <span class="number">339.0</span>    <span class="number">912.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>pandas有一个简便方法nlargest，可以做同样的工作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: agg_counts.<span class="built_in">sum</span>(<span class="number">1</span>).nlargest(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">56</span>]: </span><br><span class="line">tz</span><br><span class="line">America/New_York       <span class="number">1251.0</span></span><br><span class="line">                        <span class="number">521.0</span></span><br><span class="line">America/Chicago         <span class="number">400.0</span></span><br><span class="line">America/Los_Angeles     <span class="number">382.0</span></span><br><span class="line">America/Denver          <span class="number">191.0</span></span><br><span class="line">Europe/London            <span class="number">74.0</span></span><br><span class="line">Asia/Tokyo               <span class="number">37.0</span></span><br><span class="line">Pacific/Honolulu         <span class="number">36.0</span></span><br><span class="line">Europe/Madrid            <span class="number">35.0</span></span><br><span class="line">America/Sao_Paulo        <span class="number">33.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，如这段代码所示，可以用柱状图表示。我传递一个额外参数到seaborn的barpolt函数，来画一个堆积条形图（见图14-2）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Rearrange the data for plotting</span></span><br><span class="line">In [<span class="number">58</span>]: count_subset = count_subset.stack()</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: count_subset.name = <span class="string">&#x27;total&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: count_subset = count_subset.reset_index()</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: count_subset[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">61</span>]: </span><br><span class="line">                  tz           os  total</span><br><span class="line"><span class="number">0</span>  America/Sao_Paulo  Not Windows   <span class="number">13.0</span></span><br><span class="line"><span class="number">1</span>  America/Sao_Paulo      Windows   <span class="number">20.0</span></span><br><span class="line"><span class="number">2</span>      Europe/Madrid  Not Windows   <span class="number">16.0</span></span><br><span class="line"><span class="number">3</span>      Europe/Madrid      Windows   <span class="number">19.0</span></span><br><span class="line"><span class="number">4</span>   Pacific/Honolulu  Not Windows    <span class="number">0.0</span></span><br><span class="line"><span class="number">5</span>   Pacific/Honolulu      Windows   <span class="number">36.0</span></span><br><span class="line"><span class="number">6</span>         Asia/Tokyo  Not Windows    <span class="number">2.0</span></span><br><span class="line"><span class="number">7</span>         Asia/Tokyo      Windows   <span class="number">35.0</span></span><br><span class="line"><span class="number">8</span>      Europe/London  Not Windows   <span class="number">43.0</span></span><br><span class="line"><span class="number">9</span>      Europe/London      Windows   <span class="number">31.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: sns.barplot(x=<span class="string">&#x27;total&#x27;</span>, y=<span class="string">&#x27;tz&#x27;</span>, hue=<span class="string">&#x27;os&#x27;</span>,  data=count_subset)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-053612a5655b68d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图14-2 最常出现时区的Windows和非Windows用户" /><figcaption aria-hidden="true">图14-2 最常出现时区的Windows和非Windows用户</figcaption>
</figure>
<p>这张图不容易看出Windows用户在小分组中的相对比例，因此标准化分组百分比之和为1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">norm_total</span>(<span class="params">group</span>):</span></span><br><span class="line">    group[<span class="string">&#x27;normed_total&#x27;</span>] = group.total / group.total.<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> group</span><br><span class="line"></span><br><span class="line">results = count_subset.groupby(<span class="string">&#x27;tz&#x27;</span>).apply(norm_total)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再次画图，见图14-3：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">65</span>]: sns.barplot(x=<span class="string">&#x27;normed_total&#x27;</span>, y=<span class="string">&#x27;tz&#x27;</span>, hue=<span class="string">&#x27;os&#x27;</span>,  data=results)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-60ee355801daf412.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图14-3 最常出现时区的Windows和非Windows用户的百分比" /><figcaption aria-hidden="true">图14-3 最常出现时区的Windows和非Windows用户的百分比</figcaption>
</figure>
<p>我们还可以用groupby的transform方法，更高效的计算标准化的和：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">66</span>]: g = count_subset.groupby(<span class="string">&#x27;tz&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: results2 = count_subset.total / g.total.transform(<span class="string">&#x27;sum&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="movielens-1m数据集">14.2 MovieLens 1M数据集</h1>
<p>GroupLens Research（http://www.grouplens.org/node/73）采集了一组从20世纪90年末到21世纪初由MovieLens用户提供的电影评分数据。这些数据中包括电影评分、电影元数据（风格类型和年代）以及关于用户的人口统计学数据（年龄、邮编、性别和职业等）。基于机器学习算法的推荐系统一般都会对此类数据感兴趣。虽然我不会在本书中详细介绍机器学习技术，但我会告诉你如何对这种数据进行切片切块以满足实际需求。</p>
<p>MovieLens 1M数据集含有来自6000名用户对4000部电影的100万条评分数据。它分为三个表：评分、用户信息和电影信息。将该数据从zip文件中解压出来之后，可以通过pandas.read_table将各个表分别读到一个pandas DataFrame对象中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make display smaller</span></span><br><span class="line">pd.options.display.max_rows = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">unames = [<span class="string">&#x27;user_id&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;occupation&#x27;</span>, <span class="string">&#x27;zip&#x27;</span>]</span><br><span class="line">users = pd.read_table(<span class="string">&#x27;datasets/movielens/users.dat&#x27;</span>, sep=<span class="string">&#x27;::&#x27;</span>,</span><br><span class="line">                      header=<span class="literal">None</span>, names=unames)</span><br><span class="line"></span><br><span class="line">rnames = [<span class="string">&#x27;user_id&#x27;</span>, <span class="string">&#x27;movie_id&#x27;</span>, <span class="string">&#x27;rating&#x27;</span>, <span class="string">&#x27;timestamp&#x27;</span>]</span><br><span class="line">ratings = pd.read_table(<span class="string">&#x27;datasets/movielens/ratings.dat&#x27;</span>, sep=<span class="string">&#x27;::&#x27;</span>,</span><br><span class="line">                        header=<span class="literal">None</span>, names=rnames)</span><br><span class="line">mnames = [<span class="string">&#x27;movie_id&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;genres&#x27;</span>]</span><br><span class="line">movies = pd.read_table(<span class="string">&#x27;datasets/movielens/movies.dat&#x27;</span>, sep=<span class="string">&#x27;::&#x27;</span>,</span><br><span class="line">                       header=<span class="literal">None</span>, names=mnames)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>利用Python的切片语法，通过查看每个DataFrame的前几行即可验证数据加载工作是否一切顺利：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">69</span>]: users[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">69</span>]: </span><br><span class="line">   user_id gender  age  occupation    <span class="built_in">zip</span></span><br><span class="line"><span class="number">0</span>        <span class="number">1</span>      F    <span class="number">1</span>          <span class="number">10</span>  <span class="number">48067</span></span><br><span class="line"><span class="number">1</span>        <span class="number">2</span>      M   <span class="number">56</span>          <span class="number">16</span>  <span class="number">70072</span></span><br><span class="line"><span class="number">2</span>        <span class="number">3</span>      M   <span class="number">25</span>          <span class="number">15</span>  <span class="number">55117</span></span><br><span class="line"><span class="number">3</span>        <span class="number">4</span>      M   <span class="number">45</span>           <span class="number">7</span>  02460</span><br><span class="line"><span class="number">4</span>        <span class="number">5</span>      M   <span class="number">25</span>          <span class="number">20</span>  <span class="number">55455</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: ratings[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">70</span>]: </span><br><span class="line">   user_id  movie_id  rating  timestamp</span><br><span class="line"><span class="number">0</span>        <span class="number">1</span>      <span class="number">1193</span>       <span class="number">5</span>  <span class="number">978300760</span></span><br><span class="line"><span class="number">1</span>        <span class="number">1</span>       <span class="number">661</span>       <span class="number">3</span>  <span class="number">978302109</span></span><br><span class="line"><span class="number">2</span>        <span class="number">1</span>       <span class="number">914</span>       <span class="number">3</span>  <span class="number">978301968</span></span><br><span class="line"><span class="number">3</span>        <span class="number">1</span>      <span class="number">3408</span>       <span class="number">4</span>  <span class="number">978300275</span></span><br><span class="line"><span class="number">4</span>        <span class="number">1</span>      <span class="number">2355</span>       <span class="number">5</span>  <span class="number">978824291</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: movies[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line">   movie_id                               title                        genres</span><br><span class="line"><span class="number">0</span>         <span class="number">1</span>                    Toy Story (<span class="number">1995</span>)   Animation|Children<span class="string">&#x27;s|Comedy</span></span><br><span class="line"><span class="string">1         2                      Jumanji (1995)  Adventure|Children&#x27;</span>s|Fantasy</span><br><span class="line"><span class="number">2</span>         <span class="number">3</span>             Grumpier Old Men (<span class="number">1995</span>)                Comedy|Romance</span><br><span class="line"><span class="number">3</span>         <span class="number">4</span>            Waiting to Exhale (<span class="number">1995</span>)                  Comedy|Drama</span><br><span class="line"><span class="number">4</span>         <span class="number">5</span>  Father of the Bride Part II (<span class="number">1995</span>)                        Comedy</span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: ratings</span><br><span class="line">Out[<span class="number">72</span>]: </span><br><span class="line">         user_id  movie_id  rating  timestamp</span><br><span class="line"><span class="number">0</span>              <span class="number">1</span>      <span class="number">1193</span>       <span class="number">5</span>  <span class="number">978300760</span></span><br><span class="line"><span class="number">1</span>              <span class="number">1</span>       <span class="number">661</span>       <span class="number">3</span>  <span class="number">978302109</span></span><br><span class="line"><span class="number">2</span>              <span class="number">1</span>       <span class="number">914</span>       <span class="number">3</span>  <span class="number">978301968</span></span><br><span class="line"><span class="number">3</span>              <span class="number">1</span>      <span class="number">3408</span>       <span class="number">4</span>  <span class="number">978300275</span></span><br><span class="line"><span class="number">4</span>              <span class="number">1</span>      <span class="number">2355</span>       <span class="number">5</span>  <span class="number">978824291</span></span><br><span class="line"><span class="meta">... </span>         ...       ...     ...        ...</span><br><span class="line"><span class="number">1000204</span>     <span class="number">6040</span>      <span class="number">1091</span>       <span class="number">1</span>  <span class="number">956716541</span></span><br><span class="line"><span class="number">1000205</span>     <span class="number">6040</span>      <span class="number">1094</span>       <span class="number">5</span>  <span class="number">956704887</span></span><br><span class="line"><span class="number">1000206</span>     <span class="number">6040</span>       <span class="number">562</span>       <span class="number">5</span>  <span class="number">956704746</span></span><br><span class="line"><span class="number">1000207</span>     <span class="number">6040</span>      <span class="number">1096</span>       <span class="number">4</span>  <span class="number">956715648</span></span><br><span class="line"><span class="number">1000208</span>     <span class="number">6040</span>      <span class="number">1097</span>       <span class="number">4</span>  <span class="number">956715569</span></span><br><span class="line">[<span class="number">1000209</span> rows x <span class="number">4</span> columns]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，其中的年龄和职业是以编码形式给出的，它们的具体含义请参考该数据集的README文件。分析散布在三个表中的数据可不是一件轻松的事情。假设我们想要根据性别和年龄计算某部电影的平均得分，如果将所有数据都合并到一个表中的话问题就简单多了。我们先用pandas的merge函数将ratings跟users合并到一起，然后再将movies也合并进去。pandas会根据列名的重叠情况推断出哪些列是合并（或连接）键：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">73</span>]: data = pd.merge(pd.merge(ratings, users), movies)</span><br><span class="line"></span><br><span class="line">In [<span class="number">74</span>]: data</span><br><span class="line">Out[<span class="number">74</span>]: </span><br><span class="line">         user_id  movie_id  rating  timestamp gender  age  occupation    <span class="built_in">zip</span>  \</span><br><span class="line"><span class="number">0</span>              <span class="number">1</span>      <span class="number">1193</span>       <span class="number">5</span>  <span class="number">978300760</span>      F    <span class="number">1</span>          <span class="number">10</span>  <span class="number">48067</span>   </span><br><span class="line"><span class="number">1</span>              <span class="number">2</span>      <span class="number">1193</span>       <span class="number">5</span>  <span class="number">978298413</span>      M   <span class="number">56</span>          <span class="number">16</span>  <span class="number">70072</span>   </span><br><span class="line"><span class="number">2</span>             <span class="number">12</span>      <span class="number">1193</span>       <span class="number">4</span>  <span class="number">978220179</span>      M   <span class="number">25</span>          <span class="number">12</span>  <span class="number">32793</span>   </span><br><span class="line"><span class="number">3</span>             <span class="number">15</span>      <span class="number">1193</span>       <span class="number">4</span>  <span class="number">978199279</span>      M   <span class="number">25</span>           <span class="number">7</span>  <span class="number">22903</span>   </span><br><span class="line"><span class="number">4</span>             <span class="number">17</span>      <span class="number">1193</span>       <span class="number">5</span>  <span class="number">978158471</span>      M   <span class="number">50</span>           <span class="number">1</span>  <span class="number">95350</span>   </span><br><span class="line"><span class="meta">... </span>         ...       ...     ...        ...    ...  ...         ...    ...   </span><br><span class="line"><span class="number">1000204</span>     <span class="number">5949</span>      <span class="number">2198</span>       <span class="number">5</span>  <span class="number">958846401</span>      M   <span class="number">18</span>          <span class="number">17</span>  <span class="number">47901</span></span><br><span class="line"><span class="number">1000205</span>     <span class="number">5675</span>      <span class="number">2703</span>       <span class="number">3</span>  <span class="number">976029116</span>      M   <span class="number">35</span>          <span class="number">14</span>  <span class="number">30030</span>   </span><br><span class="line"><span class="number">1000206</span>     <span class="number">5780</span>      <span class="number">2845</span>       <span class="number">1</span>  <span class="number">958153068</span>      M   <span class="number">18</span>          <span class="number">17</span>  <span class="number">92886</span>   </span><br><span class="line"><span class="number">1000207</span>     <span class="number">5851</span>      <span class="number">3607</span>       <span class="number">5</span>  <span class="number">957756608</span>      F   <span class="number">18</span>          <span class="number">20</span>  <span class="number">55410</span>   </span><br><span class="line"><span class="number">1000208</span>     <span class="number">5938</span>      <span class="number">2909</span>       <span class="number">4</span>  <span class="number">957273353</span>      M   <span class="number">25</span>           <span class="number">1</span>  <span class="number">35401</span>   </span><br><span class="line">                                               title                genres  </span><br><span class="line"><span class="number">0</span>             One Flew Over the Cuckoo<span class="string">&#x27;s Nest (1975)                 Drama  </span></span><br><span class="line"><span class="string">1             One Flew Over the Cuckoo&#x27;</span>s Nest (<span class="number">1975</span>)                 Drama  </span><br><span class="line"><span class="number">2</span>             One Flew Over the Cuckoo<span class="string">&#x27;s Nest (1975)                 Drama  </span></span><br><span class="line"><span class="string">3             One Flew Over the Cuckoo&#x27;</span>s Nest (<span class="number">1975</span>)                 Drama  </span><br><span class="line"><span class="number">4</span>             One Flew Over the Cuckoo<span class="string">&#x27;s Nest (1975)                 Drama  </span></span><br><span class="line"><span class="string">...                                              ...                   ...  </span></span><br><span class="line"><span class="string">1000204                           Modulations (1998)           Documentary  </span></span><br><span class="line"><span class="string">1000205                        Broken Vessels (1998)                 Drama  </span></span><br><span class="line"><span class="string">1000206                            White Boys (1999)                 Drama  </span></span><br><span class="line"><span class="string">1000207                     One Little Indian (1973)  Comedy|Drama|Western  </span></span><br><span class="line"><span class="string">1000208  Five Wives, Three Secretaries and Me (1998)           Documentary  </span></span><br><span class="line"><span class="string">[1000209 rows x 10 columns]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">In [75]: data.iloc[0]</span></span><br><span class="line"><span class="string">Out[75]: </span></span><br><span class="line"><span class="string">user_id                                            1</span></span><br><span class="line"><span class="string">movie_id                                        1193</span></span><br><span class="line"><span class="string">rating                                             5</span></span><br><span class="line"><span class="string">timestamp                                  978300760</span></span><br><span class="line"><span class="string">gender                                             F</span></span><br><span class="line"><span class="string">age                                                1</span></span><br><span class="line"><span class="string">occupation                                        10</span></span><br><span class="line"><span class="string">zip                                            48067</span></span><br><span class="line"><span class="string">title         One Flew Over the Cuckoo&#x27;</span>s Nest (<span class="number">1975</span>)</span><br><span class="line">genres                                         Drama</span><br><span class="line">Name: <span class="number">0</span>, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了按性别计算每部电影的平均得分，我们可以使用pivot_table方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: mean_ratings = data.pivot_table(<span class="string">&#x27;rating&#x27;</span>, index=<span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">   ....:                                 columns=<span class="string">&#x27;gender&#x27;</span>, aggfunc=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: mean_ratings[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">77</span>]: </span><br><span class="line">gender                                F         M</span><br><span class="line">title                                            </span><br><span class="line">$<span class="number">1</span>,<span class="number">000</span>,<span class="number">000</span> Duck (<span class="number">1971</span>)         <span class="number">3.375000</span>  <span class="number">2.761905</span></span><br><span class="line"><span class="string">&#x27;Night Mother (1986)           3.388889  3.352941</span></span><br><span class="line"><span class="string">&#x27;</span>Til There Was You (<span class="number">1997</span>)      <span class="number">2.675676</span>  <span class="number">2.733333</span></span><br><span class="line"><span class="string">&#x27;burbs, The (1989)             2.793478  2.962085</span></span><br><span class="line"><span class="string">...And Justice for All (1979)  3.828571  3.689024</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>该操作产生了另一个DataFrame，其内容为电影平均得分，行标为电影名称（索引），列标为性别。现在，我打算过滤掉评分数据不够250条的电影（随便选的一个数字）。为了达到这个目的，我先对title进行分组，然后利用size()得到一个含有各电影分组大小的Series对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">78</span>]: ratings_by_title = data.groupby(<span class="string">&#x27;title&#x27;</span>).size()</span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: ratings_by_title[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">79</span>]: </span><br><span class="line">title</span><br><span class="line">$<span class="number">1</span>,<span class="number">000</span>,<span class="number">000</span> Duck (<span class="number">1971</span>)                <span class="number">37</span></span><br><span class="line"><span class="string">&#x27;Night Mother (1986)                  70</span></span><br><span class="line"><span class="string">&#x27;</span>Til There Was You (<span class="number">1997</span>)             <span class="number">52</span></span><br><span class="line"><span class="string">&#x27;burbs, The (1989)                   303</span></span><br><span class="line"><span class="string">...And Justice for All (1979)        199</span></span><br><span class="line"><span class="string">1-900 (1994)                           2</span></span><br><span class="line"><span class="string">10 Things I Hate About You (1999)    700</span></span><br><span class="line"><span class="string">101 Dalmatians (1961)                565</span></span><br><span class="line"><span class="string">101 Dalmatians (1996)                364</span></span><br><span class="line"><span class="string">12 Angry Men (1957)                  616</span></span><br><span class="line"><span class="string">dtype: int64</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">In [80]: active_titles = ratings_by_title.index[ratings_by_title &gt;= 250]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">In [81]: active_titles</span></span><br><span class="line"><span class="string">Out[81]: </span></span><br><span class="line"><span class="string">Index([&#x27;</span><span class="string">&#x27;burbs, The (1989)&#x27;</span>, <span class="string">&#x27;10 Things I Hate About You (1999)&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;101 Dalmatians (1961)&#x27;</span>, <span class="string">&#x27;101 Dalmatians (1996)&#x27;</span>, <span class="string">&#x27;12 Angry Men (1957)&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;13th Warrior, The (1999)&#x27;</span>, <span class="string">&#x27;2 Days in the Valley (1996)&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;20,000 Leagues Under the Sea (1954)&#x27;</span>, <span class="string">&#x27;2001: A Space Odyssey (1968)&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;2010 (1984)&#x27;</span>,</span><br><span class="line">       ...</span><br><span class="line"><span class="string">&#x27;X-Men (2000)&#x27;</span>, <span class="string">&#x27;Year of Living Dangerously (1982)&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Yellow Submarine (1968)&#x27;</span>, <span class="string">&#x27;You&#x27;</span>ve Got Mail (<span class="number">1998</span>)<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">       &#x27;</span>Young Frankenstein (<span class="number">1974</span>)<span class="string">&#x27;, &#x27;</span>Young Guns (<span class="number">1988</span>)<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">       &#x27;</span>Young Guns II (<span class="number">1990</span>)<span class="string">&#x27;, &#x27;</span>Young Sherlock Holmes (<span class="number">1985</span>)<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">       &#x27;</span>Zero Effect (<span class="number">1998</span>)<span class="string">&#x27;, &#x27;</span>eXistenZ (<span class="number">1999</span>)<span class="string">&#x27;],</span></span><br><span class="line"><span class="string">      dtype=&#x27;</span><span class="built_in">object</span><span class="string">&#x27;, name=&#x27;</span>title<span class="string">&#x27;, length=1216)</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>标题索引中含有评分数据大于250条的电影名称，然后我们就可以据此从前面的mean_ratings中选取所需的行了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Select rows on the index</span></span><br><span class="line">In [<span class="number">82</span>]: mean_ratings = mean_ratings.loc[active_titles]</span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: mean_ratings</span><br><span class="line">Out[<span class="number">83</span>]: </span><br><span class="line">gender                                    F         M</span><br><span class="line">title                                                </span><br><span class="line"><span class="string">&#x27;burbs, The (1989)                 2.793478  2.962085</span></span><br><span class="line"><span class="string">10 Things I Hate About You (1999)  3.646552  3.311966</span></span><br><span class="line"><span class="string">101 Dalmatians (1961)              3.791444  3.500000</span></span><br><span class="line"><span class="string">101 Dalmatians (1996)              3.240000  2.911215</span></span><br><span class="line"><span class="string">12 Angry Men (1957)                4.184397  4.328421</span></span><br><span class="line"><span class="string">...                                     ...       ...</span></span><br><span class="line"><span class="string">Young Guns (1988)                  3.371795  3.425620</span></span><br><span class="line"><span class="string">Young Guns II (1990)               2.934783  2.904025</span></span><br><span class="line"><span class="string">Young Sherlock Holmes (1985)       3.514706  3.363344</span></span><br><span class="line"><span class="string">Zero Effect (1998)                 3.864407  3.723140</span></span><br><span class="line"><span class="string">eXistenZ (1999)                    3.098592  3.289086</span></span><br><span class="line"><span class="string">[1216 rows x 2 columns]</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>为了了解女性观众最喜欢的电影，我们可以对F列降序排列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">85</span>]: top_female_ratings = mean_ratings.sort_values(by=<span class="string">&#x27;F&#x27;</span>, ascending=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: top_female_ratings[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">86</span>]: </span><br><span class="line">gender                                                     F         M</span><br><span class="line">title                                                                 </span><br><span class="line">Close Shave, A (<span class="number">1995</span>)                               <span class="number">4.644444</span>  <span class="number">4.473795</span></span><br><span class="line">Wrong Trousers, The (<span class="number">1993</span>)                          <span class="number">4.588235</span>  <span class="number">4.478261</span></span><br><span class="line">Sunset Blvd. (a.k.a. Sunset Boulevard) (<span class="number">1950</span>)       <span class="number">4.572650</span>  <span class="number">4.464589</span></span><br><span class="line">Wallace &amp; Gromit: The Best of Aardman Animation...  <span class="number">4.563107</span>  <span class="number">4.385075</span></span><br><span class="line">Schindle<span class="string">r&#x27;s List (1993)                             4.562602  4.491415</span></span><br><span class="line"><span class="string">Shawshank Redemption, The (1994)                    4.539075  4.560625</span></span><br><span class="line"><span class="string">Grand Day Out, A (1992)                             4.537879  4.293255</span></span><br><span class="line"><span class="string">To Kill a Mockingbird (1962)                        4.536667  4.372611</span></span><br><span class="line"><span class="string">Creature Comforts (1990)                            4.513889  4.272277</span></span><br><span class="line"><span class="string">Usual Suspects, The (1995)                          4.513317  4.518248</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<h2 id="计算评分分歧">计算评分分歧</h2>
<p>假设我们想要找出男性和女性观众分歧最大的电影。一个办法是给mean_ratings加上一个用于存放平均得分之差的列，并对其进行排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">87</span>]: mean_ratings[<span class="string">&#x27;diff&#x27;</span>] = mean_ratings[<span class="string">&#x27;M&#x27;</span>] - mean_ratings[<span class="string">&#x27;F&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>按"diff"排序即可得到分歧最大且女性观众更喜欢的电影：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">88</span>]: sorted_by_diff = mean_ratings.sort_values(by=<span class="string">&#x27;diff&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: sorted_by_diff[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">89</span>]: </span><br><span class="line">gender                                        F         M      diff</span><br><span class="line">title                                                              </span><br><span class="line">Dirty Dancing (<span class="number">1987</span>)                   <span class="number">3.790378</span>  <span class="number">2.959596</span> -<span class="number">0.830782</span></span><br><span class="line">Jumpin<span class="string">&#x27; Jack Flash (1986)              3.254717  2.578358 -0.676359</span></span><br><span class="line"><span class="string">Grease (1978)                          3.975265  3.367041 -0.608224</span></span><br><span class="line"><span class="string">Little Women (1994)                    3.870588  3.321739 -0.548849</span></span><br><span class="line"><span class="string">Steel Magnolias (1989)                 3.901734  3.365957 -0.535777</span></span><br><span class="line"><span class="string">Anastasia (1997)                       3.800000  3.281609 -0.518391</span></span><br><span class="line"><span class="string">Rocky Horror Picture Show, The (1975)  3.673016  3.160131 -0.512885</span></span><br><span class="line"><span class="string">Color Purple, The (1985)               4.158192  3.659341 -0.498851</span></span><br><span class="line"><span class="string">Age of Innocence, The (1993)           3.827068  3.339506 -0.487561</span></span><br><span class="line"><span class="string">Free Willy (1993)                      2.921348  2.438776 -0.482573</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>对排序结果反序并取出前10行，得到的则是男性观众更喜欢的电影：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reverse order of rows, take first 10 rows</span></span><br><span class="line">In [<span class="number">90</span>]: sorted_by_diff[::-<span class="number">1</span>][:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">90</span>]: </span><br><span class="line">gender                                         F         M      diff</span><br><span class="line">title                                                               </span><br><span class="line">Good, The Bad <span class="keyword">and</span> The Ugly, The (<span class="number">1966</span>)  <span class="number">3.494949</span>  <span class="number">4.221300</span>  <span class="number">0.726351</span></span><br><span class="line">Kentucky Fried Movie, The (<span class="number">1977</span>)        <span class="number">2.878788</span>  <span class="number">3.555147</span>  <span class="number">0.676359</span></span><br><span class="line">Dumb &amp; Dumber (<span class="number">1994</span>)                    <span class="number">2.697987</span>  <span class="number">3.336595</span>  <span class="number">0.638608</span></span><br><span class="line">Longest Day, The (<span class="number">1962</span>)                 <span class="number">3.411765</span>  <span class="number">4.031447</span>  <span class="number">0.619682</span></span><br><span class="line">Cable Guy, The (<span class="number">1996</span>)                   <span class="number">2.250000</span>  <span class="number">2.863787</span>  <span class="number">0.613787</span></span><br><span class="line">Evil Dead II (Dead By Dawn) (<span class="number">1987</span>)      <span class="number">3.297297</span>  <span class="number">3.909283</span>  <span class="number">0.611985</span></span><br><span class="line">Hidden, The (<span class="number">1987</span>)                      <span class="number">3.137931</span>  <span class="number">3.745098</span>  <span class="number">0.607167</span></span><br><span class="line">Rocky III (<span class="number">1982</span>)                        <span class="number">2.361702</span>  <span class="number">2.943503</span>  <span class="number">0.581801</span></span><br><span class="line">Caddyshack (<span class="number">1980</span>)                       <span class="number">3.396135</span>  <span class="number">3.969737</span>  <span class="number">0.573602</span></span><br><span class="line">For a Few Dollars More (<span class="number">1965</span>)           <span class="number">3.409091</span>  <span class="number">3.953795</span>  <span class="number">0.544704</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果只是想要找出分歧最大的电影（不考虑性别因素），则可以计算得分数据的方差或标准差：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Standard deviation of rating grouped by title</span></span><br><span class="line">In [<span class="number">91</span>]: rating_std_by_title = data.groupby(<span class="string">&#x27;title&#x27;</span>)[<span class="string">&#x27;rating&#x27;</span>].std()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Filter down to active_titles</span></span><br><span class="line">In [<span class="number">92</span>]: rating_std_by_title = rating_std_by_title.loc[active_titles]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Order Series by value in descending order</span></span><br><span class="line">In [<span class="number">93</span>]: rating_std_by_title.sort_values(ascending=<span class="literal">False</span>)[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">93</span>]: </span><br><span class="line">title</span><br><span class="line">Dumb &amp; Dumber (<span class="number">1994</span>)                     <span class="number">1.321333</span></span><br><span class="line">Blair Witch Project, The (<span class="number">1999</span>)          <span class="number">1.316368</span></span><br><span class="line">Natural Born Killers (<span class="number">1994</span>)              <span class="number">1.307198</span></span><br><span class="line">Tank Girl (<span class="number">1995</span>)                         <span class="number">1.277695</span></span><br><span class="line">Rocky Horror Picture Show, The (<span class="number">1975</span>)    <span class="number">1.260177</span></span><br><span class="line">Eyes Wide Shut (<span class="number">1999</span>)                    <span class="number">1.259624</span></span><br><span class="line">Evita (<span class="number">1996</span>)                             <span class="number">1.253631</span></span><br><span class="line">Billy Madison (<span class="number">1995</span>)                     <span class="number">1.249970</span></span><br><span class="line">Fear <span class="keyword">and</span> Loathing <span class="keyword">in</span> Las Vegas (<span class="number">1998</span>)    <span class="number">1.246408</span></span><br><span class="line">Bicentennial Man (<span class="number">1999</span>)                  <span class="number">1.245533</span></span><br><span class="line">Name: rating, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可能你已经注意到了，电影分类是以竖线（|）分隔的字符串形式给出的。如果想对电影分类进行分析的话，就需要先将其转换成更有用的形式才行。</p>
<h1 id="年间全美婴儿姓名">14.3 1880-2010年间全美婴儿姓名</h1>
<p>美国社会保障总署（SSA）提供了一份从1880年到现在的婴儿名字频率数据。Hadley Wickham（许多流行R包的作者）经常用这份数据来演示R的数据处理功能。</p>
<p>我们要做一些数据规整才能加载这个数据集，这么做就会产生一个如下的DataFrame：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">4</span>]: names.head(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">4</span>]:</span><br><span class="line">        name sex  births  year</span><br><span class="line"><span class="number">0</span>       Mary   F    <span class="number">7065</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">1</span>       Anna   F    <span class="number">2604</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">2</span>       Emma   F    <span class="number">2003</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">3</span>  Elizabeth   F    <span class="number">1939</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">4</span>     Minnie   F    <span class="number">1746</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">5</span>   Margaret   F    <span class="number">1578</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">6</span>        Ida   F    <span class="number">1472</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">7</span>      Alice   F    <span class="number">1414</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">8</span>     Bertha   F    <span class="number">1320</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">9</span>      Sarah   F    <span class="number">1288</span>  <span class="number">1880</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可以用这个数据集做很多事，例如：</p>
<ul>
<li>计算指定名字（可以是你自己的，也可以是别人的）的年度比例。</li>
<li>计算某个名字的相对排名。</li>
<li>计算各年度最流行的名字，以及增长或减少最快的名字。</li>
<li>分析名字趋势：元音、辅音、长度、总体多样性、拼写变化、首尾字母等。</li>
<li>分析外源性趋势：圣经中的名字、名人、人口结构变化等。</li>
</ul>
<p>利用前面介绍过的那些工具，这些分析工作都能很轻松地完成，我会讲解其中的一些。</p>
<p>到编写本书时为止，美国社会保障总署将该数据库按年度制成了多个数据文件，其中给出了每个性别/名字组合的出生总数。这些文件的原始档案可以在这里获取：<a href="http://www.ssa.gov/oact/babynames/limits.html">http://www.ssa.gov/oact/babynames/limits.html</a>。</p>
<p>如果你在阅读本书的时候这个页面已经不见了，也可以用搜索引擎找找。</p>
<p>下载"National data"文件names.zip，解压后的目录中含有一组文件（如yob1880.txt）。我用UNIX的head命令查看了其中一个文件的前10行（在Windows上，你可以用more命令，或直接在文本编辑器中打开）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [94]: !head -n 10 datasets/babynames/yob1880.txt</span><br><span class="line">Mary,F,7065</span><br><span class="line">Anna,F,2604</span><br><span class="line">Emma,F,2003</span><br><span class="line">Elizabeth,F,1939</span><br><span class="line">Minnie,F,1746</span><br><span class="line">Margaret,F,1578</span><br><span class="line">Ida,F,1472</span><br><span class="line">Alice,F,1414</span><br><span class="line">Bertha,F,1320</span><br><span class="line">Sarah,F,1288</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于这是一个非常标准的以逗号隔开的格式，所以可以用pandas.read_csv将其加载到DataFrame中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">95</span>]: <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">In [<span class="number">96</span>]: names1880 =</span><br><span class="line">pd.read_csv(<span class="string">&#x27;datasets/babynames/yob1880.txt&#x27;</span>,</span><br><span class="line">   ....:                         names=[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;births&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: names1880</span><br><span class="line">Out[<span class="number">97</span>]: </span><br><span class="line">           name sex  births</span><br><span class="line"><span class="number">0</span>          Mary   F    <span class="number">7065</span></span><br><span class="line"><span class="number">1</span>          Anna   F    <span class="number">2604</span></span><br><span class="line"><span class="number">2</span>          Emma   F    <span class="number">2003</span></span><br><span class="line"><span class="number">3</span>     Elizabeth   F    <span class="number">1939</span></span><br><span class="line"><span class="number">4</span>        Minnie   F    <span class="number">1746</span></span><br><span class="line"><span class="meta">... </span>        ...  ..     ...</span><br><span class="line"><span class="number">1995</span>     Woodie   M       <span class="number">5</span></span><br><span class="line"><span class="number">1996</span>     Worthy   M       <span class="number">5</span></span><br><span class="line"><span class="number">1997</span>     Wright   M       <span class="number">5</span></span><br><span class="line"><span class="number">1998</span>       York   M       <span class="number">5</span></span><br><span class="line"><span class="number">1999</span>  Zachariah   M       <span class="number">5</span></span><br><span class="line">[<span class="number">2000</span> rows x <span class="number">3</span> columns]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这些文件中仅含有当年出现超过5次的名字。为了简单起见，我们可以用births列的sex分组小计表示该年度的births总计：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">98</span>]: names1880.groupby(<span class="string">&#x27;sex&#x27;</span>).births.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">98</span>]: </span><br><span class="line">sex</span><br><span class="line">F     <span class="number">90993</span></span><br><span class="line">M    <span class="number">110493</span></span><br><span class="line">Name: births, dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于该数据集按年度被分隔成了多个文件，所以第一件事情就是要将所有数据都组装到一个DataFrame里面，并加上一个year字段。使用pandas.concat即可达到这个目的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">years = <span class="built_in">range</span>(<span class="number">1880</span>, <span class="number">2011</span>)</span><br><span class="line"></span><br><span class="line">pieces = []</span><br><span class="line">columns = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;births&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> year <span class="keyword">in</span> years:</span><br><span class="line">    path = <span class="string">&#x27;datasets/babynames/yob%d.txt&#x27;</span> % year</span><br><span class="line">    frame = pd.read_csv(path, names=columns)</span><br><span class="line"></span><br><span class="line">    frame[<span class="string">&#x27;year&#x27;</span>] = year</span><br><span class="line">    pieces.append(frame)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Concatenate everything into a single DataFrame</span></span><br><span class="line">names = pd.concat(pieces, ignore_index=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里需要注意几件事情。第一，concat默认是按行将多个DataFrame组合到一起的；第二，必须指定ignore_index=True，因为我们不希望保留read_csv所返回的原始行号。现在我们得到了一个非常大的DataFrame，它含有全部的名字数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">100</span>]: names</span><br><span class="line">Out[<span class="number">100</span>]: </span><br><span class="line">              name sex  births  year</span><br><span class="line"><span class="number">0</span>             Mary   F    <span class="number">7065</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">1</span>             Anna   F    <span class="number">2604</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">2</span>             Emma   F    <span class="number">2003</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">3</span>        Elizabeth   F    <span class="number">1939</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">4</span>           Minnie   F    <span class="number">1746</span>  <span class="number">1880</span></span><br><span class="line"><span class="meta">... </span>           ...  ..     ...   ...</span><br><span class="line"><span class="number">1690779</span>    Zymaire   M       <span class="number">5</span>  <span class="number">2010</span></span><br><span class="line"><span class="number">1690780</span>     Zyonne   M       <span class="number">5</span>  <span class="number">2010</span></span><br><span class="line"><span class="number">1690781</span>  Zyquarius   M       <span class="number">5</span>  <span class="number">2010</span></span><br><span class="line"><span class="number">1690782</span>      Zyran   M       <span class="number">5</span>  <span class="number">2010</span></span><br><span class="line"><span class="number">1690783</span>      Zzyzx   M       <span class="number">5</span>  <span class="number">2010</span></span><br><span class="line">[<span class="number">1690784</span> rows x <span class="number">4</span> columns]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有了这些数据之后，我们就可以利用groupby或pivot_table在year和sex级别上对其进行聚合了，如图14-4所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">101</span>]: total_births = names.pivot_table(<span class="string">&#x27;births&#x27;</span>, index=<span class="string">&#x27;year&#x27;</span>,</span><br><span class="line">   .....:                                  columns=<span class="string">&#x27;sex&#x27;</span>, aggfunc=<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">102</span>]: total_births.tail()</span><br><span class="line">Out[<span class="number">102</span>]: </span><br><span class="line">sex         F        M</span><br><span class="line">year                  </span><br><span class="line"><span class="number">2006</span>  <span class="number">1896468</span>  <span class="number">2050234</span></span><br><span class="line"><span class="number">2007</span>  <span class="number">1916888</span>  <span class="number">2069242</span></span><br><span class="line"><span class="number">2008</span>  <span class="number">1883645</span>  <span class="number">2032310</span></span><br><span class="line"><span class="number">2009</span>  <span class="number">1827643</span>  <span class="number">1973359</span></span><br><span class="line"><span class="number">2010</span>  <span class="number">1759010</span>  <span class="number">1898382</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: total_births.plot(title=<span class="string">&#x27;Total births by sex and year&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-7643b150d88aae11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图14-4 按性别和年度统计的总出生数" /><figcaption aria-hidden="true">图14-4 按性别和年度统计的总出生数</figcaption>
</figure>
<p>下面我们来插入一个prop列，用于存放指定名字的婴儿数相对于总出生数的比例。prop值为0.02表示每100名婴儿中有2名取了当前这个名字。因此，我们先按year和sex分组，然后再将新列加到各个分组上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_prop</span>(<span class="params">group</span>):</span></span><br><span class="line">    group[<span class="string">&#x27;prop&#x27;</span>] = group.births / group.births.<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> group</span><br><span class="line">names = names.groupby([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>]).apply(add_prop)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，完整的数据集就有了下面这些列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">105</span>]: names</span><br><span class="line">Out[<span class="number">105</span>]: </span><br><span class="line">              name sex  births  year      prop</span><br><span class="line"><span class="number">0</span>             Mary   F    <span class="number">7065</span>  <span class="number">1880</span>  <span class="number">0.077643</span></span><br><span class="line"><span class="number">1</span>             Anna   F    <span class="number">2604</span>  <span class="number">1880</span>  <span class="number">0.028618</span></span><br><span class="line"><span class="number">2</span>             Emma   F    <span class="number">2003</span>  <span class="number">1880</span>  <span class="number">0.022013</span></span><br><span class="line"><span class="number">3</span>        Elizabeth   F    <span class="number">1939</span>  <span class="number">1880</span>  <span class="number">0.021309</span></span><br><span class="line"><span class="number">4</span>           Minnie   F    <span class="number">1746</span>  <span class="number">1880</span>  <span class="number">0.019188</span></span><br><span class="line"><span class="meta">... </span>           ...  ..     ...   ...       ...</span><br><span class="line"><span class="number">1690779</span>    Zymaire   M       <span class="number">5</span>  <span class="number">2010</span>  <span class="number">0.000003</span></span><br><span class="line"><span class="number">1690780</span>     Zyonne   M       <span class="number">5</span>  <span class="number">2010</span>  <span class="number">0.000003</span></span><br><span class="line"><span class="number">1690781</span>  Zyquarius   M       <span class="number">5</span>  <span class="number">2010</span>  <span class="number">0.000003</span></span><br><span class="line"><span class="number">1690782</span>      Zyran   M       <span class="number">5</span>  <span class="number">2010</span>  <span class="number">0.000003</span></span><br><span class="line"><span class="number">1690783</span>      Zzyzx   M       <span class="number">5</span>  <span class="number">2010</span>  <span class="number">0.000003</span></span><br><span class="line">[<span class="number">1690784</span> rows x <span class="number">5</span> columns]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在执行这样的分组处理时，一般都应该做一些有效性检查，比如验证所有分组的prop的总和是否为1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">106</span>]: names.groupby([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>]).prop.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">106</span>]: </span><br><span class="line">year  sex</span><br><span class="line"><span class="number">1880</span>  F      <span class="number">1.0</span></span><br><span class="line">      M      <span class="number">1.0</span></span><br><span class="line"><span class="number">1881</span>  F      <span class="number">1.0</span></span><br><span class="line">      M      <span class="number">1.0</span></span><br><span class="line"><span class="number">1882</span>  F      <span class="number">1.0</span></span><br><span class="line">            ... </span><br><span class="line"><span class="number">2008</span>  M      <span class="number">1.0</span></span><br><span class="line"><span class="number">2009</span>  F      <span class="number">1.0</span></span><br><span class="line">      M      <span class="number">1.0</span></span><br><span class="line"><span class="number">2010</span>  F      <span class="number">1.0</span></span><br><span class="line">      M      <span class="number">1.0</span></span><br><span class="line">Name: prop, Length: <span class="number">262</span>, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>工作完成。为了便于实现更进一步的分析，我需要取出该数据的一个子集：每对sex/year组合的前1000个名字。这又是一个分组操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_top1000</span>(<span class="params">group</span>):</span></span><br><span class="line">    <span class="keyword">return</span> group.sort_values(by=<span class="string">&#x27;births&#x27;</span>, ascending=<span class="literal">False</span>)[:<span class="number">1000</span>]</span><br><span class="line">grouped = names.groupby([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>])</span><br><span class="line">top1000 = grouped.apply(get_top1000)</span><br><span class="line"><span class="comment"># Drop the group index, not needed</span></span><br><span class="line">top1000.reset_index(inplace=<span class="literal">True</span>, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你喜欢DIY的话，也可以这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pieces = []</span><br><span class="line"><span class="keyword">for</span> year, group <span class="keyword">in</span> names.groupby([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>]):</span><br><span class="line">    pieces.append(group.sort_values(by=<span class="string">&#x27;births&#x27;</span>, ascending=<span class="literal">False</span>)[:<span class="number">1000</span>])</span><br><span class="line">top1000 = pd.concat(pieces, ignore_index=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在的结果数据集就小多了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">108</span>]: top1000</span><br><span class="line">Out[<span class="number">108</span>]: </span><br><span class="line">             name sex  births  year      prop</span><br><span class="line"><span class="number">0</span>            Mary   F    <span class="number">7065</span>  <span class="number">1880</span>  <span class="number">0.077643</span></span><br><span class="line"><span class="number">1</span>            Anna   F    <span class="number">2604</span>  <span class="number">1880</span>  <span class="number">0.028618</span></span><br><span class="line"><span class="number">2</span>            Emma   F    <span class="number">2003</span>  <span class="number">1880</span>  <span class="number">0.022013</span></span><br><span class="line"><span class="number">3</span>       Elizabeth   F    <span class="number">1939</span>  <span class="number">1880</span>  <span class="number">0.021309</span></span><br><span class="line"><span class="number">4</span>          Minnie   F    <span class="number">1746</span>  <span class="number">1880</span>  <span class="number">0.019188</span></span><br><span class="line"><span class="meta">... </span>          ...  ..     ...   ...       ...</span><br><span class="line"><span class="number">261872</span>     Camilo   M     <span class="number">194</span>  <span class="number">2010</span>  <span class="number">0.000102</span></span><br><span class="line"><span class="number">261873</span>     Destin   M     <span class="number">194</span>  <span class="number">2010</span>  <span class="number">0.000102</span></span><br><span class="line"><span class="number">261874</span>     Jaquan   M     <span class="number">194</span>  <span class="number">2010</span>  <span class="number">0.000102</span></span><br><span class="line"><span class="number">261875</span>     Jaydan   M     <span class="number">194</span>  <span class="number">2010</span>  <span class="number">0.000102</span></span><br><span class="line"><span class="number">261876</span>     Maxton   M     <span class="number">193</span>  <span class="number">2010</span>  <span class="number">0.000102</span></span><br><span class="line">[<span class="number">261877</span> rows x <span class="number">5</span> columns]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来的数据分析工作就针对这个top1000数据集了。</p>
<h2 id="分析命名趋势">分析命名趋势</h2>
<p>有了完整的数据集和刚才生成的top1000数据集，我们就可以开始分析各种命名趋势了。首先将前1000个名字分为男女两个部分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">109</span>]: boys = top1000[top1000.sex == <span class="string">&#x27;M&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">110</span>]: girls = top1000[top1000.sex == <span class="string">&#x27;F&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是两个简单的时间序列，只需稍作整理即可绘制出相应的图表（比如每年叫做John和Mary的婴儿数）。我们先生成一张按year和name统计的总出生数透视表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">111</span>]: total_births = top1000.pivot_table(<span class="string">&#x27;births&#x27;</span>, index=<span class="string">&#x27;year&#x27;</span>,</span><br><span class="line">   .....:                                    columns=<span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">   .....:                                    aggfunc=<span class="built_in">sum</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，我们用DataFrame的plot方法绘制几个名字的曲线图（见图14-5）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">112</span>]: total_births.info()</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">Int64Index</span>:</span> <span class="number">131</span> entries, <span class="number">1880</span> to <span class="number">2010</span></span><br><span class="line">Columns: <span class="number">6868</span> entries, Aaden to Zuri</span><br><span class="line">dtypes: float64(<span class="number">6868</span>)</span><br><span class="line">memory usage: <span class="number">6.9</span> MB</span><br><span class="line"></span><br><span class="line">In [<span class="number">113</span>]: subset = total_births[[<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Harry&#x27;</span>, <span class="string">&#x27;Mary&#x27;</span>, <span class="string">&#x27;Marilyn&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: subset.plot(subplots=<span class="literal">True</span>, figsize=(<span class="number">12</span>, <span class="number">10</span>), grid=<span class="literal">False</span>,</span><br><span class="line">   .....:             title=<span class="string">&quot;Number of births per year&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-33f0f97656367a53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图14-5 几个男孩和女孩名字随时间变化的使用数量" /><figcaption aria-hidden="true">图14-5 几个男孩和女孩名字随时间变化的使用数量</figcaption>
</figure>
<p>从图中可以看出，这几个名字在美国人民的心目中已经风光不再了。但事实并非如此简单，我们在下一节中就能知道是怎么一回事了。</p>
<h2 id="评估命名多样性的增长">评估命名多样性的增长</h2>
<p>一种解释是父母愿意给小孩起常见的名字越来越少。这个假设可以从数据中得到验证。一个办法是计算最流行的1000个名字所占的比例，我按year和sex进行聚合并绘图（见图14-6）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">116</span>]: table = top1000.pivot_table(<span class="string">&#x27;prop&#x27;</span>, index=<span class="string">&#x27;year&#x27;</span>,</span><br><span class="line">   .....:                             columns=<span class="string">&#x27;sex&#x27;</span>, aggfunc=<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">117</span>]: table.plot(title=<span class="string">&#x27;Sum of table1000.prop by year and sex&#x27;</span>,</span><br><span class="line">   .....:            yticks=np.linspace(<span class="number">0</span>, <span class="number">1.2</span>, <span class="number">13</span>), xticks=<span class="built_in">range</span>(<span class="number">1880</span>, <span class="number">2020</span>, <span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-63e1ddc326a033b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图14-6 分性别统计的前1000个名字在总出生人数中的比例" /><figcaption aria-hidden="true">图14-6 分性别统计的前1000个名字在总出生人数中的比例</figcaption>
</figure>
<p>从图中可以看出，名字的多样性确实出现了增长（前1000项的比例降低）。另一个办法是计算占总出生人数前50%的不同名字的数量，这个数字不太好计算。我们只考虑2010年男孩的名字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">118</span>]: df = boys[boys.year == <span class="number">2010</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: df</span><br><span class="line">Out[<span class="number">119</span>]: </span><br><span class="line">           name sex  births  year      prop</span><br><span class="line"><span class="number">260877</span>    Jacob   M   <span class="number">21875</span>  <span class="number">2010</span>  <span class="number">0.011523</span></span><br><span class="line"><span class="number">260878</span>    Ethan   M   <span class="number">17866</span>  <span class="number">2010</span>  <span class="number">0.009411</span></span><br><span class="line"><span class="number">260879</span>  Michael   M   <span class="number">17133</span>  <span class="number">2010</span>  <span class="number">0.009025</span></span><br><span class="line"><span class="number">260880</span>   Jayden   M   <span class="number">17030</span>  <span class="number">2010</span>  <span class="number">0.008971</span></span><br><span class="line"><span class="number">260881</span>  William   M   <span class="number">16870</span>  <span class="number">2010</span>  <span class="number">0.008887</span></span><br><span class="line"><span class="meta">... </span>        ...  ..     ...   ...       ...</span><br><span class="line"><span class="number">261872</span>   Camilo   M     <span class="number">194</span>  <span class="number">2010</span>  <span class="number">0.000102</span></span><br><span class="line"><span class="number">261873</span>   Destin   M     <span class="number">194</span>  <span class="number">2010</span>  <span class="number">0.000102</span></span><br><span class="line"><span class="number">261874</span>   Jaquan   M     <span class="number">194</span>  <span class="number">2010</span>  <span class="number">0.000102</span></span><br><span class="line"><span class="number">261875</span>   Jaydan   M     <span class="number">194</span>  <span class="number">2010</span>  <span class="number">0.000102</span></span><br><span class="line"><span class="number">261876</span>   Maxton   M     <span class="number">193</span>  <span class="number">2010</span>  <span class="number">0.000102</span></span><br><span class="line">[<span class="number">1000</span> rows x <span class="number">5</span> columns]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在对prop降序排列之后，我们想知道前面多少个名字的人数加起来才够50%。虽然编写一个for循环确实也能达到目的，但NumPy有一种更聪明的矢量方式。先计算prop的累计和cumsum，然后再通过searchsorted方法找出0.5应该被插入在哪个位置才能保证不破坏顺序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">120</span>]: prop_cumsum = df.sort_values(by=<span class="string">&#x27;prop&#x27;</span>, ascending=<span class="literal">False</span>).prop.cumsum()</span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: prop_cumsum[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line"><span class="number">260877</span>    <span class="number">0.011523</span></span><br><span class="line"><span class="number">260878</span>    <span class="number">0.020934</span></span><br><span class="line"><span class="number">260879</span>    <span class="number">0.029959</span></span><br><span class="line"><span class="number">260880</span>    <span class="number">0.038930</span></span><br><span class="line"><span class="number">260881</span>    <span class="number">0.047817</span></span><br><span class="line"><span class="number">260882</span>    <span class="number">0.056579</span></span><br><span class="line"><span class="number">260883</span>    <span class="number">0.065155</span></span><br><span class="line"><span class="number">260884</span>    <span class="number">0.073414</span></span><br><span class="line"><span class="number">260885</span>    <span class="number">0.081528</span></span><br><span class="line"><span class="number">260886</span>    <span class="number">0.089621</span></span><br><span class="line">Name: prop, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: prop_cumsum.values.searchsorted(<span class="number">0.5</span>)</span><br><span class="line">Out[<span class="number">122</span>]: <span class="number">116</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于数组索引是从0开始的，因此我们要给这个结果加1，即最终结果为117。拿1900年的数据来做个比较，这个数字要小得多：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">123</span>]: df = boys[boys.year == <span class="number">1900</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: in1900 = df.sort_values(by=<span class="string">&#x27;prop&#x27;</span>, ascending=<span class="literal">False</span>).prop.cumsum()</span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: in1900.values.searchsorted(<span class="number">0.5</span>) + <span class="number">1</span></span><br><span class="line">Out[<span class="number">125</span>]: <span class="number">25</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在就可以对所有year/sex组合执行这个计算了。按这两个字段进行groupby处理，然后用一个函数计算各分组的这个值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_quantile_count</span>(<span class="params">group, q=<span class="number">0.5</span></span>):</span></span><br><span class="line">    group = group.sort_values(by=<span class="string">&#x27;prop&#x27;</span>, ascending=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">return</span> group.prop.cumsum().values.searchsorted(q) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">diversity = top1000.groupby([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>]).apply(get_quantile_count)</span><br><span class="line">diversity = diversity.unstack(<span class="string">&#x27;sex&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，diversity这个DataFrame拥有两个时间序列（每个性别各一个，按年度索引）。通过IPython，你可以查看其内容，还可以像之前那样绘制图表（如图14-7所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">128</span>]: diversity.head()</span><br><span class="line">Out[<span class="number">128</span>]: </span><br><span class="line">sex    F   M</span><br><span class="line">year        </span><br><span class="line"><span class="number">1880</span>  <span class="number">38</span>  <span class="number">14</span></span><br><span class="line"><span class="number">1881</span>  <span class="number">38</span>  <span class="number">14</span></span><br><span class="line"><span class="number">1882</span>  <span class="number">38</span>  <span class="number">15</span></span><br><span class="line"><span class="number">1883</span>  <span class="number">39</span>  <span class="number">15</span></span><br><span class="line"><span class="number">1884</span>  <span class="number">39</span>  <span class="number">16</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: diversity.plot(title=<span class="string">&quot;Number of popular names in top 50%&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-574b53a383cad681.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图14-7 按年度统计的密度表" /><figcaption aria-hidden="true">图14-7 按年度统计的密度表</figcaption>
</figure>
<p>从图中可以看出，女孩名字的多样性总是比男孩的高，而且还在变得越来越高。读者们可以自己分析一下具体是什么在驱动这个多样性（比如拼写形式的变化）。</p>
<h2 id="最后一个字母的变革">“最后一个字母”的变革</h2>
<p>2007年，一名婴儿姓名研究人员Laura Wattenberg在她自己的网站上指出（http://www.babynamewizard.com）：近百年来，男孩名字在最后一个字母上的分布发生了显著的变化。为了了解具体的情况，我首先将全部出生数据在年度、性别以及末字母上进行了聚合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># extract last letter from name column</span></span><br><span class="line">get_last_letter = <span class="keyword">lambda</span> x: x[-<span class="number">1</span>]</span><br><span class="line">last_letters = names.name.<span class="built_in">map</span>(get_last_letter)</span><br><span class="line">last_letters.name = <span class="string">&#x27;last_letter&#x27;</span></span><br><span class="line"></span><br><span class="line">table = names.pivot_table(<span class="string">&#x27;births&#x27;</span>, index=last_letters,</span><br><span class="line">                          columns=[<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;year&#x27;</span>], aggfunc=<span class="built_in">sum</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，我选出具有一定代表性的三年，并输出前面几行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">131</span>]: subtable = table.reindex(columns=[<span class="number">1910</span>, <span class="number">1960</span>, <span class="number">2010</span>], level=<span class="string">&#x27;year&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">132</span>]: subtable.head()</span><br><span class="line">Out[<span class="number">132</span>]: </span><br><span class="line">sex                 F                            M                    </span><br><span class="line">year             <span class="number">1910</span>      <span class="number">1960</span>      <span class="number">2010</span>     <span class="number">1910</span>      <span class="number">1960</span>      <span class="number">2010</span></span><br><span class="line">last_letter                                                           </span><br><span class="line">a            <span class="number">108376.0</span>  <span class="number">691247.0</span>  <span class="number">670605.0</span>    <span class="number">977.0</span>    <span class="number">5204.0</span>   <span class="number">28438.0</span></span><br><span class="line">b                 NaN     <span class="number">694.0</span>     <span class="number">450.0</span>    <span class="number">411.0</span>    <span class="number">3912.0</span>   <span class="number">38859.0</span></span><br><span class="line">c                 <span class="number">5.0</span>      <span class="number">49.0</span>     <span class="number">946.0</span>    <span class="number">482.0</span>   <span class="number">15476.0</span>   <span class="number">23125.0</span></span><br><span class="line">d              <span class="number">6750.0</span>    <span class="number">3729.0</span>    <span class="number">2607.0</span>  <span class="number">22111.0</span>  <span class="number">262112.0</span>   <span class="number">44398.0</span></span><br><span class="line">e            <span class="number">133569.0</span>  <span class="number">435013.0</span>  <span class="number">313833.0</span>  <span class="number">28655.0</span>  <span class="number">178823.0</span>  <span class="number">129012.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来我们需要按总出生数对该表进行规范化处理，以便计算出各性别各末字母占总出生人数的比例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">133</span>]: subtable.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">133</span>]: </span><br><span class="line">sex  year</span><br><span class="line">F    <span class="number">1910</span>     <span class="number">396416.0</span></span><br><span class="line">     <span class="number">1960</span>    <span class="number">2022062.0</span></span><br><span class="line">     <span class="number">2010</span>    <span class="number">1759010.0</span></span><br><span class="line">M    <span class="number">1910</span>     <span class="number">194198.0</span></span><br><span class="line">     <span class="number">1960</span>    <span class="number">2132588.0</span></span><br><span class="line"><span class="number">2010</span>    <span class="number">1898382.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">134</span>]: letter_prop = subtable / subtable.<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line">In [<span class="number">135</span>]: letter_prop</span><br><span class="line">Out[<span class="number">135</span>]: </span><br><span class="line">sex                 F                             M                    </span><br><span class="line">year             <span class="number">1910</span>      <span class="number">1960</span>      <span class="number">2010</span>      <span class="number">1910</span>      <span class="number">1960</span>      <span class="number">2010</span></span><br><span class="line">last_letter                                                            </span><br><span class="line">a            <span class="number">0.273390</span>  <span class="number">0.341853</span>  <span class="number">0.381240</span>  <span class="number">0.005031</span>  <span class="number">0.002440</span>  <span class="number">0.014980</span></span><br><span class="line">b                 NaN  <span class="number">0.000343</span>  <span class="number">0.000256</span>  <span class="number">0.002116</span>  <span class="number">0.001834</span>  <span class="number">0.020470</span></span><br><span class="line">c            <span class="number">0.000013</span>  <span class="number">0.000024</span>  <span class="number">0.000538</span>  <span class="number">0.002482</span>  <span class="number">0.007257</span>  <span class="number">0.012181</span></span><br><span class="line">d            <span class="number">0.017028</span>  <span class="number">0.001844</span>  <span class="number">0.001482</span>  <span class="number">0.113858</span>  <span class="number">0.122908</span>  <span class="number">0.023387</span></span><br><span class="line">e            <span class="number">0.336941</span>  <span class="number">0.215133</span>  <span class="number">0.178415</span>  <span class="number">0.147556</span>  <span class="number">0.083853</span>  <span class="number">0.067959</span></span><br><span class="line"><span class="meta">... </span>              ...       ...       ...       ...       ...       ...</span><br><span class="line">v                 NaN  <span class="number">0.000060</span>  <span class="number">0.000117</span>  <span class="number">0.000113</span></span><br><span class="line"><span class="number">0.000037</span>  <span class="number">0.001434</span></span><br><span class="line">w            <span class="number">0.000020</span>  <span class="number">0.000031</span>  <span class="number">0.001182</span>  <span class="number">0.006329</span>  <span class="number">0.007711</span>  <span class="number">0.016148</span></span><br><span class="line">x            <span class="number">0.000015</span>  <span class="number">0.000037</span>  <span class="number">0.000727</span>  <span class="number">0.003965</span>  <span class="number">0.001851</span>  <span class="number">0.008614</span></span><br><span class="line">y            <span class="number">0.110972</span>  <span class="number">0.152569</span>  <span class="number">0.116828</span>  <span class="number">0.077349</span>  <span class="number">0.160987</span>  <span class="number">0.058168</span></span><br><span class="line">z            <span class="number">0.002439</span>  <span class="number">0.000659</span>  <span class="number">0.000704</span>  <span class="number">0.000170</span>  <span class="number">0.000184</span>  <span class="number">0.001831</span></span><br><span class="line">[<span class="number">26</span> rows x <span class="number">6</span> columns]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有了这个字母比例数据之后，就可以生成一张各年度各性别的条形图了，如图14-8所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">1</span>, figsize=(<span class="number">10</span>, <span class="number">8</span>))</span><br><span class="line">letter_prop[<span class="string">&#x27;M&#x27;</span>].plot(kind=<span class="string">&#x27;bar&#x27;</span>, rot=<span class="number">0</span>, ax=axes[<span class="number">0</span>], title=<span class="string">&#x27;Male&#x27;</span>)</span><br><span class="line">letter_prop[<span class="string">&#x27;F&#x27;</span>].plot(kind=<span class="string">&#x27;bar&#x27;</span>, rot=<span class="number">0</span>, ax=axes[<span class="number">1</span>], title=<span class="string">&#x27;Female&#x27;</span>,</span><br><span class="line">                      legend=<span class="literal">False</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-67686f38e66ef5f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图14-8 男孩女孩名字中各个末字母的比例" /><figcaption aria-hidden="true">图14-8 男孩女孩名字中各个末字母的比例</figcaption>
</figure>
<p>可以看出，从20世纪60年代开始，以字母"n"结尾的男孩名字出现了显著的增长。回到之前创建的那个完整表，按年度和性别对其进行规范化处理，并在男孩名字中选取几个字母，最后进行转置以便将各个列做成一个时间序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">138</span>]: letter_prop = table / table.<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line">In [<span class="number">139</span>]: dny_ts = letter_prop.loc[[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;y&#x27;</span>], <span class="string">&#x27;M&#x27;</span>].T</span><br><span class="line"></span><br><span class="line">In [<span class="number">140</span>]: dny_ts.head()</span><br><span class="line">Out[<span class="number">140</span>]: </span><br><span class="line">last_letter         d         n         y</span><br><span class="line">year                                     </span><br><span class="line"><span class="number">1880</span>         <span class="number">0.083055</span>  <span class="number">0.153213</span>  <span class="number">0.075760</span></span><br><span class="line"><span class="number">1881</span>         <span class="number">0.083247</span>  <span class="number">0.153214</span>  <span class="number">0.077451</span></span><br><span class="line"><span class="number">1882</span>         <span class="number">0.085340</span>  <span class="number">0.149560</span>  <span class="number">0.077537</span></span><br><span class="line"><span class="number">1883</span>         <span class="number">0.084066</span>  <span class="number">0.151646</span>  <span class="number">0.079144</span></span><br><span class="line"><span class="number">1884</span>         <span class="number">0.086120</span>  <span class="number">0.149915</span>  <span class="number">0.080405</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有了这个时间序列的DataFrame之后，就可以通过其plot方法绘制出一张趋势图了（如图14-9所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">143</span>]: dny_ts.plot()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-51c431b2490424c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图14-9 各年出生的男孩中名字以d/n/y结尾的人数比例" /><figcaption aria-hidden="true">图14-9 各年出生的男孩中名字以d/n/y结尾的人数比例</figcaption>
</figure>
<h2 id="变成女孩名字的男孩名字以及相反的情况">变成女孩名字的男孩名字（以及相反的情况）</h2>
<p>另一个有趣的趋势是，早年流行于男孩的名字近年来“变性了”，例如Lesley或Leslie。回到top1000数据集，找出其中以"lesl"开头的一组名字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">144</span>]: all_names = pd.Series(top1000.name.unique())</span><br><span class="line"></span><br><span class="line">In [<span class="number">145</span>]: lesley_like = all_names[all_names.<span class="built_in">str</span>.lower().<span class="built_in">str</span>.contains(<span class="string">&#x27;lesl&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">146</span>]: lesley_like</span><br><span class="line">Out[<span class="number">146</span>]: </span><br><span class="line"><span class="number">632</span>     Leslie</span><br><span class="line"><span class="number">2294</span>    Lesley</span><br><span class="line"><span class="number">4262</span>    Leslee</span><br><span class="line"><span class="number">4728</span>     Lesli</span><br><span class="line"><span class="number">6103</span>     Lesly</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后利用这个结果过滤其他的名字，并按名字分组计算出生数以查看相对频率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">147</span>]: filtered = top1000[top1000.name.isin(lesley_like)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">148</span>]: filtered.groupby(<span class="string">&#x27;name&#x27;</span>).births.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">148</span>]: </span><br><span class="line">name</span><br><span class="line">Leslee      <span class="number">1082</span></span><br><span class="line">Lesley     <span class="number">35022</span></span><br><span class="line">Lesli        <span class="number">929</span></span><br><span class="line">Leslie    <span class="number">370429</span></span><br><span class="line">Lesly      <span class="number">10067</span></span><br><span class="line">Name: births, dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来，我们按性别和年度进行聚合，并按年度进行规范化处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">149</span>]: table = filtered.pivot_table(<span class="string">&#x27;births&#x27;</span>, index=<span class="string">&#x27;year&#x27;</span>,</span><br><span class="line">   .....:                              columns=<span class="string">&#x27;sex&#x27;</span>, aggfunc=<span class="string">&#x27;sum&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">150</span>]: table = table.div(table.<span class="built_in">sum</span>(<span class="number">1</span>), axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">151</span>]: table.tail()</span><br><span class="line">Out[<span class="number">151</span>]: </span><br><span class="line">sex     F   M</span><br><span class="line">year         </span><br><span class="line"><span class="number">2006</span>  <span class="number">1.0</span> NaN</span><br><span class="line"><span class="number">2007</span>  <span class="number">1.0</span> NaN</span><br><span class="line"><span class="number">2008</span>  <span class="number">1.0</span> NaN</span><br><span class="line"><span class="number">2009</span>  <span class="number">1.0</span> NaN</span><br><span class="line"><span class="number">2010</span>  <span class="number">1.0</span> NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后，就可以轻松绘制一张分性别的年度曲线图了（如图2-10所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">153</span>]: table.plot(style=&#123;<span class="string">&#x27;M&#x27;</span>: <span class="string">&#x27;k-&#x27;</span>, <span class="string">&#x27;F&#x27;</span>: <span class="string">&#x27;k--&#x27;</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-b99d98f8bb5fc695.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图14-10 各年度使用“Lesley型”名字的男女比例" /><figcaption aria-hidden="true">图14-10 各年度使用“Lesley型”名字的男女比例</figcaption>
</figure>
<h1 id="usda食品数据库">14.4 USDA食品数据库</h1>
<p>美国农业部（USDA）制作了一份有关食物营养信息的数据库。Ashley Williams制作了该数据的JSON版（http://ashleyw.co.uk/project/food-nutrient-database）。其中的记录如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;id&quot;</span>: <span class="number">21441</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;KENTUCKY FRIED CHICKEN, Fried Chicken, EXTRA CRISPY,</span></span><br><span class="line"><span class="string">Wing, meat and skin with breading&quot;</span>,</span><br><span class="line">  <span class="string">&quot;tags&quot;</span>: [<span class="string">&quot;KFC&quot;</span>],</span><br><span class="line">  <span class="string">&quot;manufacturer&quot;</span>: <span class="string">&quot;Kentucky Fried Chicken&quot;</span>,</span><br><span class="line"><span class="string">&quot;group&quot;</span>: <span class="string">&quot;Fast Foods&quot;</span>,</span><br><span class="line">  <span class="string">&quot;portions&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;amount&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;unit&quot;</span>: <span class="string">&quot;wing, with skin&quot;</span>,</span><br><span class="line">      <span class="string">&quot;grams&quot;</span>: <span class="number">68.0</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;nutrients&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;value&quot;</span>: <span class="number">20.8</span>,</span><br><span class="line">      <span class="string">&quot;units&quot;</span>: <span class="string">&quot;g&quot;</span>,</span><br><span class="line">      <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Protein&quot;</span>,</span><br><span class="line">      <span class="string">&quot;group&quot;</span>: <span class="string">&quot;Composition&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每种食物都带有若干标识性属性以及两个有关营养成分和分量的列表。这种形式的数据不是很适合分析工作，因此我们需要做一些规整化以使其具有更好用的形式。</p>
<p>从上面列举的那个网址下载并解压数据之后，你可以用任何喜欢的JSON库将其加载到Python中。我用的是Python内置的json模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">154</span>]: <span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">In [<span class="number">155</span>]: db = json.load(<span class="built_in">open</span>(<span class="string">&#x27;datasets/usda_food/database.json&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">156</span>]: <span class="built_in">len</span>(db)</span><br><span class="line">Out[<span class="number">156</span>]: <span class="number">6636</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>db中的每个条目都是一个含有某种食物全部数据的字典。nutrients字段是一个字典列表，其中的每个字典对应一种营养成分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">157</span>]: db[<span class="number">0</span>].keys()</span><br><span class="line">Out[<span class="number">157</span>]: dict_keys([<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;description&#x27;</span>, <span class="string">&#x27;tags&#x27;</span>, <span class="string">&#x27;manufacturer&#x27;</span>, <span class="string">&#x27;group&#x27;</span>, <span class="string">&#x27;porti</span></span><br><span class="line"><span class="string">ons&#x27;</span>, <span class="string">&#x27;nutrients&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">158</span>]: db[<span class="number">0</span>][<span class="string">&#x27;nutrients&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">158</span>]: </span><br><span class="line">&#123;<span class="string">&#x27;description&#x27;</span>: <span class="string">&#x27;Protein&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;group&#x27;</span>: <span class="string">&#x27;Composition&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;units&#x27;</span>: <span class="string">&#x27;g&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;value&#x27;</span>: <span class="number">25.18</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">159</span>]: nutrients = pd.DataFrame(db[<span class="number">0</span>][<span class="string">&#x27;nutrients&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">160</span>]: nutrients[:<span class="number">7</span>]</span><br><span class="line">Out[<span class="number">160</span>]: </span><br><span class="line">                   description        group units    value</span><br><span class="line"><span class="number">0</span>                      Protein  Composition     g    <span class="number">25.18</span></span><br><span class="line"><span class="number">1</span>            Total lipid (fat)  Composition     g    <span class="number">29.20</span></span><br><span class="line"><span class="number">2</span>  Carbohydrate, by difference  Composition     g     <span class="number">3.06</span></span><br><span class="line"><span class="number">3</span>                          Ash        Other     g     <span class="number">3.28</span></span><br><span class="line"><span class="number">4</span>                       Energy       Energy  kcal   <span class="number">376.00</span></span><br><span class="line"><span class="number">5</span>                        Water  Composition     g    <span class="number">39.28</span></span><br><span class="line"><span class="number">6</span>                       Energy       Energy    kJ  <span class="number">1573.00</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在将字典列表转换为DataFrame时，可以只抽取其中的一部分字段。这里，我们将取出食物的名称、分类、编号以及制造商等信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">161</span>]: info_keys = [<span class="string">&#x27;description&#x27;</span>, <span class="string">&#x27;group&#x27;</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;manufacturer&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">162</span>]: info = pd.DataFrame(db, columns=info_keys)</span><br><span class="line"></span><br><span class="line">In [<span class="number">163</span>]: info[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">163</span>]: </span><br><span class="line">                          description                   group    <span class="built_in">id</span>  \</span><br><span class="line"><span class="number">0</span>                     Cheese, caraway  Dairy <span class="keyword">and</span> Egg Products  <span class="number">1008</span>   </span><br><span class="line"><span class="number">1</span>                     Cheese, cheddar  Dairy <span class="keyword">and</span> Egg Products  <span class="number">1009</span></span><br><span class="line"><span class="number">2</span>                        Cheese, edam  Dairy <span class="keyword">and</span> Egg Products  <span class="number">1018</span>   </span><br><span class="line"><span class="number">3</span>                        Cheese, feta  Dairy <span class="keyword">and</span> Egg Products  <span class="number">1019</span>   </span><br><span class="line"><span class="number">4</span>  Cheese, mozzarella, part skim milk  Dairy <span class="keyword">and</span> Egg Products  <span class="number">1028</span>   </span><br><span class="line">  manufacturer  </span><br><span class="line"><span class="number">0</span>               </span><br><span class="line"><span class="number">1</span>               </span><br><span class="line"><span class="number">2</span>               </span><br><span class="line"><span class="number">3</span>               </span><br><span class="line"><span class="number">4</span>               </span><br><span class="line"></span><br><span class="line">In [<span class="number">164</span>]: info.info()</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">RangeIndex</span>:</span> <span class="number">6636</span> entries, <span class="number">0</span> to <span class="number">6635</span></span><br><span class="line">Data columns (total <span class="number">4</span> columns):</span><br><span class="line">description     <span class="number">6636</span> non-null <span class="built_in">object</span></span><br><span class="line">group           <span class="number">6636</span> non-null <span class="built_in">object</span></span><br><span class="line"><span class="built_in">id</span>              <span class="number">6636</span> non-null int64</span><br><span class="line">manufacturer    <span class="number">5195</span> non-null <span class="built_in">object</span></span><br><span class="line">dtypes: int64(<span class="number">1</span>), <span class="built_in">object</span>(<span class="number">3</span>)</span><br><span class="line">memory usage: <span class="number">207.5</span>+ KB</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过value_counts，你可以查看食物类别的分布情况：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">165</span>]: pd.value_counts(info.group)[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">165</span>]: </span><br><span class="line">Vegetables <span class="keyword">and</span> Vegetable Products    <span class="number">812</span></span><br><span class="line">Beef Products                        <span class="number">618</span></span><br><span class="line">Baked Products                       <span class="number">496</span></span><br><span class="line">Breakfast Cereals                    <span class="number">403</span></span><br><span class="line">Fast Foods                           <span class="number">365</span></span><br><span class="line">Legumes <span class="keyword">and</span> Legume Products          <span class="number">365</span></span><br><span class="line">Lamb, Veal, <span class="keyword">and</span> Game Products        <span class="number">345</span></span><br><span class="line">Sweets                               <span class="number">341</span></span><br><span class="line">Pork Products                        <span class="number">328</span></span><br><span class="line">Fruits <span class="keyword">and</span> Fruit Juices              <span class="number">328</span></span><br><span class="line">Name: group, dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，为了对全部营养数据做一些分析，最简单的办法是将所有食物的营养成分整合到一个大表中。我们分几个步骤来实现该目的。首先，将各食物的营养成分列表转换为一个DataFrame，并添加一个表示编号的列，然后将该DataFrame添加到一个列表中。最后通过concat将这些东西连接起来就可以了：</p>
<p>顺利的话，nutrients的结果是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">167</span>]: nutrients</span><br><span class="line">Out[<span class="number">167</span>]: </span><br><span class="line">                               description        group units    value     <span class="built_in">id</span></span><br><span class="line"><span class="number">0</span>                                  Protein  Composition     g   <span class="number">25.180</span>   <span class="number">1008</span></span><br><span class="line"><span class="number">1</span>                        Total lipid (fat)  Composition     g   <span class="number">29.200</span>   <span class="number">1008</span></span><br><span class="line"><span class="number">2</span>              Carbohydrate, by difference  Composition     g    <span class="number">3.060</span>   <span class="number">1008</span></span><br><span class="line"><span class="number">3</span>                                      Ash        Other     g    <span class="number">3.280</span>   <span class="number">1008</span></span><br><span class="line"><span class="number">4</span>                                   Energy       Energy  kcal  <span class="number">376.000</span>   <span class="number">1008</span></span><br><span class="line"><span class="meta">... </span>                                   ...          ...</span><br><span class="line"><span class="meta">... </span>     ...    ...</span><br><span class="line"><span class="number">389350</span>                 Vitamin B-<span class="number">12</span>, added     Vitamins   mcg    <span class="number">0.000</span>  <span class="number">43546</span></span><br><span class="line"><span class="number">389351</span>                         Cholesterol        Other    mg    <span class="number">0.000</span>  <span class="number">43546</span></span><br><span class="line"><span class="number">389352</span>        Fatty acids, total saturated        Other     g    <span class="number">0.072</span>  <span class="number">43546</span></span><br><span class="line"><span class="number">389353</span>  Fatty acids, total monounsaturated        Other     g    <span class="number">0.028</span>  <span class="number">43546</span></span><br><span class="line"><span class="number">389354</span>  Fatty acids, total polyunsaturated        Other     g    <span class="number">0.041</span>  <span class="number">43546</span></span><br><span class="line">[<span class="number">389355</span> rows x <span class="number">5</span> columns]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我发现这个DataFrame中无论如何都会有一些重复项，所以直接丢弃就可以了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">168</span>]: nutrients.duplicated().<span class="built_in">sum</span>()  <span class="comment"># number of duplicates</span></span><br><span class="line">Out[<span class="number">168</span>]: <span class="number">14179</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">169</span>]: nutrients = nutrients.drop_duplicates()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于两个DataFrame对象中都有"group"和"description"，所以为了明确到底谁是谁，我们需要对它们进行重命名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">170</span>]: col_mapping = &#123;<span class="string">&#x27;description&#x27;</span> : <span class="string">&#x27;food&#x27;</span>,</span><br><span class="line">   .....:                <span class="string">&#x27;group&#x27;</span>       : <span class="string">&#x27;fgroup&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">171</span>]: info = info.rename(columns=col_mapping, copy=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">172</span>]: info.info()</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">RangeIndex</span>:</span> <span class="number">6636</span> entries, <span class="number">0</span> to <span class="number">6635</span></span><br><span class="line">Data columns (total <span class="number">4</span> columns):</span><br><span class="line">food            <span class="number">6636</span> non-null <span class="built_in">object</span></span><br><span class="line">fgroup          <span class="number">6636</span> non-null <span class="built_in">object</span></span><br><span class="line"><span class="built_in">id</span>              <span class="number">6636</span> non-null int64</span><br><span class="line">manufacturer    <span class="number">5195</span> non-null <span class="built_in">object</span></span><br><span class="line">dtypes: int64(<span class="number">1</span>), <span class="built_in">object</span>(<span class="number">3</span>)</span><br><span class="line">memory usage: <span class="number">207.5</span>+ KB</span><br><span class="line"></span><br><span class="line">In [<span class="number">173</span>]: col_mapping = &#123;<span class="string">&#x27;description&#x27;</span> : <span class="string">&#x27;nutrient&#x27;</span>,</span><br><span class="line">   .....:                <span class="string">&#x27;group&#x27;</span> : <span class="string">&#x27;nutgroup&#x27;</span>&#125;</span><br><span class="line">In [<span class="number">174</span>]: nutrients = nutrients.rename(columns=col_mapping, copy=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">175</span>]: nutrients</span><br><span class="line">Out[<span class="number">175</span>]: </span><br><span class="line">                                  nutrient     nutgroup units    value     <span class="built_in">id</span></span><br><span class="line"><span class="number">0</span>                                  Protein  Composition     g   <span class="number">25.180</span>   <span class="number">1008</span></span><br><span class="line"><span class="number">1</span>                        Total lipid (fat)  Composition     g   <span class="number">29.200</span>   <span class="number">1008</span></span><br><span class="line"><span class="number">2</span>              Carbohydrate, by difference  Composition     g    <span class="number">3.060</span>   <span class="number">1008</span></span><br><span class="line"><span class="number">3</span>                                      Ash        Other     g    <span class="number">3.280</span>   <span class="number">1008</span></span><br><span class="line"><span class="number">4</span>                                   Energy       Energy  kcal  <span class="number">376.000</span>   <span class="number">1008</span></span><br><span class="line"><span class="meta">... </span>                                   ...          ...   ...      ...    ...</span><br><span class="line"><span class="number">389350</span>                 Vitamin B-<span class="number">12</span>, added     Vitamins   mcg    <span class="number">0.000</span>  <span class="number">43546</span></span><br><span class="line"><span class="number">389351</span>                         Cholesterol        Other    mg    <span class="number">0.000</span>  <span class="number">43546</span></span><br><span class="line"><span class="number">389352</span>        Fatty acids, total saturated        Other     g    <span class="number">0.072</span>  <span class="number">43546</span></span><br><span class="line"><span class="number">389353</span>  Fatty acids, total monounsaturated        Other     g    <span class="number">0.028</span>  <span class="number">43546</span></span><br><span class="line"><span class="number">389354</span>  Fatty acids, total polyunsaturated        Other     g    <span class="number">0.041</span>  <span class="number">43546</span></span><br><span class="line">[<span class="number">375176</span> rows x <span class="number">5</span> columns]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>做完这些，就可以将info跟nutrients合并起来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">176</span>]: ndata = pd.merge(nutrients, info, on=<span class="string">&#x27;id&#x27;</span>, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">177</span>]: ndata.info()</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">Int64Index</span>:</span> <span class="number">375176</span> entries, <span class="number">0</span> to <span class="number">375175</span></span><br><span class="line">Data columns (total <span class="number">8</span> columns):</span><br><span class="line">nutrient        <span class="number">375176</span> non-null <span class="built_in">object</span></span><br><span class="line">nutgroup        <span class="number">375176</span> non-null <span class="built_in">object</span></span><br><span class="line">units           <span class="number">375176</span> non-null <span class="built_in">object</span></span><br><span class="line">value           <span class="number">375176</span> non-null float64</span><br><span class="line"><span class="built_in">id</span>              <span class="number">375176</span> non-null int64</span><br><span class="line">food            <span class="number">375176</span> non-null <span class="built_in">object</span></span><br><span class="line">fgroup          <span class="number">375176</span> non-null <span class="built_in">object</span></span><br><span class="line">manufacturer    <span class="number">293054</span> non-null <span class="built_in">object</span></span><br><span class="line">dtypes: float64(<span class="number">1</span>), int64(<span class="number">1</span>), <span class="built_in">object</span>(<span class="number">6</span>)</span><br><span class="line">memory usage: <span class="number">25.8</span>+ MB</span><br><span class="line"></span><br><span class="line">In [<span class="number">178</span>]: ndata.iloc[<span class="number">30000</span>]</span><br><span class="line">Out[<span class="number">178</span>]: </span><br><span class="line">nutrient                                       Glycine</span><br><span class="line">nutgroup                                   Amino Acids</span><br><span class="line">units                                                g</span><br><span class="line">value                                             <span class="number">0.04</span></span><br><span class="line"><span class="built_in">id</span>                                                <span class="number">6158</span></span><br><span class="line">food            Soup, tomato bisque, canned, condensed</span><br><span class="line">fgroup                      Soups, Sauces, <span class="keyword">and</span> Gravies</span><br><span class="line">manufacturer                                          </span><br><span class="line">Name: <span class="number">30000</span>, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们现在可以根据食物分类和营养类型画出一张中位值图（如图14-11所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">180</span>]: result = ndata.groupby([<span class="string">&#x27;nutrient&#x27;</span>, <span class="string">&#x27;fgroup&#x27;</span>])[<span class="string">&#x27;value&#x27;</span>].quantile(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">181</span>]: result[<span class="string">&#x27;Zinc, Zn&#x27;</span>].sort_values().plot(kind=<span class="string">&#x27;barh&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-99b176d022a444c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片14-11 根据营养分类得出的锌中位值" /><figcaption aria-hidden="true">图片14-11 根据营养分类得出的锌中位值</figcaption>
</figure>
<p>只要稍微动一动脑子，就可以发现各营养成分最为丰富的食物是什么了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">by_nutrient = ndata.groupby([<span class="string">&#x27;nutgroup&#x27;</span>, <span class="string">&#x27;nutrient&#x27;</span>])</span><br><span class="line"></span><br><span class="line">get_maximum = <span class="keyword">lambda</span> x: x.loc[x.value.idxmax()]</span><br><span class="line">get_minimum = <span class="keyword">lambda</span> x: x.loc[x.value.idxmin()]</span><br><span class="line"></span><br><span class="line">max_foods = by_nutrient.apply(get_maximum)[[<span class="string">&#x27;value&#x27;</span>, <span class="string">&#x27;food&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># make the food a little smaller</span></span><br><span class="line">max_foods.food = max_foods.food.<span class="built_in">str</span>[:<span class="number">50</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于得到的DataFrame很大，所以不方便在书里面全部打印出来。这里只给出"Amino Acids"营养分组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">183</span>]: max_foods.loc[<span class="string">&#x27;Amino Acids&#x27;</span>][<span class="string">&#x27;food&#x27;</span>]</span><br><span class="line">Out[<span class="number">183</span>]: </span><br><span class="line">nutrient</span><br><span class="line">Alanine                          Gelatins, dry powder, unsweetened</span><br><span class="line">Arginine                              Seeds, sesame flour, low-fat</span><br><span class="line">Aspartic acid                                  Soy protein isolate</span><br><span class="line">Cystine               Seeds, cottonseed flour, low fat (glandless)</span><br><span class="line">Glutamic acid                                  Soy protein isolate</span><br><span class="line">                                       ...                        </span><br><span class="line">Serine           Soy protein isolate, PROTEIN TECHNOLOGIES INTE...</span><br><span class="line">Threonine        Soy protein isolate, PROTEIN TECHNOLOGIES INTE...</span><br><span class="line">Tryptophan        Sea lion, Steller, meat <span class="keyword">with</span> fat (Alaska Native)</span><br><span class="line">Tyrosine         Soy protein isolate, PROTEIN TECHNOLOGIES INTE...</span><br><span class="line">Valine           Soy protein isolate, PROTEIN TECHNOLOGIES INTE...</span><br><span class="line">Name: food, Length: <span class="number">19</span>, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="联邦选举委员会数据库">14.5 2012联邦选举委员会数据库</h1>
<p>美国联邦选举委员会发布了有关政治竞选赞助方面的数据。其中包括赞助者的姓名、职业、雇主、地址以及出资额等信息。我们对2012年美国总统大选的数据集比较感兴趣（http://www.fec.gov/disclosurep/PDownload.do）。我在2012年6月下载的数据集是一个150MB的CSV文件（P00000001-ALL.csv），我们先用pandas.read_csv将其加载进来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">184</span>]: fec = pd.read_csv(<span class="string">&#x27;datasets/fec/P00000001-ALL.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">185</span>]: fec.info()</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">RangeIndex</span>:</span> <span class="number">1001731</span> entries, <span class="number">0</span> to <span class="number">1001730</span></span><br><span class="line">Data columns (total <span class="number">16</span> columns):</span><br><span class="line">cmte_id              <span class="number">1001731</span> non-null <span class="built_in">object</span></span><br><span class="line">cand_id              <span class="number">1001731</span> non-null <span class="built_in">object</span></span><br><span class="line">cand_nm              <span class="number">1001731</span> non-null <span class="built_in">object</span></span><br><span class="line">contbr_nm            <span class="number">1001731</span> non-null <span class="built_in">object</span></span><br><span class="line">contbr_city          <span class="number">1001712</span> non-null <span class="built_in">object</span></span><br><span class="line">contbr_st            <span class="number">1001727</span> non-null <span class="built_in">object</span></span><br><span class="line">contbr_zip           <span class="number">1001620</span> non-null <span class="built_in">object</span></span><br><span class="line">contbr_employer      <span class="number">988002</span> non-null <span class="built_in">object</span></span><br><span class="line">contbr_occupation    <span class="number">993301</span> non-null <span class="built_in">object</span></span><br><span class="line">contb_receipt_amt    <span class="number">1001731</span> non-null float64</span><br><span class="line">contb_receipt_dt     <span class="number">1001731</span> non-null <span class="built_in">object</span></span><br><span class="line">receipt_desc         <span class="number">14166</span> non-null <span class="built_in">object</span></span><br><span class="line">memo_cd              <span class="number">92482</span> non-null <span class="built_in">object</span></span><br><span class="line">memo_text            <span class="number">97770</span> non-null <span class="built_in">object</span></span><br><span class="line">form_tp              <span class="number">1001731</span> non-null <span class="built_in">object</span></span><br><span class="line">file_num             <span class="number">1001731</span> non-null int64</span><br><span class="line">dtypes: float64(<span class="number">1</span>), int64(<span class="number">1</span>), <span class="built_in">object</span>(<span class="number">14</span>)</span><br><span class="line">memory usage: <span class="number">122.3</span>+ MB</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该DataFrame中的记录如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">186</span>]: fec.iloc[<span class="number">123456</span>]</span><br><span class="line">Out[<span class="number">186</span>]: </span><br><span class="line">cmte_id             C00431445</span><br><span class="line">cand_id             P80003338</span><br><span class="line">cand_nm         Obama, Barack</span><br><span class="line">contbr_nm         ELLMAN, IRA</span><br><span class="line">contbr_city             TEMPE</span><br><span class="line">                    ...      </span><br><span class="line">receipt_desc              NaN</span><br><span class="line">memo_cd                   NaN</span><br><span class="line">memo_text                 NaN</span><br><span class="line">form_tp                 SA17A</span><br><span class="line">file_num               <span class="number">772372</span></span><br><span class="line">Name: <span class="number">123456</span>, Length: <span class="number">16</span>, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可能已经想出了许多办法从这些竞选赞助数据中抽取有关赞助人和赞助模式的统计信息。我将在接下来的内容中介绍几种不同的分析工作（运用到目前为止已经学到的方法）。</p>
<p>不难看出，该数据中没有党派信息，因此最好把它加进去。通过unique，你可以获取全部的候选人名单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">187</span>]: unique_cands = fec.cand_nm.unique()</span><br><span class="line"></span><br><span class="line">In [<span class="number">188</span>]: unique_cands</span><br><span class="line">Out[<span class="number">188</span>]: </span><br><span class="line">array([<span class="string">&#x27;Bachmann, Michelle&#x27;</span>, <span class="string">&#x27;Romney, Mitt&#x27;</span>, <span class="string">&#x27;Obama, Barack&#x27;</span>,</span><br><span class="line">       <span class="string">&quot;Roemer, Charles E. &#x27;Buddy&#x27; III&quot;</span>, <span class="string">&#x27;Pawlenty, Timothy&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Johnson, Gary Earl&#x27;</span>, <span class="string">&#x27;Paul, Ron&#x27;</span>, <span class="string">&#x27;Santorum, Rick&#x27;</span>, <span class="string">&#x27;Cain, Herman&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Gingrich, Newt&#x27;</span>, <span class="string">&#x27;McCotter, Thaddeus G&#x27;</span>, <span class="string">&#x27;Huntsman, Jon&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Perry, Rick&#x27;</span>], dtype=<span class="built_in">object</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">189</span>]: unique_cands[<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">189</span>]: <span class="string">&#x27;Obama, Barack&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>指明党派信息的方法之一是使用字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parties = &#123;<span class="string">&#x27;Bachmann, Michelle&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Cain, Herman&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Gingrich, Newt&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Huntsman, Jon&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Johnson, Gary Earl&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;McCotter, Thaddeus G&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Obama, Barack&#x27;</span>: <span class="string">&#x27;Democrat&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Paul, Ron&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Pawlenty, Timothy&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Perry, Rick&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&quot;Roemer, Charles E. &#x27;Buddy&#x27; III&quot;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Romney, Mitt&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Santorum, Rick&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，通过这个映射以及Series对象的map方法，你可以根据候选人姓名得到一组党派信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">191</span>]: fec.cand_nm[<span class="number">123456</span>:<span class="number">123461</span>]</span><br><span class="line">Out[<span class="number">191</span>]: </span><br><span class="line"><span class="number">123456</span>    Obama, Barack</span><br><span class="line"><span class="number">123457</span>    Obama, Barack</span><br><span class="line"><span class="number">123458</span>    Obama, Barack</span><br><span class="line"><span class="number">123459</span>    Obama, Barack</span><br><span class="line"><span class="number">123460</span>    Obama, Barack</span><br><span class="line">Name: cand_nm, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">192</span>]: fec.cand_nm[<span class="number">123456</span>:<span class="number">123461</span>].<span class="built_in">map</span>(parties)</span><br><span class="line">Out[<span class="number">192</span>]: </span><br><span class="line"><span class="number">123456</span>    Democrat</span><br><span class="line"><span class="number">123457</span>    Democrat</span><br><span class="line"><span class="number">123458</span>    Democrat</span><br><span class="line"><span class="number">123459</span>    Democrat</span><br><span class="line"><span class="number">123460</span>    Democrat</span><br><span class="line">Name: cand_nm, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add it as a column</span></span><br><span class="line">In [<span class="number">193</span>]: fec[<span class="string">&#x27;party&#x27;</span>] = fec.cand_nm.<span class="built_in">map</span>(parties)</span><br><span class="line"></span><br><span class="line">In [<span class="number">194</span>]: fec[<span class="string">&#x27;party&#x27;</span>].value_counts()</span><br><span class="line">Out[<span class="number">194</span>]: </span><br><span class="line">Democrat      <span class="number">593746</span></span><br><span class="line">Republican    <span class="number">407985</span></span><br><span class="line">Name: party, dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里有两个需要注意的地方。第一，该数据既包括赞助也包括退款（负的出资额）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">195</span>]: (fec.contb_receipt_amt &gt; <span class="number">0</span>).value_counts()</span><br><span class="line">Out[<span class="number">195</span>]: </span><br><span class="line"><span class="literal">True</span>     <span class="number">991475</span></span><br><span class="line"><span class="literal">False</span>     <span class="number">10256</span></span><br><span class="line">Name: contb_receipt_amt, dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了简化分析过程，我限定该数据集只能有正的出资额：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">196</span>]: fec = fec[fec.contb_receipt_amt &gt; <span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于Barack Obama和Mitt Romney是最主要的两名候选人，所以我还专门准备了一个子集，只包含针对他们两人的竞选活动的赞助信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">197</span>]: fec_mrbo = fec[fec.cand_nm.isin([<span class="string">&#x27;Obama, Barack&#x27;</span>,<span class="string">&#x27;Romney, Mitt&#x27;</span>])]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="根据职业和雇主统计赞助信息">根据职业和雇主统计赞助信息</h2>
<p>基于职业的赞助信息统计是另一种经常被研究的统计任务。例如，律师们更倾向于资助民主党，而企业主则更倾向于资助共和党。你可以不相信我，自己看那些数据就知道了。首先，根据职业计算出资总额，这很简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">198</span>]: fec.contbr_occupation.value_counts()[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">198</span>]: </span><br><span class="line">RETIRED                                   <span class="number">233990</span></span><br><span class="line">INFORMATION REQUESTED                      <span class="number">35107</span></span><br><span class="line">ATTORNEY                                   <span class="number">34286</span></span><br><span class="line">HOMEMAKER                                  <span class="number">29931</span></span><br><span class="line">PHYSICIAN                                  <span class="number">23432</span></span><br><span class="line">INFORMATION REQUESTED PER BEST EFFORTS     <span class="number">21138</span></span><br><span class="line">ENGINEER                                   <span class="number">14334</span></span><br><span class="line">TEACHER                                    <span class="number">13990</span></span><br><span class="line">CONSULTANT                                 <span class="number">13273</span></span><br><span class="line">PROFESSOR                                  <span class="number">12555</span></span><br><span class="line">Name: contbr_occupation, dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不难看出，许多职业都涉及相同的基本工作类型，或者同一样东西有多种变体。下面的代码片段可以清理一些这样的数据（将一个职业信息映射到另一个）。注意，这里巧妙地利用了dict.get，它允许没有映射关系的职业也能“通过”：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">occ_mapping = &#123;</span><br><span class="line">   <span class="string">&#x27;INFORMATION REQUESTED PER BEST EFFORTS&#x27;</span> : <span class="string">&#x27;NOT PROVIDED&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;INFORMATION REQUESTED&#x27;</span> : <span class="string">&#x27;NOT PROVIDED&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;INFORMATION REQUESTED (BEST EFFORTS)&#x27;</span> : <span class="string">&#x27;NOT PROVIDED&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;C.E.O.&#x27;</span>: <span class="string">&#x27;CEO&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># If no mapping provided, return x</span></span><br><span class="line">f = <span class="keyword">lambda</span> x: occ_mapping.get(x, x)</span><br><span class="line">fec.contbr_occupation = fec.contbr_occupation.<span class="built_in">map</span>(f)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我对雇主信息也进行了同样的处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">emp_mapping = &#123;</span><br><span class="line">   <span class="string">&#x27;INFORMATION REQUESTED PER BEST EFFORTS&#x27;</span> : <span class="string">&#x27;NOT PROVIDED&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;INFORMATION REQUESTED&#x27;</span> : <span class="string">&#x27;NOT PROVIDED&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;SELF&#x27;</span> : <span class="string">&#x27;SELF-EMPLOYED&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;SELF EMPLOYED&#x27;</span> : <span class="string">&#x27;SELF-EMPLOYED&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># If no mapping provided, return x</span></span><br><span class="line">f = <span class="keyword">lambda</span> x: emp_mapping.get(x, x)</span><br><span class="line">fec.contbr_employer = fec.contbr_employer.<span class="built_in">map</span>(f)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，你可以通过pivot_table根据党派和职业对数据进行聚合，然后过滤掉总出资额不足200万美元的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">201</span>]: by_occupation = fec.pivot_table(<span class="string">&#x27;contb_receipt_amt&#x27;</span>,</span><br><span class="line">   .....:                                 index=<span class="string">&#x27;contbr_occupation&#x27;</span>,</span><br><span class="line">   .....:                                 columns=<span class="string">&#x27;party&#x27;</span>, aggfunc=<span class="string">&#x27;sum&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">202</span>]: over_2mm = by_occupation[by_occupation.<span class="built_in">sum</span>(<span class="number">1</span>) &gt; <span class="number">2000000</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">203</span>]: over_2mm</span><br><span class="line">Out[<span class="number">203</span>]: </span><br><span class="line">party                 Democrat    Republican</span><br><span class="line">contbr_occupation                           </span><br><span class="line">ATTORNEY           <span class="number">11141982.97</span>  <span class="number">7.477194e+06</span></span><br><span class="line">CEO                 <span class="number">2074974.79</span>  <span class="number">4.211041e+06</span></span><br><span class="line">CONSULTANT          <span class="number">2459912.71</span>  <span class="number">2.544725e+06</span></span><br><span class="line">ENGINEER             <span class="number">951525.55</span>  <span class="number">1.818374e+06</span></span><br><span class="line">EXECUTIVE           <span class="number">1355161.05</span>  <span class="number">4.138850e+06</span></span><br><span class="line"><span class="meta">... </span>                       ...           ...</span><br><span class="line">PRESIDENT           <span class="number">1878509.95</span>  <span class="number">4.720924e+06</span></span><br><span class="line">PROFESSOR           <span class="number">2165071.08</span>  <span class="number">2.967027e+05</span></span><br><span class="line">REAL ESTATE          <span class="number">528902.09</span>  <span class="number">1.625902e+06</span></span><br><span class="line">RETIRED            <span class="number">25305116.38</span>  <span class="number">2.356124e+07</span></span><br><span class="line">SELF-EMPLOYED        <span class="number">672393.40</span>  <span class="number">1.640253e+06</span></span><br><span class="line">[<span class="number">17</span> rows x <span class="number">2</span> columns]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>把这些数据做成柱状图看起来会更加清楚（'barh'表示水平柱状图，如图14-12所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">205</span>]: over_2mm.plot(kind=<span class="string">&#x27;barh&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-d2254e547c6ce537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图14-12 对各党派总出资额最高的职业" /><figcaption aria-hidden="true">图14-12 对各党派总出资额最高的职业</figcaption>
</figure>
<p>你可能还想了解一下对Obama和Romney总出资额最高的职业和企业。为此，我们先对候选人进行分组，然后使用本章前面介绍的类似top的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_top_amounts</span>(<span class="params">group, key, n=<span class="number">5</span></span>):</span></span><br><span class="line">    totals = group.groupby(key)[<span class="string">&#x27;contb_receipt_amt&#x27;</span>].<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> totals.nlargest(n)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后根据职业和雇主进行聚合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">207</span>]: grouped = fec_mrbo.groupby(<span class="string">&#x27;cand_nm&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">208</span>]: grouped.apply(get_top_amounts, <span class="string">&#x27;contbr_occupation&#x27;</span>, n=<span class="number">7</span>)</span><br><span class="line">Out[<span class="number">208</span>]: </span><br><span class="line">cand_nm        contbr_occupation    </span><br><span class="line">Obama, Barack  RETIRED                  <span class="number">25305116.38</span></span><br><span class="line">               ATTORNEY                 <span class="number">11141982.97</span></span><br><span class="line">               INFORMATION REQUESTED     <span class="number">4866973.96</span></span><br><span class="line">               HOMEMAKER                 <span class="number">4248875.80</span></span><br><span class="line">               PHYSICIAN                 <span class="number">3735124.94</span></span><br><span class="line">                                           ...     </span><br><span class="line">Romney, Mitt   HOMEMAKER                 <span class="number">8147446.22</span></span><br><span class="line">               ATTORNEY                  <span class="number">5364718.82</span></span><br><span class="line">               PRESIDENT                 <span class="number">2491244.89</span></span><br><span class="line">               EXECUTIVE                 <span class="number">2300947.03</span></span><br><span class="line">               C.E.O.                    <span class="number">1968386.11</span></span><br><span class="line">Name: contb_receipt_amt, Length: <span class="number">14</span>, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">209</span>]: grouped.apply(get_top_amounts, <span class="string">&#x27;contbr_employer&#x27;</span>, n=<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">209</span>]: </span><br><span class="line">cand_nm        contbr_employer      </span><br><span class="line">Obama, Barack  RETIRED                  <span class="number">22694358.85</span></span><br><span class="line">               SELF-EMPLOYED            <span class="number">17080985.96</span></span><br><span class="line">               NOT EMPLOYED              <span class="number">8586308.70</span></span><br><span class="line">               INFORMATION REQUESTED     <span class="number">5053480.37</span></span><br><span class="line">               HOMEMAKER                 <span class="number">2605408.54</span></span><br><span class="line">                                           ...     </span><br><span class="line">Romney, Mitt   CREDIT SUISSE              <span class="number">281150.00</span></span><br><span class="line">               MORGAN STANLEY             <span class="number">267266.00</span></span><br><span class="line">               GOLDMAN SACH &amp; CO.         <span class="number">238250.00</span></span><br><span class="line">               BARCLAYS CAPITAL           <span class="number">162750.00</span></span><br><span class="line">               H.I.G. CAPITAL             <span class="number">139500.00</span></span><br><span class="line">Name: contb_receipt_amt, Length: <span class="number">20</span>, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="对出资额分组">对出资额分组</h2>
<p>还可以对该数据做另一种非常实用的分析：利用cut函数根据出资额的大小将数据离散化到多个面元中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">210</span>]: bins = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">10000</span>,</span><br><span class="line">   .....:                  <span class="number">100000</span>, <span class="number">1000000</span>, <span class="number">10000000</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">211</span>]: labels = pd.cut(fec_mrbo.contb_receipt_amt, bins)</span><br><span class="line"></span><br><span class="line">In [<span class="number">212</span>]: labels</span><br><span class="line">Out[<span class="number">212</span>]: </span><br><span class="line"><span class="number">411</span>         (<span class="number">10</span>, <span class="number">100</span>]</span><br><span class="line"><span class="number">412</span>       (<span class="number">100</span>, <span class="number">1000</span>]</span><br><span class="line"><span class="number">413</span>       (<span class="number">100</span>, <span class="number">1000</span>]</span><br><span class="line"><span class="number">414</span>         (<span class="number">10</span>, <span class="number">100</span>]</span><br><span class="line"><span class="number">415</span>         (<span class="number">10</span>, <span class="number">100</span>]</span><br><span class="line">             ...     </span><br><span class="line"><span class="number">701381</span>      (<span class="number">10</span>, <span class="number">100</span>]</span><br><span class="line"><span class="number">701382</span>    (<span class="number">100</span>, <span class="number">1000</span>]</span><br><span class="line"><span class="number">701383</span>        (<span class="number">1</span>, <span class="number">10</span>]</span><br><span class="line"><span class="number">701384</span>      (<span class="number">10</span>, <span class="number">100</span>]</span><br><span class="line"><span class="number">701385</span>    (<span class="number">100</span>, <span class="number">1000</span>]</span><br><span class="line">Name: contb_receipt_amt, Length: <span class="number">694282</span>, dtype: category</span><br><span class="line">Categories (<span class="number">8</span>, interval[int64]): [(<span class="number">0</span>, <span class="number">1</span>] &lt; (<span class="number">1</span>, <span class="number">10</span>] &lt; (<span class="number">10</span>, <span class="number">100</span>] &lt; (<span class="number">100</span>, <span class="number">1000</span>] &lt; (<span class="number">1</span></span><br><span class="line"><span class="number">000</span>, <span class="number">10000</span>] &lt;</span><br><span class="line">                                  (<span class="number">10000</span>, <span class="number">100000</span>] &lt; (<span class="number">100000</span>, <span class="number">1000000</span>] &lt; (<span class="number">1000000</span>,</span><br><span class="line"> <span class="number">10000000</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在可以根据候选人姓名以及面元标签对奥巴马和罗姆尼数据进行分组，以得到一个柱状图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">213</span>]: grouped = fec_mrbo.groupby([<span class="string">&#x27;cand_nm&#x27;</span>, labels])</span><br><span class="line"></span><br><span class="line">In [<span class="number">214</span>]: grouped.size().unstack(<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">214</span>]: </span><br><span class="line">cand_nm              Obama, Barack  Romney, Mitt</span><br><span class="line">contb_receipt_amt                               </span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>]                       <span class="number">493.0</span>          <span class="number">77.0</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">10</span>]                    <span class="number">40070.0</span>        <span class="number">3681.0</span></span><br><span class="line">(<span class="number">10</span>, <span class="number">100</span>]                 <span class="number">372280.0</span>       <span class="number">31853.0</span></span><br><span class="line">(<span class="number">100</span>, <span class="number">1000</span>]               <span class="number">153991.0</span>       <span class="number">43357.0</span></span><br><span class="line">(<span class="number">1000</span>, <span class="number">10000</span>]              <span class="number">22284.0</span>       <span class="number">26186.0</span></span><br><span class="line">(<span class="number">10000</span>, <span class="number">100000</span>]                <span class="number">2.0</span>           <span class="number">1.0</span></span><br><span class="line">(<span class="number">100000</span>, <span class="number">1000000</span>]              <span class="number">3.0</span>           NaN</span><br><span class="line">(<span class="number">1000000</span>, <span class="number">10000000</span>]            <span class="number">4.0</span>           NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从这个数据中可以看出，在小额赞助方面，Obama获得的数量比Romney多得多。你还可以对出资额求和并在面元内规格化，以便图形化显示两位候选人各种赞助额度的比例（见图14-13）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">216</span>]: bucket_sums = grouped.contb_receipt_amt.<span class="built_in">sum</span>().unstack(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">217</span>]: normed_sums = bucket_sums.div(bucket_sums.<span class="built_in">sum</span>(axis=<span class="number">1</span>), axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">218</span>]: normed_sums</span><br><span class="line">Out[<span class="number">218</span>]: </span><br><span class="line">cand_nm              Obama, Barack  Romney, Mitt</span><br><span class="line">contb_receipt_amt                               </span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>]                    <span class="number">0.805182</span>      <span class="number">0.194818</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">10</span>]                   <span class="number">0.918767</span>      <span class="number">0.081233</span></span><br><span class="line">(<span class="number">10</span>, <span class="number">100</span>]                 <span class="number">0.910769</span>      <span class="number">0.089231</span></span><br><span class="line">(<span class="number">100</span>, <span class="number">1000</span>]               <span class="number">0.710176</span>      <span class="number">0.289824</span></span><br><span class="line">(<span class="number">1000</span>, <span class="number">10000</span>]             <span class="number">0.447326</span>      <span class="number">0.552674</span></span><br><span class="line">(<span class="number">10000</span>, <span class="number">100000</span>]           <span class="number">0.823120</span>      <span class="number">0.176880</span></span><br><span class="line">(<span class="number">100000</span>, <span class="number">1000000</span>]         <span class="number">1.000000</span>           NaN</span><br><span class="line">(<span class="number">1000000</span>, <span class="number">10000000</span>]       <span class="number">1.000000</span>           NaN</span><br><span class="line"></span><br><span class="line">In [<span class="number">219</span>]: normed_sums[:-<span class="number">2</span>].plot(kind=<span class="string">&#x27;barh&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-77e8c8d3c784692b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图14-13 两位候选人收到的各种捐赠额度的总额比例" /><figcaption aria-hidden="true">图14-13 两位候选人收到的各种捐赠额度的总额比例</figcaption>
</figure>
<p>我排除了两个最大的面元，因为这些不是由个人捐赠的。</p>
<p>还可以对该分析过程做许多的提炼和改进。比如说，可以根据赞助人的姓名和邮编对数据进行聚合，以便找出哪些人进行了多次小额捐款，哪些人又进行了一次或多次大额捐款。我强烈建议你下载这些数据并自己摸索一下。</p>
<h2 id="根据州统计赞助信息">根据州统计赞助信息</h2>
<p>根据候选人和州对数据进行聚合是常规操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">220</span>]: grouped = fec_mrbo.groupby([<span class="string">&#x27;cand_nm&#x27;</span>, <span class="string">&#x27;contbr_st&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">221</span>]: totals = grouped.contb_receipt_amt.<span class="built_in">sum</span>().unstack(<span class="number">0</span>).fillna(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">222</span>]: totals = totals[totals.<span class="built_in">sum</span>(<span class="number">1</span>) &gt; <span class="number">100000</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">223</span>]: totals[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">223</span>]: </span><br><span class="line">cand_nm    Obama, Barack  Romney, Mitt</span><br><span class="line">contbr_st                             </span><br><span class="line">AK             <span class="number">281840.15</span>      <span class="number">86204.24</span></span><br><span class="line">AL             <span class="number">543123.48</span>     <span class="number">527303.51</span></span><br><span class="line">AR             <span class="number">359247.28</span>     <span class="number">105556.00</span></span><br><span class="line">AZ            <span class="number">1506476.98</span>    <span class="number">1888436.23</span></span><br><span class="line">CA           <span class="number">23824984.24</span>   <span class="number">11237636.60</span></span><br><span class="line">CO            <span class="number">2132429.49</span>    <span class="number">1506714.12</span></span><br><span class="line">CT            <span class="number">2068291.26</span>    <span class="number">3499475.45</span></span><br><span class="line">DC            <span class="number">4373538.80</span>    <span class="number">1025137.50</span></span><br><span class="line">DE             <span class="number">336669.14</span>      <span class="number">82712.00</span></span><br><span class="line">FL            <span class="number">7318178.58</span>    <span class="number">8338458.81</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果对各行除以总赞助额，就会得到各候选人在各州的总赞助额比例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">224</span>]: percent = totals.div(totals.<span class="built_in">sum</span>(<span class="number">1</span>), axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">225</span>]: percent[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">225</span>]: </span><br><span class="line">cand_nm    Obama, Barack  Romney, Mitt</span><br><span class="line">contbr_st                             </span><br><span class="line">AK              <span class="number">0.765778</span>      <span class="number">0.234222</span></span><br><span class="line">AL              <span class="number">0.507390</span>      <span class="number">0.492610</span></span><br><span class="line">AR              <span class="number">0.772902</span>      <span class="number">0.227098</span></span><br><span class="line">AZ              <span class="number">0.443745</span>      <span class="number">0.556255</span></span><br><span class="line">CA              <span class="number">0.679498</span>      <span class="number">0.320502</span></span><br><span class="line">CO              <span class="number">0.585970</span>      <span class="number">0.414030</span></span><br><span class="line">CT              <span class="number">0.371476</span>      <span class="number">0.628524</span></span><br><span class="line">DC              <span class="number">0.810113</span>      <span class="number">0.189887</span></span><br><span class="line">DE              <span class="number">0.802776</span>      <span class="number">0.197224</span></span><br><span class="line">FL              <span class="number">0.467417</span>      <span class="number">0.532583</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="总结">14.6 总结</h1>
<p>我们已经完成了正文的最后一章。附录中有一些额外的内容，可能对你有用。</p>
<p>本书第一版出版已经有5年了，Python已经成为了一个流行的、广泛使用的数据分析语言。你从本书中学到的方法，在相当长的一段时间都是可用的。我希望本书介绍的工具和库对你的工作有用。</p>
]]></content>
      <categories>
        <category>Python 数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>附录B 更多关于IPython的内容（完）</title>
    <url>/2019/04/09/%E9%99%84%E5%BD%95B-%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8EIPython%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%88%E5%AE%8C%EF%BC%89/</url>
    <content><![CDATA[<p>第2章中，我们学习了IPython shell和Jupyter notebook的基础。本章中，我们会探索IPython更深层次的功能，可以从控制台或在jupyter使用。<span id="more"></span></p>
<h1 id="b.1-使用命令历史">B.1 使用命令历史</h1>
<p>Ipython维护了一个位于磁盘的小型数据库，用于保存执行的每条指令。它的用途有：</p>
<ul>
<li>只用最少的输入，就能搜索、补全和执行先前运行过的指令；</li>
<li>在不同session间保存命令历史；</li>
<li>将日志输入/输出历史到一个文件</li>
</ul>
<p>这些功能在shell中，要比notebook更为有用，因为notebook从设计上是将输入和输出的代码放到每个代码格子中。</p>
<h2 id="搜索和重复使用命令历史">搜索和重复使用命令历史</h2>
<p>Ipython可以让你搜索和执行之前的代码或其他命令。这个功能非常有用，因为你可能需要重复执行同样的命令，例如%run命令，或其它代码。假设你必须要执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In[<span class="number">7</span>]: %run first/second/third/data_script.py</span><br></pre></td></tr></table></figure>
<p>运行成功，然后检查结果，发现计算有错。解决完问题，然后修改了data_script.py，你就可以输入一些%run命令，然后按Ctrl+P或上箭头。这样就可以搜索历史命令，匹配输入字符的命令。多次按Ctrl+P或上箭头，会继续搜索命令。如果你要执行你想要执行的命令，不要害怕。你可以按下Ctrl-N或下箭头，向前移动历史命令。这样做了几次后，你可以不假思索地按下这些键！</p>
<p>Ctrl-R可以带来如同Unix风格shell（比如bash shell）的readline的部分增量搜索功能。在Windows上，readline功能是被IPython模仿的。要使用这个功能，先按Ctrl-R，然后输入一些包含于输入行的想要搜索的字符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: a_command = foo(x, y, z)</span><br><span class="line"></span><br><span class="line">(reverse-i-search)`com<span class="string">&#x27;: a_command = foo(x, y, z)</span></span><br></pre></td></tr></table></figure>
<p>Ctrl-R会循环历史，找到匹配字符的每一行。</p>
<h2 id="输入和输出变量">输入和输出变量</h2>
<p>忘记将函数调用的结果分配给变量是非常烦人的。IPython的一个session会在一个特殊变量，存储输入和输出Python对象的引用。前面两个输出会分别存储在 _（一个下划线）和 __（两个下划线）变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: <span class="number">2</span> ** <span class="number">27</span></span><br><span class="line">Out[<span class="number">24</span>]: <span class="number">134217728</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: _</span><br><span class="line">Out[<span class="number">25</span>]: <span class="number">134217728</span></span><br></pre></td></tr></table></figure>
<p>输入变量是存储在名字类似_iX的变量中，X是输入行的编号。对于每个输入变量，都有一个对应的输出变量_X。因此在输入第27行之后，会有两个新变量_27 （输出）和_i27（输入）:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">26</span>]: foo = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: foo</span><br><span class="line">Out[<span class="number">27</span>]: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: _i27</span><br><span class="line">Out[<span class="number">28</span>]: <span class="string">u&#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: _27</span><br><span class="line">Out[<span class="number">29</span>]: <span class="string">&#x27;bar&#x27;</span></span><br></pre></td></tr></table></figure>
<p>因为输入变量是字符串，它们可以用Python的exec关键字再次执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">30</span>]: <span class="built_in">exec</span>(_i27)</span><br></pre></td></tr></table></figure>
<p>这里，_i27是在In [27]输入的代码。</p>
<p>有几个魔术函数可以让你利用输入和输出历史。%hist可以打印所有或部分的输入历史，加上或不加上编号。%reset可以清理交互命名空间，或输入和输出缓存。%xdel魔术函数可以去除IPython中对一个特别对象的所有引用。对于关于这些魔术方法的更多内容，请查看文档。</p>
<blockquote>
<p>警告：当处理非常大的数据集时，要记住IPython的输入和输出的历史会造成被引用的对象不被垃圾回收（释放内存），即使你使用del关键字从交互命名空间删除变量。在这种情况下，小心使用xdel %和%reset可以帮助你避免陷入内存问题。</p>
</blockquote>
<h1 id="b.2-与操作系统交互">B.2 与操作系统交互</h1>
<p>IPython的另一个功能是无缝连接文件系统和操作系统。这意味着，在同时做其它事时，无需退出IPython，就可以像Windows或Unix使用命令行操作，包括shell命令、更改目录、用Python对象（列表或字符串）存储结果。它还有简单的命令别名和目录书签功能。</p>
<p>表B-1总结了调用shell命令的魔术函数和语法。我会在下面几节介绍这些功能。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-4da7ee14be2da211.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表B-1 IPython系统相关命令" /><figcaption aria-hidden="true">表B-1 IPython系统相关命令</figcaption>
</figure>
<h2 id="shell命令和别名">Shell命令和别名</h2>
<p>用叹号开始一行，是告诉IPython执行叹号后面的所有内容。这意味着你可以删除文件（取决于操作系统，用rm或del）、改变目录或执行任何其他命令。</p>
<p>通过给变量加上叹号，你可以在一个变量中存储命令的控制台输出。例如，在我联网的基于Linux的主机上，我可以获得IP地址为Python变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: ip_info = !ifconfig wlan0 | grep <span class="string">&quot;inet &quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: ip_info[<span class="number">0</span>].strip()</span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">&#x27;inet addr:10.0.0.11  Bcast:10.0.0.255  Mask:255.255.255.0&#x27;</span></span><br></pre></td></tr></table></figure>
<p>返回的Python对象ip_info实际上是一个自定义的列表类型，它包含着多种版本的控制台输出。</p>
<p>当使用！，IPython还可以替换定义在当前环境的Python值。要这么做，可以在变量名前面加上$符号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">3</span>]: foo = <span class="string">&#x27;test*&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: !ls $foo</span><br><span class="line">test4.py  test.py  test.xml</span><br></pre></td></tr></table></figure>
<p>%alias魔术函数可以自定义shell命令的快捷方式。看一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: %alias ll ls -l</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: ll /usr</span><br><span class="line">total <span class="number">332</span></span><br><span class="line">drwxr-xr-x   <span class="number">2</span> root root  <span class="number">69632</span> <span class="number">2012</span>-01-<span class="number">29</span> <span class="number">20</span>:<span class="number">36</span> <span class="built_in">bin</span>/</span><br><span class="line">drwxr-xr-x   <span class="number">2</span> root root   <span class="number">4096</span> <span class="number">2010</span>-08-<span class="number">23</span> <span class="number">12</span>:05 games/</span><br><span class="line">drwxr-xr-x <span class="number">123</span> root root  <span class="number">20480</span> <span class="number">2011</span>-<span class="number">12</span>-<span class="number">26</span> <span class="number">18</span>:08 include/</span><br><span class="line">drwxr-xr-x <span class="number">265</span> root root <span class="number">126976</span> <span class="number">2012</span>-01-<span class="number">29</span> <span class="number">20</span>:<span class="number">36</span> lib/</span><br><span class="line">drwxr-xr-x  <span class="number">44</span> root root  <span class="number">69632</span> <span class="number">2011</span>-<span class="number">12</span>-<span class="number">26</span> <span class="number">18</span>:08 lib32/</span><br><span class="line">lrwxrwxrwx   <span class="number">1</span> root root      <span class="number">3</span> <span class="number">2010</span>-08-<span class="number">23</span> <span class="number">16</span>:02 lib64 -&gt; lib/</span><br><span class="line">drwxr-xr-x  <span class="number">15</span> root root   <span class="number">4096</span> <span class="number">2011</span>-<span class="number">10</span>-<span class="number">13</span> <span class="number">19</span>:03 local/</span><br><span class="line">drwxr-xr-x   <span class="number">2</span> root root  <span class="number">12288</span> <span class="number">2012</span>-01-<span class="number">12</span> 09:<span class="number">32</span> sbin/</span><br><span class="line">drwxr-xr-x <span class="number">387</span> root root  <span class="number">12288</span> <span class="number">2011</span>-<span class="number">11</span>-04 <span class="number">22</span>:<span class="number">53</span> share/</span><br><span class="line">drwxrwsr-x  <span class="number">24</span> root src    <span class="number">4096</span> <span class="number">2011</span>-07-<span class="number">17</span> <span class="number">18</span>:<span class="number">38</span> src/</span><br></pre></td></tr></table></figure>
<p>你可以执行多个命令，就像在命令行中一样，只需用分号隔开：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">558</span>]: %alias test_alias (cd examples; ls; cd ..)</span><br><span class="line"></span><br><span class="line">In [<span class="number">559</span>]: test_alias</span><br><span class="line">macrodata.csv  spx.csv	tips.csv</span><br></pre></td></tr></table></figure>
<p>当session结束，你定义的别名就会失效。要创建恒久的别名，需要使用配置。</p>
<h2 id="目录书签系统">目录书签系统</h2>
<p>IPython有一个简单的目录书签系统，可以让你保存常用目录的别名，这样在跳来跳去的时候会非常方便。例如，假设你想创建一个书签，指向本书的补充内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">6</span>]: %bookmark py4da /home/wesm/code/pydata-book</span><br></pre></td></tr></table></figure>
<p>这么做之后，当使用%cd魔术命令，就可以使用定义的书签：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">7</span>]: cd py4da</span><br><span class="line">(bookmark:py4da) -&gt; /home/wesm/code/pydata-book</span><br><span class="line">/home/wesm/code/pydata-book</span><br></pre></td></tr></table></figure>
<p>如果书签的名字，与当前工作目录的一个目录重名，你可以使用-b标志来覆写，使用书签的位置。使用%bookmark的-l选项，可以列出所有的书签：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">8</span>]: %bookmark -l</span><br><span class="line">Current bookmarks:</span><br><span class="line">py4da -&gt; /home/wesm/code/pydata-book-source</span><br></pre></td></tr></table></figure>
<p>书签，和别名不同，在session之间是保持的。</p>
<h1 id="b.3-软件开发工具">B.3 软件开发工具</h1>
<p>除了作为优秀的交互式计算和数据探索环境，IPython也是有效的Python软件开发工具。在数据分析中，最重要的是要有正确的代码。幸运的是，IPython紧密集成了和加强了Python内置的pdb调试器。第二，需要快速的代码。对于这点，IPython有易于使用的代码计时和分析工具。我会详细介绍这些工具。</p>
<h2 id="交互调试器">交互调试器</h2>
<p>IPython的调试器用tab补全、语法增强、逐行异常追踪增强了pdb。调试代码的最佳时间就是刚刚发生错误。异常发生之后就输入%debug，就启动了调试器，进入抛出异常的堆栈框架：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">2</span>]: run examples/ipython_bug.py</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AssertionError                            Traceback (most recent call last)</span><br><span class="line">/home/wesm/code/pydata-book/examples/ipython_bug.py <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">     <span class="number">13</span>     throws_an_exception()</span><br><span class="line">     <span class="number">14</span></span><br><span class="line">---&gt; <span class="number">15</span> calling_things()</span><br><span class="line"></span><br><span class="line">/home/wesm/code/pydata-book/examples/ipython_bug.py <span class="keyword">in</span> calling_things()</span><br><span class="line"><span class="number">11</span> <span class="function"><span class="keyword">def</span> <span class="title">calling_things</span>():</span></span><br><span class="line">     <span class="number">12</span>     works_fine()</span><br><span class="line">---&gt; <span class="number">13</span>     throws_an_exception()</span><br><span class="line">     <span class="number">14</span></span><br><span class="line">     <span class="number">15</span> calling_things()</span><br><span class="line"></span><br><span class="line">/home/wesm/code/pydata-book/examples/ipython_bug.py <span class="keyword">in</span> throws_an_exception()</span><br><span class="line">      <span class="number">7</span>     a = <span class="number">5</span></span><br><span class="line">      <span class="number">8</span>     b = <span class="number">6</span></span><br><span class="line">----&gt; <span class="number">9</span>     <span class="keyword">assert</span>(a + b == <span class="number">10</span>)</span><br><span class="line">     <span class="number">10</span></span><br><span class="line">     <span class="number">11</span> <span class="function"><span class="keyword">def</span> <span class="title">calling_things</span>():</span></span><br><span class="line"></span><br><span class="line">AssertionError:</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: %debug</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="number">9</span>)throws_an_exception()</span><br><span class="line">      <span class="number">8</span>     b = <span class="number">6</span></span><br><span class="line">----&gt; <span class="number">9</span>     <span class="keyword">assert</span>(a + b == <span class="number">10</span>)</span><br><span class="line">     <span class="number">10</span></span><br><span class="line"></span><br><span class="line">ipdb&gt;</span><br></pre></td></tr></table></figure>
<p>一旦进入调试器，你就可以执行任意的Python代码，在每个堆栈框架中检查所有的对象和数据（解释器会保持它们活跃）。默认是从错误发生的最低级开始。通过u（up）和d（down），你可以在不同等级的堆栈踪迹切换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ipdb&gt; u</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="number">13</span>)calling_things()</span><br><span class="line">     <span class="number">12</span>     works_fine()</span><br><span class="line">---&gt; <span class="number">13</span>     throws_an_exception()</span><br><span class="line">     <span class="number">14</span></span><br></pre></td></tr></table></figure>
<p>执行%pdb命令，可以在发生任何异常时让IPython自动启动调试器，许多用户会发现这个功能非常好用。</p>
<p>用调试器帮助开发代码也很容易，特别是当你希望设置断点或在函数和脚本间移动，以检查每个阶段的状态。有多种方法可以实现。第一种是使用%run和-d，它会在执行传入脚本的任何代码之前调用调试器。你必须马上按s（step）以进入脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">5</span>]: run -d examples/ipython_bug.py</span><br><span class="line">Breakpoint <span class="number">1</span> at /home/wesm/code/pydata-book/examples/ipython_bug.py:<span class="number">1</span></span><br><span class="line">NOTE: Enter <span class="string">&#x27;c&#x27;</span> at the ipdb&gt;  prompt to start your script.</span><br><span class="line">&gt; &lt;string&gt;(<span class="number">1</span>)&lt;module&gt;()</span><br><span class="line"></span><br><span class="line">ipdb&gt; s</span><br><span class="line">--Call--</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="number">1</span>)&lt;module&gt;()</span><br><span class="line"><span class="number">1</span>---&gt; <span class="number">1</span> <span class="function"><span class="keyword">def</span> <span class="title">works_fine</span>():</span></span><br><span class="line">      <span class="number">2</span>     a = <span class="number">5</span></span><br><span class="line">      <span class="number">3</span>     b = <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>然后，你就可以决定如何工作。例如，在前面的异常，我们可以设置一个断点，就在调用works_fine之前，然后运行脚本，在遇到断点时按c（continue）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ipdb&gt; b <span class="number">12</span></span><br><span class="line">ipdb&gt; c</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="number">12</span>)calling_things()</span><br><span class="line">     <span class="number">11</span> <span class="function"><span class="keyword">def</span> <span class="title">calling_things</span>():</span></span><br><span class="line"><span class="number">2</span>--&gt; <span class="number">12</span>     works_fine()</span><br><span class="line">     <span class="number">13</span>     throws_an_exception()</span><br></pre></td></tr></table></figure>
<p>这时，你可以step进入works_fine()，或通过按n（next）执行works_fine()，进入下一行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ipdb&gt; n</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="number">13</span>)calling_things()</span><br><span class="line"><span class="number">2</span>    <span class="number">12</span>     works_fine()</span><br><span class="line">---&gt; <span class="number">13</span>     throws_an_exception()</span><br><span class="line">     <span class="number">14</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，我们可以进入throws_an_exception，到达发生错误的一行，查看变量。注意，调试器的命令是在变量名之前，在变量名前面加叹号！可以查看内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ipdb&gt; s</span><br><span class="line">--Call--</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="number">6</span>)throws_an_exception()</span><br><span class="line">      <span class="number">5</span></span><br><span class="line">----&gt; <span class="number">6</span> <span class="function"><span class="keyword">def</span> <span class="title">throws_an_exception</span>():</span></span><br><span class="line">      <span class="number">7</span>     a = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">ipdb&gt; n</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="number">7</span>)throws_an_exception()</span><br><span class="line">      <span class="number">6</span> <span class="function"><span class="keyword">def</span> <span class="title">throws_an_exception</span>():</span></span><br><span class="line">----&gt; <span class="number">7</span>     a = <span class="number">5</span></span><br><span class="line">      <span class="number">8</span>     b = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">ipdb&gt; n</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="number">8</span>)throws_an_exception()</span><br><span class="line">      <span class="number">7</span>     a = <span class="number">5</span></span><br><span class="line">----&gt; <span class="number">8</span>     b = <span class="number">6</span></span><br><span class="line">      <span class="number">9</span>     <span class="keyword">assert</span>(a + b == <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">ipdb&gt; n</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="number">9</span>)throws_an_exception()</span><br><span class="line">      <span class="number">8</span>     b = <span class="number">6</span></span><br><span class="line">----&gt; <span class="number">9</span>     <span class="keyword">assert</span>(a + b == <span class="number">10</span>)</span><br><span class="line">     <span class="number">10</span></span><br><span class="line"></span><br><span class="line">ipdb&gt; !a</span><br><span class="line"><span class="number">5</span></span><br><span class="line">ipdb&gt; !b</span><br><span class="line"><span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>提高使用交互式调试器的熟练度需要练习和经验。表B-2，列出了所有调试器命令。如果你习惯了IDE，你可能觉得终端的调试器在一开始会不顺手，但会觉得越来越好用。一些Python的IDEs有很好的GUI调试器，选择顺手的就好。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-90a4b17e20b5b03a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表B-2 IPython调试器命令" /><figcaption aria-hidden="true">表B-2 IPython调试器命令</figcaption>
</figure>
<h2 id="使用调试器的其它方式">使用调试器的其它方式</h2>
<p>还有一些其它工作可以用到调试器。第一个是使用特殊的set_trace函数（根据pdb.set_trace命名的），这是一个简装的断点。还有两种方法是你可能想用的（像我一样，将其添加到IPython的配置）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.debugger <span class="keyword">import</span> Pdb</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_trace</span>():</span></span><br><span class="line">    Pdb(color_scheme=<span class="string">&#x27;Linux&#x27;</span>).set_trace(sys._getframe().f_back)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">f, *args, **kwargs</span>):</span></span><br><span class="line">    pdb = Pdb(color_scheme=<span class="string">&#x27;Linux&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> pdb.runcall(f, *args, **kwargs)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第一个函数set_trace非常简单。如果你想暂时停下来进行仔细检查（比如发生异常之前），可以在代码的任何位置使用set_trace：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">7</span>]: run examples/ipython_bug.py</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="number">16</span>)calling_things()</span><br><span class="line">     <span class="number">15</span>     set_trace()</span><br><span class="line">---&gt; <span class="number">16</span>     throws_an_exception()</span><br><span class="line">     <span class="number">17</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>按c（continue）可以让代码继续正常行进。</p>
<p>我们刚看的debug函数，可以让你方便的在调用任何函数时使用调试器。假设我们写了一个下面的函数，想逐步分析它的逻辑：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x, y, z=<span class="number">1</span></span>):</span></span><br><span class="line">    tmp = x + y</span><br><span class="line">    <span class="keyword">return</span> tmp / z</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>普通地使用f，就会像f(1, 2, z=3)。而要想进入f，将f作为第一个参数传递给debug，再将位置和关键词参数传递给f：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">6</span>]: debug(f, <span class="number">1</span>, <span class="number">2</span>, z=<span class="number">3</span>)</span><br><span class="line">&gt; &lt;ipython-<span class="built_in">input</span>&gt;(<span class="number">2</span>)f()</span><br><span class="line">      <span class="number">1</span> <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x, y, z</span>):</span></span><br><span class="line">----&gt; <span class="number">2</span>     tmp = x + y</span><br><span class="line">      <span class="number">3</span>     <span class="keyword">return</span> tmp / z</span><br><span class="line"></span><br><span class="line">ipdb&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这两个简单方法节省了我平时的大量时间。</p>
<p>最后，调试器可以和%run一起使用。脚本通过运行%run -d，就可以直接进入调试器，随意设置断点并启动脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: %run -d examples/ipython_bug.py</span><br><span class="line">Breakpoint <span class="number">1</span> at /home/wesm/code/pydata-book/examples/ipython_bug.py:<span class="number">1</span></span><br><span class="line">NOTE: Enter <span class="string">&#x27;c&#x27;</span> at the ipdb&gt;  prompt to start your script.</span><br><span class="line">&gt; &lt;string&gt;(<span class="number">1</span>)&lt;module&gt;()</span><br><span class="line"></span><br><span class="line">ipdb&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>加上-b和行号，可以预设一个断点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">2</span>]: %run -d -b2 examples/ipython_bug.py</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span> at /home/wesm/code/pydata-book/examples/ipython_bug.py:<span class="number">2</span></span><br><span class="line">NOTE: Enter <span class="string">&#x27;c&#x27;</span> at the ipdb&gt;  prompt to start your script.</span><br><span class="line">&gt; &lt;string&gt;(<span class="number">1</span>)&lt;module&gt;()</span><br><span class="line"></span><br><span class="line">ipdb&gt; c</span><br><span class="line">&gt; /home/wesm/code/pydata-book/examples/ipython_bug.py(<span class="number">2</span>)works_fine()</span><br><span class="line">      <span class="number">1</span> <span class="function"><span class="keyword">def</span> <span class="title">works_fine</span>():</span></span><br><span class="line"><span class="number">1</span>---&gt; <span class="number">2</span>     a = <span class="number">5</span></span><br><span class="line">      <span class="number">3</span>     b = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">ipdb&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="代码计时time-和-timeit">代码计时：%time 和 %timeit</h2>
<p>对于大型和长时间运行的数据分析应用，你可能希望测量不同组件或单独函数调用语句的执行时间。你可能想知道哪个函数占用的时间最长。幸运的是，IPython可以让你开发和测试代码时，很容易地获得这些信息。</p>
<p>手动用time模块和它的函数time.clock和time.time给代码计时，既单调又重复，因为必须要写一些无趣的模板化代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iterations):</span><br><span class="line">    <span class="comment"># some code to run here</span></span><br><span class="line">elapsed_per = (time.time() - start) / iterations</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为这是一个很普通的操作，IPython有两个魔术函数，%time和%timeit，可以自动化这个过程。</p>
<p>%time会运行一次语句，报告总共的执行时间。假设我们有一个大的字符串列表，我们想比较不同的可以挑选出特定开头字符串的方法。这里有一个含有600000字符串的列表，和两个方法，用以选出foo开头的字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a very large list of strings</span></span><br><span class="line">strings = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foobar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;Guido Van Rossum&#x27;</span>] * <span class="number">100000</span></span><br><span class="line"></span><br><span class="line">method1 = [x <span class="keyword">for</span> x <span class="keyword">in</span> strings <span class="keyword">if</span> x.startswith(<span class="string">&#x27;foo&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">method2 = [x <span class="keyword">for</span> x <span class="keyword">in</span> strings <span class="keyword">if</span> x[:<span class="number">3</span>] == <span class="string">&#x27;foo&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看起来它们的性能应该是同级别的，但事实呢？用%time进行一下测量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">561</span>]: %time method1 = [x <span class="keyword">for</span> x <span class="keyword">in</span> strings <span class="keyword">if</span> x.startswith(<span class="string">&#x27;foo&#x27;</span>)]</span><br><span class="line">CPU times: user <span class="number">0.19</span> s, sys: <span class="number">0.00</span> s, total: <span class="number">0.19</span> s</span><br><span class="line">Wall time: <span class="number">0.19</span> s</span><br><span class="line"></span><br><span class="line">In [<span class="number">562</span>]: %time method2 = [x <span class="keyword">for</span> x <span class="keyword">in</span> strings <span class="keyword">if</span> x[:<span class="number">3</span>] == <span class="string">&#x27;foo&#x27;</span>]</span><br><span class="line">CPU times: user <span class="number">0.09</span> s, sys: <span class="number">0.00</span> s, total: <span class="number">0.09</span> s</span><br><span class="line">Wall time: <span class="number">0.09</span> s</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Wall time（wall-clock time的简写）是主要关注的。第一个方法是第二个方法的两倍多，但是这种测量方法并不准确。如果用%time多次测量，你就会发现结果是变化的。要想更准确，可以使用%timeit魔术函数。给出任意一条语句，它能多次运行这条语句以得到一个更为准确的时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">563</span>]: %timeit [x <span class="keyword">for</span> x <span class="keyword">in</span> strings <span class="keyword">if</span> x.startswith(<span class="string">&#x27;foo&#x27;</span>)]</span><br><span class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">159</span> ms per loop</span><br><span class="line"></span><br><span class="line">In [<span class="number">564</span>]: %timeit [x <span class="keyword">for</span> x <span class="keyword">in</span> strings <span class="keyword">if</span> x[:<span class="number">3</span>] == <span class="string">&#x27;foo&#x27;</span>]</span><br><span class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">59.3</span> ms per loop</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个例子说明了解Python标准库、NumPy、pandas和其它库的性能是很有价值的。在大型数据分析中，这些毫秒的时间就会累积起来！</p>
<p>%timeit特别适合分析执行时间短的语句和函数，即使是微秒或纳秒。这些时间可能看起来毫不重要，但是一个20微秒的函数执行1百万次就比一个5微秒的函数长15秒。在上一个例子中，我们可以直接比较两个字符串操作，以了解它们的性能特点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">565</span>]: x = <span class="string">&#x27;foobar&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">566</span>]: y = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">567</span>]: %timeit x.startswith(y)</span><br><span class="line"><span class="number">1000000</span> loops, best of <span class="number">3</span>: <span class="number">267</span> ns per loop</span><br><span class="line"></span><br><span class="line">In [<span class="number">568</span>]: %timeit x[:<span class="number">3</span>] == y</span><br><span class="line"><span class="number">10000000</span> loops, best of <span class="number">3</span>: <span class="number">147</span> ns per loop</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="基础分析prun和run--p">基础分析：%prun和%run -p</h2>
<p>分析代码与代码计时关系很紧密，除了它关注的是“时间花在了哪里”。Python主要的分析工具是cProfile模块，它并不局限于IPython。cProfile会执行一个程序或任意的代码块，并会跟踪每个函数执行的时间。</p>
<p>使用cProfile的通常方式是在命令行中运行一整段程序，输出每个函数的累积时间。假设我们有一个简单的在循环中进行线型代数运算的脚本（计算一系列的100×100矩阵的最大绝对特征值）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> eigvals</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_experiment</span>(<span class="params">niter=<span class="number">100</span></span>):</span></span><br><span class="line">    K = <span class="number">100</span></span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(niter):</span><br><span class="line">        mat = np.random.randn(K, K)</span><br><span class="line">        max_eigenvalue = np.<span class="built_in">abs</span>(eigvals(mat)).<span class="built_in">max</span>()</span><br><span class="line">        results.append(max_eigenvalue)</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">some_results = run_experiment()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Largest one we saw: %s&#x27;</span> % np.<span class="built_in">max</span>(some_results)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可以用cProfile运行这个脚本，使用下面的命令行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m cProfile cprof_example.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行之后，你会发现输出是按函数名排序的。这样要看出谁耗费的时间多有点困难，最好用-s指定排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python -m cProfile -s cumulative cprof_example.py</span><br><span class="line">Largest one we saw: <span class="number">11.923204422</span></span><br><span class="line">    <span class="number">15116</span> function calls (<span class="number">14927</span> primitive calls) <span class="keyword">in</span> <span class="number">0.720</span> seconds</span><br><span class="line"></span><br><span class="line">Ordered by: cumulative time</span><br><span class="line"></span><br><span class="line">ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">     <span class="number">1</span>    <span class="number">0.001</span>    <span class="number">0.001</span>    <span class="number">0.721</span>    <span class="number">0.721</span> cprof_example.py:<span class="number">1</span>(&lt;module&gt;)</span><br><span class="line">   <span class="number">100</span>    <span class="number">0.003</span>    <span class="number">0.000</span>    <span class="number">0.586</span>    <span class="number">0.006</span> linalg.py:<span class="number">702</span>(eigvals)</span><br><span class="line">   <span class="number">200</span>    <span class="number">0.572</span>    <span class="number">0.003</span>    <span class="number">0.572</span>    <span class="number">0.003</span> &#123;numpy.linalg.lapack_lite.dgeev&#125;</span><br><span class="line">     <span class="number">1</span>    <span class="number">0.002</span>    <span class="number">0.002</span>    <span class="number">0.075</span>    <span class="number">0.075</span> __init__.py:<span class="number">106</span>(&lt;module&gt;)</span><br><span class="line">   <span class="number">100</span>    <span class="number">0.059</span>    <span class="number">0.001</span>    <span class="number">0.059</span>    <span class="number">0.001</span> &#123;method <span class="string">&#x27;randn&#x27;</span>)</span><br><span class="line">     <span class="number">1</span>    <span class="number">0.000</span>    <span class="number">0.000</span>    <span class="number">0.044</span>    <span class="number">0.044</span> add_newdocs.py:<span class="number">9</span>(&lt;module&gt;)</span><br><span class="line">     <span class="number">2</span>    <span class="number">0.001</span>    <span class="number">0.001</span>    <span class="number">0.037</span>    <span class="number">0.019</span> __init__.py:<span class="number">1</span>(&lt;module&gt;)</span><br><span class="line">     <span class="number">2</span>    <span class="number">0.003</span>    <span class="number">0.002</span>    <span class="number">0.030</span>    <span class="number">0.015</span> __init__.py:<span class="number">2</span>(&lt;module&gt;)</span><br><span class="line">     <span class="number">1</span>    <span class="number">0.000</span>    <span class="number">0.000</span>    <span class="number">0.030</span>    <span class="number">0.030</span> type_check.py:<span class="number">3</span>(&lt;module&gt;)</span><br><span class="line">     <span class="number">1</span>    <span class="number">0.001</span>    <span class="number">0.001</span>    <span class="number">0.021</span>    <span class="number">0.021</span> __init__.py:<span class="number">15</span>(&lt;module&gt;)</span><br><span class="line">     <span class="number">1</span>    <span class="number">0.013</span>    <span class="number">0.013</span>    <span class="number">0.013</span>    <span class="number">0.013</span> numeric.py:<span class="number">1</span>(&lt;module&gt;)</span><br><span class="line">     <span class="number">1</span>    <span class="number">0.000</span>    <span class="number">0.000</span>    <span class="number">0.009</span>    <span class="number">0.009</span> __init__.py:<span class="number">6</span>(&lt;module&gt;)</span><br><span class="line">     <span class="number">1</span>    <span class="number">0.001</span>    <span class="number">0.001</span>    <span class="number">0.008</span>    <span class="number">0.008</span> __init__.py:<span class="number">45</span>(&lt;module&gt;)</span><br><span class="line">   <span class="number">262</span>    <span class="number">0.005</span>    <span class="number">0.000</span>    <span class="number">0.007</span>    <span class="number">0.000</span> function_base.py:<span class="number">3178</span>(add_newdoc)</span><br><span class="line">   <span class="number">100</span>    <span class="number">0.003</span>    <span class="number">0.000</span>    <span class="number">0.005</span>    <span class="number">0.000</span> linalg.py:<span class="number">162</span>(_assertFinite)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>只显示出前15行。扫描cumtime列，可以容易地看出每个函数用了多少时间。如果一个函数调用了其它函数，计时并不会停止。cProfile会记录每个函数的起始和结束时间，使用它们进行计时。</p>
<p>除了在命令行中使用，cProfile也可以在程序中使用，分析任意代码块，而不必运行新进程。Ipython的%prun和%run -p，有便捷的接口实现这个功能。%prun使用类似cProfile的命令行选项，但是可以分析任意Python语句，而不用整个py文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">4</span>]: %prun -l <span class="number">7</span> -s cumulative run_experiment()</span><br><span class="line">         <span class="number">4203</span> function calls <span class="keyword">in</span> <span class="number">0.643</span> seconds</span><br><span class="line"></span><br><span class="line">Ordered by: cumulative time</span><br><span class="line"><span class="type">List</span> reduced <span class="keyword">from</span> <span class="number">32</span> to <span class="number">7</span> due to restriction &lt;<span class="number">7</span>&gt;</span><br><span class="line">ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">     <span class="number">1</span>    <span class="number">0.000</span>    <span class="number">0.000</span>    <span class="number">0.643</span>    <span class="number">0.643</span> &lt;string&gt;:<span class="number">1</span>(&lt;module&gt;)</span><br><span class="line">     <span class="number">1</span>    <span class="number">0.001</span>    <span class="number">0.001</span>    <span class="number">0.643</span>    <span class="number">0.643</span> cprof_example.py:<span class="number">4</span>(run_experiment)</span><br><span class="line">   <span class="number">100</span>    <span class="number">0.003</span>    <span class="number">0.000</span>    <span class="number">0.583</span>    <span class="number">0.006</span> linalg.py:<span class="number">702</span>(eigvals)</span><br><span class="line">   <span class="number">200</span>    <span class="number">0.569</span>    <span class="number">0.003</span>    <span class="number">0.569</span>    <span class="number">0.003</span> &#123;numpy.linalg.lapack_lite.dgeev&#125;</span><br><span class="line">   <span class="number">100</span>    <span class="number">0.058</span>    <span class="number">0.001</span>    <span class="number">0.058</span>    <span class="number">0.001</span> &#123;method <span class="string">&#x27;randn&#x27;</span>&#125;</span><br><span class="line">   <span class="number">100</span>    <span class="number">0.003</span>    <span class="number">0.000</span>    <span class="number">0.005</span>    <span class="number">0.000</span> linalg.py:<span class="number">162</span>(_assertFinite)</span><br><span class="line">   <span class="number">200</span>    <span class="number">0.002</span>    <span class="number">0.000</span>    <span class="number">0.002</span>    <span class="number">0.000</span> &#123;method <span class="string">&#x27;all&#x27;</span> of <span class="string">&#x27;numpy.ndarray&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>相似的，调用<code>%run -p -s cumulative cprof_example.py</code>有和命令行相似的作用，只是你不用离开Ipython。</p>
<p>在Jupyter notebook中，你可以使用%%prun魔术方法（两个%）来分析一整段代码。这会弹出一个带有分析输出的独立窗口。便于快速回答一些问题，比如“为什么这段代码用了这么长时间”？</p>
<p>使用IPython或Jupyter，还有一些其它工具可以让分析工作更便于理解。其中之一是SnakeViz（https://github.com/jiffyclub/snakeviz/），它会使用d3.js产生一个分析结果的交互可视化界面。</p>
<h2 id="逐行分析函数">逐行分析函数</h2>
<p>有些情况下，用%prun（或其它基于cProfile的分析方法）得到的信息，不能获得函数执行时间的整个过程，或者结果过于复杂，加上函数名，很难进行解读。对于这种情况，有一个小库叫做line_profiler（可以通过PyPI或包管理工具获得）。它包含IPython插件，可以启用一个新的魔术函数%lprun，可以对一个函数或多个函数进行逐行分析。你可以通过修改IPython配置（查看IPython文档或本章后面的配置小节）加入下面这行，启用这个插件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># A list of dotted module names of IPython extensions to load.</span></span><br><span class="line">c.TerminalIPythonApp.extensions = [<span class="string">&#x27;line_profiler&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你还可以运行命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%load_ext line_profiler</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>line_profiler也可以在程序中使用（查看完整文档），但是在IPython中使用是最为强大的。假设你有一个带有下面代码的模块prof_mod，做一些NumPy数组操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_and_sum</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    added = x + y</span><br><span class="line">    summed = added.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> summed</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_function</span>():</span></span><br><span class="line">    x = randn(<span class="number">1000</span>, <span class="number">1000</span>)</span><br><span class="line">    y = randn(<span class="number">1000</span>, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> add_and_sum(x, y)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果想了解add_and_sum函数的性能，%prun可以给出下面内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">569</span>]: %run prof_mod</span><br><span class="line"></span><br><span class="line">In [<span class="number">570</span>]: x = randn(<span class="number">3000</span>, <span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">571</span>]: y = randn(<span class="number">3000</span>, <span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">572</span>]: %prun add_and_sum(x, y)</span><br><span class="line">         <span class="number">4</span> function calls <span class="keyword">in</span> <span class="number">0.049</span> seconds</span><br><span class="line">   Ordered by: internal time</span><br><span class="line">   ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">        <span class="number">1</span>    <span class="number">0.036</span>    <span class="number">0.036</span>    <span class="number">0.046</span>    <span class="number">0.046</span> prof_mod.py:<span class="number">3</span>(add_and_sum)</span><br><span class="line">        <span class="number">1</span>    <span class="number">0.009</span>    <span class="number">0.009</span>    <span class="number">0.009</span>    <span class="number">0.009</span> &#123;method <span class="string">&#x27;sum&#x27;</span> of <span class="string">&#x27;numpy.ndarray&#x27;</span>&#125;</span><br><span class="line">        <span class="number">1</span>    <span class="number">0.003</span>    <span class="number">0.003</span>    <span class="number">0.049</span>    <span class="number">0.049</span> &lt;string&gt;:<span class="number">1</span>(&lt;module&gt;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的做法启发性不大。激活了IPython插件line_profiler，新的命令%lprun就能用了。使用中的不同点是，我们必须告诉%lprun要分析的函数是哪个。语法是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%lprun -f func1 -f func2 statement_to_profile</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们想分析add_and_sum，运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">573</span>]: %lprun -f add_and_sum add_and_sum(x, y)</span><br><span class="line">Timer unit: <span class="number">1e-06</span> s</span><br><span class="line">File: prof_mod.py</span><br><span class="line">Function: add_and_sum at line <span class="number">3</span></span><br><span class="line">Total time: <span class="number">0.045936</span> s</span><br><span class="line">Line <span class="comment">#      Hits         Time  Per Hit   % Time  Line Contents</span></span><br><span class="line">==============================================================</span><br><span class="line">     <span class="number">3</span>                                           <span class="function"><span class="keyword">def</span> <span class="title">add_and_sum</span>(<span class="params">x, y</span>):</span></span><br><span class="line">     <span class="number">4</span>         <span class="number">1</span>        <span class="number">36510</span>  <span class="number">36510.0</span>     <span class="number">79.5</span>      added = x + y</span><br><span class="line">     <span class="number">5</span>         <span class="number">1</span>         <span class="number">9425</span>   <span class="number">9425.0</span>     <span class="number">20.5</span>      summed = added.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">     <span class="number">6</span>         <span class="number">1</span>            <span class="number">1</span>      <span class="number">1.0</span>      <span class="number">0.0</span>      <span class="keyword">return</span> summed</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样就容易诠释了。我们分析了和代码语句中一样的函数。看之前的模块代码，我们可以调用call_function并对它和add_and_sum进行分析，得到一个完整的代码性能概括：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">574</span>]: %lprun -f add_and_sum -f call_function call_function()</span><br><span class="line">Timer unit: <span class="number">1e-06</span> s</span><br><span class="line">File: prof_mod.py</span><br><span class="line">Function: add_and_sum at line <span class="number">3</span></span><br><span class="line">Total time: <span class="number">0.005526</span> s</span><br><span class="line">Line <span class="comment">#      Hits         Time  Per Hit   % Time  Line Contents</span></span><br><span class="line">==============================================================</span><br><span class="line">     <span class="number">3</span>                                           <span class="function"><span class="keyword">def</span> <span class="title">add_and_sum</span>(<span class="params">x, y</span>):</span></span><br><span class="line">     <span class="number">4</span>         <span class="number">1</span>         <span class="number">4375</span>   <span class="number">4375.0</span>     <span class="number">79.2</span>      added = x + y</span><br><span class="line">     <span class="number">5</span>         <span class="number">1</span>         <span class="number">1149</span>   <span class="number">1149.0</span>     <span class="number">20.8</span>      summed = added.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">     <span class="number">6</span>         <span class="number">1</span>            <span class="number">2</span>      <span class="number">2.0</span>      <span class="number">0.0</span>      <span class="keyword">return</span> summed</span><br><span class="line">File: prof_mod.py</span><br><span class="line">Function: call_function at line <span class="number">8</span></span><br><span class="line">Total time: <span class="number">0.121016</span> s</span><br><span class="line">Line <span class="comment">#      Hits         Time  Per Hit   % Time  Line Contents</span></span><br><span class="line">==============================================================</span><br><span class="line">     <span class="number">8</span>                                           <span class="function"><span class="keyword">def</span> <span class="title">call_function</span>():</span></span><br><span class="line">     <span class="number">9</span>         <span class="number">1</span>        <span class="number">57169</span>  <span class="number">57169.0</span>     <span class="number">47.2</span>      x = randn(<span class="number">1000</span>, <span class="number">1000</span>)</span><br><span class="line">    <span class="number">10</span>         <span class="number">1</span>        <span class="number">58304</span>  <span class="number">58304.0</span>     <span class="number">48.2</span>      y = randn(<span class="number">1000</span>, <span class="number">1000</span>)</span><br><span class="line">    <span class="number">11</span>         <span class="number">1</span>         <span class="number">5543</span>   <span class="number">5543.0</span>      <span class="number">4.6</span>      <span class="keyword">return</span> add_and_sum(x, y)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我的经验是用%prun (cProfile)进行宏观分析，%lprun (line_profiler)做微观分析。最好对这两个工具都了解清楚。</p>
<blockquote>
<p>笔记：使用%lprun必须要指明函数名的原因是追踪每行的执行时间的损耗过多。追踪无用的函数会显著地改变结果。</p>
</blockquote>
<h1 id="b.4-使用ipython高效开发的技巧">B.4 使用IPython高效开发的技巧</h1>
<p>方便快捷地写代码、调试和使用是每个人的目标。除了代码风格，流程细节（比如代码重载）也需要一些调整。</p>
<p>因此，这一节的内容更像是门艺术而不是科学，还需要你不断的试验，以达成高效。最终，你要能结构优化代码，并且能省时省力地检查程序或函数的结果。我发现用IPython设计的软件比起命令行，要更适合工作。尤其是当发生错误时，你需要检查自己或别人写的数月或数年前写的代码的错误。</p>
<h2 id="重载模块依赖">重载模块依赖</h2>
<p>在Python中，当你输入import some_lib，some_lib中的代码就会被执行，所有的变量、函数和定义的引入，就会被存入到新创建的some_lib模块命名空间。当下一次输入some_lib，就会得到一个已存在的模块命名空间的引用。潜在的问题是当你%run一个脚本，它依赖于另一个模块，而这个模块做过修改，就会产生问题。假设我在test_script.py中有如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> some_lib</span><br><span class="line"></span><br><span class="line">x = <span class="number">5</span></span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">result = some_lib.get_answer(x, y)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你运行过了%run test_script.py，然后修改了some_lib.py，下一次再执行%run test_script.py，还会得到旧版本的some_lib.py，这是因为Python模块系统的“一次加载”机制。这一点区分了Python和其它数据分析环境，比如MATLAB，它会自动传播代码修改。解决这个问题，有多种方法。第一种是在标准库importlib模块中使用reload函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> some_lib</span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"></span><br><span class="line">importlib.reload(some_lib)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这可以保证每次运行test_script.py时可以加载最新的some_lib.py。很明显，如果依赖更深，在各处都使用reload是非常麻烦的。对于这个问题，IPython有一个特殊的dreload函数（它不是魔术函数）重载深层的模块。如果我运行过some_lib.py，然后输入dreload(some_lib)，就会尝试重载some_lib和它的依赖。不过，这个方法不适用于所有场景，但比重启IPython强多了。</p>
<h2 id="代码设计技巧">代码设计技巧</h2>
<p>对于这单，没有简单的对策，但是有一些原则，是我在工作中发现很好用的。</p>
<h2 id="保持相关对象和数据活跃">保持相关对象和数据活跃</h2>
<p>为命令行写一个下面示例中的程序是很少见的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> my_functions <span class="keyword">import</span> g</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> g(x + y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    x = <span class="number">6</span></span><br><span class="line">    y = <span class="number">7.5</span></span><br><span class="line">    result = x + y</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在IPython中运行这个程序会发生问题，你发现是什么了吗？运行之后，任何定义在main函数中的结果和对象都不能在IPython中被访问到。更好的方法是将main中的代码直接在模块的命名空间中执行（或者在<code>__name__ == '__main__':</code>中，如果你想让这个模块可以被引用）。这样，当你%rundiamante，就可以查看所有定义在main中的变量。这等价于在Jupyter notebook的代码格中定义一个顶级变量。</p>
<h2 id="扁平优于嵌套">扁平优于嵌套</h2>
<p>深层嵌套的代码总让我联想到洋葱皮。当测试或调试一个函数时，你需要剥多少层洋葱皮才能到达目标代码呢？“扁平优于嵌套”是Python之禅的一部分，它也适用于交互式代码开发。尽量将函数和类去耦合和模块化，有利于测试（如果你是在写单元测试）、调试和交互式使用。</p>
<h2 id="克服对大文件的恐惧">克服对大文件的恐惧</h2>
<p>如果你之前是写JAVA（或者其它类似的语言），你可能被告知要让文件简短。在多数语言中，这都是合理的建议：太长会让人感觉是坏代码，意味着重构和重组是必要的。但是，在用IPython开发时，运行10个相关联的小文件（小于100行），比起两个或三个长文件，会让你更头疼。更少的文件意味着重载更少的模块和更少的编辑时在文件中跳转。我发现维护大模块，每个模块都是紧密组织的，会更实用和Pythonic。经过方案迭代，有时会将大文件分解成小文件。</p>
<p>我不建议极端化这条建议，那样会形成一个单独的超大文件。找到一个合理和直观的大型代码模块库和封装结构往往需要一点工作，但这在团队工作中非常重要。每个模块都应该结构紧密，并且应该能直观地找到负责每个功能领域功能和类。</p>
<h1 id="b.5-ipython高级功能">B.5 IPython高级功能</h1>
<p>要全面地使用IPython系统需要用另一种稍微不同的方式写代码，或深入IPython的配置。</p>
<h2 id="让类是对ipython友好的">让类是对IPython友好的</h2>
<p>IPython会尽可能地在控制台美化展示每个字符串。对于许多对象，比如字典、列表和元组，内置的pprint模块可以用来美化格式。但是，在用户定义的类中，你必自己生成字符串。假设有一个下面的简单的类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, msg</span>):</span></span><br><span class="line">        self.msg = msg</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果这么写，就会发现默认的输出不够美观：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">576</span>]: x = Message(<span class="string">&#x27;I have a secret&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">577</span>]: x</span><br><span class="line">Out[<span class="number">577</span>]: &lt;__main__.Message instance at <span class="number">0x60ebbd8</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>IPython会接收__repr__魔术方法返回的字符串（通过output = repr(obj)），并在控制台打印出来。因此，我们可以添加一个简单的__repr__方法到前面的类中，以得到一个更有用的输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, msg</span>):</span></span><br><span class="line">        self.msg = msg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Message: %s&#x27;</span> % self.msg</span><br><span class="line">In [<span class="number">579</span>]: x = Message(<span class="string">&#x27;I have a secret&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">580</span>]: x</span><br><span class="line">Out[<span class="number">580</span>]: Message: I have a secret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="文件和配置">文件和配置</h2>
<p>通过扩展配置系统，大多数IPython和Jupyter notebook的外观（颜色、提示符、行间距等等）和动作都是可以配置的。通过配置，你可以做到：</p>
<ul>
<li>改变颜色主题</li>
<li>改变输入和输出提示符，或删除输出之后、输入之前的空行</li>
<li>执行任意Python语句（例如，引入总是要使用的代码或者每次加载IPython都要运行的内容）</li>
<li>启用IPython总是要运行的插件，比如line_profiler中的%lprun魔术函数</li>
<li>启用Jupyter插件</li>
<li>定义自己的魔术函数或系统别名</li>
</ul>
<p>IPython的配置存储在特殊的ipython_config.py文件中，它通常是在用户home目录的.ipython/文件夹中。配置是通过一个特殊文件。当你启动IPython，就会默认加载这个存储在profile_default文件夹中的默认文件。因此，在我的Linux系统，完整的IPython配置文件路径是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/home/wesm/.ipython/profile_default/ipython_config.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要启动这个文件，运行下面的命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ipython profile create</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个文件中的内容留给读者自己探索。这个文件有注释，解释了每个配置选项的作用。另一点，可以有多个配置文件。假设你想要另一个IPython配置文件，专门是为另一个应用或项目的。创建一个新的配置文件很简单，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ipython profile create secret_project</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>做完之后，在新创建的profile_secret_project目录便捷配置文件，然后如下启动IPython：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ ipython --profile=secret_project</span><br><span class="line">Python <span class="number">3.5</span><span class="number">.1</span> | packaged by conda-forge | (default, May <span class="number">20</span> <span class="number">2016</span>, 05:<span class="number">22</span>:<span class="number">56</span>)</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">IPython <span class="number">5.1</span><span class="number">.0</span> -- An enhanced Interactive Python.</span><br><span class="line">?         -&gt; Introduction <span class="keyword">and</span> overview of IPython<span class="string">&#x27;s features.</span></span><br><span class="line"><span class="string">%quickref -&gt; Quick reference.</span></span><br><span class="line"><span class="string">help      -&gt; Python&#x27;</span>s own <span class="built_in">help</span> system.</span><br><span class="line"><span class="built_in">object</span>?   -&gt; Details about <span class="string">&#x27;object&#x27;</span>, use <span class="string">&#x27;object??&#x27;</span> <span class="keyword">for</span> extra details.</span><br><span class="line"></span><br><span class="line">IPython profile: secret_project</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>和之前一样，IPython的文档是一个极好的学习配置文件的资源。</p>
<p>配置Jupyter有些不同，因为你可以使用除了Python的其它语言。要创建一个类似的Jupyter配置文件，运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样会在home目录的.jupyter/jupyter_notebook_config.py创建配置文件。编辑完之后，可以将它重命名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ mv ~/.jupyter/jupyter_notebook_config.py ~/.jupyter/my_custom_config.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打开Jupyter之后，你可以添加--config参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">jupyter notebook --config=~/.jupyter/my_custom_config.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="b.6-总结">B.6 总结</h1>
<p>学习过本书中的代码案例，你的Python技能得到了一定的提升，我建议你持续学习IPython和Jupyter。因为这两个项目的设计初衷就是提高生产率的，你可能还会发现一些工具，可以让你更便捷地使用Python和计算库。</p>
<p>你可以在nbviewer（https://nbviewer.jupyter.org/）上找到更多有趣的Jupyter notebooks。</p>
]]></content>
      <categories>
        <category>Python 数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
</search>
