<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;ly1998117.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:true,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;&#x2F;search.xml&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:false}}</script>
<meta name="description" content="Early detection of lung cancer">
<meta property="og:type" content="article">
<meta property="og:title" content="Deep Learning with PyTorch -- Part 2 Learning from images (C9-C10)">
<meta property="og:url" content="https://ly1998117.github.io/2021/08/13/DetectCancer/index.html">
<meta property="og:site_name" content="LiuYang&#39;s Blog">
<meta property="og:description" content="Early detection of lung cancer">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ly1998117.github.io/2021/08/13/DetectCancer/1.png">
<meta property="og:image" content="https://ly1998117.github.io/2021/08/13/DetectCancer/2.png">
<meta property="og:image" content="https://ly1998117.github.io/2021/08/13/DetectCancer/3.png">
<meta property="og:image" content="https://ly1998117.github.io/2021/08/13/DetectCancer/4.png">
<meta property="og:image" content="https://ly1998117.github.io/2021/08/13/DetectCancer/5.png">
<meta property="og:image" content="https://ly1998117.github.io/2021/08/13/DetectCancer/6.png">
<meta property="og:image" content="https://ly1998117.github.io/2021/08/13/DetectCancer/7.png">
<meta property="og:image" content="https://ly1998117.github.io/2021/08/13/DetectCancer/8.png">
<meta property="og:image" content="https://ly1998117.github.io/2021/08/13/DetectCancer/9.png">
<meta property="og:image" content="https://ly1998117.github.io/2021/08/13/DetectCancer/10.png">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/ecfb5f44205930f7a33a9c240f41eb94051f3f01">
<meta property="og:image" content="https://ly1998117.github.io/2021/08/13/DetectCancer/11.png">
<meta property="og:image" content="https://ly1998117.github.io/2021/08/13/DetectCancer/12.png">
<meta property="og:image" content="https://ly1998117.github.io/2021/08/13/DetectCancer/13.png">
<meta property="og:image" content="https://ly1998117.github.io/2021/08/13/DetectCancer/14.png">
<meta property="og:image" content="https://ly1998117.github.io/2021/08/13/DetectCancer/15.png">
<meta property="og:image" content="https://ly1998117.github.io/2021/08/13/DetectCancer/16.png">
<meta property="article:published_time" content="2021-08-13T09:27:12.000Z">
<meta property="article:modified_time" content="2021-08-23T14:44:20.297Z">
<meta property="article:author" content="LiuYang">
<meta property="article:tag" content="PyTorch">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ly1998117.github.io/2021/08/13/DetectCancer/1.png">


<link rel="canonical" href="https://ly1998117.github.io/2021/08/13/DetectCancer/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;ly1998117.github.io&#x2F;2021&#x2F;08&#x2F;13&#x2F;DetectCancer&#x2F;&quot;,&quot;path&quot;:&quot;2021&#x2F;08&#x2F;13&#x2F;DetectCancer&#x2F;&quot;,&quot;title&quot;:&quot;Deep Learning with PyTorch -- Part 2 Learning from images (C9-C10)&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Deep Learning with PyTorch -- Part 2 Learning from images (C9-C10) | LiuYang's Blog</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LiuYang's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">26</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#early-detection-of-lung-cancer"><span class="nav-number">1.</span> <span class="nav-text">Early detection of lung cancer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-9-using-pytorch-to-fight-cancer"><span class="nav-number">2.</span> <span class="nav-text">Chapter 9 Using PyTorch to fight cancer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#introduction-to-the-use-case"><span class="nav-number">2.1.</span> <span class="nav-text">9.1 Introduction to the use case</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#preparing-for-a-large-scale-project"><span class="nav-number">2.2.</span> <span class="nav-text">9.2 Preparing for a large-scale project</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#what-is-a-ct-scan-exactly"><span class="nav-number">2.3.</span> <span class="nav-text">9.3 What is a CT scan, exactly?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#the-project-an-end-to-end-detector-for-lung-cancer"><span class="nav-number">2.4.</span> <span class="nav-text">9.4 The project: An end-to-end detector for lung cancer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#why-cant-we-just-throw-data-at-a-neural-network-until-it-works"><span class="nav-number">2.5.</span> <span class="nav-text">9.4.1 Why can’t we just throw data at a neural network until it works?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#what-is-a-nodule"><span class="nav-number">2.6.</span> <span class="nav-text">9.4.2 What is a nodule?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#our-data-source-the-luna-grand-challenge"><span class="nav-number">2.7.</span> <span class="nav-text">9.4.3 Our data source: The LUNA Grand Challenge</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#downloading-the-luna-data"><span class="nav-number">2.8.</span> <span class="nav-text">9.4.4 Downloading the LUNA data</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-10-combining-data-sources-into-a-unified-dataset"><span class="nav-number">3.</span> <span class="nav-text">Chapter 10 Combining data sources into a unified dataset</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#raw-ct-data-files"><span class="nav-number">3.1.</span> <span class="nav-text">10.1 Raw CT data files</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#parsing-lunas-annotation-data"><span class="nav-number">3.2.</span> <span class="nav-text">10.2 Parsing LUNA’s annotation data</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#training-and-validation-sets"><span class="nav-number">3.2.1.</span> <span class="nav-text">10.2.1 Training and validation sets</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unifying-our-annotation-and-candidate-data"><span class="nav-number">3.2.2.</span> <span class="nav-text">10.2.2 Unifying our annotation and candidate data</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#loading-individual-ct-scans"><span class="nav-number">3.3.</span> <span class="nav-text">10.3 Loading individual CT scans</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#hounsfield-units"><span class="nav-number">3.3.1.</span> <span class="nav-text">10.3.1 Hounsfield Units</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#locating-a-nodule-using-the-patient-coordinate-system"><span class="nav-number">3.4.</span> <span class="nav-text">10.4 Locating a nodule using the patient coordinate system</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#the-patient-coordinate-system"><span class="nav-number">3.4.1.</span> <span class="nav-text">10.4.1 The patient coordinate system</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ct-scan-shape-and-voxel-sizes"><span class="nav-number">3.4.2.</span> <span class="nav-text">10.4.2 CT scan shape and voxel sizes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#converting-between-millimeters-and-voxel-addresses"><span class="nav-number">3.4.3.</span> <span class="nav-text">10.4.3 Converting between millimeters and voxel addresses</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#extracting-a-nodule-from-a-ct-scan"><span class="nav-number">3.4.4.</span> <span class="nav-text">10.4.4 Extracting a nodule from a CT scan</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-straightforward-dataset-implementation"><span class="nav-number">3.5.</span> <span class="nav-text">10.5 A straightforward dataset implementation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#caching-candidate-arrays-with-the-getctrawcandidate-function"><span class="nav-number">3.5.1.</span> <span class="nav-text">10.5.1 Caching candidate arrays with the getCtRawCandidate function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#constructing-our-dataset-in-lunadataset.__init__"><span class="nav-number">3.5.2.</span> <span class="nav-text">10.5.2 *Constructing our dataset in LunaDataset.__init__*</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#a-trainingvalidation-split"><span class="nav-number">3.5.3.</span> <span class="nav-text">10.5.3 A training&#x2F;validation split</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rendering-the-data"><span class="nav-number">3.5.4.</span> <span class="nav-text">10.5.4 Rendering the data</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#conclution"><span class="nav-number">3.6.</span> <span class="nav-text">10.6 Conclution</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LiuYang"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">LiuYang</p>
  <div class="site-description" itemprop="description">人与人的悲欢并不相通</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.macwk.com/" title="https:www.macwk.com&#x2F;" rel="noopener" target="_blank">Macwk</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ly1998117.github.io/2021/08/13/DetectCancer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="LiuYang">
      <meta itemprop="description" content="人与人的悲欢并不相通">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuYang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Deep Learning with PyTorch -- Part 2 Learning from images (C9-C10)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-13 17:27:12" itemprop="dateCreated datePublished" datetime="2021-08-13T17:27:12+08:00">2021-08-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-08-23 22:44:20" itemprop="dateModified" datetime="2021-08-23T22:44:20+08:00">2021-08-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/PyTorch/" itemprop="url" rel="index"><span itemprop="name">PyTorch</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>48k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>44 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="early-detection-of-lung-cancer"><em>Early detection of lung cancer</em></h2>
<span id="more"></span>
<p>We’ll take a single use case and explore it in depth over the course of several chapters, starting with the basic building blocks we learned in part 1, and building out a more complete project than we’ve seen so far. In order to train the models we’ll develop in part 2, you will need access to a GPU with <strong>at least 8 GB of RAM as well as several hundred gigabytes of free disk space to store the training data.</strong></p>
<ul>
<li>Chapter 9 introduces the project, environment, and data we will consume and the structure of the project we’ll implement.</li>
<li>Chapter 10 shows how we can turn our data into a PyTorch dataset</li>
<li>chapters 11 and 12 introduce our classification model: the metrics we need to gauge how well the dataset is training, and implement solutions to problems preventing the model from training well.</li>
<li>In chapter 13, we’ll shift gears to the beginning of the end-to-end project by creating a segmentation model that produces a heatmap rather than a single classifica- tion. That heatmap will be used to generate locations to classify.</li>
<li>in chapter 14, we’ll combine our segmentation and classification models to perform a final diagnosis.</li>
</ul>
<h2 id="chapter-9-using-pytorch-to-fight-cancer">Chapter 9 <em>Using PyTorch to fight cancer</em></h2>
<ul>
<li>Breaking a large problem into smaller, easier ones</li>
<li>Exploring the constraints of an intricate deep learning problem, and deciding on a structure and approach</li>
<li>Downloading the training data</li>
</ul>
<p>We’ll start by covering the overall plan for part 2 of the book so that we have a solid idea of the larger scope the following individual chapters will be building toward.</p>
<h3 id="introduction-to-the-use-case">9.1 Introduction to <em>the use case</em></h3>
<p>Our goal for this part of the book is to give you the tools to deal with situations where things aren’t working, which is a far more common state of affairs than part 1 might have led you to believe. We can’t predict every failure case or cover every debugging technique, but hopefully we’ll give you enough to not feel stuck when you encounter a new roadblock.</p>
<p>In order to present these ideas and techniques, we need a context with some nuance and a fair bit of heft to it. We’ve chosen automatic detection of malignant tumors in the lungs using only a CT scan of a patient’s chest as input. We’ll be focusing on the technical challenges rather than the human impact, but make no mistake—even from just an engineering perspective, part 2 will require a more serious, structured approach than we needed in part 1 in order to have the project succeed.</p>
<p><strong>our project in this part of the book will take three-dimensional CT scans of human torsos as input and produce as output the location of suspected malignant tumors, if any exist.</strong></p>
<p>This part of the book will remain focused on the problem of detecting lung tumors, but the skills we’ll teach are general. Learning how to investigate, preprocess, and present your data for training is important no matter what project you’re working on.</p>
<blockquote>
<p>NOTE While the end result of part 2 will work, the output will not be accurate enough to use clinically. We’re focusing on using this as a motivating example for <em>teaching PyTorch</em>, not on employing every last trick to solve the problem.</p>
</blockquote>
<h3 id="preparing-for-a-large-scale-project">9.2 <em>Preparing for a large-scale project</em></h3>
<p>This project will build off of the foundational skills learned in part 1. We will use 3D data as input to our model, however. This is conceptually similar to the 2D image data used in the last few chapters of part 1, but we will not be able to rely on all of the 2D-specific tools available in the PyTorch ecosystem.</p>
<p>The main differences between the work we did with convolutional models in chapter 8 and what we’ll do in part 2 are related to how much effort we put into things outside the model itself. this will not end up being a case where we convert the CT to a tensor, feed it into a neural network, and have the answer pop out the other side. As is common for real-world use cases such as this, a workable approach will be more complicated to account for confounding factors such as limited data availability, finite computational resources, and limitations on our ability to design effective models.</p>
<p>Trying to train the models we will build on CPU could take weeks!1 If you don’t have a GPU handy, we provide pretrained models in chapter 14; <strong>Colaboratory (https://colab.research.google.com) provides free GPU instances that might be of use. PyTorch even comes preinstalled!</strong> You will also need to have at least 220 GB of free disk space to store the raw training data, cached data, and trained models.</p>
<p>Before we get into the details of how we’ll break down our problem, we need to learn some details about the medical domain.</p>
<h3 id="what-is-a-ct-scan-exactly">9.3 <em>What is a CT scan, exactly?</em></h3>
<p>We will be using data from CT scans extensively as the main data format for our project, so having a working understanding of the data format’s strengths, weak- nesses, and fundamental nature will be crucial to utilizing it well.</p>
<p>The key point we noted earlier is this: CT scans are essentially 3D X-rays, represented as a 3D array of single-channel data.</p>
<blockquote>
<p><strong>Voxel</strong> A voxel is the 3D equivalent to the familiar two-dimensional pixel. It encloses a vol- ume of space (hence, “volumetric pixel”), rather than an area, and is typically arranged in a 3D grid to represent a field of data. Each of those dimensions will have a measurable distance associated with it. Often, voxels are cubic, but for this chap- ter, we will be dealing with voxels that are rectangular prisms.</p>
</blockquote>
<p>In addition to medical data, we can see similar voxel data in fluid simulations, 3D scene reconstructions from 2D images, light detection and ranging (LIDAR) data for self-driving cars, and many other problem spaces. while the APIs that we’re going to cover here apply generally, we must also be aware of the nature of the data we’re using with those APIs if we want to be effective.</p>
<p>Each voxel of a CT scan has a numeric value that roughly corresponds to the average mass density of the matter contained inside. Most visualizations of that data show high-density material like bones and metal implants as white, low-density air and lung tissue as black, and fat and tissue as various shades of gray. Again, this ends up looking somewhat similar to an X-ray, with some key differences.</p>
<p>The primary difference between CT scans and X-rays is that whereas an X-ray is a projection of 3D intensity (in this case, tissue and bone density) onto a 2D plane, a CT scan retains the third dimension of the data. This allows us to render the data in a vari- ety of ways: for example, as a grayscale solid, which we can see in figure 9.1.</p>
<p><img src="1.png" alt="1" style="zoom:40%;" /></p>
<center>
Figure 9.1 A CT scan of a human torso showing, from the top, skin, organs, spine, and patient support bed.
</center>
<p>This 3D representation also allows us to “see inside” the subject by hiding tissue types we are not interested in. For example, we can render the data in 3D and restrict visibility to only bone and lung tissue, as in figure 9.2.</p>
<p><img src="2.png" alt="2" style="zoom:40%;" /></p>
<center>
Figure 9.2 CT Scan showing ribs, spine, and lung structures
</center>
<p>CT scans are much more difficult to acquire than X-rays, because doing so requires a machine like the one shown in figure 9.3 that typically costs upward of a million dollars new and requires trained staff to operate it. combined with patient privacy regulations, can make it somewhat difficult to get CT scans unless someone has already done the work of gathering and organizing a collection of them.</p>
<p>A final difference between a CT scan and an X-ray is that the data is a digital-only format. <em>CT</em> stands for <em>computed tomography</em>. The raw output of the scanning process doesn’t look particularly meaningful to the human eye and must be properly reinterpreted by a computer into something we can understand.</p>
<h3 id="the-project-an-end-to-end-detector-for-lung-cancer">9.4 <em>The project: An end-to-end detector for lung cancer</em></h3>
<p>Most of the bytes on disk will be devoted to storing the CT scans’ 3D arrays containing density information, and our models will primarily consume various subslices of those 3D arrays. We’re going to use <strong>five main steps</strong> to go from examining a whole-chest CT scan to giving the patient a lung cancer diagnosis.</p>
<p>Our full, end-to-end solution shown in figure 9.4 will load CT data files to produce a Ct instance that contains the full 3D scan, combine that with a module that performs <em>segmentation</em> (flagging voxels of interest), and then group the interesting voxels into small lumps in the search for candidate <em>nodules</em>.</p>
<p><img src="3.png" alt="3" style="zoom:40%;" /></p>
<center>
Figure 9.4 The end-to-end process of taking a full-chest CT scan and determining whether the patent has a malignant tumor
</center>
<blockquote>
<p>Nodules</p>
<p>A mass of tissue made of proliferating cells in the lung is a <em>tumor</em>. A tumor can be <em>benign</em> or it can be <em>malignant</em>, in which case it is also referred to as <em>cancer</em>. A small tumor in the lung (just a few millimeters wide) is called a <em>nodule</em>. About 40% of lung nodules turn out to be malignant—small cancers.</p>
</blockquote>
<p>Last, each of those individual, per-nodule classifications can then be combined into a whole-patient diagnosis. In more detail, we will do the following:</p>
<ol type="1">
<li>Load our raw CT scan data into a form that we can use with PyTorch. The process is somewhat less complicated with 2D image data and simpler still with non-image data.</li>
<li>Identify the voxels of potential tumors in the lungs using PyTorch to implement a technique known as <em>segmentation</em>. This is roughly akin to producing a heatmap of areas that should be fed into our classifier in step 3.</li>
<li>Group interesting voxels into lumps: that is, candidate nodules (see figure 9.5 for more information on nodules). Here, we will find the rough center of each hotspot on our heatmap. Each nodule can be located by the index, row, and column of its center point. Grouping voxels will not involve PyTorch directly, which is why we’ve pulled this out into a separate step.</li>
<li>Classify candidate nodules as actual nodules or non-nodules using 3D convolution. The features that determine the nature of a tumor from a candidate structure are local to the tumor in question, so this approach should provide a good balance between limiting input data size and excluding relevant information.</li>
<li>Diagnose the patient using the combined per-nodule classifications. we will attempt to deter- mine whether the nodule is benign or malignant based on imaging data alone.</li>
</ol>
<p>Figure 9.4 only depicts the final path through the system once we’ve built and trained all of the requisite models. The actual work required to train the relevant models will be detailed as we get closer to implementing each step.</p>
<blockquote>
<p><strong>On the shoulders of giants</strong></p>
<p>We are <em>standing on the shoulders of giants</em> when deciding on this five-step approach. We’ll discuss these giants and their work more in chapter 14.</p>
</blockquote>
<p>We will first work on step 1 (data loading), and then jump to step 4 before we come back and implement steps 2 and 3, since step 4 (classification) requires an approach similar to what we used in chapter 8, using multiple convolutional and pooling layers to aggregate spatial information before feeding it into a linear classifier.</p>
<h3 id="why-cant-we-just-throw-data-at-a-neural-network-until-it-works">9.4.1 <em>Why can’t we just throw data at a neural network until it works?</em></h3>
<p>It’s a hard task to automate, and people haven’t fully figured it out yet. That difficulty translates to complexity; once we as a society have solved this problem definitively, there will probably be an off-the-shelf library package we can grab to have it Just Work, but we’re not there just yet.</p>
<p>Why so difficult, though?</p>
<ul>
<li>the majority of a CT scan is fundamentally uninteresting with regard to answering the question, “Does this patient have a malignant tumor?” This makes intuitive sense, since the vast majority of the patient’s body will consist of healthy cells.</li>
<li>In the cases where there is a malignant tumor, up to 99.9999% of the voxels in the CT still won’t be cancer.</li>
</ul>
<p><img src="4.png" alt="4" style="zoom:33%;" /></p>
<center>
Figure 9.5 A CT scan with approximately 1,000 structures that look like tumors to the untrained eye. Exactly one has been identified as a nodule when reviewed by a human specialist. The rest are normal anatomical structures like blood vessels, lesions, and other non-problematic lumps.
</center>
<p>The project architecture we will use has the benefit of working well with a more modest amount of data. So while it’s certainly theoretically possible to just throw an arbitrarily large amount of data at a neural network until it learns the specifics of the proverbial lost needle, as well as how to ignore the hay, <strong>it’s going to be practically prohibitive to collect enough data and wait for a long enough time to train the network properly.</strong></p>
<p>To come up with the best solution, we could investigate proven model designs that can better integrate data in an end-to-end manner. <strong>For example, Retina U-Net (https://arxiv.org/pdf/1811.08661.pdf) and FishNet (http://mng.bz/K240). </strong>These complicated designs are capable of producing high-quality results, but they’re not the <em>best</em> because understanding the design decisions behind them requires having mastered fundamental concepts first. That makes these advanced models poor candidates to use while teaching those same fundamentals!</p>
<p>Our approach for solving the problem won’t use end-to-end gradient backpropagation to directly optimize for our end goal. Instead, <strong>we’ll optimize discrete chunks of the problem individually, since our segmentation model and classification model won’t be trained in tandem with each other.</strong> That might limit the top-end effectiveness of our solution, but we feel that this will make for a much better learning experience.</p>
<p>We feel that being able to focus on a single step at a time allows us to zoom in and concentrate on the smaller number of new skills we’re learning. Each of our two models will be focused on performing exactly one task. Our segmentation model is forced to consume the entire image, but we will structure things so that our classification model gets a zoomed-in view of the areas of interest.</p>
<p>Step 3 (grouping) will produce and step 4 (classification) will consume data similar to the image in figure 9.6 containing sequential transverse slices of a tumor. This image is a close-up view of a (potentially malignant, or at least indeterminate) tumor, and it is what we’re going to train the step 4 model to identify, and the step 5 model to classify as either benign or malignant.</p>
<blockquote>
<p><strong>NOTE</strong> Standard rendering of CTs places the superior at the top of the image (basically, the head goes up), but CTs order their slices such that the first slice is the inferior (toward the feet). So, Matplotlib renders the images upside down unless we take care to flip them. Since that flip doesn’t really matter to our model, we won’t complicate the code paths between our raw data and the model, but we will add a flip to our rendering code to get the images rightside up.</p>
</blockquote>
<p><img src="5.png" alt="5" style="zoom:40%;" /></p>
<center>
Figure 9.6 A close-up, multislice crop of the tumor from the CT scan in figure 9.5
</center>
<h3 id="what-is-a-nodule">9.4.2 <em>What is a nodule?</em></h3>
<p>a nodule is any of the myriad lumps and bumps that might appear inside someone’s lungs. The precise definition limits the size of a nodule to 3 cm or less, with a larger lump being a lung mass; but we’re going to use nodule interchangeably for all such anatomical structures, since it’s a somewhat arbitrary cutoff and we’re going to deal with lumps on both sides of 3 cm using the same code paths. A nodule—a small mass in the lung—can turn out to be benign or a malignant tumor (also referred to as cancer)</p>
<p>The key part is this: <strong>the cancers that we are trying to detect will <em>always</em> be nodules, either suspended in the very non-dense tissue of the lung or attached to the lung wall.</strong> That means we can limit our classifier to only nodules, rather than have it examine all tissue. Being able to restrict the scope of expected inputs will help our classifier learn the task at hand.</p>
<p>In figure 9.8, we can see a stereotypical example of a malignant nodule. The smallest nodules we’ll be concerned with are only a few millimeters across, though the one in figure 9.8 is larger.</p>
<p><img src="6.png" alt="6" style="zoom:40%;" /></p>
<center>
Figure 9.8 A CT scan with a malignant nodule displaying a visual discrepancy from other nodules
</center>
<h3 id="our-data-source-the-luna-grand-challenge">9.4.3 <em>Our data source: The LUNA Grand Challenge</em></h3>
<p>The CT scans we were just looking at come from the LUNA (LUng Nodule Analysis) Grand Challenge. The LUNA Grand Challenge is the combination of an open dataset with high-quality labels of patient CT scans (many with lung nodules) and a public ranking of classifiers against the data. The goal of the LUNA Grand Challenge is to encourage improvements in nodule detection by making it easy for teams to compete for high positions on the leader board.</p>
<blockquote>
<p>NOTE Many CT scans “in the wild” are incredibly messy, in terms of idiosyncrasies between various scanners and processing programs. For example, some scanners indicate areas of the CT scan that are outside of the scanner’s field of view by setting the density of those voxels to something negative. CT scans can also be acquired with a variety of settings on the CT scanner, which can change the resulting image in ways ranging from subtly to wildly different. <strong>Although the LUNA data is generally clean, be sure to check your assumptions if you incorporate other data sources.</strong></p>
</blockquote>
<p><strong>We will be using the LUNA 2016 dataset. The <a target="_blank" rel="noopener" href="https://luna16.grand-challenge.org/Description">LUNA site</a> describes two tracks for the challenge:</strong></p>
<ul>
<li>the first track, “Nodule detection (NDET),” roughly corresponds to our step 1 (segmentation);</li>
<li>the second track, “False positive reduction (FPRED),” is similar to our step 3 (classification). When the site discusses “locations of possible nodules,” it is talking about a process similar to what we’ll cover in chapter 13.</li>
</ul>
<h3 id="downloading-the-luna-data">9.4.4 <em>Downloading the LUNA data</em></h3>
<p>It’s about <strong>60 GB</strong> of data compressed, so depending on your internet connection, it might take a while to download. Once uncompressed, it takes up about <strong>120 GB</strong> of space; and we’ll need another <strong>100 GB</strong> or so of cache space to store smaller chunks of data so that we can access it more quickly than reading in the whole CT.</p>
<p>Navigate to https://luna16.grand-challenge.org/download and either register using email or use the Google OAuth login. Once logged in, you should see two download links to Zenodo data, as well as a link to Academic Torrents. The data should be the same from either.</p>
<p>The data we will be using comes in 10 subsets, aptly named subset0 through subset9. Unzip each of them so you have separate subdirectories like code/data-unversioned/ part2/luna/subset0, and so on. In addition, you need the candidates.csv and annotations.csv files. We’ve included these files on the book’s website and in the GitHub repository for convenience, so they should already be present in code/data/part2/luna/*.csv. They can also be downloaded from the same location as the data subsets.</p>
<blockquote>
<p>NOTE If you do not have easy access to ~220 GB of free disk space, <strong>it’s possible to run the examples using only 1 or 2 of the 10 subsets of data.</strong> The smaller training set will result in the model performing much more poorly, but that’s better than not being able to run the examples at all.</p>
</blockquote>
<h2 id="chapter-10-combining-data-sources-into-a-unified-dataset">Chapter 10 <em>Combining data sources into a unified dataset</em></h2>
<ul>
<li>Loading and processing raw data files</li>
<li>Implementing a Python class to represent our data</li>
<li>Converting our data into a format usable by PyTorch</li>
<li>Visualizing the training and validation data</li>
</ul>
<p>Now that we’ve discussed the high-level goals for part 2, as well as outlined how the data will flow through our system, let’s get into specifics of what we’re going to do in this chapter. It’s time to implement basic data-loading and data-processing routines for our raw data. Basically, every significant project you work on will need something analogous to what we cover here. Figure 10.1 shows the high-level map of our project from chapter 9. We’ll focus on step 1, data loading, for the rest of this chapter. Our goal is to be able to produce a training sample given our inputs of raw CT scan data and a list of annotations for those CTs.</p>
<p><img src="7.png" alt="7" style="zoom:40%;" /></p>
<center>
Figure 10.1 Our end-to-end lung cancer detection project, with a focus on this chapter’s topic: step 1, data loading
</center>
<p>Figure 10.2 shows what we’ll need to do to turn our raw data into a training sample. Luckily, we got a head start on <em>understanding</em> our data in the last chapter, but we have more work to do on that front as well.</p>
<p><img src="8.png" alt="8" style="zoom:50%;" /></p>
<h3 id="raw-ct-data-files">10.1 <em>Raw CT data files</em></h3>
<p>Our CT data comes in two files: a .mhd file containing metadata header information, and a .raw file containing the raw bytes that make up the 3D array. Each file’s name starts with a unique identifier called the <em>series UID</em> (<strong>the name comes from the Digital Imaging and Communications in Medicine [DICOM] nomenclature</strong>) for the CT scan in question. For example, for series UID 1.2.3, there would be two files: 1.2.3.mhd and 1.2.3.raw.</p>
<p>**Our Ct class will consume those two files and produce the 3D array, as well as the transformation matrix to convert from the patient coordinate system (which we will discuss in more detail in section 10.6) to the index, row, column coordinates needed by the array (these coordinates are shown as (I,R,C) in the figures and are denoted with _irc variable suffixes in the code).** just remember that we’ve got some coordinate system conversion to do before we can apply these coordinates to our CT data. We’ll explore the details as we need them.</p>
<p>We will also load the annotation data provided by LUNA, which will give us a list of nodule coordinates, each with a malignancy flag, along with the series UID of the relevant CT scan. By combining the nodule coordinate with coordinate system transformation information, we get the index, row, and column of the voxel at the center of our nodule.</p>
<p>Using the (I,R,C) coordinates, we can crop a small 3D slice of our CT data to use as the input to our model. <strong>Along with this 3D sample array, we must construct the rest of our training sample tuple, which will have the sample array, nodule status flag, series UID, and the index of this sample in the CT list of nodule candidates.</strong> This sample tuple is exactly what PyTorch expects from our Dataset subclass and represents the last section of our bridge from our original raw data to the standard structure of PyTorch tensors.</p>
<p>Limiting or cropping our data so as not to drown our model in noise is important, as is making sure we’re not so aggressive that our signal gets cropped out of our input. We want to make sure the range of our data is well behaved, especially after normalization. Clamping our data to remove outliers can be useful, especially if our data is prone to extreme outliers. We can also create handcrafted, algorithmic transformations of our input; this is known as <em>feature engineering</em>.</p>
<h3 id="parsing-lunas-annotation-data">10.2 <em>Parsing LUNA’s annotation data</em></h3>
<p>The first thing we need to do is begin loading our data. Making sure we know how to work with the raw input is required no matter what, and knowing how our data will look after it loads can help inform the structure of our early experiments. We could try loading individual CT scans, but we think it makes sense to parse the CSV files that LUNA provides, which contain information about the points of interest in each CT scan. As we can see in figure 10.3, we expect to get some coordinate information, an indication of whether the coordinate is a nodule, and a unique identifier for the CT scan. Since there are fewer types of information in the CSV files, and they’re easier to parse, we’re hoping they will give us some clues about what to look for once we start loading CTs.</p>
<p><img src="9.png" alt="9" style="zoom:50%;" /></p>
<center>
Figure 10.3 The LUNA annotations in candidates.csv contain the CT series, the nodule candidate’s position, and a flag indicating if the candidate is actually a nodule or not.
</center>
<p>The candidates.csv file contains information about all lumps that potentially look like nodules, whether those lumps are malignant, benign tumors, or something else altogether. We’ll use this as the basis for building a complete list of candidates that can then be split into our training and validation datasets.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Counts the number of lines in the file</span></span><br><span class="line">$ wc -l candidates.csv</span><br><span class="line">551066 candidates.csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prints the first few lines of the file</span></span><br><span class="line">$ head data/part2/luna/candidates.csv</span><br><span class="line">seriesuid,coordX,coordY,coordZ,class</span><br><span class="line">1.3...6860,-56.08,-67.85,-311.92,0</span><br><span class="line">1.3...6860,53.21,-244.41,-245.17,0</span><br><span class="line">1.3...6860,103.66,-121.8,-286.62,0</span><br><span class="line">1.3...6860,-33.66,-72.75,-308.41,0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Counts the number of lines that end with 1, which indicates malignancy</span></span><br><span class="line">$ grep <span class="string">&#x27;,1$&#x27;</span> candidates.csv | wc -l</span><br><span class="line">1351</span><br></pre></td></tr></table></figure>
<blockquote>
<p>NOTE The values in the seriesuid column have been elided to better fit the printed page.</p>
</blockquote>
<p><strong>So we have 551,000 lines, each with a seriesuid (which we’ll call series_uid in the code), some (X,Y,Z) coordinates, and a class column that corresponds to the nodule status (it’s a Boolean value: 0 for a candidate that is not an actual nodule, and 1 for a candidate that is a nodule, either malignant or benign). We have 1,351 candidates flagged as actual nodules.</strong></p>
<p><strong>The annotations.csv file contains information about some of the candidates that have been flagged as nodules</strong>. We are interested in the diameter_mm information in particular:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ wc -l annotations.csv</span><br><span class="line">1187 annotations.csv</span><br><span class="line"></span><br><span class="line">$ head data/part2/luna/annotations.csv</span><br><span class="line">seriesuid,coordX,coordY,coordZ,diameter_mm</span><br><span class="line">1.3.6...6860,-128.6994211,-175.3192718,-298.3875064,5.651470635</span><br><span class="line">1.3.6...6860,103.7836509,-211.9251487,-227.12125,4.224708481</span><br><span class="line">1.3.6...5208,69.63901724,-140.9445859,876.3744957,5.786347814</span><br><span class="line">1.3.6...0405,-24.0138242,192.1024053,-391.0812764,8.143261683</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>We have size information for about 1,200 nodules. This is useful, since we can use it to make sure our training and validation data includes a representative spread of nodule sizes.</strong> Without this, it’s possible that our validation set could end up with only extreme values, making it seem as though our model is underperforming.</p>
<h4 id="training-and-validation-sets">10.2.1 <em>Training and validation sets</em></h4>
<p>we’ll split our data into training and validation sets. We want to make sure both sets are <em>representative</em> of the range of real-world input data we’re expecting to see and handle normally. If either set is meaningfully different from our real-world use cases, it’s pretty likely that our model will behave differently than we expect—all of the training and statistics we collect won’t be predictive once we transfer over to production use!</p>
<p>Let’s get back to our nodules. We’re going to sort them by size and take every <em>N</em>th one for our validation set. That should give us the representative spread we’re looking for. Unfortunately, the location information provided in annotations.csv doesn’t always precisely line up with the coordinates in candidates.csv:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep 100225287222365663678666836860 annotations.csv 1.3.6...6860,-128.6994211,-175.3192718,-298.3875064,5.651470635 1.3.6...6860,103.7836509,-211.9251487,-227.12125,4.224708481</span><br><span class="line"></span><br><span class="line">$ grep <span class="string">&#x27;100225287222365663678666836860.*,1$&#x27;</span> candidates.csv 1.3.6...6860,104.16480444,-211.685591018,-227.011363746,1 1.3.6...6860,-128.94,-175.04,-297.87,1</span><br></pre></td></tr></table></figure>
<p>If we truncate the corresponding coordinates from each file, we end up with (–128.70, –175.32,–298.39) versus (–128.94,–175.04,–297.87). <strong>Since the nodule in question has a diameter of 5 mm, both of these points are clearly meant to be the “center” of the nodule, but they don’t line up exactly. It would be a perfectly valid response to decide that dealing with this data mismatch isn’t worth it, and to ignore the file.</strong> We are going to do the legwork to make things line up, though, since real-world datasets are often imperfect this way, and this is a good example of the kind of work you will need to do to assemble data from disparate data sources.</p>
<h4 id="unifying-our-annotation-and-candidate-data">10.2.2 <em>Unifying our annotation and candidate data</em></h4>
<p>Now that we know what our raw data files look like, let’s build a getCandidateInfoList function that will stitch it all together. We’ll use a named tuple that is defined at the top of the file to hold the information for each nodule.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">CandidateInfoTuple = namedtuple(</span><br><span class="line">    <span class="string">&#x27;CandidateInfoTuple&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;isNodule_bool, diameter_mm, series_uid, center_xyz&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>These tuples are <em>not</em> our training samples, as they’re missing the chunks of CT data we need. Instead, these represent a sanitized, cleaned, unified interface to the human-annotated data we’re using. It’s very important to isolate having to deal with messy data from model training. Otherwise, your training loop can get cluttered quickly, because you have to keep dealing with special cases and other distractions in the middle of code that should be focused on training.</p>
<p>Our list of candidate information will have the <strong>nodule status</strong> (what we’re going to be training the model to classify), <strong>diameter</strong> (useful for getting a good spread in training, since large and small nodules will not have the same features), <strong>series</strong> (to locate the correct CT scan), and <strong>candidate center</strong> (to find the candidate in the larger CT). <strong>The function that will build a list of these NoduleInfoTuple instances starts by using an inmemory caching decorator, followed by getting the list of files present on disk.</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@functools.lru_cache(<span class="params"><span class="number">1</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCandidateInfoList</span>(<span class="params">requireOnDisk_bool=<span class="literal">True</span></span>):</span></span><br><span class="line">	mhd_list = glob.glob(os.path.join(subset_path, <span class="string">&#x27;*.mhd&#x27;</span>))</span><br><span class="line">	presentOnDisk_set = &#123;os.path.split(p)[-<span class="number">1</span>][:-<span class="number">4</span>] <span class="keyword">for</span> p <span class="keyword">in</span> mhd_list&#125;</span><br></pre></td></tr></table></figure>
<p>Since parsing some of the data files can be slow, we’ll cache the results of this function call in memory. Speeding up our data pipeline by carefully applying inmemory or on-disk caching can result in some pretty impressive gains in training speed.</p>
<p>we’ll support running our training program with less than the full set of training data, due to the long download times and high disk space requirements. The <code>requireOnDisk_bool</code> parameter is what makes good on that promise; <strong>we’re detecting which LUNA series UIDs are actually present and ready to be loaded from disk, and we’ll use that information to limit which entries we use from the CSV files we’re about to parse.</strong> Being able to run a subset of our data through the training loop can be useful to verify that the code is working as intended. Often a model’s training results are bad to useless when doing so, but exercising our logging, metrics, model check-pointing, and similar functionality is beneficial.</p>
<p>After we get our candidate information, we want to merge in the diameter information from annotations.csv. First we need to group our annotations by <code>series_uid</code>, as that’s the first key we’ll use to cross-reference each row from the two files.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> @functools.lru_cache(<span class="params"><span class="number">1</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCandidateInfoList</span>(<span class="params">requireOnDisk_bool=<span class="literal">True</span></span>):</span></span><br><span class="line">    ...</span><br><span class="line">    diameter_dict = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(data_dir, <span class="string">&#x27;annotations.csv&#x27;</span>),<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">list</span>(csv.reader(f))[<span class="number">1</span>:]:</span><br><span class="line">            <span class="built_in">print</span>(row)</span><br><span class="line">            series_uid = row[<span class="number">0</span>]</span><br><span class="line">            annotationCenter_xyz = <span class="built_in">tuple</span>([<span class="built_in">float</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> row[<span class="number">1</span>:<span class="number">4</span>]])</span><br><span class="line">            annotationDiameter_mm = <span class="built_in">float</span>(row[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">            diameter_dict.setdefault(series_uid, []).append(</span><br><span class="line">                (annotationCenter_xyz, annotationDiameter_mm)</span><br><span class="line">            )</span><br><span class="line"><span class="comment"># we’ll build our full list of candidates using the information in the candidates.csv file.</span></span><br><span class="line">    candidateInfo_list = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(data_dir, <span class="string">&#x27;candidates.csv&#x27;</span>), <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="comment"># [&#x27;seriesuid&#x27;, &#x27;coordX&#x27;, &#x27;coordY&#x27;, &#x27;coordZ&#x27;, &#x27;class&#x27;]</span></span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">list</span>(csv.reader(f)):</span><br><span class="line">                <span class="built_in">print</span>(row)</span><br><span class="line">                series_uid = row[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> series_uid <span class="keyword">not</span> <span class="keyword">in</span> presentOnDist_set <span class="keyword">and</span> requireOnDist_bool:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                isNodule_bool = <span class="built_in">bool</span>(<span class="built_in">int</span>(row[<span class="number">4</span>]))</span><br><span class="line">                candidateCenter_xyz = <span class="built_in">tuple</span>(<span class="built_in">float</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> row[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line">                candidateDiameter_mm = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> anntation_tuple <span class="keyword">in</span> diameter_dict.get(series_uid, []):</span><br><span class="line">                    annotationCenter_xyz, annotationDiameter_mm = anntation_tuple</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                        delta_mm = <span class="built_in">abs</span>(candidateCenter_xyz[i] - annotationCenter_xyz[i])</span><br><span class="line">                        <span class="keyword">if</span> delta_mm &gt; annotationDiameter_mm / <span class="number">4</span>:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        candidateDiameter_mm = annotationDiameter_mm</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    candidateInfo_list.append(CandidateInfoTuple(</span><br><span class="line">                        isNodule_bool,</span><br><span class="line">                        candidateDiameter_mm,</span><br><span class="line">                        series_uid,</span><br><span class="line">                        candidateCenter_xyz</span><br><span class="line">                    ))</span><br><span class="line">    candidateInfo_list.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> candidateInfo_list</span><br></pre></td></tr></table></figure>
<p>For each of the candidate entries for a given <code>series_uid</code>, we loop through the annotations we collected earlier for the same <code>series_uid</code> and see if the two coordinates are close enough to consider them the same nodule. If they are, great! Now we have diameter information for that nodule. If we don’t find a match, that’s fine; we’ll just treat the nodule as having a 0.0 diameter. <strong>Since we’re only using this information to get a good spread of nodule sizes in our training and validation sets, having incorrect diameter sizes for some nodules shouldn’t be a problem, but we should remember we’re doing this in case our assumption here is wrong.</strong></p>
<p>That’s a lot of somewhat fiddly code just to merge in our nodule diameter. Unfortunately, having to do this kind of manipulation and fuzzy matching can be fairly common, depending on your raw data. Once we get to this point, however, we just need to sort the data and return it.</p>
<h3 id="loading-individual-ct-scans">10.3 Loading individual CT scans</h3>
<p>we need to be able to take our CT data from a pile of bits on disk and turn it into a Python object from which we can extract 3D nodule density data. We can see this path from the .mhd and .raw files to Ct objects in figure 10.4. Our nodule annotation information acts like a map to the interesting parts of our raw data. Before we can follow that map to our data of interest, we need to get the data into an addressable form.</p>
<p><img src="10.png" alt="10" style="zoom:50%;" /></p>
<center>
Figure 10.4 Loading a CT scan produces a voxel array and a transformation from patient coordinates to array indices.
</center>
<p>The native file format for CT scans is DICOM (www.dicomstandard.org). The first version of the DICOM standard was authored in 1984, and as we might expect from anything computing-related that comes from that time period, it’s a bit of a mess.</p>
<p>LUNA has converted the data we’re going to be using for this chapter into the <strong>MetaIO</strong> format, which is quite a bit easier to use (https://itk.org/Wiki/MetaIO/Documentation#Quick_Start). We can treat the format of the data files as a black box and use <code>SimpleITK</code> to load them into more familiar NumPy arrays.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SimpleITK <span class="keyword">as</span> sitk</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CT</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, series_uid</span>):</span></span><br><span class="line">        mhd_path = glob.glob(os.path.join(subset_path, <span class="string">f&#x27;<span class="subst">&#123;series_uid&#125;</span>.mhd&#x27;</span>))[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># sitk.ReadImage implicitly consumes the .raw file in addition to the passed-in .mhd file.</span></span><br><span class="line">        ct_mhd = sitk.ReadImage(mhd_path)</span><br><span class="line">        ct_array = np.array(sitk.GetArrayFromImage(ct_mhd), dtype=np.float32)</span><br></pre></td></tr></table></figure>
<p>For real projects, you’ll want to understand what types of information are contained in your raw data, but it’s perfectly fine to rely on third-party code like <code>SimpleITK</code> to parse the bits on disk. Finding the right balance of knowing everything about your inputs versus blindly accepting whatever your data-loading library hands you will prob- ably take some experience. Just remember that we’re mostly concerned about <em>data</em>, not <em>bits</em>. It’s the information that matters, not how it’s represented.</p>
<p>We identify specific CT scans using the <em>series instance UID</em> (series_uid) assigned when the CT scan was created. DICOM makes heavy use of unique identifiers (UIDs) <em>10.3.1</em> for individual DICOM files, groups of files, courses of treatment, and so on. These identifiers are similar in concept to UUIDs (https://docs.python.org/3.6/library/ uuid.html), but they have a different creation process and are formatted differently.</p>
<p><strong>For our purposes, we can treat them as opaque ASCII strings that serve as unique keys to reference the various CT scans.</strong> Officially, only the characters 0 through 9 and the period (.) are valid characters in a DICOM UID, but some DICOM files in the wild have been anonymized with routines that replace the UIDs with hexadecimal (0–9 and a–f) or other technically out-of-spec values (these out-of-spec values typically aren’t flagged or cleaned by DICOM parsers; as we said before, it’s a bit of a mess).</p>
<p><strong>The 10 subsets we discussed earlier have about 90 CT scans each (888 in total), with every CT scan represented as two files: one with a .mhd extension and one with a .raw extension. The data being split between multiple files is hidden behind the sitk routines, however, and is not something we need to be directly concerned with.</strong></p>
<p><strong>At this point, ct_a is a three-dimensional array. All three dimensions are spatial, and the single intensity channel is implicit.</strong></p>
<h4 id="hounsfield-units">10.3.1 <em>Hounsfield Units</em></h4>
<p>Without understanding the nuances of our data’s values and range, we’ll end up feeding values into our model that will hinder its ability to learn what we want it to. Continuing the <code>__init__</code> method, we need to do a bit of cleanup on the ct_a values. <strong>CT scan voxels are expressed in Hounsfield units (仿射剂量) (HU; https://en.wikipedia.org/wiki/Hounsfield_scale), which are odd units; air is –1,000 HU (close enough to 0 g/cc [grams per cubic centimeter] for our purposes), water is 0 HU (1 g/cc), and bone is at least +1,000 HU (2–3 g/cc).</strong></p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ecfb5f44205930f7a33a9c240f41eb94051f3f01" alt="{\displaystyle HU=1000\times {\frac {\mu -\mu _{\textrm {water}}}{\mu _{\textrm {water}}-\mu _{\textrm {air}}}}}" style="zoom:100%;" /></p>
<figure>
<img src="11.png" alt="11" /><figcaption aria-hidden="true">11</figcaption>
</figure>
<p>Some CT scanners use HU values that correspond to negative densities to indicate that those voxels are outside of the CT scanner’s field of view. <strong>For our purposes, everything outside of the patient should be air, so we discard that field-of-view information by setting a lower bound of the values to –1,000 HU. Similarly, the exact densities of bones, metal implants, and so on are not relevant to our use case, so we cap density at roughly 2 g/cc (1,000 HU)</strong> even though that’s not biologically accurate in most cases.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ct_array = clip(-<span class="number">1000</span>, <span class="number">1000</span>, ct_array)</span><br><span class="line"></span><br><span class="line">self.series_uid = series_uid</span><br><span class="line">self.hu_array = ct_array</span><br></pre></td></tr></table></figure>
<p>Values above 0 HU don’t scale perfectly with density, but the tumors we’re interested in are typically around 1 g/cc (0 HU), so we’re going to ignore that HU doesn’t map perfectly to common units like g/cc. That’s fine, since our model will be trained to consume HU directly.</p>
<p>It’s important to know that our data uses the range of –1,000 to +1,000, since in chapter 13 we end up adding channels of information to our samples. If we don’t account for the disparity between HU and our additional data, those new channels can easily be overshadowed by the raw HU values.</p>
<h3 id="locating-a-nodule-using-the-patient-coordinate-system">10.4 <em>Locating a nodule using the patient coordinate system</em></h3>
<p>Deep learning models typically need fixed-size inputs, due to having a fixed number of input neurons. We need to be able to produce a fixed-size array containing the candidate so that we can use it as input to our classifier. We’d like to train our model using a crop of the CT scan that has a candidate nicely centered, <strong>since then our model doesn’t have to learn how to notice nodules tucked away in the corner of the input. By reducing the variation in expected inputs, we make the model’s job easier.</strong></p>
<h4 id="the-patient-coordinate-system">10.4.1 <em>The patient coordinate system</em></h4>
<p>Unfortunately, all of the candidate center data we loaded in section 10.2 is expressed in millimeters, not voxels! We can’t just plug locations in millimeters into an array index and expect everything to work out the way we want.</p>
<p><strong>As we can see in figure 10.5, we need to transform our coordinates from the millimeter-based coordinate system (X,Y,Z) they’re expressed in, to the voxel-address-based coordinate system (I,R,C) used to take array slices from our CT scan data. </strong></p>
<p>when dealing with CT scans, we refer to the array dimensions as <em>index, row, and column,</em> because a separate meaning exists for X, Y, and Z, as illustrated in figure 10.6. The <strong><em>patient coordinate system</em></strong> defines positive X to be patient-left (<em>left</em>), positive Y to be patient-behind (<em>posterior</em>), and positive Z to be toward-patient-head (<em>superior</em>). Left-posterior-superior is sometimes abbreviated <em>LPS</em>.</p>
<p><img src="12.png" alt="12" style="zoom:50%;" /></p>
<center>
Figure 10.6 Our inappropriately clothed patient demonstrating the axes of the patient coordinate system
</center>
<p>The patient coordinate system is measured in millimeters and has an arbitrarily positioned origin that does not correspond to the origin of the CT voxel array, as shown in figure 10.7.</p>
<p><img src="13.png" alt="13" style="zoom:50%;" /></p>
<center>
Figure 10.7 Array coordinates and patient coordinates have different origins and scaling.
</center>
<p>The patient coordinate system is often used to specify the locations of interesting anatomy in a way that is independent of any particular scan. The metadata that defines the relationship between the CT array and the patient coordinate system is stored in the header of DICOM files, and that meta-image format preserves the data in its header as well. This metadata allows us to construct the transformation from (X,Y,Z) to (I,R,C) that we saw in figure 10.5.</p>
<h4 id="ct-scan-shape-and-voxel-sizes">10.4.2 <em>CT scan shape and voxel sizes</em></h4>
<p>One of the most common variations between CT scans is the size of the voxels; typically, they are not cubes. Instead, they can be 1.125 mm × 1.125 mm × 2.5 mm or similar. Usually the row and column dimensions have voxel sizes that are the same, and the index dimension has a larger value, but other ratios can exist.</p>
<p>When plotted using square pixels, the non-cubic voxels can end up looking somewhat distorted. That’s an imperfect analogy, since in this case the distortion is uniform and linear—the patient looks far more squat or barrel-chested in figure 10.8 than they would in reality.</p>
<p>Knowing these kinds of details can help when trying to interpret our results visually. Without this information, it would be easy to assume that something was wrong with our data loading: we might think the data looked so squat because we were skipping half of the slices by accident, or something along those lines.</p>
<p><img src="14.png" alt="13" style="zoom:50%;" /></p>
<center>
Figure 10.8 A CT scan with non-cubic voxels along the index-axis. Note how compressed the lungs are from top to bottom.
</center>
<p>CTs are commonly 512 rows by 512 columns, with the index dimension ranging from around 100 total slices up to perhaps 250 slices (250 slices times 2.5 millimeters is typically enough to contain the anatomical region of interest). This results in a lower bound of approximately <span class="math inline">\(2^{25}\)</span> voxels, or about 32 million data points. Each CT specifies the voxel size in millimeters as part of the file metadata; for example, we’ll call <code>ct_mhd .GetSpacing()</code> in listing 10.10.</p>
<h4 id="converting-between-millimeters-and-voxel-addresses">10.4.3 <em>Converting between millimeters and voxel addresses</em></h4>
<p>We will define some utility code to assist with the conversion between patient coordinates in millimeters (which we will denote in the code with an _xyz suffix on variables and the like) and (I,R,C) array coordinates (which we will denote in code with an _irc suffix).</p>
<p>You might wonder whether the SimpleITK library comes with utility functions to convert these. And indeed, an Image instance does feature two methods—<code>TransformIndexToPhysicalPoint</code> and <code>TransformPhysicalPointToIndex</code>—to do just that (except shuffling from CRI [column,row,index] IRC). However, we want to be able to do this computation without keeping the Image object around, so we’ll perform the math manually here.</p>
<p>Flipping the axes (and potentially a rotation or other transforms) is encoded in a 3 × 3 matrix returned as a tuple from <code>ct_mhd.GetDirections()</code>. To go from voxel indices to coordinates, we need to follow these four steps in order:</p>
<ul>
<li><strong>Flip the coordinates from IRC to CRI, to align with XYZ.</strong></li>
<li><strong>Scale the indices with the voxel sizes.</strong></li>
<li><strong>Matrix-multiply with the directions matrix, using @ in Python.</strong></li>
<li><strong>Add the offset for the origin.</strong></li>
</ul>
<p>To go back from XYZ to IRC, we need to perform the inverse of each step in the reverse order. We keep the voxel sizes in named tuples, so we convert these into arrays.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">IrcTuple = namedtuple(<span class="string">&#x27;IrcTuple&#x27;</span>, [<span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;row&#x27;</span>, <span class="string">&#x27;column&#x27;</span>])</span><br><span class="line">XyzTuple = namedtuple(<span class="string">&#x27;XyzTuple&#x27;</span>, [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">irc2xyz</span>(<span class="params">coord_irc, origin_xyz, vxSize_xyz, direction_array</span>):</span></span><br><span class="line">    cri_array = np.array(coord_irc)[::-<span class="number">1</span>]</span><br><span class="line">    origin_array = np.array(origin_xyz)</span><br><span class="line">    vxSize_array = np.array(vxSize_xyz)</span><br><span class="line">    coord_xyz = (direction_array @ (cri_array * vxSize_array)) + origin_array</span><br><span class="line">    <span class="keyword">return</span> XyzTuple(*coord_xyz)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xyz2irc</span>(<span class="params">coord_xyz, origin_xyz, vxSize_xyz, direction_array</span>):</span></span><br><span class="line">    coord_array = np.array(coord_xyz)</span><br><span class="line">    origin_array = np.array(origin_xyz)</span><br><span class="line">    vxSize_array = np.array(vxSize_xyz)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 求矩阵的 inverse</span></span><br><span class="line">    cri_array = (coord_array - origin_array) @ np.linalg.inv(direction_array) / vxSize_array</span><br><span class="line">    <span class="comment"># 四舍五入</span></span><br><span class="line">    cri_array = np.<span class="built_in">round</span>(cri_array).astype(<span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">return</span> IrcTuple(*cri_array[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>The metadata we need to convert from patient coordinates (_xyz) to array coordinates (_irc) is contained in the MetaIO file alongside the CT data itself. We pull the voxel sizing and positioning metadata out of the .mhd file at the same time we get the ct_a.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ct</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, series_uid</span>):</span></span><br><span class="line">        ...</span><br><span class="line">        self.original_xyz = XyzTuple(*ct_mhd.GetOrigin())</span><br><span class="line">        self.vxSize_xyz = XyzTuple(*ct_mhd.GetSpacing())</span><br><span class="line">        self.direction_array = np.array(ct_mhd.GetDirection()).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>These are the inputs we need to pass into our xyz2irc conversion function, in addition to the individual point to covert. With these attributes, our CT object implementation now has all the data needed to convert a candidate center from patient coordinates to array coordinates.</p>
<h4 id="extracting-a-nodule-from-a-ct-scan">10.4.4 Extracting a nodule from a CT scan</h4>
<p>we will extract an area around each candidate and let the model focus on one candidate at a time. Looking for ways to reduce the scope of the problem for our model can help, especially in the early stages of a project when we’re trying to get our first working implementation up and running.</p>
<p>The <code>getRawNodule</code> function takes the center expressed in the patient coordinate sys- tem (X,Y,Z), just as it’s specified in the LUNA CSV data, as well as a width in voxels. It returns a cubic chunk of CT, as well as the center of the candidate converted to array coordinates.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getRawCandidate</span>(<span class="params">self, center_xyz, width_irc</span>):</span></span><br><span class="line">    center_irc = xyz2irc(</span><br><span class="line">        center_xyz, </span><br><span class="line">        self.original_xyz, </span><br><span class="line">        self.vxSize_xyz, </span><br><span class="line">        self.direction_array</span><br><span class="line">    )</span><br><span class="line">    slice_list = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> axis, center_val <span class="keyword">in</span> <span class="built_in">enumerate</span>(center_irc):</span><br><span class="line">        start_ndx = <span class="built_in">int</span>(<span class="built_in">round</span>(center_val - width_irc[axis] / <span class="number">2</span>))</span><br><span class="line">        end_ndx = <span class="built_in">int</span>(start_ndx + width_irc[axis])</span><br><span class="line">        slice_list.append(<span class="built_in">slice</span>(start_ndx, end_ndx))</span><br><span class="line">    ct_chunk = self.hu_array[<span class="built_in">tuple</span>(slice_list)]</span><br><span class="line">    <span class="keyword">return</span> ct_chunk, center_irc</span><br></pre></td></tr></table></figure>
<h3 id="a-straightforward-dataset-implementation">10.5 <em>A straightforward dataset implementation</em></h3>
<p>By subclassing Dataset, we will take our arbitrary data and plug it into the rest of the PyTorch ecosystem. Each Ct instance represents hundreds of different samples that we can use to train our model or validate its effectiveness. Our LunaDataset class will normalize those samples, flattening each CT’s nodules into a single collection from which samples can be retrieved without regard for which Ct instance the sample originates from. This flattening is often how we want to process data, although as we’ll see in chapter 12, in some situations a simple flattening of the data isn’t enough to train a model well.</p>
<p>In terms of implementation, we are going to start with the requirements imposed from subclassing Dataset and work backward. This is different from the datasets we’ve worked with earlier; there we were using classes provided by external libraries, whereas here we need to implement and instantiate the class ourselves. Once we have done so, we can use it similarly to those earlier examples.</p>
<blockquote>
<p>any Dataset subclasses we want to implement must provide these two functions:</p>
<ul>
<li>An implementation of <code>__len__</code> that must return a single, constant value after initialization (the value ends up being cached in some use cases)</li>
<li>The <code>__getitem__</code> method, which takes an index and returns a tuple with sample data to be used for training (or validation, as the case may be)</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, ndx</span>):</span></span><br><span class="line">    candidate_info_tuple = self.candidateInfo_list[ndx]</span><br><span class="line">    width_irc = (<span class="number">32</span>, <span class="number">48</span>, <span class="number">48</span>)</span><br><span class="line"></span><br><span class="line">    candidate_array, center_irc = getCtRawCandidate(</span><br><span class="line">        candidate_info_tuple.series_uid,</span><br><span class="line">        candidate_info_tuple.center_xyz,</span><br><span class="line">        width_irc</span><br><span class="line">    )</span><br><span class="line">    candidate_torch = torch.from_numpy(candidate_array).to(torch.float32).unsqueeze(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># build our classification tensor.</span></span><br><span class="line">    pos_t = torch.tensor([</span><br><span class="line">    	<span class="keyword">not</span> candidateInfo_tup.isNodule_bool,</span><br><span class="line">    	candidateInfo_tup.isNodule_bool</span><br><span class="line">	],</span><br><span class="line">  		dtype=torch.long,</span><br><span class="line">	)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        candidate_torch,</span><br><span class="line">        pos_t,</span><br><span class="line">        candidate_info_tuple.series_uid,</span><br><span class="line">        torch.tensor(center_irc)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p><strong>This has two elements, one each for our possible candidate classes (nodule or nonnodule; or positive or negative, respectively).</strong> We could have a single output for the nodule status, but <code>nn.CrossEntropyLoss</code> expects one output value per class, so that’s what we provide here. The exact details of the tensors you construct will change based on the type of project you’re working on.</p>
<p>Let’s take a look at our final sample tuple (the larger nodule_t output isn’t partic- ularly readable, so we elide most of it in the listing).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(tensor([[[[-<span class="number">899.</span>, -<span class="number">903.</span>, -<span class="number">825.</span>,  ..., -<span class="number">901.</span>, -<span class="number">898.</span>, -<span class="number">893.</span>],</span><br><span class="line">		..., </span><br><span class="line">   		[ -<span class="number">92.</span>,  -<span class="number">63.</span>,    <span class="number">4.</span>,  ...,   <span class="number">63.</span>,   <span class="number">70.</span>,   <span class="number">52.</span>]]]]),</span><br><span class="line"> tensor([<span class="number">0</span>, <span class="number">1</span>]),</span><br><span class="line"><span class="string">&#x27;1.3.6...287966244644280690737019247886&#x27;</span>, </span><br><span class="line"> tensor([ <span class="number">91</span>, <span class="number">360</span>, <span class="number">341</span>]))</span><br></pre></td></tr></table></figure>
<h4 id="caching-candidate-arrays-with-the-getctrawcandidate-function">10.5.1 <em>Caching candidate arrays with the getCtRawCandidate function</em></h4>
<p>In order to get decent performance out of LunaDataset, we’ll need to invest in some on-disk caching. <strong>This will allow us to avoid having to read an entire CT scan from disk for every sample.</strong> Doing so would be prohibitively slow! Make sure you’re paying attention to bottlenecks in your project and doing what you can to optimize them once they start slowing you down. <strong>Without caching, the <code>LunaDataset</code> is easily 50 times slower! We’ll revisit this in the chapter’s exercises.</strong></p>
<p>The function itself is easy. It’s a file-cache-backed (https://pypi.python.org/pypi/ diskcache) wrapper around the Ct.getRawCandidate method we saw earlier.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@functools.lru_cache(<span class="params"><span class="number">1</span>, typed=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCt</span>(<span class="params">series_uid</span>):</span></span><br><span class="line">	<span class="keyword">return</span> CT(series_uid)</span><br><span class="line"></span><br><span class="line"><span class="meta">@raw_cache.memoize(<span class="params">typed=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCtRawCandidate</span>(<span class="params">series_uid, center_xyz, width_irc</span>):</span></span><br><span class="line">  	ct = getCt(series_uid)</span><br><span class="line">  	ct_chunk, center_irc = ct.getRawCandidate(center_xyz, width_irc)</span><br><span class="line">    <span class="keyword">return</span> ct_chunk, center_irc</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>First, we’re caching the getCt return value in memory so that we can repeatedly ask for the same Ct instance without having to reload all of the data from disk.</strong></li>
<li><strong>The getCtRawCandidate function that calls getCt <em>also</em> has its outputs cached, however; so after our cache is populated, getCt won’t ever be called. These values are cached to disk using the Python library diskcache. </strong>it’s much, much faster to read in 215 float32 values from disk than it is to read in 225 int16 values, convert to float32, and then select a 215 subset.</li>
</ul>
<blockquote>
<p>If the definitions of these functions ever materially change, we will need to remove the cached values from disk. If we don’t, the cache will continue to return them, even if now the function will not map the given inputs to the old output. <strong>The data is stored in the <code>luna/cache</code> directory.</strong></p>
</blockquote>
<h4 id="constructing-our-dataset-in-lunadataset.__init__">10.5.2 *Constructing our dataset in LunaDataset.__init__*</h4>
<p>Just about every project will need to separate samples into a training set and a validation set. We are going to do that here by designating every tenth sample, specified by the <code>val_stride</code> parameter, as a member of the validation set. We will also accept an <code>isValSet_bool</code> parameter and use it to determine whether we should keep only the training data, the validation data, or everything.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LunaDataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="params"><span class="function">         val_stride=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">         isValSet_bool=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">         series_uid=<span class="literal">None</span>   </span></span></span><br><span class="line"><span class="params"><span class="function">   </span>):</span></span><br><span class="line">        self.candidateInfo_list =copy.copy(getCandidateInfoList())</span><br><span class="line">        <span class="keyword">if</span> series_uid:</span><br><span class="line">              self.candidateInfo_list = [</span><br><span class="line">              x <span class="keyword">for</span> x <span class="keyword">in</span> self.candidateInfo_list <span class="keyword">if</span> x.series_uid == series_uid</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>If we pass in a truthy series_uid, then the instance will only have nodules from that series. This can be useful for visualization or debugging, by making it easier to look at, for instance, a single problematic CT scan.</p>
<h4 id="a-trainingvalidation-split">10.5.3 <em>A training/validation split</em></h4>
<p>We allow for the Dataset to partition out 1/<em>N</em> th of the data into a subset used for validating the model. How we will handle that subset is based on the value of the <code>isValSet _bool</code> argument.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> isValSet_bool:</span><br><span class="line">           <span class="keyword">assert</span> val_stride &gt; <span class="number">0</span>, val_stride</span><br><span class="line">           self.candidateInfo_list = self.candidateInfo_list[::val_stride]</span><br><span class="line">           <span class="keyword">assert</span> self.candidateInfo_list</span><br><span class="line">       <span class="keyword">elif</span> val_stride &gt; <span class="number">0</span>:</span><br><span class="line">           <span class="keyword">del</span> self.candidateInfo_list[::val_stride]</span><br><span class="line">           <span class="keyword">assert</span> self.candidateInfo_list</span><br></pre></td></tr></table></figure>
<p><strong>Deletes the validation images (every val_stride-th item in the list) from <code>self.candidateInfo_list</code>. We made a copy earlier so that we don’t alter the original list.</strong></p>
<p><strong>This means we can create two Dataset instances and be confident that there is strict segregation between our training data and our validation data.</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">candidateInfo_list = getCandidateInfoList(requireOnDist_bool=<span class="literal">False</span>)</span><br><span class="line">positive_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> candidateInfo_list <span class="keyword">if</span> x.isNodule_bool <span class="keyword">is</span> <span class="literal">True</span>]</span><br><span class="line"><span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(positive_list):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;i:&gt;4d&#125;</span>, <span class="subst">&#123;x.diameter_mm:&gt;<span class="number">4.2</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># out:</span></span><br><span class="line">   <span class="number">0</span>, <span class="number">32.27</span></span><br><span class="line"> <span class="number">100</span>, <span class="number">17.75</span></span><br><span class="line"> <span class="number">200</span>, <span class="number">12.99</span></span><br><span class="line"> <span class="number">300</span>, <span class="number">9.95</span></span><br><span class="line"> <span class="number">400</span>, <span class="number">8.22</span></span><br><span class="line"> <span class="number">500</span>, <span class="number">7.01</span></span><br><span class="line"> <span class="number">600</span>, <span class="number">6.26</span></span><br><span class="line"> <span class="number">700</span>, <span class="number">5.69</span></span><br><span class="line"> <span class="number">800</span>, <span class="number">5.12</span></span><br><span class="line"> <span class="number">900</span>, <span class="number">4.66</span></span><br><span class="line"><span class="number">1000</span>, <span class="number">3.97</span></span><br><span class="line"><span class="number">1100</span>, <span class="number">0.00</span></span><br><span class="line"><span class="number">1200</span>, <span class="number">0.00</span></span><br><span class="line"><span class="number">1300</span>, <span class="number">0.00</span></span><br></pre></td></tr></table></figure>
<p>We have a few very large candidates, starting at 32 mm, but they rapidly drop off to half that size. The bulk of the candidates are in the 4 to 10 mm range, and several hundred don’t have size information at all. we had more actual nodules than we had diameter annotations.</p>
<p><strong>The larger takeaway is that our training and validation splits should have a few properties in order to work well:</strong></p>
<ul>
<li><strong>Both sets should include examples of all variations of expected inputs.</strong></li>
<li><strong>Neither set should have samples that aren’t representative of expected inputs <em>unless</em> they have a specific purpose like training the model to be robust to outliers.</strong></li>
<li><strong>The training set shouldn’t offer unfair hints about the validation set that wouldn’t be true for real-world data (for example, including the same sample in both sets; this is known as a <em>leak</em> in the training set).</strong></li>
</ul>
<h4 id="rendering-the-data">10.5.4 <em>Rendering the data</em></h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showCandidate</span>(<span class="params">series_uid, dataset_ndx=<span class="literal">None</span>, **kwargs</span>):</span></span><br><span class="line">    ds = LunaDataset(series_uid=series_uid, **kwargs)</span><br><span class="line">    ct = CT(series_uid=series_uid)</span><br><span class="line"></span><br><span class="line">    positive_list = [i <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(ds.candidateInfo_list) <span class="keyword">if</span> x.isNodule_bool]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dataset_ndx <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> positive_list:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Noting: using first positive sample&quot;</span>)</span><br><span class="line">            dataset_ndx = positive_list[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Warning: no positive samples found; using first negative sample.&quot;</span>)</span><br><span class="line">            dataset_ndx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    ct_chunk_torch, pos_t, series_uid, center_irc = ds[dataset_ndx]</span><br><span class="line">    ct_chunk_array = ct_chunk_torch.squeeze(<span class="number">0</span>).numpy()</span><br><span class="line"></span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">30</span>, <span class="number">50</span>))</span><br><span class="line">    group_list = [</span><br><span class="line">        [<span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>],</span><br><span class="line">        [<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>],</span><br><span class="line">        [<span class="number">19</span>, <span class="number">21</span>, <span class="number">23</span>],</span><br><span class="line">    ]</span><br><span class="line">    subplot = fig.add_subplot(<span class="built_in">len</span>(group_list) + <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">    subplot.set_title(<span class="string">f&#x27;index <span class="subst">&#123;center_irc[<span class="number">0</span>]&#125;</span>&#x27;</span>, fontsize=<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">for</span> label <span class="keyword">in</span> (subplot.get_xticklabels() + subplot.get_yticklabels()):</span><br><span class="line">        label.set_fontsize(<span class="number">20</span>)</span><br><span class="line">    plt.imshow(ct.hu_array[<span class="built_in">int</span>(center_irc[<span class="number">0</span>])], clim=clim, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    subplot = fig.add_subplot(<span class="built_in">len</span>(group_list) + <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">    subplot.set_title(<span class="string">f&#x27;row <span class="subst">&#123;<span class="built_in">int</span>(center_irc[<span class="number">1</span>])&#125;</span>&#x27;</span>, fontsize=<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">for</span> label <span class="keyword">in</span> (subplot.get_xticklabels() + subplot.get_yticklabels()):</span><br><span class="line">        label.set_fontsize(<span class="number">20</span>)</span><br><span class="line">    plt.imshow(ct.hu_array[:, <span class="built_in">int</span>(center_irc[<span class="number">1</span>])], clim=clim, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.gca().invert_yaxis()</span><br><span class="line"></span><br><span class="line">    subplot = fig.add_subplot(<span class="built_in">len</span>(group_list) + <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">    subplot.set_title(<span class="string">f&#x27;col <span class="subst">&#123;<span class="built_in">int</span>(center_irc[<span class="number">2</span>])&#125;</span>&#x27;</span>, fontsize=<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">for</span> label <span class="keyword">in</span> (subplot.get_xticklabels() + subplot.get_yticklabels()):</span><br><span class="line">        label.set_fontsize(<span class="number">20</span>)</span><br><span class="line">    plt.imshow(ct.hu_array[:, :, <span class="built_in">int</span>(center_irc[<span class="number">2</span>])], clim=clim, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.gca().invert_yaxis()</span><br><span class="line"></span><br><span class="line">    subplot = fig.add_subplot(<span class="built_in">len</span>(group_list) + <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    subplot.set_title(<span class="string">f&#x27;index <span class="subst">&#123;<span class="built_in">int</span>(center_irc[<span class="number">0</span>])&#125;</span>&#x27;</span>, fontsize=<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">for</span> label <span class="keyword">in</span> (subplot.get_xticklabels() + subplot.get_yticklabels()):</span><br><span class="line">        label.set_fontsize(<span class="number">20</span>)</span><br><span class="line">    plt.imshow(ct_chunk_array[ct_chunk_array.shape[<span class="number">0</span>] // <span class="number">2</span>], clim=clim, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    subplot = fig.add_subplot(<span class="built_in">len</span>(group_list) + <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">    subplot.set_title(<span class="string">f&#x27;row <span class="subst">&#123;<span class="built_in">int</span>(center_irc[<span class="number">1</span>])&#125;</span>&#x27;</span>, fontsize=<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">for</span> label <span class="keyword">in</span> (subplot.get_xticklabels() + subplot.get_yticklabels()):</span><br><span class="line">        label.set_fontsize(<span class="number">20</span>)</span><br><span class="line">    plt.imshow(ct_chunk_array[:, ct_chunk_array.shape[<span class="number">1</span>] // <span class="number">2</span>], clim=clim, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.gca().invert_yaxis()</span><br><span class="line"></span><br><span class="line">    subplot = fig.add_subplot(<span class="built_in">len</span>(group_list) + <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">    subplot.set_title(<span class="string">f&#x27;col <span class="subst">&#123;<span class="built_in">int</span>(center_irc[<span class="number">2</span>])&#125;</span>&#x27;</span>, fontsize=<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">for</span> label <span class="keyword">in</span> (subplot.get_xticklabels() + subplot.get_yticklabels()):</span><br><span class="line">        label.set_fontsize(<span class="number">20</span>)</span><br><span class="line">    plt.imshow(ct_chunk_array[:, :, ct_chunk_array.shape[<span class="number">2</span>] // <span class="number">2</span>], clim=clim, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.gca().invert_yaxis()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row, index_list <span class="keyword">in</span> <span class="built_in">enumerate</span>(group_list):</span><br><span class="line">        <span class="keyword">for</span> col, index <span class="keyword">in</span> <span class="built_in">enumerate</span>(index_list):</span><br><span class="line">            subplot = fig.add_subplot(<span class="built_in">len</span>(group_list) + <span class="number">2</span>, <span class="number">3</span>, row * <span class="number">3</span> + col + <span class="number">7</span>)</span><br><span class="line">            subplot.set_title(<span class="string">f&#x27;slice: <span class="subst">&#123;index&#125;</span>&#x27;</span>, fontsize=<span class="number">30</span>)</span><br><span class="line">            <span class="keyword">for</span> label <span class="keyword">in</span> (subplot.get_xticklabels() + subplot.get_yticklabels()):</span><br><span class="line">                label.set_fontsize(<span class="number">20</span>)</span><br><span class="line">            plt.imshow(ct_chunk_array[index], clim=clim, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="built_in">print</span>(series_uid, dataset_ndx, <span class="built_in">bool</span>(pos_t[<span class="number">0</span>]), positive_list)</span><br></pre></td></tr></table></figure>
<p>This produces images akin to those showing CT and nodule slices earlier in this chapter.</p>
<p><img src="15.png" alt="13" style="zoom:40%;" /></p>
<p><img src="16.png" alt="13" style="zoom:40%;" /></p>
<h3 id="conclution">10.6 Conclution</h3>
<p>In this chapter, we got <em>PyTorch’s</em> head wrapped around our data! By transforming our DICOM-via-meta-image raw data into tensors, we’ve set the stage to start implementing a model and a training loop, which we’ll see in the next chapter.</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/PyTorch/" rel="tag"># PyTorch</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/08/13/ML11/" rel="prev" title="机器学习 by 李宏毅(11)">
                  <i class="fa fa-chevron-left"></i> 机器学习 by 李宏毅(11)
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2017 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiuYang</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">1m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">15:18</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>






  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{&quot;enable&quot;:true,&quot;tags&quot;:&quot;none&quot;,&quot;js&quot;:&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;mathjax@3.1.4&#x2F;es5&#x2F;tex-mml-chtml.js&quot;}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.1.0/dist/quicklink.umd.js"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{&quot;enable&quot;:true,&quot;home&quot;:true,&quot;archive&quot;:true,&quot;delay&quot;:true,&quot;timeout&quot;:3000,&quot;priority&quot;:true,&quot;ignores&quot;:null,&quot;url&quot;:&quot;https:&#x2F;&#x2F;ly1998117.github.io&#x2F;2021&#x2F;08&#x2F;13&#x2F;DetectCancer&#x2F;&quot;}</script>
  <script src="/js/third-party/quicklink.js"></script>



  <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
  <script src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
  <script async src="/js/cursor/explosion.js"></script>

</body>
</html>
